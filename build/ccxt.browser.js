(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*  A entry point for the browser bundle version. This gets compiled by:
        
        browserify --debug ./ccxt.browser.js > ./build/ccxt.browser.js
 */

window.ccxt = require ('./ccxt')
},{"./ccxt":2}],2:[function(require,module,exports){
"use strict";

/*

MIT License

Copyright (c) 2017 Igor Kroitor

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

"use strict";

//-----------------------------------------------------------------------------

const Exchange  = require ('./js/base/Exchange')
const functions = require ('./js/base/functions')
const errors    = require ('./js/base/errors')

//-----------------------------------------------------------------------------
// this is updated by vss.js when building

const version = '1.10.399'

Exchange.ccxtVersion = version

//-----------------------------------------------------------------------------

const exchanges = {
    '_1broker':                require ('./js/_1broker.js'),
    '_1btcxe':                 require ('./js/_1btcxe.js'),
    'acx':                     require ('./js/acx.js'),
    'allcoin':                 require ('./js/allcoin.js'),
    'anxpro':                  require ('./js/anxpro.js'),
    'binance':                 require ('./js/binance.js'),
    'bit2c':                   require ('./js/bit2c.js'),
    'bitbay':                  require ('./js/bitbay.js'),
    'bitcoincoid':             require ('./js/bitcoincoid.js'),
    'bitfinex':                require ('./js/bitfinex.js'),
    'bitfinex2':               require ('./js/bitfinex2.js'),
    'bitflyer':                require ('./js/bitflyer.js'),
    'bithumb':                 require ('./js/bithumb.js'),
    'bitlish':                 require ('./js/bitlish.js'),
    'bitmarket':               require ('./js/bitmarket.js'),
    'bitmex':                  require ('./js/bitmex.js'),
    'bitso':                   require ('./js/bitso.js'),
    'bitstamp':                require ('./js/bitstamp.js'),
    'bitstamp1':               require ('./js/bitstamp1.js'),
    'bittrex':                 require ('./js/bittrex.js'),
    'bl3p':                    require ('./js/bl3p.js'),
    'bleutrade':               require ('./js/bleutrade.js'),
    'btcbox':                  require ('./js/btcbox.js'),
    'btcchina':                require ('./js/btcchina.js'),
    'btcexchange':             require ('./js/btcexchange.js'),
    'btcmarkets':              require ('./js/btcmarkets.js'),
    'btctradeua':              require ('./js/btctradeua.js'),
    'btcturk':                 require ('./js/btcturk.js'),
    'btcx':                    require ('./js/btcx.js'),
    'bter':                    require ('./js/bter.js'),
    'bxinth':                  require ('./js/bxinth.js'),
    'ccex':                    require ('./js/ccex.js'),
    'cex':                     require ('./js/cex.js'),
    'chbtc':                   require ('./js/chbtc.js'),
    'chilebit':                require ('./js/chilebit.js'),
    'coincheck':               require ('./js/coincheck.js'),
    'coinfloor':               require ('./js/coinfloor.js'),
    'coingi':                  require ('./js/coingi.js'),
    'coinmarketcap':           require ('./js/coinmarketcap.js'),
    'coinmate':                require ('./js/coinmate.js'),
    'coinsecure':              require ('./js/coinsecure.js'),
    'coinspot':                require ('./js/coinspot.js'),
    'cryptopia':               require ('./js/cryptopia.js'),
    'dsx':                     require ('./js/dsx.js'),
    'exmo':                    require ('./js/exmo.js'),
    'flowbtc':                 require ('./js/flowbtc.js'),
    'foxbit':                  require ('./js/foxbit.js'),
    'fybse':                   require ('./js/fybse.js'),
    'fybsg':                   require ('./js/fybsg.js'),
    'gatecoin':                require ('./js/gatecoin.js'),
    'gateio':                  require ('./js/gateio.js'),
    'gdax':                    require ('./js/gdax.js'),
    'gemini':                  require ('./js/gemini.js'),
    'getbtc':                  require ('./js/getbtc.js'),
    'hitbtc':                  require ('./js/hitbtc.js'),
    'hitbtc2':                 require ('./js/hitbtc2.js'),
    'huobi':                   require ('./js/huobi.js'),
    'huobicny':                require ('./js/huobicny.js'),
    'huobipro':                require ('./js/huobipro.js'),
    'independentreserve':      require ('./js/independentreserve.js'),
    'itbit':                   require ('./js/itbit.js'),
    'jubi':                    require ('./js/jubi.js'),
    'kraken':                  require ('./js/kraken.js'),
    'kucoin':                  require ('./js/kucoin.js'),
    'kuna':                    require ('./js/kuna.js'),
    'lakebtc':                 require ('./js/lakebtc.js'),
    'liqui':                   require ('./js/liqui.js'),
    'livecoin':                require ('./js/livecoin.js'),
    'luno':                    require ('./js/luno.js'),
    'mercado':                 require ('./js/mercado.js'),
    'mixcoins':                require ('./js/mixcoins.js'),
    'nova':                    require ('./js/nova.js'),
    'okcoincny':               require ('./js/okcoincny.js'),
    'okcoinusd':               require ('./js/okcoinusd.js'),
    'okex':                    require ('./js/okex.js'),
    'paymium':                 require ('./js/paymium.js'),
    'poloniex':                require ('./js/poloniex.js'),
    'qryptos':                 require ('./js/qryptos.js'),
    'quadrigacx':              require ('./js/quadrigacx.js'),
    'quoine':                  require ('./js/quoine.js'),
    'southxchange':            require ('./js/southxchange.js'),
    'surbitcoin':              require ('./js/surbitcoin.js'),
    'therock':                 require ('./js/therock.js'),
    'tidex':                   require ('./js/tidex.js'),
    'urdubit':                 require ('./js/urdubit.js'),
    'vaultoro':                require ('./js/vaultoro.js'),
    'vbtc':                    require ('./js/vbtc.js'),
    'virwox':                  require ('./js/virwox.js'),
    'wex':                     require ('./js/wex.js'),
    'xbtce':                   require ('./js/xbtce.js'),
    'yobit':                   require ('./js/yobit.js'),
    'yunbi':                   require ('./js/yunbi.js'),
    'zaif':                    require ('./js/zaif.js'),
    'zb':                      require ('./js/zb.js'),    
}

//-----------------------------------------------------------------------------

module.exports = Object.assign ({ version, Exchange, exchanges: Object.keys (exchanges) }, exchanges, functions, errors)

//-----------------------------------------------------------------------------

},{"./js/_1broker.js":3,"./js/_1btcxe.js":4,"./js/acx.js":5,"./js/allcoin.js":6,"./js/anxpro.js":7,"./js/base/Exchange":8,"./js/base/errors":10,"./js/base/functions":11,"./js/binance.js":13,"./js/bit2c.js":14,"./js/bitbay.js":15,"./js/bitcoincoid.js":16,"./js/bitfinex.js":17,"./js/bitfinex2.js":18,"./js/bitflyer.js":19,"./js/bithumb.js":20,"./js/bitlish.js":21,"./js/bitmarket.js":22,"./js/bitmex.js":23,"./js/bitso.js":24,"./js/bitstamp.js":25,"./js/bitstamp1.js":26,"./js/bittrex.js":27,"./js/bl3p.js":28,"./js/bleutrade.js":29,"./js/btcbox.js":30,"./js/btcchina.js":31,"./js/btcexchange.js":32,"./js/btcmarkets.js":33,"./js/btctradeua.js":34,"./js/btcturk.js":35,"./js/btcx.js":36,"./js/bter.js":37,"./js/bxinth.js":38,"./js/ccex.js":39,"./js/cex.js":40,"./js/chbtc.js":41,"./js/chilebit.js":42,"./js/coincheck.js":43,"./js/coinfloor.js":44,"./js/coingi.js":45,"./js/coinmarketcap.js":46,"./js/coinmate.js":47,"./js/coinsecure.js":48,"./js/coinspot.js":49,"./js/cryptopia.js":50,"./js/dsx.js":51,"./js/exmo.js":52,"./js/flowbtc.js":53,"./js/foxbit.js":54,"./js/fybse.js":55,"./js/fybsg.js":56,"./js/gatecoin.js":57,"./js/gateio.js":58,"./js/gdax.js":59,"./js/gemini.js":60,"./js/getbtc.js":61,"./js/hitbtc.js":62,"./js/hitbtc2.js":63,"./js/huobi.js":64,"./js/huobicny.js":65,"./js/huobipro.js":66,"./js/independentreserve.js":67,"./js/itbit.js":68,"./js/jubi.js":69,"./js/kraken.js":70,"./js/kucoin.js":71,"./js/kuna.js":72,"./js/lakebtc.js":73,"./js/liqui.js":74,"./js/livecoin.js":75,"./js/luno.js":76,"./js/mercado.js":77,"./js/mixcoins.js":78,"./js/nova.js":79,"./js/okcoincny.js":80,"./js/okcoinusd.js":81,"./js/okex.js":82,"./js/paymium.js":83,"./js/poloniex.js":84,"./js/qryptos.js":85,"./js/quadrigacx.js":86,"./js/quoine.js":87,"./js/southxchange.js":88,"./js/surbitcoin.js":89,"./js/therock.js":90,"./js/tidex.js":91,"./js/urdubit.js":92,"./js/vaultoro.js":93,"./js/vbtc.js":94,"./js/virwox.js":95,"./js/wex.js":96,"./js/xbtce.js":97,"./js/yobit.js":98,"./js/yunbi.js":99,"./js/zaif.js":100,"./js/zb.js":101}],3:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class _1broker extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': '_1broker',
            'name': '1Broker',
            'countries': 'US',
            'rateLimit': 1500,
            'version': 'v2',
            'hasPublicAPI': false,
            'hasCORS': true,
            'hasFetchTrades': false,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1m': '60',
                '15m': '900',
                '1h': '3600',
                '1d': '86400',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766021-420bd9fc-5ecb-11e7-8ed6-56d0081efed2.jpg',
                'api': 'https://1broker.com/api',
                'www': 'https://1broker.com',
                'doc': 'https://1broker.com/?c=en/content/api-documentation',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': false,
            },
            'api': {
                'private': {
                    'get': [
                        'market/bars',
                        'market/categories',
                        'market/details',
                        'market/list',
                        'market/quotes',
                        'market/ticks',
                        'order/cancel',
                        'order/create',
                        'order/open',
                        'position/close',
                        'position/close_cancel',
                        'position/edit',
                        'position/history',
                        'position/open',
                        'position/shared/get',
                        'social/profile_statistics',
                        'social/profile_trades',
                        'user/bitcoin_deposit_address',
                        'user/details',
                        'user/overview',
                        'user/quota_status',
                        'user/transaction_log',
                    ],
                },
            },
        });
    }

    async fetchCategories () {
        let response = await this.privateGetMarketCategories ();
        // they return an empty string among their categories, wtf?
        let categories = response['response'];
        let result = [];
        for (let i = 0; i < categories.length; i++) {
            if (categories[i])
                result.push (categories[i]);
        }
        return result;
    }

    async fetchMarkets () {
        let this_ = this; // workaround for Babel bug (not passing `this` to _recursive() call)
        let categories = await this.fetchCategories ();
        let result = [];
        for (let c = 0; c < categories.length; c++) {
            let category = categories[c];
            let markets = await this_.privateGetMarketList ({
                'category': category.toLowerCase (),
            });
            for (let p = 0; p < markets['response'].length; p++) {
                let market = markets['response'][p];
                let id = market['symbol'];
                let symbol = undefined;
                let base = undefined;
                let quote = undefined;
                if ((category == 'FOREX') || (category == 'CRYPTO')) {
                    symbol = market['name'];
                    let parts = symbol.split ('/');
                    base = parts[0];
                    quote = parts[1];
                } else {
                    base = id;
                    quote = 'USD';
                    symbol = base + '/' + quote;
                }
                base = this_.commonCurrencyCode (base);
                quote = this_.commonCurrencyCode (quote);
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'info': market,
                });
            }
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balance = await this.privateGetUserOverview ();
        let response = balance['response'];
        let result = {
            'info': response,
        };
        let currencies = Object.keys (this.currencies);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            result[currency] = this.account ();
        }
        let total = parseFloat (response['balance']);
        result['BTC']['free'] = total;
        result['BTC']['total'] = total;
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetMarketQuotes (this.extend ({
            'symbols': this.marketId (symbol),
        }, params));
        let orderbook = response['response'][0];
        let timestamp = this.parse8601 (orderbook['updated']);
        let bidPrice = parseFloat (orderbook['bid']);
        let askPrice = parseFloat (orderbook['ask']);
        let bid = [ bidPrice, undefined ];
        let ask = [ askPrice, undefined ];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'bids': [ bid ],
            'asks': [ ask ],
        };
    }

    async fetchTrades (symbol) {
        throw new ExchangeError (this.id + ' fetchTrades () method not implemented yet');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let result = await this.privateGetMarketBars (this.extend ({
            'symbol': this.marketId (symbol),
            'resolution': 60,
            'limit': 1,
        }, params));
        let orderbook = await this.fetchOrderBook (symbol);
        let ticker = result['response'][0];
        let timestamp = this.parse8601 (ticker['date']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['h']),
            'low': parseFloat (ticker['l']),
            'bid': orderbook['bids'][0][0],
            'ask': orderbook['asks'][0][0],
            'vwap': undefined,
            'open': parseFloat (ticker['o']),
            'close': parseFloat (ticker['c']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            this.parse8601 (ohlcv['date']),
            parseFloat (ohlcv['o']),
            parseFloat (ohlcv['h']),
            parseFloat (ohlcv['l']),
            parseFloat (ohlcv['c']),
            undefined,
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'resolution': this.timeframes[timeframe],
        };
        if (since)
            request['date_start'] = this.iso8601 (since); // they also support date_end
        if (limit)
            request['limit'] = limit;
        let result = await this.privateGetMarketBars (this.extend (request, params));
        return this.parseOHLCVs (result['response'], market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'symbol': this.marketId (symbol),
            'margin': amount,
            'direction': (side == 'sell') ? 'short' : 'long',
            'leverage': 1,
            'type': side,
        };
        if (type == 'limit')
            order['price'] = price;
        else
            order['type'] += '_market';
        let result = await this.privateGetOrderCreate (this.extend (order, params));
        return {
            'info': result,
            'id': result['response']['order_id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        this.checkRequiredCredentials ();
        let url = this.urls['api'] + '/' + this.version + '/' + path + '.php';
        let query = this.extend ({ 'token': this.apiKey }, params);
        url += '?' + this.urlencode (query);
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('warning' in response)
            if (response['warning'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],4:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class _1btcxe extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': '_1btcxe',
            'name': '1BTCXE',
            'countries': 'PA', // Panama
            'comment': 'Crypto Capital API',
            'hasCORS': true,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'timeframes': {
                '1d': '1year',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766049-2b294408-5ecc-11e7-85cc-adaff013dc1a.jpg',
                'api': 'https://1btcxe.com/api',
                'www': 'https://1btcxe.com',
                'doc': 'https://1btcxe.com/api-docs.php',
            },
            'api': {
                'public': {
                    'get': [
                        'stats',
                        'historical-prices',
                        'order-book',
                        'transactions',
                    ],
                },
                'private': {
                    'post': [
                        'balances-and-info',
                        'open-orders',
                        'user-transactions',
                        'btc-deposit-address/get',
                        'btc-deposit-address/new',
                        'deposits/get',
                        'withdrawals/get',
                        'orders/new',
                        'orders/edit',
                        'orders/cancel',
                        'orders/status',
                        'withdrawals/new',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/EUR': { 'id': 'EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTC/CNY': { 'id': 'CNY', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY' },
                'BTC/RUB': { 'id': 'RUB', 'symbol': 'BTC/RUB', 'base': 'BTC', 'quote': 'RUB' },
                'BTC/CHF': { 'id': 'CHF', 'symbol': 'BTC/CHF', 'base': 'BTC', 'quote': 'CHF' },
                'BTC/JPY': { 'id': 'JPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
                'BTC/GBP': { 'id': 'GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
                'BTC/CAD': { 'id': 'CAD', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD' },
                'BTC/AUD': { 'id': 'AUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
                'BTC/AED': { 'id': 'AED', 'symbol': 'BTC/AED', 'base': 'BTC', 'quote': 'AED' },
                'BTC/BGN': { 'id': 'BGN', 'symbol': 'BTC/BGN', 'base': 'BTC', 'quote': 'BGN' },
                'BTC/CZK': { 'id': 'CZK', 'symbol': 'BTC/CZK', 'base': 'BTC', 'quote': 'CZK' },
                'BTC/DKK': { 'id': 'DKK', 'symbol': 'BTC/DKK', 'base': 'BTC', 'quote': 'DKK' },
                'BTC/HKD': { 'id': 'HKD', 'symbol': 'BTC/HKD', 'base': 'BTC', 'quote': 'HKD' },
                'BTC/HRK': { 'id': 'HRK', 'symbol': 'BTC/HRK', 'base': 'BTC', 'quote': 'HRK' },
                'BTC/HUF': { 'id': 'HUF', 'symbol': 'BTC/HUF', 'base': 'BTC', 'quote': 'HUF' },
                'BTC/ILS': { 'id': 'ILS', 'symbol': 'BTC/ILS', 'base': 'BTC', 'quote': 'ILS' },
                'BTC/INR': { 'id': 'INR', 'symbol': 'BTC/INR', 'base': 'BTC', 'quote': 'INR' },
                'BTC/MUR': { 'id': 'MUR', 'symbol': 'BTC/MUR', 'base': 'BTC', 'quote': 'MUR' },
                'BTC/MXN': { 'id': 'MXN', 'symbol': 'BTC/MXN', 'base': 'BTC', 'quote': 'MXN' },
                'BTC/NOK': { 'id': 'NOK', 'symbol': 'BTC/NOK', 'base': 'BTC', 'quote': 'NOK' },
                'BTC/NZD': { 'id': 'NZD', 'symbol': 'BTC/NZD', 'base': 'BTC', 'quote': 'NZD' },
                'BTC/PLN': { 'id': 'PLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                'BTC/RON': { 'id': 'RON', 'symbol': 'BTC/RON', 'base': 'BTC', 'quote': 'RON' },
                'BTC/SEK': { 'id': 'SEK', 'symbol': 'BTC/SEK', 'base': 'BTC', 'quote': 'SEK' },
                'BTC/SGD': { 'id': 'SGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
                'BTC/THB': { 'id': 'THB', 'symbol': 'BTC/THB', 'base': 'BTC', 'quote': 'THB' },
                'BTC/TRY': { 'id': 'TRY', 'symbol': 'BTC/TRY', 'base': 'BTC', 'quote': 'TRY' },
                'BTC/ZAR': { 'id': 'ZAR', 'symbol': 'BTC/ZAR', 'base': 'BTC', 'quote': 'ZAR' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalancesAndInfo ();
        let balance = response['balances-and-info'];
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            account['free'] = this.safeFloat (balance['available'], currency, 0.0);
            account['used'] = this.safeFloat (balance['on_hold'], currency, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetOrderBook (this.extend ({
            'currency': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (response['order-book'], undefined, 'bid', 'ask', 'price', 'order_amount');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetStats (this.extend ({
            'currency': this.marketId (symbol),
        }, params));
        let ticker = response['stats'];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['max']),
            'low': parseFloat (ticker['min']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['daily_change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['total_btc_traded']),
        };
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        return [
            this.parse8601 (ohlcv['date'] + ' 00:00:00'),
            undefined,
            undefined,
            undefined,
            parseFloat (ohlcv['price']),
            undefined,
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1d', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetHistoricalPrices (this.extend ({
            'currency': market['id'],
            'timeframe': this.timeframes[timeframe],
        }, params));
        let ohlcvs = this.omit (response['historical-prices'], 'request_currency');
        return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['timestamp']) * 1000;
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': trade['maker_type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'currency': market['id'],
        }, params));
        let trades = this.omit (response['transactions'], 'request_currency');
        return this.parseTrades (trades, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = {
            'side': side,
            'type': type,
            'currency': this.marketId (symbol),
            'amount': amount,
        };
        if (type == 'limit')
            order['limit_price'] = price;
        let result = await this.privatePostOrdersNew (this.extend (order, params));
        return {
            'info': result,
            'id': result,
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostOrdersCancel ({ 'id': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdrawalsNew (this.extend ({
            'currency': currency,
            'amount': parseFloat (amount),
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['result']['uuid'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (this.id == 'cryptocapital')
            throw new ExchangeError (this.id + ' is an abstract base API for _1btcxe');
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let query = this.extend ({
                'api_key': this.apiKey,
                'nonce': this.nonce (),
            }, params);
            let request = this.json (query);
            query['signature'] = this.hmac (this.encode (request), this.encode (this.secret));
            body = this.json (query);
            headers = { 'Content-Type': 'application/json' };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('errors' in response) {
            let errors = [];
            for (let e = 0; e < response['errors'].length; e++) {
                let error = response['errors'][e];
                errors.push (error['code'] + ': ' + error['message']);
            }
            errors = errors.join (' ');
            throw new ExchangeError (this.id + ' ' + errors);
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],5:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, OrderNotFound } = require ('./base/errors')


//  ---------------------------------------------------------------------------

module.exports = class acx extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'acx',
            'name': 'ACX',
            'countries': 'AU',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '12h': '720',
                '1d': '1440',
                '3d': '4320',
                '1w': '10080',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30247614-1fe61c74-9621-11e7-9e8c-f1a627afa279.jpg',
                'extension': '.json',
                'api': 'https://acx.io/api',
                'www': 'https://acx.io',
                'doc': 'https://acx.io/documents/api_v2',
            },
            'api': {
                'public': {
                    'get': [
                        'markets', // Get all available markets
                        'tickers', // Get ticker of all markets
                        'tickers/{market}', // Get ticker of specific market
                        'trades', // Get recent trades on market, each trade is included only once Trades are sorted in reverse creation order.
                        'order_book', // Get the order book of specified market
                        'depth', // Get depth or specified market Both asks and bids are sorted from highest price to lowest.
                        'k', // Get OHLC(k line) of specific market
                        'k_with_pending_trades', // Get K data with pending trades, which are the trades not included in K data yet, because there's delay between trade generated and processed by K data generator
                        'timestamp', // Get server current time, in seconds since Unix epoch
                    ],
                },
                'private': {
                    'get': [
                        'members/me', // Get your profile and accounts info
                        'deposits', // Get your deposits history
                        'deposit', // Get details of specific deposit
                        'deposit_address', // Where to deposit The address field could be empty when a new address is generating (e.g. for bitcoin), you should try again later in that case.
                        'orders', // Get your orders, results is paginated
                        'order', // Get information of specified order
                        'trades/my', // Get your executed trades Trades are sorted in reverse creation order.
                        'withdraws', // Get your cryptocurrency withdraws
                        'withdraw', // Get your cryptocurrency withdraw
                    ],
                    'post': [
                        'orders', // Create a Sell/Buy order
                        'orders/multi', // Create multiple sell/buy orders
                        'orders/clear', // Cancel all my orders
                        'order/delete', // Cancel an order
                        'withdraw', // Create a withdraw
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'maker': 0.0,
                    'taker': 0.0,
                },
                'funding': {
                    'tierBased': false,
                    'percentage': true,
                    'withdraw': 0.0, // There is only 1% fee on withdrawals to your bank account.
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetMembersMe ();
        let balances = response['accounts'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': parseFloat (balance['balance']),
                'used': parseFloat (balance['locked']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetDepth (this.extend ({
            'market': market['id'],
            'limit': 300,
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        let result = this.parseOrderBook (orderbook, timestamp);
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['at'] * 1000;
        ticker = ticker['ticker'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high', undefined),
            'low': this.safeFloat (ticker, 'low', undefined),
            'bid': this.safeFloat (ticker, 'buy', undefined),
            'ask': this.safeFloat (ticker, 'sell', undefined),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last', undefined),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'vol', undefined),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = undefined;
            let symbol = id;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let base = id.slice (0, 3);
                let quote = id.slice (3, 6);
                base = base.toUpperCase ();
                quote = quote.toUpperCase ();
                base = this.commonCurrencyCode (base);
                quote = this.commonCurrencyCode (quote);
                let symbol = base + '/' + quote;
            }
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTickersMarket (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTicker (response, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = trade['timestamp'] * 1000;
        let side = (trade['type'] == 'bid') ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'market': market['id'],
        }, params));
        // looks like they switched this endpoint off
        // it returns 503 Service Temporarily Unavailable always
        // return this.parseTrades (response, market, since, limit);
        return response;
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            ohlcv[1],
            ohlcv[2],
            ohlcv[3],
            ohlcv[4],
            ohlcv[5],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!limit)
            limit = 500; // default is 30
        let request = {
            'market': market['id'],
            'period': this.timeframes[timeframe],
            'limit': limit,
        };
        if (since)
            request['timestamp'] = since;
        let response = await this.publicGetK (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    parseOrder (order, market = undefined) {
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            let marketId = order['market'];
            symbol = this.marketsById[marketId]['symbol'];
        }
        let timestamp = this.parse8601 (order['created_at']);
        let state = order['state'];
        let status = undefined;
        if (state == 'done') {
            status = 'closed';
        } else if (state == 'wait') {
            status = 'open';
        } else if (state == 'cancel') {
            status = 'canceled';
        }
        return {
            'id': order['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': status,
            'symbol': symbol,
            'type': order['ord_type'],
            'side': order['side'],
            'price': parseFloat (order['price']),
            'amount': parseFloat (order['volume']),
            'filled': parseFloat (order['executed_volume']),
            'remaining': parseFloat (order['remaining_volume']),
            'trades': undefined,
            'fee': undefined,
            'info': order,
        };
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'market': this.marketId (symbol),
            'side': side,
            'volume': amount.toString (),
            'ord_type': type,
        };
        if (type == 'limit') {
            order['price'] = price.toString ();
        }
        let response = await this.privatePostOrders (this.extend (order, params));
        let market = this.marketsById[response['market']];
        return this.parseOrder (response, market);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let result = await this.privatePostOrderDelete ({ 'id': id });
        let order = this.parseOrder(result);
        if (order['status'] == 'closed') {
            throw new OrderNotFound (this.id + ' ' + result);
        }
        return order;
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currency.toLowerCase (),
            'sum': amount,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': undefined,
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    encodeParams (params) {
        if ('orders' in params) {
            let orders = params['orders'];
            let query = this.urlencode (this.keysort (this.omit (params, 'orders')));
            for (let i = 0; i < orders.length; i++) {
                let order = orders[i];
                let keys = Object.keys (order);
                for (let k = 0; k < keys.length; k++) {
                    let key = keys[k];
                    let value = order[key];
                    query += '&orders%5B%5D%5B' + key + '%5D=' + value.toString ();
                }
            }
            return query;
        }
        return this.urlencode (this.keysort (params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/api' + '/' + this.version + '/' + this.implodeParams (path, params);
        if ('extension' in this.urls)
            request += this.urls['extension'];
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + request;
        if (api == 'public') {
            if (Object.keys (query).length) {
                url += '?' + this.urlencode (query);
            }
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let query = this.encodeParams (this.extend ({
                'access_key': this.apiKey,
                'tonce': nonce,
            }, params));
            let auth = method + '|' + request + '|' + query;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            let suffix = query + '&signature=' + signature;
            if (method == 'GET') {
                url += '?' + suffix;
            } else {
                body = suffix;
                headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
            }
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],6:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const okcoinusd = require ('./okcoinusd.js')

//  ---------------------------------------------------------------------------

module.exports = class allcoin extends okcoinusd {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'allcoin',
            'name': 'Allcoin',
            'countries': 'CA',
            'hasCORS': false,
            'extension': '',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/31561809-c316b37c-b061-11e7-8d5a-b547b4d730eb.jpg',
                'api': {
                    'web': 'https://allcoin.com',
                    'public': 'https://api.allcoin.com/api',
                    'private': 'https://api.allcoin.com/api',
                },
                'www': 'https://allcoin.com',
                'doc': 'https://allcoin.com/About/APIReference',
            },
            'api': {
                'web': {
                    'get': [
                        'marketoverviews/',
                    ],
                },
                'public': {
                    'get': [
                        'depth',
                        'kline',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'batch_trade',
                        'cancel_order',
                        'order_history',
                        'order_info',
                        'orders_info',
                        'repayment',
                        'trade',
                        'trade_history',
                        'userinfo',
                    ],
                },
            },
            'markets': undefined,
        });
    }

    async fetchMarkets () {
        // todo rewrite for https://www.allcoin.com/Home/MarketOverViewDetail/
        let currencies = [ 'BTC', 'ETH', 'USD', 'QTUM', 'CNET', 'CK.USD' ];
        let result = [];
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let response = await this.webGetMarketoverviews ({
                'type': 'full',
                'secondary': currency,
            });
            let markets = response['Markets'];
            for (let k = 0; k < markets.length; k++) {
                let market = markets[k];
                let base = market['Primary'];
                let quote = market['Secondary'];
                let id = base.toLowerCase () + '_' + quote.toLowerCase ();
                let symbol = base + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'type': 'spot',
                    'spot': true,
                    'future': false,
                    'info': market,
                });
            }
        }
        return result;
    }

    getOrderStatus (status) {
        if (status == -1)
            return 'canceled';
        if (status == 0)
            return 'open';
        if (status == 1)
            return 'open'; // partially filled
        if (status == 2)
            return 'closed';
        if (status == 10)
            return 'canceled';
        return status;
    }
}

},{"./okcoinusd.js":81}],7:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class anxpro extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'anxpro',
            'name': 'ANXPro',
            'countries': [ 'JP', 'SG', 'HK', 'NZ' ],
            'version': '2',
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchTrades': false,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27765983-fd8595da-5ec9-11e7-82e3-adb3ab8c2612.jpg',
                'api': 'https://anxpro.com/api',
                'www': 'https://anxpro.com',
                'doc': [
                    'http://docs.anxv2.apiary.io',
                    'https://anxpro.com/pages/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{currency_pair}/money/ticker',
                        '{currency_pair}/money/depth/full',
                        '{currency_pair}/money/trade/fetch', // disabled by ANXPro
                    ],
                },
                'private': {
                    'post': [
                        '{currency_pair}/money/order/add',
                        '{currency_pair}/money/order/cancel',
                        '{currency_pair}/money/order/quote',
                        '{currency_pair}/money/order/result',
                        '{currency_pair}/money/orders',
                        'money/{currency}/address',
                        'money/{currency}/send_simple',
                        'money/info',
                        'money/trade/list',
                        'money/wallet/history',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'multiplier': 100000 },
                'BTC/HKD': { 'id': 'BTCHKD', 'symbol': 'BTC/HKD', 'base': 'BTC', 'quote': 'HKD', 'multiplier': 100000 },
                'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'multiplier': 100000 },
                'BTC/CAD': { 'id': 'BTCCAD', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD', 'multiplier': 100000 },
                'BTC/AUD': { 'id': 'BTCAUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD', 'multiplier': 100000 },
                'BTC/SGD': { 'id': 'BTCSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD', 'multiplier': 100000 },
                'BTC/JPY': { 'id': 'BTCJPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY', 'multiplier': 100000 },
                'BTC/GBP': { 'id': 'BTCGBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP', 'multiplier': 100000 },
                'BTC/NZD': { 'id': 'BTCNZD', 'symbol': 'BTC/NZD', 'base': 'BTC', 'quote': 'NZD', 'multiplier': 100000 },
                'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'multiplier': 100000 },
                'STR/BTC': { 'id': 'STRBTC', 'symbol': 'STR/BTC', 'base': 'STR', 'quote': 'BTC', 'multiplier': 100000000 },
                'XRP/BTC': { 'id': 'XRPBTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'multiplier': 100000000 },
                'DOGE/BTC': { 'id': 'DOGEBTC', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC', 'multiplier': 100000000 },
            },
            'fees': {
                'trading': {
                    'maker': 0.3 / 100,
                    'taker': 0.6 / 100,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostMoneyInfo ();
        let balance = response['data'];
        let currencies = Object.keys (balance['Wallets']);
        let result = { 'info': balance };
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let account = this.account ();
            if (currency in balance['Wallets']) {
                let wallet = balance['Wallets'][currency];
                account['free'] = parseFloat (wallet['Available_Balance']['value']);
                account['total'] = parseFloat (wallet['Balance']['value']);
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetCurrencyPairMoneyDepthFull (this.extend ({
            'currency_pair': this.marketId (symbol),
        }, params));
        let orderbook = response['data'];
        let t = parseInt (orderbook['dataUpdateTime']);
        let timestamp = parseInt (t / 1000);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetCurrencyPairMoneyTicker (this.extend ({
            'currency_pair': this.marketId (symbol),
        }, params));
        let ticker = response['data'];
        let t = parseInt (ticker['dataUpdateTime']);
        let timestamp = parseInt (t / 1000);
        let bid = this.safeFloat (ticker['buy'], 'value');
        let ask = this.safeFloat (ticker['sell'], 'value');;
        let vwap = parseFloat (ticker['vwap']['value']);
        let baseVolume = parseFloat (ticker['vol']['value']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']['value']),
            'low': parseFloat (ticker['low']['value']),
            'bid': bid,
            'ask': ask,
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']['value']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']['value']),
            'baseVolume': baseVolume,
            'quoteVolume': baseVolume * vwap,
            'info': ticker,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        throw new ExchangeError (this.id + ' switched off the trades endpoint, see their docs at http://docs.anxv2.apiary.io/reference/market-data/currencypairmoneytradefetch-disabled');
        return this.publicGetCurrencyPairMoneyTradeFetch (this.extend ({
            'currency_pair': this.marketId (symbol),
        }, params));
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let order = {
            'currency_pair': market['id'],
            'amount_int': parseInt (amount * 100000000), // 10^8
        };
        if (type == 'limit') {
            order['price_int'] = parseInt (price * market['multiplier']); // 10^5 or 10^8
        }
        order['type'] = (side == 'buy') ? 'bid' : 'ask';
        let result = await this.privatePostCurrencyPairMoneyOrderAdd (this.extend (order, params));
        return {
            'info': result,
            'id': result['data'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCurrencyPairMoneyOrderCancel ({ 'oid': id });
    }

    getAmountMultiplier (currency) {
        if (currency == 'BTC') {
            return 100000000;
        } else if (currency == 'LTC') {
            return 100000000;
        } else if (currency == 'STR') {
            return 100000000;
        } else if (currency == 'XRP') {
            return 100000000;
        } else if (currency == 'DOGE') {
            return 100000000;
        }
        return 100;
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let multiplier = this.getAmountMultiplier (currency);
        let response = await this.privatePostMoneyCurrencySendSimple (this.extend ({
            'currency': currency,
            'amount_int': parseInt (amount * multiplier),
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['data']['transactionId'],
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + '/' + this.version + '/' + request;
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let secret = this.base64ToBinary (this.secret);
            let auth = request + "\0" + body;
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Rest-Key': this.apiKey,
                'Rest-Sign': this.decode (signature),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (response['result'] == 'success')
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],8:[function(require,module,exports){
(function (process){
"use strict";

//-----------------------------------------------------------------------------

const isNode    = (typeof window === 'undefined')
    , functions = require ('./functions')
    , throttle  = require ('./throttle')
    , fetch     = require ('fetch-ponyfill')().fetch
    , Market    = require ('./Market')

const { deepExtend
      , extend
      , sleep
      , timeout
      , indexBy
      , sortBy
      , aggregate
      , uuid
      , precisionFromString } = functions

const { ExchangeError
      , NotSupported
      , AuthenticationError
      , DDoSProtection
      , RequestTimeout
      , ExchangeNotAvailable } = require ('./errors')

// stub until we get a better solution for Webpack and React
// const journal = isNode && require ('./journal')
const journal = undefined

module.exports = class Exchange {

    getMarket (symbol) {

        if (!this.marketClasses)
            this.marketClasses = {}

        let marketClass = this.marketClasses[symbol]

        if (marketClass)
            return marketClass

        marketClass = new Market (this, symbol)
        this.marketClasses[symbol] = marketClass // only one Market instance per market
        return marketClass
    }

    describe () { return {} }

    constructor (userConfig = {}) {

        Object.assign (this, functions, { encode: string => string, decode: string => string })

        if (isNode)
            this.nodeVersion = process.version.match (/\d+\.\d+.\d+/) [0]

        // this.initRestRateLimiter ()

        // if (isNode) {
        //     this.userAgent = {
        //         'User-Agent': 'ccxt/' + Exchange.ccxtVersion +
        //             ' (+https://github.com/ccxt/ccxt)' +
        //             ' Node.js/' + this.nodeVersion + ' (JavaScript)'
        //     }
        // }

        this.userAgents = {
            'chrome': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',
        }

        this.headers = {}

        // prepended to URL, like https://proxy.com/https://exchange.com/api...
        this.proxy = ''

        this.iso8601          = timestamp => new Date (timestamp).toISOString ()
        this.parse8601        = x => Date.parse (((x.indexOf ('+') >= 0) || (x.slice (-1) == 'Z')) ? x : (x + 'Z'))
        this.milliseconds     = Date.now
        this.microseconds     = () => Math.floor (this.milliseconds () * 1000)
        this.seconds          = () => Math.floor (this.milliseconds () / 1000)
        this.id               = undefined

        // rate limiter settings
        this.enableRateLimit  = false
        this.rateLimit        = 2000  // milliseconds = seconds * 1000

        this.parseJsonResponse             = true  // whether a reply is required to be in JSON or not
        this.substituteCommonCurrencyCodes = true  // reserved
        this.parseBalanceFromOpenOrders    = false // some exchanges return balance updates from order API endpoints

        this.timeout          = 10000 // milliseconds
        this.verbose          = false
        this.debug            = false
        this.journal          = 'debug.json'
        this.userAgent        = undefined
        this.twofa            = false // two-factor authentication (2FA)
        this.timeframes       = undefined
        this.hasPublicAPI         = true
        this.hasPrivateAPI        = true
        this.hasCORS              = false
        this.hasDeposit           = false
        this.hasFetchBalance      = true
        this.hasFetchClosedOrders = false
        this.hasFetchCurrencies   = false
        this.hasFetchMyTrades     = false
        this.hasFetchOHLCV        = false
        this.hasFetchOpenOrders   = false
        this.hasFetchOrder        = false
        this.hasFetchOrderBook    = true
        this.hasFetchOrders       = false
        this.hasFetchTicker       = true
        this.hasFetchTickers      = false
        this.hasFetchTrades       = true
        this.hasWithdraw          = false
        this.hasCreateOrder       = this.hasPrivateAPI
        this.hasCancelOrder       = this.hasPrivateAPI

        this.requiredCredentials = {
            'apiKey':   true,
            'secret':   true,
            'uid':      false,
            'login':    false,
            'password': false,
        }

        this.balance    = {}
        this.orderbooks = {}
        this.tickers    = {}
        this.fees       = {}
        this.orders     = {}
        this.trades     = {}
        this.currencies = {}

        this.last_http_response = undefined
        this.last_json_response = undefined

        // TODO: generate
        this.market_id                   = this.marketId
        this.market_ids                  = this.marketIds
        this.implode_params              = this.implodeParams
        this.extract_params              = this.extractParams
        this.fetch_balance               = this.fetchBalance
        this.fetch_free_balance          = this.fetchFreeBalance
        this.fetch_used_balance          = this.fetchUsedBalance
        this.fetch_total_balance         = this.fetchTotalBalance
        this.fetch_l2_order_book         = this.fetchL2OrderBook
        this.fetch_order_book            = this.fetchOrderBook
        this.fetch_tickers               = this.fetchTickers
        this.fetch_ticker                = this.fetchTicker
        this.fetch_trades                = this.fetchTrades
        this.fetch_order                 = this.fetchOrder
        this.fetch_orders                = this.fetchOrders
        this.fetch_open_orders           = this.fetchOpenOrders
        this.fetch_closed_orders         = this.fetchClosedOrders
        this.fetch_order_status          = this.fetchOrderStatus
        this.fetch_markets               = this.fetchMarkets
        this.load_markets                = this.loadMarkets
        this.set_markets                 = this.setMarkets
        this.parse_balance               = this.parseBalance
        this.parse_bid_ask               = this.parseBidAsk
        this.parse_bids_asks             = this.parseBidsAsks
        this.parse_order_book            = this.parseOrderBook
        this.parse_trades                = this.parseTrades
        this.parse_orders                = this.parseOrders
        this.parse_ohlcv                 = this.parseOHLCV
        this.parse_ohlcvs                = this.parseOHLCVs
        this.edit_limit_buy_order        = this.editLimitBuyOrder
        this.edit_limit_sell_order       = this.editLimitSellOrder
        this.edit_limit_order            = this.editLimitOrder
        this.edit_order                  = this.editOrder
        this.create_limit_buy_order      = this.createLimitBuyOrder
        this.create_limit_sell_order     = this.createLimitSellOrder
        this.create_market_buy_order     = this.createMarketBuyOrder
        this.create_market_sell_order    = this.createMarketSellOrder
        this.create_order                = this.createOrder
        this.calculate_fee               = this.calculateFee
        this.common_currency_code        = this.commonCurrencyCode
        this.price_to_precision          = this.priceToPrecision
        this.amount_to_precision         = this.amountToPrecision
        this.fee_to_precision            = this.feeToPrecision
        this.cost_to_precision           = this.costToPrecision
        this.precisionFromString         = precisionFromString
        this.precision_from_string       = precisionFromString
        this.truncate                    = functions.truncate
        this.uuid                        = uuid

        // API methods metainfo
        this.has = {
            'cancelOrder': this.hasPrivateAPI,
            'createDepositAddress': false,
            'createOrder': this.hasPrivateAPI,
            'deposit': false,
            'fetchBalance': this.hasPrivateAPI,
            'fetchClosedOrders': false,
            'fetchCurrencies': false,
            'fetchDepositAddress': false,
            'fetchMarkets': true,
            'fetchMyTrades': false,
            'fetchOHLCV': false,
            'fetchOpenOrders': false,
            'fetchOrder': false,
            'fetchOrderBook': true,
            'fetchOrders': false,
            'fetchTicker': true,
            'fetchTickers': false,
            'fetchTrades': true,
            'withdraw': false,
        }

        // merge configs
        const config = deepExtend (this.describe (), userConfig)

        // merge to this
        for (const [property, value] of Object.entries (config))
            this[property] = deepExtend (this[property], value)

        if (this.api)
            this.defineRestApi (this.api, 'request')

        this.initRestRateLimiter ()

        if (this.markets)
            this.setMarkets (this.markets)

        if (this.debug && journal) {
            journal (() => this.journal, this, Object.keys (this.has))
        }
    }

    defaults () {
        return { /* override me */ }
    }

    nonce () {
        return this.seconds ()
    }

    encodeURIComponent (...args) {
        return encodeURIComponent (...args)
    }

    checkRequiredCredentials () {
        Object.keys (this.requiredCredentials).map (key => {
            if (this.requiredCredentials[key] && !this[key])
                throw new AuthenticationError (this.id + ' requires `' + key + '`')
        })
    }

    initRestRateLimiter () {

        this.tokenBucket = this.extend ({
            refillRate:  1 / this.rateLimit,
            delay:       1,
            capacity:    1,
            defaultCost: 1,
            maxCapacity: 1000,
        }, this.tokenBucket)

        this.throttle = throttle (this.tokenBucket)

        this.executeRestRequest = function (url, method = 'GET', headers = undefined, body = undefined) {

            let promise =
                fetch (url, { 'method': method, 'headers': headers, 'body': body, 'agent': this.tunnelAgent || null, timeout: this.timeout})
                    .catch (e => {
                        if (isNode)
                            throw new ExchangeNotAvailable ([ this.id, method, url, e.type, e.message ].join (' '))
                        throw e // rethrow all unknown errors
                    })
                    .then (response => this.handleRestErrors (response, url, method, headers, body))
                    .then (response => this.handleRestResponse (response, url, method, headers, body))

            return timeout (this.timeout, promise).catch (e => {
                if (e instanceof RequestTimeout)
                    throw new RequestTimeout (this.id + ' ' + method + ' ' + url + ' ' + e.message + ' (' + this.timeout + ' ms)')
                throw e
            })
        }
    }

    defineRestApi (api, methodName, options = {}) {

        for (const type of Object.keys (api)) {
            for (const httpMethod of Object.keys (api[type])) {

                let urls = api[type][httpMethod]
                for (let i = 0; i < urls.length; i++) {
                    let url = urls[i].trim ()
                    let splitPath = url.split (/[^a-zA-Z0-9]/)

                    let uppercaseMethod  = httpMethod.toUpperCase ()
                    let lowercaseMethod  = httpMethod.toLowerCase ()
                    let camelcaseMethod  = this.capitalize (lowercaseMethod)
                    let camelcaseSuffix  = splitPath.map (this.capitalize).join ('')
                    let underscoreSuffix = splitPath.map (x => x.trim ().toLowerCase ()).filter (x => x.length > 0).join ('_')

                    if (camelcaseSuffix.indexOf (camelcaseMethod) === 0)
                        camelcaseSuffix = camelcaseSuffix.slice (camelcaseMethod.length)

                    if (underscoreSuffix.indexOf (lowercaseMethod) === 0)
                        underscoreSuffix = underscoreSuffix.slice (lowercaseMethod.length)

                    let camelcase  = type + camelcaseMethod + this.capitalize (camelcaseSuffix)
                    let underscore = type + '_' + lowercaseMethod + '_' + underscoreSuffix

                    if ('suffixes' in options) {
                        if ('camelcase' in options['suffixes'])
                            camelcase += options['suffixes']['camelcase']
                        if ('underscore' in options.suffixes)
                            underscore += options['suffixes']['underscore']
                    }

                    if ('underscore_suffix' in options)
                        underscore += options.underscoreSuffix;
                    if ('camelcase_suffix' in options)
                        camelcase += options.camelcaseSuffix;

                    let partial = async params => this[methodName] (url, type, uppercaseMethod, params || {})

                    this[camelcase]  = partial
                    this[underscore] = partial
                }
            }
        }
    }

    fetch (url, method = 'GET', headers = undefined, body = undefined) {

        if (isNode && this.userAgent) {
            if (typeof this.userAgent == 'string')
                headers = extend ({ 'User-Agent': this.userAgent }, headers)
            else if ((typeof this.userAgent == 'object') && ('User-Agent' in this.userAgent))
                headers = extend (this.userAgent, headers)
        }

        if (typeof this.proxy == 'function') {

            url = this.proxy (url)
            headers = extend ({ 'Origin': '*' }, headers)

        } else if (typeof this.proxy == 'string') {

            if (this.proxy.length)
                headers = extend ({ 'Origin': '*' }, headers)

            url = this.proxy + url
        }

        headers = extend (this.headers, headers)

        if (this.verbose)
            console.log (this.id, method, url, "\nRequest:\n", headers, body)

        return this.executeRestRequest (url, method, headers, body)
    }

    async fetch2 (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {

        if (this.enableRateLimit)
            await this.throttle ()

        let request = this.sign (path, api, method, params, headers, body)
        return this.fetch (request.url, request.method, request.headers, request.body)
    }

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        return this.fetch2 (path, api, method, params, headers, body)
    }

    handleErrors (statusCode, statusText, url, method, headers, body) {
        // override me
    }

    defaultErrorHandler (code, reason, url, method, headers, body) {
        if (this.verbose)
            console.log (this.id, method, url, code, reason, body ? ("\nResponse:\n" + body) : '')
        if ((code >= 200) && (code <= 300))
            return body
        let error = undefined
        this.last_http_response = body
        let details = body
        let match = body.match ('\<title\>([^<]+)')
        if (match)
            details = match[1].trim ();
        if ([ 429 ].includes (code)) {
            error = DDoSProtection
        } else if ([ 404, 409, 422, 500, 501, 502, 520, 521, 522, 525 ].includes (code)) {
            error = ExchangeNotAvailable
        } else if ([ 400, 403, 405, 503, 530 ].includes (code)) {
            let ddosProtection = body.match (/cloudflare|incapsula/i)
            if (ddosProtection) {
                error = DDoSProtection
            } else {
                error = ExchangeNotAvailable
                details += ' (possible reasons: ' + [
                    'invalid API keys',
                    'bad or old nonce',
                    'exchange is down or offline',
                    'on maintenance',
                    'DDoS protection',
                    'rate-limiting',
                ].join (', ') + ')'
            }
        } else if ([ 408, 504 ].includes (code)) {
            error = RequestTimeout
        } else if ([ 401, 511 ].includes (code)) {
            error = AuthenticationError
        } else {
            error = ExchangeError
        }
        throw new error ([ this.id, method, url, code, reason, details ].join (' '))
    }

    handleRestErrors (response, url, method = 'GET', headers = undefined, body = undefined) {

        if (typeof response == 'string')
            return response

        return response.text ().then (text => {

            const args = [ response.status, response.statusText, url, method, headers, text ]

            this.handleErrors (...args)
            return this.defaultErrorHandler (...args)
        })
    }

    handleRestResponse (response, url, method = 'GET', headers = undefined, body = undefined) {

        try {

            this.last_http_response = response
            if (this.parseJsonResponse) {
                this.last_json_response =
                    ((typeof response == 'string') && (response.length > 1)) ?
                        JSON.parse (response) : response
                return this.last_json_response
            }

            return response

        } catch (e) {

            let maintenance = response.match (/offline|busy|retry|wait|unavailable|maintain|maintenance|maintenancing/i)
            let ddosProtection = response.match (/cloudflare|incapsula|overload/i)

            if (e instanceof SyntaxError) {

                let error = ExchangeNotAvailable
                let details = 'not accessible from this location at the moment'
                if (maintenance)
                    details = 'offline, on maintenance or unreachable from this location at the moment'
                if (ddosProtection)
                    error = DDoSProtection
                throw new error ([ this.id, method, url, details ].join (' '))
            }

            if (this.verbose)
                console.log (this.id, method, url, 'error', e, "response body:\n'" + response + "'")

            throw e
        }
    }

    setMarkets (markets, currencies = undefined) {
        let values = Object.values (markets).map (market => deepExtend ({
            'limits': this.limits,
            'precision': this.precision,
        }, this.fees['trading'], market))
        this.markets = deepExtend (this.markets, indexBy (values, 'symbol'))
        this.marketsById = indexBy (markets, 'id')
        this.markets_by_id = this.marketsById
        this.symbols = Object.keys (this.markets).sort ()
        this.ids = Object.keys (this.markets_by_id).sort ()
        if (currencies) {
            this.currencies = deepExtend (currencies, this.currencies)
        } else {
            const baseCurrencies =
                values.filter (market => 'base' in market)
                    .map (market => ({
                        id: market.baseId || market.base,
                        code: market.base,
                    }))
            const quoteCurrencies =
                values.filter (market => 'quote' in market)
                    .map (market => ({
                        id: market.quoteId || market.quote,
                        code: market.quote,
                    }))
            const currencies = sortBy (baseCurrencies.concat (quoteCurrencies), 'code')
            this.currencies = deepExtend (indexBy (currencies, 'code'), this.currencies)
        }
        return this.markets
    }

    async loadMarkets (reload = false) {
        if (!reload && this.markets) {
            if (!this.marketsById) {
                return this.setMarkets (this.markets)
            }
            return this.markets
        }
        const markets = await this.fetchMarkets ()
        let currencies = undefined
        if (this.has.fetchCurrencies) {
            currencies = await this.fetchCurrencies ()
        }
        return this.setMarkets (markets, currencies)
    }

    fetchTickers (symbols = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchTickers not supported yet')
    }

    fetchOrder (id, symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOrder not supported yet');
    }

    fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOrders not supported yet');
    }

    fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOpenOrders not supported yet');
    }

    fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchClosedOrders not supported yet');
    }

    fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchMyTrades not supported yet');
    }

    fetchCurrencies () {
        throw new NotSupported (this.id + ' fetchCurrencies not supported yet');
    }

    fetchMarkets () {
        return new Promise ((resolve, reject) => resolve (this.markets))
    }

    async fetchOrderStatus (id, market = undefined) {
        let order = await this.fetchOrder (id)
        return order['status']
    }

    account () {
        return {
            'free': 0.0,
            'used': 0.0,
            'total': 0.0,
        }
    }

    commonCurrencyCode (currency) {
        if (!this.substituteCommonCurrencyCodes)
            return currency
        if (currency == 'XBT')
            return 'BTC'
        if (currency == 'BCC')
            return 'BCH'
        if (currency == 'DRK')
            return 'DASH'
        return currency
    }

    currency (code) {

        if (typeof this.currencies == 'undefined')
            return new ExchangeError (this.id + ' currencies not loaded')

        if ((typeof code === 'string') && (code in this.currencies))
            return this.currencies[code]

        throw new ExchangeError (this.id + ' does not have currency code ' + code)
    }


    market (symbol) {

        if (typeof this.markets == 'undefined')
            return new ExchangeError (this.id + ' markets not loaded')

        if ((typeof symbol === 'string') && (symbol in this.markets))
            return this.markets[symbol]

        throw new ExchangeError (this.id + ' does not have market symbol ' + symbol)
    }

    marketId (symbol) {
        return this.market (symbol).id || symbol
    }

    marketIds (symbols) {
        return symbols.map (symbol => this.marketId(symbol));
    }

    symbol (symbol) {
        return this.market (symbol).symbol || symbol
    }

    extractParams (string) {
        let re = /{([a-zA-Z0-9_]+?)}/g
        let matches = []
        let match
        while (match = re.exec (string))
            matches.push (match[1])
        return matches
    }

    implodeParams (string, params) {
        for (let property in params)
            string = string.replace ('{' + property + '}', params[property])
        return string
    }

    url (path, params = {}) {
        let result = this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path))
        if (Object.keys (query).length)
            result += '?' + this.urlencode (query)
        return result
    }

    parseBidAsk (bidask, priceKey = 0, amountKey = 1) {
        let price = parseFloat (bidask[priceKey])
        let amount = parseFloat (bidask[amountKey])
        return [ price, amount ]
    }

    parseBidsAsks (bidasks, priceKey = 0, amountKey = 1) {
        return Object.values (bidasks || []).map (bidask => this.parseBidAsk (bidask, priceKey, amountKey))
    }

    async fetchL2OrderBook (symbol, params = {}) {
        let orderbook = await this.fetchOrderBook (symbol, params)
        return extend (orderbook, {
            'bids': sortBy (aggregate (orderbook.bids), 0, true),
            'asks': sortBy (aggregate (orderbook.asks), 0),
        })
    }

    parseOrderBook (orderbook, timestamp = undefined, bidsKey = 'bids', asksKey = 'asks', priceKey = 0, amountKey = 1) {
        timestamp = timestamp || this.milliseconds ();
        return {
            'bids': (bidsKey in orderbook) ? this.parseBidsAsks (orderbook[bidsKey], priceKey, amountKey) : [],
            'asks': (asksKey in orderbook) ? this.parseBidsAsks (orderbook[asksKey], priceKey, amountKey) : [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    }

    getCurrencyUsedOnOpenOrders (currency) {
        return Object.values (this.orders).filter (order => (order['status'] == 'open')).reduce ((total, order) => {
            let symbol = order['symbol'];
            let market = this.markets[symbol];
            let amount = order['remaining']
            if (currency == market['base'] && order['side'] == 'sell') {
                return total + amount
            } else if (currency == market['quote'] && order['side'] == 'buy') {
                return total + (order['cost'] || (order['price'] * amount))
            } else {
                return total
            }
        }, 0)
    }

    parseBalance (balance) {

        const currencies = Object.keys (this.omit (balance, 'info'));

        currencies.forEach (currency => {

            if (typeof balance[currency].used == 'undefined') {

                if (this.parseBalanceFromOpenOrders && ('open_orders' in balance['info'])) {
                    const exchangeOrdersCount = balance['info']['open_orders'];
                    const cachedOrdersCount = Object.values (this.orders).filter (order => (order['status'] == 'open')).length;
                    if (cachedOrdersCount == exchangeOrdersCount) {
                        balance[currency].used = this.getCurrencyUsedOnOpenOrders (currency)
                        balance[currency].total = balance[currency].used + balance[currency].free
                    }
                } else {
                    balance[currency].used = this.getCurrencyUsedOnOpenOrders (currency)
                    balance[currency].total = balance[currency].used + balance[currency].free
                }
            }

            [ 'free', 'used', 'total' ].forEach (account => {
                balance[account] = balance[account] || {}
                balance[account][currency] = balance[currency][account]
            })
        })
        return balance;
    }

    async fetchPartialBalance (part, params = {}) {
        let balance = await this.fetchBalance (params)
        return balance[part]
    }

    fetchFreeBalance (params = {}) {
        return this.fetchPartialBalance ('free', params)
    }

    fetchUsedBalance (params = {}) {
        return this.fetchPartialBalance ('used', params)
    }

    fetchTotalBalance (params = {}) {
        return this.fetchPartialBalance ('total', params)
    }

    filterBySinceLimit (array, since = undefined, limit = undefined) {
        if (since)
            array = array.filter (entry => entry.timestamp > since)
        if (limit)
            array = array.slice (0, limit)
        return array
    }

    parseTrades (trades, market = undefined, since = undefined, limit = undefined) {
        let result = Object.values (trades).map (trade => this.parseTrade (trade, market))
        result = sortBy (result, 'timestamp', true)
        return this.filterBySinceLimit (result, since, limit)
    }

    parseOrders (orders, market = undefined, since = undefined, limit = undefined) {
        let result = Object.values (orders).map (order => this.parseOrder (order, market))
        return this.filterBySinceLimit (result, since, limit)
    }

    filterOrdersBySymbol (orders, symbol = undefined) {
        let grouped = this.groupBy (orders, 'symbol')
        if (symbol) {
            if (symbol in grouped)
                return grouped[symbol]
            return []
        }
        return orders
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return ohlcv
    }

    parseOHLCVs (ohlcvs, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        ohlcvs = Object.values (ohlcvs)
        let result = []
        for (let i = 0; i < ohlcvs.length; i++) {
            if (limit && (result.length >= limit))
                break;
            let ohlcv = this.parseOHLCV (ohlcvs[i], market, timeframe, since, limit)
            if (since && (ohlcv[0] < since))
                continue
            result.push (ohlcv)
        }
        return result
    }

    editLimitBuyOrder (id, symbol, ...args) {
        return this.editLimitOrder (id, symbol, 'buy', ...args)
    }

    editLimitSellOrder (id, symbol, ...args) {
        return this.editLimitOrder (id, symbol, 'sell', ...args)
    }

    editLimitOrder (id, symbol, ...args) {
        return this.editOrder (id, symbol, 'limit', ...args)
    }

    async editOrder (id, symbol, ...args) {
        if (!this.enableRateLimit)
            throw new ExchangeError (this.id + ' editOrder() requires enableRateLimit = true')
        await this.cancelOrder (id, symbol);
        return this.createOrder (symbol, ...args)
    }

    createLimitBuyOrder (symbol, ...args) {
        return this.createOrder  (symbol, 'limit', 'buy', ...args)
    }

    createLimitSellOrder (symbol, ...args) {
        return this.createOrder (symbol, 'limit', 'sell', ...args)
    }

    createMarketBuyOrder (symbol, amount, params = {}) {
        return this.createOrder (symbol, 'market', 'buy', amount, undefined, params)
    }

    createMarketSellOrder (symbol, amount, params = {}) {
        return this.createOrder (symbol, 'market', 'sell', amount, undefined, params)
    }

    costToPrecision (symbol, cost) {
        return parseFloat (cost).toFixed (this.markets[symbol].precision.price)
    }

    priceToPrecision (symbol, price) {
        return parseFloat (price).toFixed (this.markets[symbol].precision.price)
    }

    amountToPrecision (symbol, amount) {
        return this.truncate(amount, this.markets[symbol].precision.amount)
    }

    amountToLots (symbol, amount) {
        return this.amountToPrecision (symbol, Math.floor (amount / this.markets[symbol].lot) * this.markets[symbol].lot)
    }

    feeToPrecision (symbol, fee) {
        return parseFloat (fee).toFixed (this.markets[symbol].precision.price)
    }

    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let market = this.markets[symbol]
        let rate = market[takerOrMaker]
        let cost = parseFloat (this.costToPrecision (symbol, amount * price))
        return {
            'type': takerOrMaker,
            'currency': market['quote'],
            'rate': rate,
            'cost': parseFloat (this.feeToPrecision (symbol, rate * cost)),
        }
    }

    Ymd (timestamp, infix = ' ') {
        let date = new Date (timestamp)
        let Y = date.getUTCFullYear ()
        let m = date.getUTCMonth () + 1
        let d = date.getUTCDate ()
        m = m < 10 ? ('0' + m) : m
        d = d < 10 ? ('0' + d) : d
        return Y + '-' + m + '-' + d
    }

    YmdHMS (timestamp, infix = ' ') {
        let date = new Date (timestamp)
        let Y = date.getUTCFullYear ()
        let m = date.getUTCMonth () + 1
        let d = date.getUTCDate ()
        let H = date.getUTCHours ()
        let M = date.getUTCMinutes ()
        let S = date.getUTCSeconds ()
        m = m < 10 ? ('0' + m) : m
        d = d < 10 ? ('0' + d) : d
        H = H < 10 ? ('0' + H) : H
        M = M < 10 ? ('0' + M) : M
        S = S < 10 ? ('0' + S) : S
        return Y + '-' + m + '-' + d + infix + H + ':' + M + ':' + S
    }
}

}).call(this,require('_process'))

},{"./Market":9,"./errors":10,"./functions":11,"./throttle":12,"_process":137,"fetch-ponyfill":136}],9:[function(require,module,exports){
"use strict";

module.exports = class Market {

    constructor (exchange, symbol) {
        this.exchange = exchange;
        this.symbol = symbol;
        this.market = exchange.markets[symbol];
    }

    amountToPrecision (amount) {
        return this.exchange.amountToPrecision (this.symbol, amount)
    }

    createLimitBuyOrder(amount, price) {
        return this.exchange.createLimitBuyOrder (this.symbol, amount, price)
    }

    createLimitSellOrder(amount, price) {
        return this.exchange.createLimitSellOrder (this.symbol, amount, price)
    }
}

},{}],10:[function(require,module,exports){
class BaseError extends Error {
    constructor (message) {
        super (message)
        // a workaround to make `instanceof BaseError` work in ES5
        this.constructor = BaseError
        this.__proto__   = BaseError.prototype
        this.message     = message
    }
}

class ExchangeError extends BaseError {
    constructor (message) {
        super (message)
        this.constructor = ExchangeError
        this.__proto__   = ExchangeError.prototype
        this.message     = message
    }
}

class NotSupported extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = NotSupported
        this.__proto__   = NotSupported.prototype
        this.message     = message
    }
}

class AuthenticationError extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = AuthenticationError
        this.__proto__   = AuthenticationError.prototype
        this.message     = message
    }
}

class InvalidNonce extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = InvalidNonce
        this.__proto__   = InvalidNonce.prototype
        this.message     = message
    }
}

class InsufficientFunds extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = InsufficientFunds
        this.__proto__   = InsufficientFunds.prototype
        this.message     = message
    }
}

class InvalidOrder extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = InvalidOrder
        this.__proto__   = InvalidOrder.prototype
        this.message     = message
    }
}

class OrderNotFound extends InvalidOrder {
    constructor (message) {
        super (message)
        this.constructor = OrderNotFound
        this.__proto__   = OrderNotFound.prototype
        this.message     = message
    }
}

class OrderNotCached extends InvalidOrder {
    constructor (message) {
        super (message)
        this.constructor = OrderNotCached
        this.__proto__   = OrderNotCached.prototype
        this.message     = message
    }
}

class CancelPending extends InvalidOrder {
    constructor (message) {
        super (message)
        this.constructor = CancelPending
        this.__proto__   = CancelPending.prototype
        this.message     = message
    }
}

class NetworkError extends BaseError {
    constructor (message) {
        super (message)
        this.constructor = NetworkError
        this.__proto__   = NetworkError.prototype
        this.message     = message
    }
}

class DDoSProtection extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = DDoSProtection
        this.__proto__   = DDoSProtection.prototype
        this.message     = message
    }
}

class RequestTimeout extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = RequestTimeout
        this.__proto__   = RequestTimeout.prototype
        this.message     = message
    }
}

class ExchangeNotAvailable extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = ExchangeNotAvailable
        this.__proto__   = ExchangeNotAvailable.prototype
        this.message     = message
    }
}

module.exports = {

    BaseError,
    ExchangeError,
    NotSupported,
    AuthenticationError,
    InvalidNonce,
    InsufficientFunds,
    InvalidOrder,
    OrderNotFound,
    OrderNotCached,
    CancelPending,
    NetworkError,
    DDoSProtection,
    RequestTimeout,
    ExchangeNotAvailable,
}
},{}],11:[function(require,module,exports){
"use strict";

//-----------------------------------------------------------------------------

const CryptoJS = require ('crypto-js')
    , qs       = require ('qs') // querystring

//-----------------------------------------------------------------------------

const { RequestTimeout } = require ('./errors')

//-----------------------------------------------------------------------------
// utility helpers

const setTimeout_original = setTimeout

// setTimeout can fire earlier than specified, so we need to ensure it does not happen...

const setTimeout_safe = (done, ms, setTimeout = setTimeout_original /* overrideable for mocking purposes */, targetTime = Date.now () + ms) => {

    let clearInnerTimeout = () => {}
    let active = true

    let id = setTimeout (() => {
        active = true
        const rest = targetTime - Date.now ()
        if (rest > 0) {
            clearInnerTimeout = setTimeout_safe (done, rest, setTimeout, targetTime) // try sleep more
        } else {
            done ()
        }
    }, ms)

    return function clear () { 
        if (active) {
            active = false // dunno if IDs are unique on various platforms, so it's better to rely on this flag to exclude the possible cancellation of the wrong timer (if called after completion)
            clearTimeout (id)
        }
        clearInnerTimeout ()
    }
}

const sleep = ms => new Promise (resolve => setTimeout_safe (resolve, ms))

const decimal = float => parseFloat (float).toString ()

const timeout = async (ms, promise) => {

    let clear = () => {}
    const timeout = new Promise (resolve => (clear = setTimeout_safe (resolve, ms)))

    try {
        return await Promise.race ([promise, timeout.then (() => { throw new RequestTimeout ('request timed out') })])
    } finally {
        clear () // fixes https://github.com/ccxt/ccxt/issues/749
    }
}

const capitalize = string => string.length ? (string.charAt (0).toUpperCase () + string.slice (1)) : string

const keysort = object => {
    const result = {}
    Object.keys (object).sort ().forEach (key => result[key] = object[key])
    return result
}

const extend = (...args) => Object.assign ({}, ...args)

const deepExtend = function (...args) {

    // if (args.length < 1)
    //     return args
    // else if (args.length < 2)
    //     return args[0]

    let result = undefined

    for (const arg of args) {

        if (arg && (typeof arg == 'object') && (arg.constructor === Object || !('constructor' in arg))) {

            if (typeof result != 'object') {
                result = {}
            }

            for (const key in arg) {
                result[key] = deepExtend (result[key], arg[key])
            }

        } else {

            result = arg
        }
    }

    return result
}

const omit = (object, ...args) => {
    const result = extend (object)
    for (const x of args) {
        if (typeof x === 'string') {
            delete result[x]
        } else if (Array.isArray (x)) {
            for (const k of x)
                delete result[k]
        }
    }
    return result
}

const groupBy = (array, key) => {
    const result = {}
    Object
        .values (array)
        .filter (entry => entry[key] != 'undefined')
        .forEach (entry => {
            if (typeof result[entry[key]] == 'undefined')
                result[entry[key]] = []
            result[entry[key]].push (entry)
        })
    return result
}

const filterBy = (array, key, value = undefined) => {
    if (value) {
        let grouped = groupBy (array, key)
        if (value in grouped)
            return grouped[value]
        return []
    }
    return array
}

const indexBy = (array, key) => {
    const result = {}
    Object
        .values (array)
        .filter (entry => entry[key] != 'undefined')
        .forEach (entry => {
            result[entry[key]] = entry
        })
    return result
}

const sortBy = (array, key, descending = false) => {
    descending = descending ? -1 : 1
    return array.sort ((a, b) => ((a[key] < b[key]) ? -descending : ((a[key] > b[key]) ? descending : 0)))
}

const flatten = (array, result = []) => {
    for (let i = 0, length = array.length; i < length; i++) {
        const value = array[i]
        if (Array.isArray (value)) {
            flatten (value, result)
        } else {
            result.push (value)
        }
    }
    return result
}

const unique = array => array.filter ((value, index, self) => (self.indexOf (value) == index))

const pluck = (array, key) => array
                                .filter (element => (typeof element[key] != 'undefined'))
                                .map (element => element[key])

const urlencode = object => qs.stringify (object)
const rawencode = object => qs.stringify (object, { encode: false })

const sum = (...args) => {
    const result = args.filter (arg => typeof arg != 'undefined')
    return (result.length > 0) ?
        result.reduce ((sum, value) => sum + value, 0) : undefined
}

const safeFloat = (object, key, defaultValue = undefined) => {
    if (key in object) {
        if (typeof object[key] == 'number')
            return object[key]
        else if ((typeof object[key] == 'string') && object[key])
            return parseFloat (object[key])
    }
    return defaultValue
}

const safeString = (object, key, defaultValue = undefined) => {
    return (object && (key in object) && object[key]) ? object[key].toString () : defaultValue
}

const safeInteger = (object, key, defaultValue = undefined) => {
    return ((key in object) && object[key]) ? parseInt (object[key]) : defaultValue
}

const safeValue = (object, key, defaultValue = undefined) => {
    return ((key in object) && object[key]) ? object[key] : defaultValue
}

const uuid = a => a ?
    (a ^ Math.random () * 16 >> a / 4).toString (16) :
    ([1e7]+-1e3+-4e3+-8e3+-1e11).replace (/[018]/g, uuid)

// See https://stackoverflow.com/questions/1685680/how-to-avoid-scientific-notation-for-large-numbers-in-javascript for discussion

function toFixed (x) { // avoid scientific notation for too large and too small numbers

    if (Math.abs (x) < 1.0) {
        const e = parseInt (x.toString ().split ('e-')[1])
        if (e) {
            x *= Math.pow (10, e-1)
            x = '0.' + (new Array (e)).join ('0') + x.toString ().substring (2)
        }
    } else {
        let e = parseInt (x.toString ().split ('+')[1])
        if (e > 20) {
            e -= 20
            x /= Math.pow (10, e)
            x += (new Array (e+1)).join ('0')
        }
    }
    return x
}

// See https://stackoverflow.com/questions/4912788/truncate-not-round-off-decimal-numbers-in-javascript for discussion

// > So, after all it turned out, rounding bugs will always haunt you, no matter how hard you try to compensate them.
// > Hence the problem should be attacked by representing numbers exactly in decimal notation.

const truncate_regExpCache = []
    , truncate = (num, precision = 0) => {
        num = toFixed (num)
        const re = truncate_regExpCache[precision] || (truncate_regExpCache[precision] = new RegExp("([-]*\\d+\\.\\d{" + precision + "})(\\d)"))
        const [,result] = num.toString ().match (re) || [null, num]
        return parseFloat (result)
    }

const precisionFromString = (string) => {
    const split = string.replace (/0+$/g, '').split ('.')
    return (split.length > 1) ? (split[1].length) : 0
}

const ordered = x => x // a stub to keep assoc keys in order, in JS it does nothing, it's mostly for Python

const aggregate = function (bidasks) {

    let result = {}

    bidasks.forEach (([ price, volume ]) => {
        result[price] = (result[price] || 0) + volume
    })

    return Object.keys (result).map (price => [
        parseFloat (price),
        parseFloat (result[price]),
    ])
}

//-----------------------------------------------------------------------------
// string ←→ binary ←→ base64 conversion routines

const stringToBinary = str => {
    const arr = new Uint8Array (str.length)
    for (let i = 0; i < str.length; i++) { arr[i] = str.charCodeAt(i); }
    return CryptoJS.lib.WordArray.create (arr)
}

const stringToBase64 = string => CryptoJS.enc.Latin1.parse (string).toString (CryptoJS.enc.Base64)
    , utf16ToBase64  = string => CryptoJS.enc.Utf16 .parse (string).toString (CryptoJS.enc.Base64)
    , base64ToBinary = string => CryptoJS.enc.Base64.parse (string)
    , base64ToString = string => CryptoJS.enc.Base64.parse (string).toString (CryptoJS.enc.Utf8)
    , binaryToString = string => string

const binaryConcat = (...args) => args.reduce ((a, b) => a.concat (b))

// url-safe-base64 without equals signs, with + replaced by - and slashes replaced by underscores
const urlencodeBase64 = base64string => base64string.replace (/[=]+$/, '')
                                                    .replace (/\+/g, '-')
                                                    .replace (/\//g, '_')

//-----------------------------------------------------------------------------
// cryptography

const hash = (request, hash = 'md5', digest = 'hex') => {
    const result = CryptoJS[hash.toUpperCase ()] (request)
    return (digest == 'binary') ? result : result.toString (CryptoJS.enc[capitalize (digest)])
}

const hmac = (request, secret, hash = 'sha256', digest = 'hex') => {
    const encoding = (digest == 'binary') ? 'Latin1' : capitalize (digest)
    return CryptoJS['Hmac' + hash.toUpperCase ()] (request, secret).toString (CryptoJS.enc[capitalize (encoding)])
}

//-----------------------------------------------------------------------------
// a JSON Web Token authentication method

const jwt = (request, secret, alg = 'HS256', hash = 'sha256') => {
    const encodedHeader = urlencodeBase64 (stringToBase64 (JSON.stringify ({ 'alg': alg, 'typ': 'JWT' })))
        , encodedData = urlencodeBase64 (stringToBase64 (JSON.stringify (request)))
        , token = [ encodedHeader, encodedData ].join ('.')
        , signature = urlencodeBase64 (utf16ToBase64 (hmac (token, secret, hash, 'utf16')))
    return [ token, signature ].join ('.')
}

//-----------------------------------------------------------------------------

module.exports = {

    setTimeout_safe,

    // common utility functions

    sleep,
    timeout,
    capitalize,
    keysort,
    extend,
    deepExtend,
    omit,
    groupBy,
    indexBy,
    sortBy,
    filterBy,
    flatten,
    unique,
    pluck,
    urlencode,
    rawencode,
    sum,
    decimal,
    safeFloat,
    safeString,
    safeInteger,
    safeValue,
    ordered,
    aggregate,
    truncate,
    uuid,
    precisionFromString,

    // underscore aliases

    index_by: indexBy,
    sort_by: sortBy,
    group_by: groupBy,
    filter_by: filterBy,
    safe_float: safeFloat,
    safe_string: safeString,
    safe_integer: safeInteger,
    safe_value: safeValue,

    // crypto functions

    binaryConcat,
    stringToBinary,
    binaryToString,
    stringToBase64,
    utf16ToBase64,
    base64ToBinary,
    base64ToString,
    urlencodeBase64,
    hash,
    hmac,
    jwt,

    // json
    json:   JSON.stringify,
    unjson: JSON.parse
}

},{"./errors":10,"crypto-js":110,"qs":139}],12:[function(require,module,exports){
"use strict";

const { sleep }  = require ('./functions')

const throttle = cfg => {

    let lastTimestamp = Date.now ()
        , numTokens = (typeof cfg.numTokens != 'undefined') ? cfg.numTokens : cfg.capacity
        , queue = []
        , running = false
        , counter = 0

    return Object.assign (cost => {

        if (queue.length > cfg.maxCapacity)
            throw new Error ('Backlog is over max capacity of ' + cfg.maxCapacity)

        return new Promise (async (resolve, reject) => {

            try {

                queue.push ({ cost, resolve, reject })

                if (!running) {
                    running = true
                    while (queue.length > 0) {
                        const hasEnoughTokens = cfg.capacity ? (numTokens > 0) : (numTokens >= 0)
                        if (hasEnoughTokens) {
                            if (queue.length > 0) {
                                let { cost, resolve, reject } = queue[0]
                                cost = (cost || cfg.defaultCost)
                                if (numTokens >= Math.min (cost, cfg.capacity)) {
                                    numTokens -= cost
                                    queue.shift ()
                                    resolve ()
                                }
                            }
                        }
                        let now = Date.now ()
                        let elapsed = now - lastTimestamp
                        lastTimestamp = now
                        numTokens = Math.min (cfg.capacity, numTokens + elapsed * cfg.refillRate)
                        await sleep (cfg.delay)
                    }
                    running = false
                }

            } catch (e) {

                reject (e)
            }
        })

    }, cfg, {
        configure: newCfg => throttle (Object.assign ({}, cfg, newCfg))
    })
}

module.exports = throttle

},{"./functions":11}],13:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, OrderNotFound, InvalidOrder } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class binance extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'binance',
            'name': 'Binance',
            'countries': 'CN', // China
            'rateLimit': 500,
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasFetchMyTrades': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchTickers': true,
                'fetchOHLCV': true,
                'fetchMyTrades': true,
                'fetchOrder': true,
                'fetchOrders': true,
                'fetchOpenOrders': true,
                'withdraw': true,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '8h': '8h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg',
                'api': {
                    'web': 'https://www.binance.com',
                    'wapi': 'https://api.binance.com/wapi/v3',
                    'public': 'https://api.binance.com/api/v1',
                    'private': 'https://api.binance.com/api/v3',
                },
                'www': 'https://www.binance.com',
                'doc': 'https://www.binance.com/restapipub.html',
                'fees': [
                    'https://binance.zendesk.com/hc/en-us/articles/115000429332',
                    'https://support.binance.com/hc/en-us/articles/115000583311',
                ],
            },
            'api': {
                'web': {
                    'get': [
                        'exchange/public/product',
                    ],
                },
                'wapi': {
                    'post': [
                        'withdraw',
                    ],
                    'get': [
                        'depositHistory',
                        'withdrawHistory',
                        'depositAddress',
                    ],
                },
                'public': {
                    'get': [
                        'exchangeInfo',
                        'ping',
                        'time',
                        'depth',
                        'aggTrades',
                        'klines',
                        'ticker/24hr',
                        'ticker/allPrices',
                        'ticker/allBookTickers',
                    ],
                },
                'private': {
                    'get': [
                        'order',
                        'openOrders',
                        'allOrders',
                        'account',
                        'myTrades',
                    ],
                    'post': [
                        'order',
                        'order/test',
                        'userDataStream',
                    ],
                    'put': [
                        'userDataStream'
                    ],
                    'delete': [
                        'order',
                        'userDataStream',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'taker': 0.001,
                    'maker': 0.001,
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BNB': 1.0,
                        'BTC': 0.0005,
                        'ETH': 0.005,
                        'LTC': 0.001,
                        'NEO': 0.0,
                        'QTUM': 0.01,
                        'SNT': 50.0,
                        'BNT': 0.6,
                        'EOS': 2.0,
                        'BCH': 0.0005,
                        'GAS': 0.0,
                        'USDT': 5.0,
                        'OAX': 2.0,
                        'DNT': 30.0,
                        'MCO': 0.15,
                        'ICN': 0.5,
                        'WTC': 0.2,
                        'OMG': 0.1,
                        'ZRX': 5.0,
                        'STRAT': 0.1,
                        'SNGLS': 8.0,
                        'BQX': 2.0,
                        'KNC': 1.0,
                        'FUN': 50.0,
                        'SNM': 10.0,
                        'LINK': 5.0,
                        'XVG': 0.1,
                        'CTR': 1.0,
                        'SALT': 0.3,
                        'IOTA': 0.0,
                        'MDA': 0.5,
                        'MTL': 0.15,
                        'SUB': 10.0,
                        'ETC': 0.01,
                        'MTH': 10.0,
                        'ENG': 2.0,
                        'AST': 4.0,
                        'BTG': undefined,
                        'DASH': 0.002,
                        'EVX': 1.0,
                        'REQ': 30.0,
                        'LRC': 7.0,
                        'VIB': 7.0,
                        'HSR': 0.0001,
                        'TRX': 500.0,
                        'POWR': 15.0,
                        'ARK': 0.1,
                        'YOYO': 30.0,
                        'XRP': 0.15,
                        'MOD': 1.0,
                        'ENJ': 1.0,
                        'STORJ': 2.0,
                    },
                    'deposit': {
                        'BNB': 0,
                        'BTC': 0,
                        'ETH': 0,
                        'LTC': 0,
                        'NEO': 0,
                        'QTUM': 0,
                        'SNT': 0,
                        'BNT': 0,
                        'EOS': 0,
                        'BCH': 0,
                        'GAS': 0,
                        'USDT': 0,
                        'OAX': 0,
                        'DNT': 0,
                        'MCO': 0,
                        'ICN': 0,
                        'WTC': 0,
                        'OMG': 0,
                        'ZRX': 0,
                        'STRAT': 0,
                        'SNGLS': 0,
                        'BQX': 0,
                        'KNC': 0,
                        'FUN': 0,
                        'SNM': 0,
                        'LINK': 0,
                        'XVG': 0,
                        'CTR': 0,
                        'SALT': 0,
                        'IOTA': 0,
                        'MDA': 0,
                        'MTL': 0,
                        'SUB': 0,
                        'ETC': 0,
                        'MTH': 0,
                        'ENG': 0,
                        'AST': 0,
                        'BTG': 0,
                        'DASH': 0,
                        'EVX': 0,
                        'REQ': 0,
                        'LRC': 0,
                        'VIB': 0,
                        'HSR': 0,
                        'TRX': 0,
                        'POWR': 0,
                        'ARK': 0,
                        'YOYO': 0,
                        'XRP': 0,
                        'MOD': 0,
                        'ENJ': 0,
                        'STORJ': 0,
                    },
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetExchangeInfo ();
        let markets = response['symbols'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['symbol'];
            let base = this.commonCurrencyCode (market['baseAsset']);
            let quote = this.commonCurrencyCode (market['quoteAsset']);
            let symbol = base + '/' + quote;
            let filters = this.indexBy (market['filters'], 'filterType');
            let precision = {
                'amount': market['baseAssetPrecision'],
                'price': market['quotePrecision'],
            };
            let active = (market['status'] == 'TRADING');
            let lot = -1 * Math.log10 (precision['amount']);
            let entry = this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'lot': lot,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': -1 * Math.log10 (precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': lot,
                        'max': undefined,
                    },
                },
            });
            if ('PRICE_FILTER' in filters) {
                let filter = filters['PRICE_FILTER'];
                entry['precision']['price'] = this.precisionFromString (filter['tickSize']);
                entry['limits']['price'] = {
                    'min': parseFloat (filter['minPrice']),
                    'max': parseFloat (filter['maxPrice']),
                };
            }
            if ('LOT_SIZE' in filters) {
                let filter = filters['LOT_SIZE'];
                entry['precision']['amount'] = this.precisionFromString (filter['stepSize']);
                entry['lot'] = parseFloat (filter['stepSize']);
                entry['limits']['amount'] = {
                    'min': parseFloat (filter['minQty']),
                    'max': parseFloat (filter['maxQty']),
                };
            }
            if ('MIN_NOTIONAL' in filters) {
                entry['limits']['cost']['min'] = parseFloat (filters['MIN_NOTIONAL']['minNotional']);
            }
            result.push (entry);
        }
        return result;
    }

    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let market = this.markets[symbol];
        let key = 'quote';
        let rate = market[takerOrMaker];
        let cost = parseFloat (this.costToPrecision (symbol, amount * rate));
        if (side == 'sell') {
            cost *= price;
        } else {
            key = 'base';
        }
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': parseFloat (this.feeToPrecision (symbol, cost)),
        };
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetAccount (params);
        let result = { 'info': response };
        let balances = response['balances'];
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let asset = balance['asset'];
            let currency = this.commonCurrencyCode (asset);
            let account = {
                'free': parseFloat (balance['free']),
                'used': parseFloat (balance['locked']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetDepth (this.extend ({
            'symbol': market['id'],
            'limit': 100, // default = maximum = 100
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market) {
        let timestamp = this.safeInteger (ticker, 'closeTime');
        if (typeof timestamp == 'undefined')
            timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'highPrice'),
            'low': this.safeFloat (ticker, 'lowPrice'),
            'bid': this.safeFloat (ticker, 'bidPrice'),
            'ask': this.safeFloat (ticker, 'askPrice'),
            'vwap': this.safeFloat (ticker, 'weightedAvgPrice'),
            'open': this.safeFloat (ticker, 'openPrice'),
            'close': this.safeFloat (ticker, 'prevClosePrice'),
            'first': undefined,
            'last': this.safeFloat (ticker, 'lastPrice'),
            'change': this.safeFloat (ticker, 'priceChangePercent'),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': this.safeFloat (ticker, 'quoteVolume'),
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTicker24hr (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (response, market);
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickerAllBookTickers (params);
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker['symbol'];
            if (id in this.markets_by_id) {
                let market = this.markets_by_id[id];
                let symbol = market['symbol'];
                result[symbol] = this.parseTicker (ticker, market);
            }
        }
        return result;
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0],
            parseFloat (ohlcv[1]),
            parseFloat (ohlcv[2]),
            parseFloat (ohlcv[3]),
            parseFloat (ohlcv[4]),
            parseFloat (ohlcv[5]),
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'interval': this.timeframes[timeframe],
        };
        request['limit'] = (limit) ? limit : 500; // default == max == 500
        if (since)
            request['startTime'] = since;
        let response = await this.publicGetKlines (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    parseTrade (trade, market = undefined) {
        let timestampField = ('T' in trade) ? 'T' : 'time';
        let timestamp = trade[timestampField];
        let priceField = ('p' in trade) ? 'p' : 'price';
        let price = parseFloat (trade[priceField]);
        let amountField = ('q' in trade) ? 'q' : 'qty';
        let amount = parseFloat (trade[amountField]);
        let idField = ('a' in trade) ? 'a' : 'id';
        let id = trade[idField].toString ();
        let side = undefined;
        let order = undefined;
        if ('orderId' in trade)
            order = trade['orderId'].toString ();
        if ('m' in trade) {
            side = trade['m'] ? 'sell' : 'buy'; // this is reversed intentionally
        } else {
            side = (trade['isBuyer']) ? 'buy' : 'sell'; // this is a true side
        }
        let fee = undefined;
        if ('commission' in trade) {
            fee = {
                'cost': parseFloat (trade['commission']),
                'currency': this.commonCurrencyCode (trade['commissionAsset']),
            };
        }
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': id,
            'order': order,
            'type': undefined,
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
        };
        if (since) {
            request['startTime'] = since;
            request['endTime'] = since + 86400000;
        }
        if (limit)
            request['limit'] = limit;
        // 'fromId': 123,    // ID to get aggregate trades from INCLUSIVE.
        // 'startTime': 456, // Timestamp in ms to get aggregate trades from INCLUSIVE.
        // 'endTime': 789,   // Timestamp in ms to get aggregate trades until INCLUSIVE.
        // 'limit': 500,     // default = maximum = 500
        let response = await this.publicGetAggTrades (this.extend (request, params));
        return this.parseTrades (response, market, since, limit);
    }

    parseOrderStatus (status) {
        if (status == 'NEW')
            return 'open';
        if (status == 'PARTIALLY_FILLED')
            return 'open';
        if (status == 'FILLED')
            return 'closed';
        if (status == 'CANCELED')
            return 'canceled';
        return status.toLowerCase ();
    }

    parseOrder (order, market = undefined) {
        let status = this.parseOrderStatus (order['status']);
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            let id = order['symbol'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
        }
        let timestamp = order['time'];
        let price = parseFloat (order['price']);
        let amount = parseFloat (order['origQty']);
        let filled = this.safeFloat (order, 'executedQty', 0.0);
        let remaining = Math.max (amount - filled, 0.0);
        let result = {
            'info': order,
            'id': order['orderId'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': order['type'].toLowerCase (),
            'side': order['side'].toLowerCase (),
            'price': price,
            'amount': amount,
            'cost': price * amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': undefined,
        };
        return result;
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let order = {
            'symbol': market['id'],
            'quantity': this.amountToPrecision (symbol, amount),
            'type': type.toUpperCase (),
            'side': side.toUpperCase (),
        };
        if (type == 'limit') {
            order = this.extend (order, {
                'price': this.priceToPrecision (symbol, price),
                'timeInForce': 'GTC', // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
            });
        }
        let response = await this.privatePostOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderId'].toString (),
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrder requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privateGetOrder (this.extend ({
            'symbol': market['id'],
            'orderId': parseInt (id),
        }, params));
        return this.parseOrder (response, market);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrders requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.privateGetAllOrders (this.extend (request, params));
        return this.parseOrders (response, market, since, limit);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privateGetOpenOrders (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseOrders (response, market, since, limit);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' cancelOrder requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = undefined;
        try {
            response = await this.privateDeleteOrder (this.extend ({
                'symbol': market['id'],
                'orderId': parseInt (id),
                // 'origClientOrderId': id,
            }, params));
        } catch (e) {
            if (this.last_http_response.indexOf ('UNKNOWN_ORDER') >= 0)
                throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
            throw e;
        }
        return response;
    }

    nonce () {
        return this.milliseconds ();
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchMyTrades requires a symbol');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.privateGetMyTrades (this.extend (request, params));
        return this.parseTrades (response, market, since, limit);
    }

    commonCurrencyCode (currency) {
        if (currency == 'BCC')
            return 'BCH';
        return currency;
    }

    currencyId (currency) {
        if (currency == 'BCH')
            return 'BCC';
        return currency;
    }

    async fetchDepositAddress (currency, params = {}) {
        let response = await this.wapiGetDepositAddress (this.extend ({
            'asset': this.currencyId (currency),
            'recvWindow': 10000000,
        }, params));
        if ('success' in response) {
            if (response['success']) {
                let address = this.safeString (response, 'address');
                return {
                    'currency': currency,
                    'address': address,
                    'status': 'ok',
                    'info': response,
                };
            }
        }
        throw new ExchangeError (this.id + ' fetchDepositAddress failed: ' + this.last_http_response);
    }

    async withdraw (currency, amount, address, params = {}) {
        let response = await this.wapiPostWithdraw (this.extend ({
            'asset': this.currencyId (currency),
            'address': address,
            'amount': parseFloat (amount),
            'recvWindow': 10000000,
        }, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        url += '/' + path;
        if (api == 'wapi')
            url += '.html';
        if ((api == 'private') || (api == 'wapi')) {
            this.checkRequiredCredentials ();
            let nonce = this.milliseconds ();
            let query = this.urlencode (this.extend ({ 'timestamp': nonce }, params));
            let signature = this.hmac (this.encode (query), this.encode (this.secret));
            query += '&' + 'signature=' + signature;
            headers = {
                'X-MBX-APIKEY': this.apiKey,
            };
            if ((method == 'GET') || (api == 'wapi')) {
                url += '?' + query;
            } else {
                body = query;
                headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code >= 400) {
            if (body.indexOf ('MIN_NOTIONAL') >= 0)
                throw new InvalidOrder (this.id + ' order cost = amount * price should be > 0.001 BTC ' + body);
            if (body.indexOf ('LOT_SIZE') >= 0)
                throw new InvalidOrder (this.id + ' order amount should be evenly divisible by lot size, use this.amountToLots (symbol, amount) ' + body);
            if (body.indexOf ('PRICE_FILTER') >= 0)
                throw new InvalidOrder (this.id + ' order price exceeds allowed price precision or invalid, use this.priceToPrecision (symbol, amount) ' + body);
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('code' in response) {
            if (response['code'] < 0) {
                if (response['code'] == -2010)
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
                if (response['code'] == -2011)
                    throw new OrderNotFound (this.id + ' ' + this.json (response));
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],14:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

//  ---------------------------------------------------------------------------

module.exports = class bit2c extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bit2c',
            'name': 'Bit2C',
            'countries': 'IL', // Israel
            'rateLimit': 3000,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg',
                'api': 'https://www.bit2c.co.il',
                'www': 'https://www.bit2c.co.il',
                'doc': [
                    'https://www.bit2c.co.il/home/api',
                    'https://github.com/OferE/bit2c',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'Exchanges/{pair}/Ticker',
                        'Exchanges/{pair}/orderbook',
                        'Exchanges/{pair}/trades',
                    ],
                },
                'private': {
                    'post': [
                        'Account/Balance',
                        'Account/Balance/v2',
                        'Merchant/CreateCheckout',
                        'Order/AccountHistory',
                        'Order/AddCoinFundsRequest',
                        'Order/AddFund',
                        'Order/AddOrder',
                        'Order/AddOrderMarketPriceBuy',
                        'Order/AddOrderMarketPriceSell',
                        'Order/CancelOrder',
                        'Order/MyOrders',
                        'Payment/GetMyId',
                        'Payment/Send',
                    ],
                },
            },
            'markets': {
                'BTC/NIS': { 'id': 'BtcNis', 'symbol': 'BTC/NIS', 'base': 'BTC', 'quote': 'NIS' },
                'BCH/NIS': { 'id': 'BchNis', 'symbol': 'BCH/NIS', 'base': 'BCH', 'quote': 'NIS' },
                'LTC/NIS': { 'id': 'LtcNis', 'symbol': 'LTC/NIS', 'base': 'LTC', 'quote': 'NIS' },
                'BTG/NIS': { 'id': 'BtgNis', 'symbol': 'BTG/NIS', 'base': 'BTG', 'quote': 'NIS' },
            },
            'fees': {
                'trading': {
                    'maker': 0.5 / 100,
                    'taker': 0.5 / 100,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balance = await this.privatePostAccountBalanceV2 ();
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balance) {
                let available = 'AVAILABLE_' + currency;
                account['free'] = balance[available];
                account['total'] = balance[currency];
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetExchangesPairOrderbook (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetExchangesPairTicker (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let averagePrice = parseFloat (ticker['av']);
        let baseVolume = parseFloat (ticker['a']);
        let quoteVolume = baseVolume * averagePrice;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['h']),
            'ask': parseFloat (ticker['l']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['ll']),
            'change': undefined,
            'percentage': undefined,
            'average': averagePrice,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = parseInt (trade['date']) * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetExchangesPairTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePostOrderAddOrder';
        let order = {
            'Amount': amount,
            'Pair': this.marketId (symbol),
        };
        if (type == 'market') {
            method += 'MarketPrice' + this.capitalize (side);
        } else {
            order['Price'] = price;
            order['Total'] = amount * price;
            order['IsBid'] = (side == 'buy');
        }
        let result = await this[method] (this.extend (order, params));
        return {
            'info': result,
            'id': result['NewOrder']['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostOrderCancelOrder ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        if (api == 'public') {
            url += '.json';
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let query = this.extend ({ 'nonce': nonce }, params);
            body = this.urlencode (query);
            let signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'key': this.apiKey,
                'sign': this.decode (signature),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8}],15:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitbay extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitbay',
            'name': 'BitBay',
            'countries': [ 'PL', 'EU' ], // Poland
            'rateLimit': 1000,
            'hasCORS': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766132-978a7bd8-5ece-11e7-9540-bc96d1e9bbb8.jpg',
                'www': 'https://bitbay.net',
                'api': {
                    'public': 'https://bitbay.net/API/Public',
                    'private': 'https://bitbay.net/API/Trading/tradingApi.php',
                },
                'doc': [
                    'https://bitbay.net/public-api',
                    'https://bitbay.net/account/tab-api',
                    'https://github.com/BitBayNet/API',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{id}/all',
                        '{id}/market',
                        '{id}/orderbook',
                        '{id}/ticker',
                        '{id}/trades',
                    ],
                },
                'private': {
                    'post': [
                        'info',
                        'trade',
                        'cancel',
                        'orderbook',
                        'orders',
                        'transfer',
                        'withdraw',
                        'history',
                        'transactions',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTC/PLN': { 'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                'LTC/USD': { 'id': 'LTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD' },
                'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR' },
                'LTC/PLN': { 'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN' },
                'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'ETH/USD': { 'id': 'ETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
                'ETH/EUR': { 'id': 'ETHEUR', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR' },
                'ETH/PLN': { 'id': 'ETHPLN', 'symbol': 'ETH/PLN', 'base': 'ETH', 'quote': 'PLN' },
                'ETH/BTC': { 'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
                'LSK/USD': { 'id': 'LSKUSD', 'symbol': 'LSK/USD', 'base': 'LSK', 'quote': 'USD' },
                'LSK/EUR': { 'id': 'LSKEUR', 'symbol': 'LSK/EUR', 'base': 'LSK', 'quote': 'EUR' },
                'LSK/PLN': { 'id': 'LSKPLN', 'symbol': 'LSK/PLN', 'base': 'LSK', 'quote': 'PLN' },
                'LSK/BTC': { 'id': 'LSKBTC', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC' },
            },
            'fees': {
                'trading': {
                    'maker': 0.3 / 100,
                    'taker': 0.0043,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostInfo ();
        if ('balances' in response) {
            let balance = response['balances'];
            let result = { 'info': balance };
            let currencies = Object.keys (this.currencies);
            for (let i = 0; i < currencies.length; i++) {
                let currency = currencies[i];
                let account = this.account ();
                if (currency in balance) {
                    account['free'] = parseFloat (balance[currency]['available']);
                    account['used'] = parseFloat (balance[currency]['locked']);
                    account['total'] = this.sum (account['free'], account['used']);
                }
                result[currency] = account;
            }
            return this.parseBalance (result);
        }
        throw new ExchangeError (this.id + ' empty balance response ' + this.json (response));
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetIdOrderbook (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetIdTicker (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let baseVolume = this.safeFloat (ticker, 'volume');
        let vwap = this.safeFloat (ticker, 'vwap');
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'max'),
            'low': this.safeFloat (ticker, 'min'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'average'),
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        return this.privatePostTrade (this.extend ({
            'type': side,
            'currency': market['base'],
            'amount': amount,
            'payment_currency': market['quote'],
            'rate': price,
        }, params));
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancel ({ 'id': id });
    }

    isFiat (currency) {
        let fiatCurrencies = {
            'USD': true,
            'EUR': true,
            'PLN': true,
        };
        if (currency in fiatCurrencies)
            return true;
        return false;
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let method = undefined;
        let request = {
            'currency': currency,
            'quantity': amount,
        };
        if (this.isFiat (currency)) {
            method = 'privatePostWithdraw';
            // request['account'] = params['account']; // they demand an account number
            // request['express'] = params['express']; // whatever it means, they don't explain
            // request['bic'] = '';
        } else {
            method = 'privatePostTransfer';
            request['address'] = address;
        }
        let response = await this[method] (this.extend (request, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path, params) + '.json';
        } else {
            this.checkRequiredCredentials ();
            body = this.urlencode (this.extend ({
                'method': path,
                'moment': this.nonce (),
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'API-Key': this.apiKey,
                'API-Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],16:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitcoincoid extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitcoincoid',
            'name': 'Bitcoin.co.id',
            'countries': 'ID', // Indonesia
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766138-043c7786-5ecf-11e7-882b-809c14f38b53.jpg',
                'api': {
                    'public': 'https://vip.bitcoin.co.id/api',
                    'private': 'https://vip.bitcoin.co.id/tapi',
                },
                'www': 'https://www.bitcoin.co.id',
                'doc': [
                    'https://vip.bitcoin.co.id/downloads/BITCOINCOID-API-DOCUMENTATION.pdf',
                    'https://vip.bitcoin.co.id/trade_api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{pair}/ticker',
                        '{pair}/trades',
                        '{pair}/depth',
                    ],
                },
                'private': {
                    'post': [
                        'getInfo',
                        'transHistory',
                        'trade',
                        'tradeHistory',
                        'openOrders',
                        'cancelOrder',
                    ],
                },
            },
            'markets': {
                'BTC/IDR': { 'id': 'btc_idr', 'symbol': 'BTC/IDR', 'base': 'BTC', 'quote': 'IDR', 'baseId': 'btc', 'quoteId': 'idr' },
                'BCH/IDR': { 'id': 'bch_idr', 'symbol': 'BCH/IDR', 'base': 'BCH', 'quote': 'IDR', 'baseId': 'bch', 'quoteId': 'idr' },
                'ETH/IDR': { 'id': 'eth_idr', 'symbol': 'ETH/IDR', 'base': 'ETH', 'quote': 'IDR', 'baseId': 'eth', 'quoteId': 'idr' },
                'ETC/IDR': { 'id': 'etc_idr', 'symbol': 'ETC/IDR', 'base': 'ETC', 'quote': 'IDR', 'baseId': 'etc', 'quoteId': 'idr' },
                'XRP/IDR': { 'id': 'xrp_idr', 'symbol': 'XRP/IDR', 'base': 'XRP', 'quote': 'IDR', 'baseId': 'xrp', 'quoteId': 'idr' },
                'XZC/IDR': { 'id': 'xzc_idr', 'symbol': 'XZC/IDR', 'base': 'XZC', 'quote': 'IDR', 'baseId': 'xzc', 'quoteId': 'idr' },
                'XLM/IDR': {'id': 'str_idr', 'symbol': 'XLM/IDR', 'base': 'XLM', 'quote': 'IDR', 'baseId': 'str', 'quoteId': 'idr'},
                'BTS/BTC': { 'id': 'bts_btc', 'symbol': 'BTS/BTC', 'base': 'BTS', 'quote': 'BTC', 'baseId': 'bts', 'quoteId': 'btc' },
                'DASH/BTC': { 'id': 'drk_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC', 'baseId': 'drk', 'quoteId': 'btc' },
                'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC', 'baseId': 'doge', 'quoteId': 'btc' },
                'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'eth', 'quoteId': 'btc' },
                'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'ltc', 'quoteId': 'btc' },
                'NXT/BTC': { 'id': 'nxt_btc', 'symbol': 'NXT/BTC', 'base': 'NXT', 'quote': 'BTC', 'baseId': 'nxt', 'quoteId': 'btc' },
                'XLM/BTC': { 'id': 'str_btc', 'symbol': 'XLM/BTC', 'base': 'XLM', 'quote': 'BTC', 'baseId': 'str', 'quoteId': 'btc' },
                'XEM/BTC': { 'id': 'nem_btc', 'symbol': 'XEM/BTC', 'base': 'XEM', 'quote': 'BTC', 'baseId': 'nem', 'quoteId': 'btc' },
                'XRP/BTC': { 'id': 'xrp_btc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'baseId': 'xrp', 'quoteId': 'btc' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostGetInfo ();
        let balance = response['return'];
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            account['free'] = this.safeFloat (balance['balance'], lowercase, 0.0);
            account['used'] = this.safeFloat (balance['balance_hold'], lowercase, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetPairDepth (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell');
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetPairTicker (this.extend ({
            'pair': market['id'],
        }, params));
        let ticker = response['ticker'];
        let timestamp = parseFloat (ticker['server_time']) * 1000;
        let baseVolume = 'vol_' + market['baseId'].toLowerCase ();
        let quoteVolume = 'vol_' + market['quoteId'].toLowerCase ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker[baseVolume]),
            'quoteVolume': parseFloat (ticker[quoteVolume]),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetPairTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let order = {
            'pair': market['id'],
            'type': side,
            'price': price,
        };
        let base = market['baseId'];
        order[base] = amount;
        let result = await this.privatePostTrade (this.extend (order, params));
        return {
            'info': result,
            'id': result['return']['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path, params);
        } else {
            this.checkRequiredCredentials ();
            body = this.urlencode (this.extend ({
                'method': path,
                'nonce': this.nonce (),
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + response['error']);
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],17:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, NotSupported, InvalidOrder, OrderNotFound } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitfinex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitfinex',
            'name': 'Bitfinex',
            'countries': 'US',
            'version': 'v1',
            'rateLimit': 1500,
            'hasCORS': false,
            // old metainfo interface
            'hasFetchOrder': true,
            'hasFetchTickers': true,
            'hasDeposit': true,
            'hasWithdraw': true,
            'hasFetchOHLCV': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            // new metainfo interface
            'has': {
                'fetchOHLCV': true,
                'fetchTickers': true,
                'fetchOrder': true,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
                'fetchMyTrades': true,
                'withdraw': true,
                'deposit': true,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '3h': '3h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '7D',
                '2w': '14D',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                'api': 'https://api.bitfinex.com',
                'www': 'https://www.bitfinex.com',
                'doc': [
                    'https://bitfinex.readme.io/v1/docs',
                    'https://github.com/bitfinexcom/bitfinex-api-node',
                ],
            },
            'api': {
                'v2': {
                    'get': [
                        'candles/trade:{timeframe}:{symbol}/{section}',
                        'candles/trade:{timeframe}:{symbol}/last',
                        'candles/trade:{timeframe}:{symbol}/hist',
                    ],
                },
                'public': {
                    'get': [
                        'book/{symbol}',
                        // 'candles/{symbol}',
                        'lendbook/{currency}',
                        'lends/{currency}',
                        'pubticker/{symbol}',
                        'stats/{symbol}',
                        'symbols',
                        'symbols_details',
                        'tickers',
                        'today',
                        'trades/{symbol}',
                    ],
                },
                'private': {
                    'post': [
                        'account_fees',
                        'account_infos',
                        'balances',
                        'basket_manage',
                        'credits',
                        'deposit/new',
                        'funding/close',
                        'history',
                        'history/movements',
                        'key_info',
                        'margin_infos',
                        'mytrades',
                        'mytrades_funding',
                        'offer/cancel',
                        'offer/new',
                        'offer/status',
                        'offers',
                        'offers/hist',
                        'order/cancel',
                        'order/cancel/all',
                        'order/cancel/multi',
                        'order/cancel/replace',
                        'order/new',
                        'order/new/multi',
                        'order/status',
                        'orders',
                        'orders/hist',
                        'position/claim',
                        'positions',
                        'summary',
                        'taken_funds',
                        'total_taken_funds',
                        'transfer',
                        'unused_taken_funds',
                        'withdraw',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': true,
                    'percentage': true,
                    'maker': 0.1 / 100,
                    'taker': 0.2 / 100,
                    'tiers': {
                        'taker': [
                            [0, 0.2 / 100],
                            [500000, 0.2 / 100],
                            [1000000, 0.2 / 100],
                            [2500000, 0.2 / 100],
                            [5000000, 0.2 / 100],
                            [7500000, 0.2 / 100],
                            [10000000, 0.18 / 100],
                            [15000000, 0.16 / 100],
                            [20000000, 0.14 / 100],
                            [25000000, 0.12 / 100],
                            [30000000, 0.1 / 100],
                        ],
                        'maker': [
                            [0, 0.1 / 100],
                            [500000, 0.08 / 100],
                            [1000000, 0.06 / 100],
                            [2500000, 0.04 / 100],
                            [5000000, 0.02 / 100],
                            [7500000, 0],
                            [10000000, 0],
                            [15000000, 0],
                            [20000000, 0],
                            [25000000, 0],
                            [30000000, 0],
                        ],
                    },
                },
                'funding': {
                    'tierBased': false, // true for tier-based/progressive
                    'percentage': false, // fixed commission
                    'deposit': {
                        'BTC': 0.0005,
                        'IOTA': 0.5,
                        'ETH': 0.01,
                        'BCH': 0.01,
                        'LTC': 0.1,
                        'EOS': 0.1,
                        'XMR': 0.04,
                        'SAN': 0.1,
                        'DASH': 0.01,
                        'ETC': 0.01,
                        'XPR': 0.02,
                        'YYW': 0.1,
                        'NEO': 0,
                        'ZEC': 0.1,
                        'BTG': 0,
                        'OMG': 0.1,
                        'DATA': 1,
                        'QASH': 1,
                        'ETP': 0.01,
                        'QTUM': 0.01,
                        'EDO': 0.5,
                        'AVT': 0.5,
                        'USDT': 0,
                    },
                    'withdraw': {
                        'BTC': 0.0005,
                        'IOTA': 0.5,
                        'ETH': 0.01,
                        'BCH': 0.01,
                        'LTC': 0.1,
                        'EOS': 0.1,
                        'XMR': 0.04,
                        'SAN': 0.1,
                        'DASH': 0.01,
                        'ETC': 0.01,
                        'XPR': 0.02,
                        'YYW': 0.1,
                        'NEO': 0,
                        'ZEC': 0.1,
                        'BTG': 0,
                        'OMG': 0.1,
                        'DATA': 1,
                        'QASH': 1,
                        'ETP': 0.01,
                        'QTUM': 0.01,
                        'EDO': 0.5,
                        'AVT': 0.5,
                        'USDT': 5,
                    },
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        // issue #4 Bitfinex names Dash as DSH, instead of DASH
        if (currency == 'DSH')
            return 'DASH';
        if (currency == 'QTM')
            return 'QTUM';
        if (currency == 'BCC')
            return 'CST_BCC';
        if (currency == 'BCU')
            return 'CST_BCU';
        // issue #796
        if (currency == 'IOT')
            return 'IOTA';
        return currency;
    }

    async fetchMarkets () {
        let markets = await this.publicGetSymbolsDetails ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['pair'].toUpperCase ();
            let baseId = id.slice (0, 3);
            let quoteId = id.slice (3, 6);
            let base = this.commonCurrencyCode (baseId);
            let quote = this.commonCurrencyCode (quoteId);
            let symbol = base + '/' + quote;
            let precision = {
                'price': market['price_precision'],
                'amount': market['price_precision'],
            };
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': parseFloat (market['minimum_order_size']),
                        'max': parseFloat (market['maximum_order_size']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balanceType = this.safeString (params, 'type', 'exchange');
        let balances = await this.privatePostBalances ();
        let result = { 'info': balances };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            if (balance['type'] == balanceType) {
                let currency = balance['currency'];
                let uppercase = currency.toUpperCase ();
                uppercase = this.commonCurrencyCode (uppercase);
                let account = this.account ();
                account['free'] = parseFloat (balance['available']);
                account['total'] = parseFloat (balance['amount']);
                account['used'] = account['total'] - account['free'];
                result[uppercase] = account;
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers (params);
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            if ('pair' in ticker) {
                let id = ticker['pair'];
                if (id in this.markets_by_id) {
                    let market = this.markets_by_id[id];
                    let symbol = market['symbol'];
                    result[symbol] = this.parseTicker (ticker, market);
                } else {
                    throw new ExchangeError (this.id + ' fetchTickers() failed to recognize symbol ' + id + ' ' + this.json (ticker));
                }
            } else {
                throw new ExchangeError (this.id + ' fetchTickers() response not recognized ' + this.json (tickers));
            }
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetPubtickerSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = parseFloat (ticker['timestamp']) * 1000;
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else if ('pair' in ticker) {
            let id = ticker['pair'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                throw new ExchangeError (this.id + ' unrecognized ticker symbol ' + id + ' ' + this.json (ticker));
            }
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['mid']),
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (parseFloat (trade['timestamp'])) * 1000;
        let side = trade['type'].toLowerCase ();
        let orderId = this.safeString (trade, 'order_id');
        let price = parseFloat (trade['price']);
        let amount = parseFloat (trade['amount']);
        let cost = price * amount;
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'order': orderId,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': undefined,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = { 'symbol': market['id'] };
        if (limit) {
            request['limit_trades'] = limit;
        }
        if (since) {
            request['timestamp'] = parseInt (since / 1000);
        }
        let response = await this.privatePostMytrades (this.extend (request, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let orderType = type;
        if ((type == 'limit') || (type == 'market'))
            orderType = 'exchange ' + type;
        // amount = this.amountToPrecision (symbol, amount);
        let order = {
            'symbol': this.marketId (symbol),
            'amount': amount.toString (),
            'side': side,
            'type': orderType,
            'ocoorder': false,
            'buy_price_oco': 0,
            'sell_price_oco': 0,
        };
        if (type == 'market') {
            order['price'] = this.nonce ().toString ();
        } else {
            // price = this.priceToPrecision (symbol, price);
            order['price'] = price.toString ();
        }
        let result = await this.privatePostOrderNew (this.extend (order, params));
        return this.parseOrder(result);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_id': parseInt (id) });
    }

    parseOrder (order, market = undefined) {
        let side = order['side'];
        let open = order['is_live'];
        let canceled = order['is_cancelled'];
        let status = undefined;
        if (open) {
            status = 'open';
        } else if (canceled) {
            status = 'canceled';
        } else {
            status = 'closed';
        }
        let symbol = undefined;
        if (!market) {
            let exchange = order['symbol'].toUpperCase ();
            if (exchange in this.markets_by_id) {
                market = this.markets_by_id[exchange];
            }
        }
        if (market)
            symbol = market['symbol'];
        let orderType = order['type'];
        let exchange = orderType.indexOf ('exchange ') >= 0;
        if (exchange) {
            let [ prefix, orderType ] = order['type'].split (' ');
        }
        let timestamp = parseInt (parseFloat (order['timestamp']) * 1000);
        let result = {
            'info': order,
            'id': order['id'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': orderType,
            'side': side,
            'price': parseFloat (order['price']),
            'average': parseFloat (order['avg_execution_price']),
            'amount': parseFloat (order['original_amount']),
            'remaining': parseFloat (order['remaining_amount']),
            'filled': parseFloat (order['executed_amount']),
            'status': status,
            'fee': undefined,
        };
        return result;
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrders (params);
        let orders = this.parseOrders (response, undefined, since, limit);
        if (symbol)
            orders = this.filterBy (orders, 'symbol', symbol);
        return orders;
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        if (limit)
            request['limit'] = limit;
        let response = await this.privatePostOrdersHist (this.extend (request, params));
        let orders = this.parseOrders (response, undefined, since, limit);
        if (symbol)
            return this.filterBy (orders, 'symbol', symbol);
        return orders;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus (this.extend ({
            'order_id': parseInt (id),
        }, params));
        return this.parseOrder (response);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0],
            ohlcv[1],
            ohlcv[3],
            ohlcv[4],
            ohlcv[2],
            ohlcv[5],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let v2id = 't' + market['id'];
        let request = {
            'symbol': v2id,
            'timeframe': this.timeframes[timeframe],
        };
        if (limit)
            request['limit'] = limit;
        if (since)
            request['start'] = since;
        request = this.extend (request, params);
        let response = await this.v2GetCandlesTradeTimeframeSymbolHist (request);
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    getCurrencyName (currency) {
        if (currency == 'BTC') {
            return 'bitcoin';
        } else if (currency == 'LTC') {
            return 'litecoin';
        } else if (currency == 'ETH') {
            return 'ethereum';
        } else if (currency == 'ETC') {
            return 'ethereumc';
        } else if (currency == 'OMNI') {
            return 'mastercoin'; // ???
        } else if (currency == 'ZEC') {
            return 'zcash';
        } else if (currency == 'XMR') {
            return 'monero';
        } else if (currency == 'USD') {
            return 'wire';
        } else if (currency == 'DASH') {
            return 'dash';
        } else if (currency == 'XRP') {
            return 'ripple';
        } else if (currency == 'EOS') {
            return 'eos';
        } else if (currency == 'BCH') {
            return 'bcash';
        } else if (currency == 'USDT') {
            return 'tetheruso';
        }
        throw new NotSupported (this.id + ' ' + currency + ' not supported for withdrawal');
    }

    async createDepositAddress (currency, params = {}) {
        let response = await this.fetchDepositAddress (currency, this.extend ({
            'renew': 1,
        }, params));
        return {
            'currency': currency,
            'address': response['address'],
            'status': 'ok',
            'info': response['info'],
        };
    }

    async fetchDepositAddress (currency, params = {}) {
        let name = this.getCurrencyName (currency);
        let request = {
            'method': name,
            'wallet_name': 'exchange',
            'renew': 0, // a value of 1 will generate a new address
        };
        let response = await this.privatePostDepositNew (this.extend (request, params));
        return {
            'currency': currency,
            'address': response['address'],
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        let name = this.getCurrencyName (currency);
        let request = {
            'withdraw_type': name,
            'walletselected': 'exchange',
            'amount': amount.toString (),
            'address': address,
        };
        let responses = await this.privatePostWithdraw (this.extend (request, params));
        let response = responses[0];
        return {
            'info': response,
            'id': response['withdrawal_id'],
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.implodeParams (path, params);
        if (api == 'v2') {
            request = '/' + api + request;
        } else {
            request = '/' + this.version + request;
        }
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + request;
        if ((api == 'public') || (path.indexOf ('/hist') >= 0)) {
            if (Object.keys (query).length) {
                let suffix = '?' + this.urlencode (query);
                url += suffix;
                request += suffix;
            }
        }
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            query = this.extend ({
                'nonce': nonce.toString (),
                'request': request,
            }, query);
            query = this.json (query);
            query = this.encode (query);
            let payload = this.stringToBase64 (query);
            let secret = this.encode (this.secret);
            let signature = this.hmac (payload, secret, 'sha384');
            headers = {
                'X-BFX-APIKEY': this.apiKey,
                'X-BFX-PAYLOAD': this.decode (payload),
                'X-BFX-SIGNATURE': signature,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                let message = response['message'];
                if (message.indexOf ('Key price should be a decimal number') >= 0) {
                    throw new InvalidOrder (this.id + ' ' + message);
                } else if (message.indexOf ('Invalid order: not enough exchange balance') >= 0) {
                    throw new InsufficientFunds (this.id + ' ' + message);
                } else if (message.indexOf ('Invalid order') >= 0) {
                    throw new InvalidOrder (this.id + ' ' + message);
                } else if (message.indexOf ('Order could not be cancelled.') >= 0) {
                    throw new OrderNotFound (this.id + ' ' + message);
                }
            }
            throw new ExchangeError (this.id + ' ' + body);
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('message' in response) {
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],18:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const bitfinex = require ('./bitfinex.js')
const { ExchangeError, NotSupported, InsufficientFunds } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class bitfinex2 extends bitfinex {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitfinex2',
            'name': 'Bitfinex v2',
            'countries': 'US',
            'version': 'v2',
            'hasCORS': true,
            // old metainfo interface
            'hasFetchOrder': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'hasDeposit': false,
            'hasFetchOpenOrders': false,
            'hasFetchClosedOrders': false,
            // new metainfo interface
            'has': {
                'fetchOHLCV': true,
                'fetchTickers': true,
                'fetchOrder': true,
                'fetchOpenOrders': false,
                'fetchClosedOrders': false,
                'withdraw': true,
                'deposit': false,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '3h': '3h',
                '6h': '6h',
                '12h': '12h',
                '1d': '1D',
                '1w': '7D',
                '2w': '14D',
                '1M': '1M',
            },
            'rateLimit': 1500,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                'api': 'https://api.bitfinex.com',
                'www': 'https://www.bitfinex.com',
                'doc': [
                    'https://bitfinex.readme.io/v2/docs',
                    'https://github.com/bitfinexcom/bitfinex-api-node',
                ],
                'fees': 'https://www.bitfinex.com/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'platform/status',
                        'tickers',
                        'ticker/{symbol}',
                        'trades/{symbol}/hist',
                        'book/{symbol}/{precision}',
                        'book/{symbol}/P0',
                        'book/{symbol}/P1',
                        'book/{symbol}/P2',
                        'book/{symbol}/P3',
                        'book/{symbol}/R0',
                        'symbols_details',
                        'stats1/{key}:{size}:{symbol}/{side}/{section}',
                        'stats1/{key}:{size}:{symbol}/long/last',
                        'stats1/{key}:{size}:{symbol}/long/hist',
                        'stats1/{key}:{size}:{symbol}/short/last',
                        'stats1/{key}:{size}:{symbol}/short/hist',
                        'candles/trade:{timeframe}:{symbol}/{section}',
                        'candles/trade:{timeframe}:{symbol}/last',
                        'candles/trade:{timeframe}:{symbol}/hist',
                    ],
                    'post': [
                        'calc/trade/avg',
                    ],
                },
                'private': {
                    'post': [
                        'auth/r/wallets',
                        'auth/r/orders/{symbol}',
                        'auth/r/orders/{symbol}/new',
                        'auth/r/orders/{symbol}/hist',
                        'auth/r/order/{symbol}:{id}/trades',
                        'auth/r/trades/{symbol}/hist',
                        'auth/r/positions',
                        'auth/r/funding/offers/{symbol}',
                        'auth/r/funding/offers/{symbol}/hist',
                        'auth/r/funding/loans/{symbol}',
                        'auth/r/funding/loans/{symbol}/hist',
                        'auth/r/funding/credits/{symbol}',
                        'auth/r/funding/credits/{symbol}/hist',
                        'auth/r/funding/trades/{symbol}/hist',
                        'auth/r/info/margin/{key}',
                        'auth/r/info/funding/{key}',
                        'auth/r/movements/{currency}/hist',
                        'auth/r/stats/perf:{timeframe}/hist',
                        'auth/r/alerts',
                        'auth/w/alert/set',
                        'auth/w/alert/{type}:{symbol}:{price}/del',
                        'auth/calc/order/avail',
                    ],
                },
            },
            'markets': {
                'AVT/BTC': { 'id': 'tAVTBTC', 'symbol': 'AVT/BTC', 'base': 'AVT', 'quote': 'BTC' },
                'AVT/ETH': { 'id': 'tAVTETH', 'symbol': 'AVT/ETH', 'base': 'AVT', 'quote': 'ETH' },
                'AVT/USD': { 'id': 'tAVTUSD', 'symbol': 'AVT/USD', 'base': 'AVT', 'quote': 'USD' },
                'CST_BCC/BTC': { 'id': 'tBCCBTC', 'symbol': 'CST_BCC/BTC', 'base': 'CST_BCC', 'quote': 'BTC' },
                'CST_BCC/USD': { 'id': 'tBCCUSD', 'symbol': 'CST_BCC/USD', 'base': 'CST_BCC', 'quote': 'USD' },
                'BCH/BTC': { 'id': 'tBCHBTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC' },
                'BCH/ETH': { 'id': 'tBCHETH', 'symbol': 'BCH/ETH', 'base': 'BCH', 'quote': 'ETH' },
                'BCH/USD': { 'id': 'tBCHUSD', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD' },
                'CST_BCU/BTC': { 'id': 'tBCUBTC', 'symbol': 'CST_BCU/BTC', 'base': 'CST_BCU', 'quote': 'BTC' },
                'CST_BCU/USD': { 'id': 'tBCUUSD', 'symbol': 'CST_BCU/USD', 'base': 'CST_BCU', 'quote': 'USD' },
                'BT1/BTC': { 'id': 'tBT1BTC', 'symbol': 'BT1/BTC', 'base': 'BT1', 'quote': 'BTC' },
                'BT1/USD': { 'id': 'tBT1USD', 'symbol': 'BT1/USD', 'base': 'BT1', 'quote': 'USD' },
                'BT2/BTC': { 'id': 'tBT2BTC', 'symbol': 'BT2/BTC', 'base': 'BT2', 'quote': 'BTC' },
                'BT2/USD': { 'id': 'tBT2USD', 'symbol': 'BT2/USD', 'base': 'BT2', 'quote': 'USD' },
                'BTC/USD': { 'id': 'tBTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/EUR': { 'id': 'tBTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTG/BTC': { 'id': 'tBTGBTC', 'symbol': 'BTG/BTC', 'base': 'BTG', 'quote': 'BTC' },
                'BTG/USD': { 'id': 'tBTGUSD', 'symbol': 'BTG/USD', 'base': 'BTG', 'quote': 'USD' },
                'DASH/BTC': { 'id': 'tDSHBTC', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
                'DASH/USD': { 'id': 'tDSHUSD', 'symbol': 'DASH/USD', 'base': 'DASH', 'quote': 'USD' },
                'DAT/BTC': { 'id': 'tDATBTC', 'symbol': 'DAT/BTC', 'base': 'DAT', 'quote': 'BTC' },
                'DAT/ETH': { 'id': 'tDATETH', 'symbol': 'DAT/ETH', 'base': 'DAT', 'quote': 'ETH' },
                'DAT/USD': { 'id': 'tDATUSD', 'symbol': 'DAT/USD', 'base': 'DAT', 'quote': 'USD' },
                'EDO/BTC': { 'id': 'tEDOBTC', 'symbol': 'EDO/BTC', 'base': 'EDO', 'quote': 'BTC' },
                'EDO/ETH': { 'id': 'tEDOETH', 'symbol': 'EDO/ETH', 'base': 'EDO', 'quote': 'ETH' },
                'EDO/USD': { 'id': 'tEDOUSD', 'symbol': 'EDO/USD', 'base': 'EDO', 'quote': 'USD' },
                'EOS/BTC': { 'id': 'tEOSBTC', 'symbol': 'EOS/BTC', 'base': 'EOS', 'quote': 'BTC' },
                'EOS/ETH': { 'id': 'tEOSETH', 'symbol': 'EOS/ETH', 'base': 'EOS', 'quote': 'ETH' },
                'EOS/USD': { 'id': 'tEOSUSD', 'symbol': 'EOS/USD', 'base': 'EOS', 'quote': 'USD' },
                'ETC/BTC': { 'id': 'tETCBTC', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC' },
                'ETC/USD': { 'id': 'tETCUSD', 'symbol': 'ETC/USD', 'base': 'ETC', 'quote': 'USD' },
                'ETH/BTC': { 'id': 'tETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
                'ETH/USD': { 'id': 'tETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
                'ETP/BTC': { 'id': 'tETPBTC', 'symbol': 'ETP/BTC', 'base': 'ETP', 'quote': 'BTC' },
                'ETP/ETH': { 'id': 'tETPETH', 'symbol': 'ETP/ETH', 'base': 'ETP', 'quote': 'ETH' },
                'ETP/USD': { 'id': 'tETPUSD', 'symbol': 'ETP/USD', 'base': 'ETP', 'quote': 'USD' },
                'IOTA/BTC': { 'id': 'tIOTBTC', 'symbol': 'IOTA/BTC', 'base': 'IOTA', 'quote': 'BTC' },
                'IOTA/ETH': { 'id': 'tIOTETH', 'symbol': 'IOTA/ETH', 'base': 'IOTA', 'quote': 'ETH' },
                'IOTA/USD': { 'id': 'tIOTUSD', 'symbol': 'IOTA/USD', 'base': 'IOTA', 'quote': 'USD' },
                'LTC/BTC': { 'id': 'tLTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'LTC/USD': { 'id': 'tLTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD' },
                'NEO/BTC': { 'id': 'tNEOBTC', 'symbol': 'NEO/BTC', 'base': 'NEO', 'quote': 'BTC' },
                'NEO/ETH': { 'id': 'tNEOETH', 'symbol': 'NEO/ETH', 'base': 'NEO', 'quote': 'ETH' },
                'NEO/USD': { 'id': 'tNEOUSD', 'symbol': 'NEO/USD', 'base': 'NEO', 'quote': 'USD' },
                'OMG/BTC': { 'id': 'tOMGBTC', 'symbol': 'OMG/BTC', 'base': 'OMG', 'quote': 'BTC' },
                'OMG/ETH': { 'id': 'tOMGETH', 'symbol': 'OMG/ETH', 'base': 'OMG', 'quote': 'ETH' },
                'OMG/USD': { 'id': 'tOMGUSD', 'symbol': 'OMG/USD', 'base': 'OMG', 'quote': 'USD' },
                'QTUM/BTC': { 'id': 'tQTMBTC', 'symbol': 'QTUM/BTC', 'base': 'QTUM', 'quote': 'BTC' },
                'QTUM/ETH': { 'id': 'tQTMETH', 'symbol': 'QTUM/ETH', 'base': 'QTUM', 'quote': 'ETH' },
                'QTUM/USD': { 'id': 'tQTMUSD', 'symbol': 'QTUM/USD', 'base': 'QTUM', 'quote': 'USD' },
                'RRT/BTC': { 'id': 'tRRTBTC', 'symbol': 'RRT/BTC', 'base': 'RRT', 'quote': 'BTC' },
                'RRT/USD': { 'id': 'tRRTUSD', 'symbol': 'RRT/USD', 'base': 'RRT', 'quote': 'USD' },
                'SAN/BTC': { 'id': 'tSANBTC', 'symbol': 'SAN/BTC', 'base': 'SAN', 'quote': 'BTC' },
                'SAN/ETH': { 'id': 'tSANETH', 'symbol': 'SAN/ETH', 'base': 'SAN', 'quote': 'ETH' },
                'SAN/USD': { 'id': 'tSANUSD', 'symbol': 'SAN/USD', 'base': 'SAN', 'quote': 'USD' },
                'XMR/BTC': { 'id': 'tXMRBTC', 'symbol': 'XMR/BTC', 'base': 'XMR', 'quote': 'BTC' },
                'XMR/USD': { 'id': 'tXMRUSD', 'symbol': 'XMR/USD', 'base': 'XMR', 'quote': 'USD' },
                'XRP/BTC': { 'id': 'tXRPBTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
                'XRP/USD': { 'id': 'tXRPUSD', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD' },
                'ZEC/BTC': { 'id': 'tZECBTC', 'symbol': 'ZEC/BTC', 'base': 'ZEC', 'quote': 'BTC' },
                'ZEC/USD': { 'id': 'tZECUSD', 'symbol': 'ZEC/USD', 'base': 'ZEC', 'quote': 'USD' },
            },
            'fees': {
                'trading': {
                    'maker': 0.1 / 100,
                    'taker': 0.2 / 100,
                },
                'funding': {
                    'withdraw': {
                        'BTC': 0.0005,
                        'BCH': 0.0005,
                        'ETH': 0.01,
                        'EOS': 0.1,
                        'LTC': 0.001,
                        'OMG': 0.1,
                        'IOT': 0.0,
                        'NEO': 0.0,
                        'ETC': 0.01,
                        'XRP': 0.02,
                        'ETP': 0.01,
                        'ZEC': 0.001,
                        'BTG': 0.0,
                        'DASH': 0.01,
                        'XMR': 0.04,
                        'QTM': 0.01,
                        'EDO': 0.5,
                        'DAT': 1.0,
                        'AVT': 0.5,
                        'SAN': 0.1,
                        'USDT': 5.0,
                    },
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        // issue #4 Bitfinex names Dash as DSH, instead of DASH
        if (currency == 'DSH')
            return 'DASH';
        if (currency == 'QTM')
            return 'QTUM';
        // issue #796
        if (currency == 'IOT')
            return 'IOTA';
        return currency;
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostAuthRWallets ();
        let balanceType = this.safeString (params, 'type', 'exchange');
        let result = { 'info': response };
        for (let b = 0; b < response.length; b++) {
            let balance = response[b];
            let [ accountType, currency, total, interest, available ] = balance;
            if (accountType == balanceType) {
                if (currency[0] == 't')
                    currency = currency.slice (1);
                let uppercase = currency.toUpperCase ();
                uppercase = this.commonCurrencyCode (uppercase);
                let account = this.account ();
                account['free'] = available;
                account['total'] = total;
                if (account['free'])
                    account['used'] = account['total'] - account['free'];
                result[uppercase] = account;
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetBookSymbolPrecision (this.extend ({
            'symbol': this.marketId (symbol),
            'precision': 'R0',
        }, params));
        let timestamp = this.milliseconds ();
        let result = {
            'bids': [],
            'asks': [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        for (let i = 0; i < orderbook.length; i++) {
            let order = orderbook[i];
            let price = order[1];
            let amount = order[2];
            let side = (amount > 0) ? 'bids' : 'asks';
            amount = Math.abs (amount);
            result[side].push ([ price, amount ]);
        }
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let length = ticker.length;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker[length - 2],
            'low': ticker[length - 1],
            'bid': ticker[length - 10],
            'ask': ticker[length - 8],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': ticker[length - 4],
            'change': ticker[length - 6],
            'percentage': ticker[length - 5],
            'average': undefined,
            'baseVolume': ticker[length - 3],
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        let tickers = await this.publicGetTickers (this.extend ({
            'symbols': this.ids.join (','),
        }, params));
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker[0];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.markets[symbol];
        let ticker = await this.publicGetTickerSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let [ id, timestamp, amount, price ] = trade;
        let side = (amount < 0) ? 'sell' : 'buy';
        if (amount < 0) {
            amount = -amount;
        }
        return {
            'id': id.toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': price,
            'amount': amount,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
        };
        if (since) {
            request['start'] = since;
        }
        if (limit) {
            request['limit'] = limit;
        }
        let response = await this.publicGetTradesSymbolHist (this.extend (request, params));
        return this.parseTrades (response, market, since, limit);
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'timeframe': this.timeframes[timeframe],
        };
        if (limit)
            request['limit'] = limit;
        if (since)
            request['start'] = since;
        request = this.extend (request, params);
        let response = await this.publicGetCandlesTradeTimeframeSymbolHist (request);
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        throw new NotSupported (this.id + ' createOrder not implemented yet');
    }

    cancelOrder (id, symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' cancelOrder not implemented yet');
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOrder not implemented yet');
    }

    async withdraw (currency, amount, address, params = {}) {
        throw new NotSupported (this.id + ' withdraw not implemented yet');
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + '/' + request;
        if (api == 'public') {
            if (Object.keys (query).length) {
                url += '?' + this.urlencode (query);
            }
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.json (query);
            let auth = '/api' + '/' + request + nonce + body;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha384');
            headers = {
                'bfx-nonce': nonce,
                'bfx-apikey': this.apiKey,
                'bfx-signature': signature,
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (response) {
            if ('message' in response) {
                if (response['message'].indexOf ('not enough exchange balance') >= 0)
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
            return response;
        } else if (response == '') {
            throw new ExchangeError (this.id + ' returned empty response');
        }
        return response;
    }
}

},{"./base/errors":10,"./bitfinex.js":17}],19:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

//  ---------------------------------------------------------------------------

module.exports = class bitflyer extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitflyer',
            'name': 'bitFlyer',
            'countries': 'JP',
            'version': 'v1',
            'rateLimit': 500,
            'hasCORS': false,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg',
                'api': 'https://api.bitflyer.jp',
                'www': 'https://bitflyer.jp',
                'doc': 'https://bitflyer.jp/API',
            },
            'api': {
                'public': {
                    'get': [
                        'getmarkets',    // or 'markets'
                        'getboard',      // or 'board'
                        'getticker',     // or 'ticker'
                        'getexecutions', // or 'executions'
                        'gethealth',
                        'getchats',
                    ],
                },
                'private': {
                    'get': [
                        'getpermissions',
                        'getbalance',
                        'getcollateral',
                        'getcollateralaccounts',
                        'getaddresses',
                        'getcoinins',
                        'getcoinouts',
                        'getbankaccounts',
                        'getdeposits',
                        'getwithdrawals',
                        'getchildorders',
                        'getparentorders',
                        'getparentorder',
                        'getexecutions',
                        'getpositions',
                        'gettradingcommission',
                    ],
                    'post': [
                        'sendcoin',
                        'withdraw',
                        'sendchildorder',
                        'cancelchildorder',
                        'sendparentorder',
                        'cancelparentorder',
                        'cancelallchildorders',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.25 / 100,
                    'taker': 0.25 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['product_code'];
            let currencies = id.split ('_');
            let base = undefined;
            let quote = undefined;
            let symbol = id;
            let numCurrencies = currencies.length;
            if (numCurrencies == 1) {
                base = symbol.slice (0, 3);
                quote = symbol.slice (3, 6);
            } else if (numCurrencies == 2) {
                base = currencies[0];
                quote = currencies[1];
                symbol = base + '/' + quote;
            } else {
                base = currencies[1];
                quote = currencies[2];
            }
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = {};
        for (let b = 0; b < response.length; b++) {
            let account = response[b];
            let currency = account['currency_code'];
            balances[currency] = account;
        }
        let result = { 'info': response };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balances) {
                account['total'] = balances[currency]['amount'];
                account['free'] = balances[currency]['available'];
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBoard (this.extend ({
            'product_code': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'size');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let ticker = await this.publicGetTicker (this.extend ({
            'product_code': this.marketId (symbol),
        }, params));
        let timestamp = this.parse8601 (ticker['timestamp']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['best_bid']),
            'ask': parseFloat (ticker['best_ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['ltp']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_by_product']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let side = undefined;
        let order = undefined;
        if ('side' in trade)
            if (trade['side']) {
                side = trade['side'].toLowerCase ();
                let id = side + '_child_order_acceptance_id';
                if (id in trade)
                    order = trade[id];
            }
        let timestamp = this.parse8601 (trade['exec_date']);
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['size'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetExecutions (this.extend ({
            'product_code': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'product_code': this.marketId (symbol),
            'child_order_type': type.toUpperCase (),
            'side': side.toUpperCase (),
            'price': price,
            'size': amount,
        };
        let result = await this.privatePostSendchildorder (this.extend (order, params));
        return {
            'info': result,
            'id': result['child_order_acceptance_id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelchildorder (this.extend ({
            'parent_order_id': id,
        }, params));
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdraw (this.extend ({
            'currency_code': currency,
            'amount': amount,
            // 'bank_account_id': 1234,
        }, params));
        return {
            'info': response,
            'id': response['message_id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.version + '/';
        if (api == 'private')
            request += 'me/';
        request += path;
        if (method == 'GET') {
            if (Object.keys (params).length)
                request += '?' + this.urlencode (params);
        }
        let url = this.urls['api'] + request;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.json (params);
            let auth = [ nonce, method, request, body ].join ('');
            headers = {
                'ACCESS-KEY': this.apiKey,
                'ACCESS-TIMESTAMP': nonce,
                'ACCESS-SIGN': this.hmac (this.encode (auth), this.encode (this.secret)),
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8}],20:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, NotSupported } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bithumb extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bithumb',
            'name': 'Bithumb',
            'countries': 'KR', // South Korea
            'rateLimit': 500,
            'hasCORS': true,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg',
                'api': {
                    'public': 'https://api.bithumb.com/public',
                    'private': 'https://api.bithumb.com',
                },
                'www': 'https://www.bithumb.com',
                'doc': 'https://www.bithumb.com/u1/US127',
            },
            'api': {
                'public': {
                    'get': [
                        'ticker/{currency}',
                        'ticker/all',
                        'orderbook/{currency}',
                        'orderbook/all',
                        'recent_transactions/{currency}',
                        'recent_transactions/all',
                    ],
                },
                'private': {
                    'post': [
                        'info/account',
                        'info/balance',
                        'info/wallet_address',
                        'info/ticker',
                        'info/orders',
                        'info/user_transactions',
                        'trade/place',
                        'info/order_detail',
                        'trade/cancel',
                        'trade/btc_withdrawal',
                        'trade/krw_deposit',
                        'trade/krw_withdrawal',
                        'trade/market_buy',
                        'trade/market_sell',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.15 / 100,
                    'taker': 0.15 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTickerAll ();
        let currencies = Object.keys (markets['data']);
        let result = [];
        for (let i = 0; i < currencies.length; i++) {
            let id = currencies[i];
            if (id != 'date') {
                let market = markets['data'][id];
                let base = id;
                let quote = 'KRW';
                let symbol = id + '/' + quote;
                result.push (this.extend (this.fees['trading'], {
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'info': market,
                    'lot': undefined,
                    'active': true,
                    'precision': {
                        'amount': undefined,
                        'price': undefined,
                    },
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                }));
            }
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostInfoBalance (this.extend ({
            'currency': 'ALL',
        }, params));
        let result = { 'info': response };
        let balances = response['data'];
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            let lowercase = currency.toLowerCase ();
            account['total'] = this.safeFloat (balances, 'total_' + lowercase);
            account['used'] = this.safeFloat (balances, 'in_use_' + lowercase);
            account['free'] = this.safeFloat (balances, 'available_' + lowercase);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetOrderbookCurrency (this.extend ({
            'count': 50, // max = 50
            'currency': market['base'],
        }, params));
        let orderbook = response['data'];
        let timestamp = parseInt (orderbook['timestamp']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'quantity');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = parseInt (ticker['date']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'max_price'),
            'low': this.safeFloat (ticker, 'min_price'),
            'bid': this.safeFloat (ticker, 'buy_price'),
            'ask': this.safeFloat (ticker, 'sell_price'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'opening_price'),
            'close': this.safeFloat (ticker, 'closing_price'),
            'first': undefined,
            'last': this.safeFloat (ticker, 'last_trade'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'average_price'),
            'baseVolume': this.safeFloat (ticker, 'volume_1day'),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        let response = await this.publicGetTickerAll (params);
        let result = {};
        let timestamp = response['data']['date'];
        let tickers = this.omit (response['data'], 'date');
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let symbol = id;
            let market = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
            let ticker = tickers[id];
            ticker['date'] = timestamp;
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTickerCurrency (this.extend ({
            'currency': market['base'],
        }, params));
        return this.parseTicker (response['data'], market);
    }

    parseTrade (trade, market) {
        // a workaround for their bug in date format, hours are not 0-padded
        let [ transaction_date, transaction_time ] = trade['transaction_date'].split (' ');
        let transaction_time_short = transaction_time.length < 8;
        if (transaction_time_short)
            transaction_time = '0' + transaction_time;
        let timestamp = this.parse8601 (transaction_date + ' ' + transaction_time);
        let side = (trade['type'] == 'ask') ? 'sell' : 'buy';
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['units_traded']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetRecentTransactionsCurrency (this.extend ({
            'currency': market['base'],
            'count': 100, // max = 100
        }, params));
        return this.parseTrades (response['data'], market, since, limit);
    }

    createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        throw new NotSupported (this.id + ' private API not implemented yet');
        //     let prefix = '';
        //     if (type == 'market')
        //         prefix = 'market_';
        //     let order = {
        //         'pair': this.marketId (symbol),
        //         'quantity': amount,
        //         'price': price || 0,
        //         'type': prefix + side,
        //     };
        //     let response = await this.privatePostOrderCreate (this.extend (order, params));
        //     return {
        //         'info': response,
        //         'id': response['order_id'].toString (),
        //     };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        let side = ('side' in params);
        if (!side)
            throw new ExchangeError (this.id + ' cancelOrder requires a side parameter (sell or buy)');
        side = (side == 'buy') ? 'purchase' : 'sales';
        let currency = ('currency' in params);
        if (!currency)
            throw new ExchangeError (this.id + ' cancelOrder requires a currency parameter');
        return await this.privatePostTradeCancel ({
            'order_id': id,
            'type': params['side'],
            'currency': params['currency'],
        });
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let endpoint = '/' + this.implodeParams (path, params);
        let url = this.urls['api'][api] + endpoint;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            body = this.urlencode (this.extend ({
                'endpoint': endpoint,
            }, query));
            let nonce = this.nonce ().toString ();
            let auth = endpoint + "\0" + body + "\0" + nonce;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha512');
            headers = {
                'Api-Key': this.apiKey,
                'Api-Sign': this.decode (this.stringToBase64 (this.encode (signature))),
                'Api-Nonce': nonce,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response) {
            if (response['status'] == '0000')
                return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],21:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { NotSupported } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitlish extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitlish',
            'name': 'Bitlish',
            'countries': [ 'GB', 'EU', 'RU' ],
            'rateLimit': 1500,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766275-dcfc6c30-5ed3-11e7-839d-00a846385d0b.jpg',
                'api': 'https://bitlish.com/api',
                'www': 'https://bitlish.com',
                'doc': 'https://bitlish.com/api',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': false,
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'taker': 0.3 / 100, // anonymous 0.3%, verified 0.2%
                    'maker': 0,
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.001,
                        'LTC': 0.001,
                        'DOGE': 0.001,
                        'ETH': 0.001,
                        'XMR': 0,
                        'ZEC': 0.001,
                        'DASH': 0.0001,
                        'EUR': 50,
                    },
                    'deposit': {
                        'BTC': 0,
                        'LTC': 0,
                        'DOGE': 0,
                        'ETH': 0,
                        'XMR': 0,
                        'ZEC': 0,
                        'DASH': 0,
                        'EUR': 0,
                    },
                },
            },
            'api': {
                'public': {
                    'get': [
                        'instruments',
                        'ohlcv',
                        'pairs',
                        'tickers',
                        'trades_depth',
                        'trades_history',
                    ],
                    'post': [
                        'instruments',
                        'ohlcv',
                        'pairs',
                        'tickers',
                        'trades_depth',
                        'trades_history',
                    ],
                },
                'private': {
                    'post': [
                        'accounts_operations',
                        'balance',
                        'cancel_trade',
                        'cancel_trades_by_ids',
                        'cancel_all_trades',
                        'create_bcode',
                        'create_template_wallet',
                        'create_trade',
                        'deposit',
                        'list_accounts_operations_from_ts',
                        'list_active_trades',
                        'list_bcodes',
                        'list_my_matches_from_ts',
                        'list_my_trades',
                        'list_my_trads_from_ts',
                        'list_payment_methods',
                        'list_payments',
                        'redeem_code',
                        'resign',
                        'signin',
                        'signout',
                        'trade_details',
                        'trade_options',
                        'withdraw',
                        'withdraw_by_id',
                    ],
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (!this.substituteCommonCurrencyCodes)
            return currency;
        if (currency == 'XBT')
            return 'BTC';
        if (currency == 'BCC')
            return 'BCH';
        if (currency == 'DRK')
            return 'DASH';
        if (currency == 'DSH')
            currency = 'DASH';
        if (currency == 'XDG')
            currency = 'DOGE';
        return currency;
    }

    async fetchMarkets () {
        let markets = await this.publicGetPairs ();
        let result = [];
        let keys = Object.keys (markets);
        for (let p = 0; p < keys.length; p++) {
            let market = markets[keys[p]];
            let id = market['id'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'high': this.safeFloat (ticker, 'max'),
            'low': this.safeFloat (ticker, 'min'),
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': this.safeFloat (ticker, 'first'),
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': this.safeFloat (ticker, 'prc'),
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'sum'),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTickers (params);
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        // let market = this.market (symbol);
        let now = this.seconds ();
        let start = now - 86400 * 30; // last 30 days
        let interval = [ start.toString (), undefined ];
        return await this.publicPostOhlcv (this.extend ({
            'time_range': interval,
        }, params));
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetTradesDepth (this.extend ({
            'pair_id': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (parseInt (orderbook['last']) / 1000);
        return this.parseOrderBook (orderbook, timestamp, 'bid', 'ask', 'price', 'volume');
    }

    parseTrade (trade, market = undefined) {
        let side = (trade['dir'] == 'bid') ? 'buy' : 'sell';
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let timestamp = parseInt (trade['created'] / 1000);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesHistory (this.extend ({
            'pair_id': market['id'],
        }, params));
        return this.parseTrades (response['list'], market, since, limit);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let result = { 'info': response };
        let currencies = Object.keys (response);
        let balance = {};
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let account = response[currency];
            currency = currency.toUpperCase ();
            // issue #4 bitlish names Dash as DSH, instead of DASH
            if (currency == 'DSH')
                currency = 'DASH';
            if (currency == 'XDG')
                currency = 'DOGE';
            balance[currency] = account;
        }
        currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balance) {
                account['free'] = parseFloat (balance[currency]['funds']);
                account['used'] = parseFloat (balance[currency]['holded']);
                account['total'] = this.sum (account['free'], account['used']);
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    signIn () {
        return this.privatePostSignin ({
            'login': this.login,
            'passwd': this.password,
        });
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'pair_id': this.marketId (symbol),
            'dir': (side == 'buy') ? 'bid' : 'ask',
            'amount': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let result = await this.privatePostCreateTrade (this.extend (order, params));
        return {
            'info': result,
            'id': result['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelTrade ({ 'id': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency != 'BTC') {
            // they did not document other types...
            throw new NotSupported (this.id + ' currently supports BTC withdrawals only, until they document other currencies...');
        }
        let response = await this.privatePostWithdraw (this.extend ({
            'currency': currency.toLowerCase (),
            'amount': parseFloat (amount),
            'account': address,
            'payment_method': 'bitcoin', // they did not document other types...
        }, params));
        return {
            'info': response,
            'id': response['message_id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (method == 'GET') {
                if (Object.keys (params).length)
                    url += '?' + this.urlencode (params);
            }
            else {
                body = this.json (params);
                headers = { 'Content-Type': 'application/json' };
            }
        } else {
            this.checkRequiredCredentials ();
            body = this.json (this.extend ({ 'token': this.apiKey }, params));
            headers = { 'Content-Type': 'application/json' };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],22:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitmarket extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitmarket',
            'name': 'BitMarket',
            'countries': [ 'PL', 'EU' ],
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'timeframes': {
                '90m': '90m',
                '6h': '6h',
                '1d': '1d',
                '1w': '7d',
                '1M': '1m',
                '3M': '3m',
                '6M': '6m',
                '1y': '1y',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27767256-a8555200-5ef9-11e7-96fd-469a65e2b0bd.jpg',
                'api': {
                    'public': 'https://www.bitmarket.net',
                    'private': 'https://www.bitmarket.pl/api2/', // last slash is critical
                },
                'www': [
                    'https://www.bitmarket.pl',
                    'https://www.bitmarket.net',
                ],
                'doc': [
                    'https://www.bitmarket.net/docs.php?file=api_public.html',
                    'https://www.bitmarket.net/docs.php?file=api_private.html',
                    'https://github.com/bitmarket-net/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'json/{market}/ticker',
                        'json/{market}/orderbook',
                        'json/{market}/trades',
                        'json/ctransfer',
                        'graphs/{market}/90m',
                        'graphs/{market}/6h',
                        'graphs/{market}/1d',
                        'graphs/{market}/7d',
                        'graphs/{market}/1m',
                        'graphs/{market}/3m',
                        'graphs/{market}/6m',
                        'graphs/{market}/1y',
                    ],
                },
                'private': {
                    'post': [
                        'info',
                        'trade',
                        'cancel',
                        'orders',
                        'trades',
                        'history',
                        'withdrawals',
                        'tradingdesk',
                        'tradingdeskStatus',
                        'tradingdeskConfirm',
                        'cryptotradingdesk',
                        'cryptotradingdeskStatus',
                        'cryptotradingdeskConfirm',
                        'withdraw',
                        'withdrawFiat',
                        'withdrawPLNPP',
                        'withdrawFiatFast',
                        'deposit',
                        'transfer',
                        'transfers',
                        'marginList',
                        'marginOpen',
                        'marginClose',
                        'marginCancel',
                        'marginModify',
                        'marginBalanceAdd',
                        'marginBalanceRemove',
                        'swapList',
                        'swapOpen',
                        'swapClose',
                    ],
                },
            },
            'markets': {
                'BTC/PLN': { 'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'LTC/PLN': { 'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN' },
                'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'LiteMineX/BTC': { 'id': 'LiteMineXBTC', 'symbol': 'LiteMineX/BTC', 'base': 'LiteMineX', 'quote': 'BTC' },
            },
            'fees': {
                'trading': {
                    'tierBased': true,
                    'percentage': true,
                    'taker': 0.45 / 100,
                    'maker': 0.15 / 100,
                    'tiers': {
                        'taker': [
                            [0, 0.45 / 100],
                            [99.99, 0.44 / 100],
                            [299.99, 0.43 / 100],
                            [499.99, 0.42 / 100],
                            [999.99, 0.41 / 100],
                            [1999.99, 0.40 / 100],
                            [2999.99, 0.39 / 100],
                            [4999.99, 0.38 / 100],
                            [9999.99, 0.37 / 100],
                            [19999.99, 0.36 / 100],
                            [29999.99, 0.35 / 100],
                            [49999.99, 0.34 / 100],
                            [99999.99, 0.33 / 100],
                            [199999.99, 0.32 / 100],
                            [299999.99, 0.31 / 100],
                            [499999.99, 0.0 / 100],
                        ],
                        'maker': [
                            [0, 0.15 / 100],
                            [99.99, 0.14 / 100],
                            [299.99, 0.13 / 100],
                            [499.99, 0.12 / 100],
                            [999.99, 0.11 / 100],
                            [1999.99, 0.10 / 100],
                            [2999.99, 0.9 / 100],
                            [4999.99, 0.8 / 100],
                            [9999.99, 0.7 / 100],
                            [19999.99, 0.6 / 100],
                            [29999.99, 0.5 / 100],
                            [49999.99, 0.4 / 100],
                            [99999.99, 0.3 / 100],
                            [199999.99, 0.2 / 100],
                            [299999.99, 0.1 / 100],
                            [499999.99, 0.0 / 100],
                        ],
                    },
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.0008,
                        'LTC': 0.005,
                        'BCH': 0.0008,
                        'BTG': 0.0008,
                        'DOGE': 1,
                        'EUR': 2,
                        'PLN': 2,
                    },
                    'deposit': {
                        'BTC': 0,
                        'LTC': 0,
                        'BCH': 0,
                        'BTG': 0,
                        'DOGE': 25,
                        'EUR': 2, // SEPA. Transfer INT (SHA): 5 EUR
                        'PLN': 0,
                    },
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostInfo ();
        let data = response['data'];
        let balance = data['balances'];
        let result = { 'info': data };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balance['available'])
                account['free'] = balance['available'][currency];
            if (currency in balance['blocked'])
                account['used'] = balance['blocked'][currency];
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetJsonMarketOrderbook (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        return {
            'bids': orderbook['bids'],
            'asks': orderbook['asks'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetJsonMarketTicker (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let side = (trade['type'] == 'bid') ? 'buy' : 'sell';
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetJsonMarketTrades (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '90m', since = undefined, limit = undefined) {
        return [
            ohlcv['time'] * 1000,
            parseFloat (ohlcv['open']),
            parseFloat (ohlcv['high']),
            parseFloat (ohlcv['low']),
            parseFloat (ohlcv['close']),
            parseFloat (ohlcv['vol']),
        ];
    }

    async fetchOHLCV (symbol, timeframe = '90m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'publicGetGraphsMarket' + this.timeframes[timeframe];
        let market = this.market (symbol);
        let response = await this[method] (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostTrade (this.extend ({
            'market': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        let result = {
            'info': response,
        };
        if ('id' in response['order'])
            result['id'] = response['id'];
        return result;
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancel ({ 'id': id });
    }

    isFiat (currency) {
        if (currency == 'EUR')
            return true;
        if (currency == 'PLN')
            return true;
        return false;
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let method = undefined;
        let request = {
            'currency': currency,
            'quantity': amount,
        };
        if (this.isFiat (currency)) {
            method = 'privatePostWithdrawFiat';
            if ('account' in params) {
                request['account'] = params['account']; // bank account code for withdrawal
            } else {
                throw new ExchangeError (this.id + ' requires account parameter to withdraw fiat currency');
            }
            if ('account2' in params) {
                request['account2'] = params['account2']; // bank SWIFT code (EUR only)
            } else {
                if (currency == 'EUR')
                    throw new ExchangeError (this.id + ' requires account2 parameter to withdraw EUR');
            }
            if ('withdrawal_note' in params) {
                request['withdrawal_note'] = params['withdrawal_note']; // a 10-character user-specified withdrawal note (PLN only)
            } else {
                if (currency == 'PLN')
                    throw new ExchangeError (this.id + ' requires withdrawal_note parameter to withdraw PLN');
            }
        } else {
            method = 'privatePostWithdraw';
            request['address'] = address;
        }
        let response = await this[method] (this.extend (request, params));
        return {
            'info': response,
            'id': response,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path + '.json', params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let query = this.extend ({
                'tonce': nonce,
                'method': path,
            }, params);
            body = this.urlencode (query);
            headers = {
                'API-Key': this.apiKey,
                'API-Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],23:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitmex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitmex',
            'name': 'BitMEX',
            'countries': 'SC', // Seychelles
            'version': 'v1',
            'userAgent': undefined,
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchOHLCV': true,
            'hasWithdraw': true,
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '1h': '1h',
                '1d': '1d',
            },
            'urls': {
                'test': 'https://testnet.bitmex.com',
                'logo': 'https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg',
                'api': 'https://www.bitmex.com',
                'www': 'https://www.bitmex.com',
                'doc': [
                    'https://www.bitmex.com/app/apiOverview',
                    'https://github.com/BitMEX/api-connectors/tree/master/official-http',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'announcement',
                        'announcement/urgent',
                        'funding',
                        'instrument',
                        'instrument/active',
                        'instrument/activeAndIndices',
                        'instrument/activeIntervals',
                        'instrument/compositeIndex',
                        'instrument/indices',
                        'insurance',
                        'leaderboard',
                        'liquidation',
                        'orderBook',
                        'orderBook/L2',
                        'quote',
                        'quote/bucketed',
                        'schema',
                        'schema/websocketHelp',
                        'settlement',
                        'stats',
                        'stats/history',
                        'trade',
                        'trade/bucketed',
                    ],
                },
                'private': {
                    'get': [
                        'apiKey',
                        'chat',
                        'chat/channels',
                        'chat/connected',
                        'execution',
                        'execution/tradeHistory',
                        'notification',
                        'order',
                        'position',
                        'user',
                        'user/affiliateStatus',
                        'user/checkReferralCode',
                        'user/commission',
                        'user/depositAddress',
                        'user/margin',
                        'user/minWithdrawalFee',
                        'user/wallet',
                        'user/walletHistory',
                        'user/walletSummary',
                    ],
                    'post': [
                        'apiKey',
                        'apiKey/disable',
                        'apiKey/enable',
                        'chat',
                        'order',
                        'order/bulk',
                        'order/cancelAllAfter',
                        'order/closePosition',
                        'position/isolate',
                        'position/leverage',
                        'position/riskLimit',
                        'position/transferMargin',
                        'user/cancelWithdrawal',
                        'user/confirmEmail',
                        'user/confirmEnableTFA',
                        'user/confirmWithdrawal',
                        'user/disableTFA',
                        'user/logout',
                        'user/logoutAll',
                        'user/preferences',
                        'user/requestEnableTFA',
                        'user/requestWithdrawal',
                    ],
                    'put': [
                        'order',
                        'order/bulk',
                        'user',
                    ],
                    'delete': [
                        'apiKey',
                        'order',
                        'order/all',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetInstrumentActiveAndIndices ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let active = (market['state'] != 'Unlisted');
            let id = market['symbol'];
            let base = market['underlying'];
            let quote = market['quoteCurrency'];
            let type = undefined;
            let future = false;
            let prediction = false;
            let basequote = base + quote;
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let swap = (id == basequote);
            let symbol = id;
            if (swap) {
                type = 'swap';
                symbol = base + '/' + quote;
            } else if (id.indexOf ('B_') >= 0) {
                prediction = true;
                type = 'prediction';
            } else {
                future = true;
                type = 'future';
            }
            let maker = market['makerFee'];
            let taker = market['takerFee'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': active,
                'taker': taker,
                'maker': maker,
                'type': type,
                'spot': false,
                'swap': swap,
                'future': future,
                'prediction': prediction,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetUserMargin ({ 'currency': 'all' });
        let result = { 'info': response };
        for (let b = 0; b < response.length; b++) {
            let balance = response[b];
            let currency = balance['currency'].toUpperCase ();
            currency = this.commonCurrencyCode (currency);
            let account = {
                'free': balance['availableMargin'],
                'used': 0.0,
                'total': balance['amount'],
            };
            if (currency == 'BTC') {
                account['free'] = account['free'] * 0.00000001;
                account['total'] = account['total'] * 0.00000001;
            }
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookL2 (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let result = {
            'bids': [],
            'asks': [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        for (let o = 0; o < orderbook.length; o++) {
            let order = orderbook[o];
            let side = (order['side'] == 'Sell') ? 'asks' : 'bids';
            let amount = order['size'];
            let price = order['price'];
            result[side].push ([ price, amount ]);
        }
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!market['active'])
            throw new ExchangeError (this.id + ': symbol ' + symbol + ' is delisted');
        let request = this.extend ({
            'symbol': market['id'],
            'binSize': '1d',
            'partial': true,
            'count': 1,
            'reverse': true,
        }, params);
        let quotes = await this.publicGetQuoteBucketed (request);
        let quotesLength = quotes.length;
        let quote = quotes[quotesLength - 1];
        let tickers = await this.publicGetTradeBucketed (request);
        let ticker = tickers[0];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (quote['bidPrice']),
            'ask': parseFloat (quote['askPrice']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['homeNotional']),
            'quoteVolume': parseFloat (ticker['foreignNotional']),
            'info': ticker,
        };
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['timestamp']);
        return [
            timestamp,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        // send JSON key/value pairs, such as {"key": "value"}
        // filter by individual fields and do advanced queries on timestamps
        // let filter = { 'key': 'value' };
        // send a bare series (e.g. XBU) to nearest expiring contract in that series
        // you can also send a timeframe, e.g. XBU:monthly
        // timeframes: daily, weekly, monthly, quarterly, and biquarterly
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'binSize': this.timeframes[timeframe],
            'partial': true,     // true == include yet-incomplete current bins
            // 'filter': filter, // filter by individual fields and do advanced queries
            // 'columns': [],    // will return all columns if omitted
            // 'start': 0,       // starting point for results (wtf?)
            // 'reverse': false, // true == newest first
            // 'endTime': '',    // ending date filter for results
        };
        if (since) {
            let ymdhms = this.YmdHMS (since);
            let ymdhm = ymdhms.slice (0, 16);
            request['startTime'] = ymdhm; // starting date filter for results
        }
        if (limit)
            request['count'] = limit; // default 100
        let response = await this.publicGetTradeBucketed (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['timestamp']);
        let symbol = undefined;
        if (!market) {
            if ('symbol' in trade)
                market = this.markets_by_id[trade['symbol']];
        }
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['trdMatchID'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': trade['side'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['size'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrade (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'symbol': this.marketId (symbol),
            'side': this.capitalize (side),
            'orderQty': amount,
            'ordType': this.capitalize (type),
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderID'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteOrder ({ 'orderID': id });
    }

    isFiat (currency) {
        if (currency == 'EUR')
            return true;
        if (currency == 'PLN')
            return true;
        return false;
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency != 'BTC')
            throw new ExchangeError (this.id + ' supoprts BTC withdrawals only, other currencies coming soon...');
        let request = {
            'currency': 'XBt', // temporarily
            'amount': amount,
            'address': address,
            // 'otpToken': '123456', // requires if two-factor auth (OTP) is enabled
            // 'fee': 0.001, // bitcoin network fee
        };
        let response = await this.privatePostUserRequestWithdrawal (this.extend (request, params));
        return {
            'info': response,
            'id': response['transactID'],
        };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code >= 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                if ('error' in response) {
                    if ('message' in response['error']) {
                        throw new ExchangeError (this.id + ' ' + this.json (response));
                    }
                }
            }
            throw new ExchangeError (this.id + ' ' + body);
        }
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let query = '/api' + '/' + this.version + '/' + path;
        if (Object.keys (params).length)
            query += '?' + this.urlencode (params);
        let url = this.urls['api'] + query;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = method + query + nonce;
            if (method == 'POST') {
                if (Object.keys (params).length) {
                    body = this.json (params);
                    auth += body;
                }
            }
            headers = {
                'Content-Type': 'application/json',
                'api-nonce': nonce,
                'api-key': this.apiKey,
                'api-signature': this.hmac (this.encode (auth), this.encode (this.secret)),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],24:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitso extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitso',
            'name': 'Bitso',
            'countries': 'MX', // Mexico
            'rateLimit': 2000, // 30 requests per minute
            'version': 'v3',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766335-715ce7aa-5ed5-11e7-88a8-173a27bb30fe.jpg',
                'api': 'https://api.bitso.com',
                'www': 'https://bitso.com',
                'doc': 'https://bitso.com/api_info',
            },
            'api': {
                'public': {
                    'get': [
                        'available_books',
                        'ticker',
                        'order_book',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'account_status',
                        'balance',
                        'fees',
                        'fundings',
                        'fundings/{fid}',
                        'funding_destination',
                        'kyc_documents',
                        'ledger',
                        'ledger/trades',
                        'ledger/fees',
                        'ledger/fundings',
                        'ledger/withdrawals',
                        'mx_bank_codes',
                        'open_orders',
                        'order_trades/{oid}',
                        'orders/{oid}',
                        'user_trades',
                        'user_trades/{tid}',
                        'withdrawals/',
                        'withdrawals/{wid}',
                    ],
                    'post': [
                        'bitcoin_withdrawal',
                        'debit_card_withdrawal',
                        'ether_withdrawal',
                        'orders',
                        'phone_number',
                        'phone_verification',
                        'phone_withdrawal',
                        'spei_withdrawal',
                    ],
                    'delete': [
                        'orders/{oid}',
                        'orders/all',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetAvailableBooks ();
        let result = [];
        for (let i = 0; i < markets['payload'].length; i++) {
            let market = markets['payload'][i];
            let id = market['book'];
            let symbol = id.toUpperCase ().replace ('_', '/');
            let [ base, quote ] = symbol.split ('/');
            let limits = {
                'amount': {
                    'min': parseFloat (market['minimum_amount']),
                    'max': parseFloat (market['maximum_amount']),
                },
                'price': {
                    'min': parseFloat (market['minimum_price']),
                    'max': parseFloat (market['maximum_price']),
                },
                'cost': {
                    'min': parseFloat (market['minimum_value']),
                    'max': parseFloat (market['maximum_value']),
                },
            };
            let precision = {
                'amount': this.precisionFromString (market['minimum_amount']),
                'price': this.precisionFromString (market['minimum_price']),
            };
            let lot = limits['amount']['min'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'lot': lot,
                'limits': limits,
                'precision': precision,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['payload']['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'].toUpperCase ();
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['locked']),
                'total': parseFloat (balance['total']),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderBook (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let orderbook = response['payload'];
        let timestamp = this.parse8601 (orderbook['updated_at']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetTicker (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let ticker = response['payload'];
        let timestamp = this.parse8601 (ticker['created_at']);
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['created_at']);
        let symbol = undefined;
        if (!market) {
            if ('book' in trade)
                market = this.markets_by_id[trade['book']];
        }
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': trade['maker_side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'book': market['id'],
        }, params));
        return this.parseTrades (response['payload'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'book': this.marketId (symbol),
            'side': side,
            'type': type,
            'major': this.amountToPrecision (symbol, amount),
        };
        if (type == 'limit')
            order['price'] = this.priceToPrecision (symbol, price);
        let response = await this.privatePostOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['payload']['oid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteOrders ({ 'oid': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let query = '/' + this.version + '/' + this.implodeParams (path, params);
        let url = this.urls['api'] + query;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let request = [ nonce, method, query ].join ('');
            if (Object.keys (params).length) {
                body = this.json (params);
                request += body;
            }
            let signature = this.hmac (this.encode (request), this.encode (this.secret));
            let auth = this.apiKey + ':' + nonce + ':' + signature;
            headers = {
                'Authorization': "Bitso " + auth,
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],25:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitstamp extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitstamp',
            'name': 'Bitstamp',
            'countries': 'GB',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': false,
            'hasFetchOrder': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                'api': 'https://www.bitstamp.net/api',
                'www': 'https://www.bitstamp.net',
                'doc': 'https://www.bitstamp.net/api',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'order_book/{pair}/',
                        'ticker_hour/{pair}/',
                        'ticker/{pair}/',
                        'transactions/{pair}/',
                        'trading-pairs-info/',
                    ],
                },
                'private': {
                    'post': [
                        'balance/',
                        'balance/{pair}/',
                        'user_transactions/',
                        'user_transactions/{pair}/',
                        'open_orders/all/',
                        'open_orders/{pair}',
                        'order_status/',
                        'cancel_order/',
                        'buy/{pair}/',
                        'buy/market/{pair}/',
                        'sell/{pair}/',
                        'sell/market/{pair}/',
                        'ltc_withdrawal/',
                        'ltc_address/',
                        'eth_withdrawal/',
                        'eth_address/',
                        'transfer-to-main/',
                        'transfer-from-main/',
                        'xrp_withdrawal/',
                        'xrp_address/',
                        'withdrawal/open/',
                        'withdrawal/status/',
                        'withdrawal/cancel/',
                        'liquidation_address/new/',
                        'liquidation_address/info/',
                    ],
                },
                'v1': {
                    'post': [
                        'bitcoin_deposit_address/',
                        'unconfirmed_btc/',
                        'bitcoin_withdrawal/',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': true,
                    'percentage': true,
                    'taker': 0.25 / 100,
                    'maker': 0.25 / 100,
                    'tiers': {
                        'taker': [
                            [0, 0.25 / 100],
                            [20000, 0.24 / 100],
                            [100000, 0.22 / 100],
                            [400000, 0.20 / 100],
                            [600000, 0.15 / 100],
                            [1000000, 0.14 / 100],
                            [2000000, 0.13 / 100],
                            [4000000, 0.12 / 100],
                            [20000000, 0.11 / 100],
                            [20000001, 0.10 / 100],
                        ],
                        'maker': [
                            [0, 0.25 / 100],
                            [20000, 0.24 / 100],
                            [100000, 0.22 / 100],
                            [400000, 0.20 / 100],
                            [600000, 0.15 / 100],
                            [1000000, 0.14 / 100],
                            [2000000, 0.13 / 100],
                            [4000000, 0.12 / 100],
                            [20000000, 0.11 / 100],
                            [20000001, 0.10 / 100],
                        ],
                    },
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0,
                        'LTC': 0,
                        'ETH': 0,
                        'XRP': 0,
                        'USD': 25,
                        'EUR': 0.90,
                    },
                    'deposit': {
                        'BTC': 0,
                        'LTC': 0,
                        'ETH': 0,
                        'XRP': 0,
                        'USD': 25,
                        'EUR': 0,
                    },
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTradingPairsInfo ();
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            let id = market['url_symbol'];
            let precision = {
                'amount': market['base_decimals'],
                'price': market['counter_decimals'],
            };
            let [ cost, currency ] = market['minimum_order'].split (' ');
            let active = (market['trading'] == 'Enabled');
            let lot = Math.pow (10, -precision['amount']);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'lot': lot,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': parseFloat (cost),
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let ticker = await this.publicGetTickerPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        if ('date' in trade) {
            timestamp = parseInt (trade['date']) * 1000;
        } else if ('datetime' in trade) {
            // timestamp = this.parse8601 (trade['datetime']);
            timestamp = parseInt (trade['datetime']) * 1000;
        }
        let side = (trade['type'] == 0) ? 'buy' : 'sell';
        let order = undefined;
        if ('order_id' in trade)
            order = trade['order_id'].toString ();
        if ('currency_pair' in trade) {
            if (trade['currency_pair'] in this.markets_by_id)
                market = this.markets_by_id[trade['currency_pair']];
        }
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTransactionsPair (this.extend ({
            'pair': market['id'],
            'time': 'minute',
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balance = await this.privatePostBalance ();
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let total = lowercase + '_balance';
            let free = lowercase + '_available';
            let used = lowercase + '_reserved';
            let account = this.account ();
            if (free in balance)
                account['free'] = parseFloat (balance[free]);
            if (used in balance)
                account['used'] = parseFloat (balance[used]);
            if (total in balance)
                account['total'] = parseFloat (balance[total]);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'pair': this.marketId (symbol),
            'amount': amount,
        };
        if (type == 'market')
            method += 'Market';
        else
            order['price'] = price;
        method += 'Pair';
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'id': id });
    }

    parseOrderStatus (order) {
        if ((order['status'] == 'Queue') || (order['status'] == 'Open'))
            return 'open';
        if (order['status'] == 'Finished')
            return 'closed';
        return order['status'];
    }

    async fetchOrderStatus (id, symbol = undefined) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus ({ 'id': id });
        return this.parseOrderStatus (response);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = this.extend ({ 'pair': pair }, params);
        let response = await this.privatePostOpenOrdersPair (request);
        return this.parseTrades (response, market, since, limit);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderStatus ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (api != 'v1')
            url += this.version + '/';
        url += this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.encode (this.hmac (this.encode (auth), this.encode (this.secret)));
            query = this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query);
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],26:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, NotSupported, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bitstamp1 extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bitstamp1',
            'name': 'Bitstamp v1',
            'countries': 'GB',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                'api': 'https://www.bitstamp.net/api',
                'www': 'https://www.bitstamp.net',
                'doc': 'https://www.bitstamp.net/api',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'ticker',
                        'ticker_hour',
                        'order_book',
                        'transactions',
                        'eur_usd',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'user_transactions',
                        'open_orders',
                        'order_status',
                        'cancel_order',
                        'cancel_all_orders',
                        'buy',
                        'sell',
                        'bitcoin_deposit_address',
                        'unconfirmed_btc',
                        'ripple_withdrawal',
                        'ripple_address',
                        'withdrawal_requests',
                        'bitcoin_withdrawal',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'btcusd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'BTC/EUR': { 'id': 'btceur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                'EUR/USD': { 'id': 'eurusd', 'symbol': 'EUR/USD', 'base': 'EUR', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'XRP/USD': { 'id': 'xrpusd', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'XRP/EUR': { 'id': 'xrpeur', 'symbol': 'XRP/EUR', 'base': 'XRP', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                'XRP/BTC': { 'id': 'xrpbtc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
                'LTC/USD': { 'id': 'ltcusd', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'LTC/EUR': { 'id': 'ltceur', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
                'ETH/USD': { 'id': 'ethusd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'maker': 0.0025, 'taker': 0.0025 },
                'ETH/EUR': { 'id': 'etheur', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                'ETH/BTC': { 'id': 'ethbtc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.0025, 'taker': 0.0025 },
            },
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchOrderBook doesn't support " + symbol + ', use it for BTC/USD only');
        let orderbook = await this.publicGetOrderBook (params);
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    async fetchTicker (symbol, params = {}) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchTicker doesn't support " + symbol + ', use it for BTC/USD only');
        let ticker = await this.publicGetTicker (params);
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        if ('date' in trade) {
            timestamp = parseInt (trade['date']) * 1000;
        } else if ('datetime' in trade) {
            // timestamp = this.parse8601 (trade['datetime']);
            timestamp = parseInt (trade['datetime']) * 1000;
        }
        let side = (trade['type'] == 0) ? 'buy' : 'sell';
        let order = undefined;
        if ('order_id' in trade)
            order = trade['order_id'].toString ();
        if ('currency_pair' in trade) {
            if (trade['currency_pair'] in this.markets_by_id)
                market = this.markets_by_id[trade['currency_pair']];
        }
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchTrades doesn't support " + symbol + ', use it for BTC/USD only');
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'time': 'minute',
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async fetchBalance (params = {}) {
        let balance = await this.privatePostBalance ();
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let total = lowercase + '_balance';
            let free = lowercase + '_available';
            let used = lowercase + '_reserved';
            let account = this.account ();
            account['free'] = this.safeFloat (balance, free, 0.0);
            account['used'] = this.safeFloat (balance, used, 0.0);
            account['total'] = this.safeFloat (balance, total, 0.0);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type != 'limit')
            throw new ExchangeError (this.id + ' ' + this.version + ' accepts limit orders only');
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' v1 supports BTC/USD orders only');
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'amount': amount,
            'price': price,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder ({ 'id': id });
    }

    parseOrderStatus (order) {
        if ((order['status'] == 'Queue') || (order['status'] == 'Open'))
            return 'open';
        if (order['status'] == 'Finished')
            return 'closed';
        return order['status'];
    }

    async fetchOrderStatus (id, symbol = undefined) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus ({ 'id': id });
        return this.parseOrderStatus (response);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = this.extend ({ 'id': pair }, params);
        let response = await this.privatePostOpenOrdersId (request);
        return this.parseTrades (response, market, since, limit);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOrder is not implemented yet');
        await this.loadMarkets ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.encode (this.hmac (this.encode (auth), this.encode (this.secret)));
            query = this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query);
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}
},{"./base/Exchange":8,"./base/errors":10}],27:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InvalidOrder, InsufficientFunds, OrderNotFound } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bittrex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bittrex',
            'name': 'Bittrex',
            'countries': 'US',
            'version': 'v1.1',
            'rateLimit': 1500,
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchMyTrades': false,
            'hasFetchCurrencies': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchTickers': true,
                'fetchOHLCV': true,
                'fetchOrder': true,
                'fetchOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchMyTrades': false,
                'fetchCurrencies': true,
                'withdraw': true,
            },
            'timeframes': {
                '1m': 'oneMin',
                '5m': 'fiveMin',
                '30m': 'thirtyMin',
                '1h': 'hour',
                '1d': 'day',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766352-cf0b3c26-5ed5-11e7-82b7-f3826b7a97d8.jpg',
                'api': {
                    'public': 'https://bittrex.com/api',
                    'account': 'https://bittrex.com/api',
                    'market': 'https://bittrex.com/api',
                    'v2': 'https://bittrex.com/api/v2.0/pub',
                },
                'www': 'https://bittrex.com',
                'doc': [
                    'https://bittrex.com/Home/Api',
                    'https://www.npmjs.org/package/node.bittrex.api',
                ],
                'fees': [
                    'https://bittrex.com/Fees',
                    'https://support.bittrex.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-',
                ],
            },
            'api': {
                'v2': {
                    'get': [
                        'currencies/GetBTCPrice',
                        'market/GetTicks',
                        'market/GetLatestTick',
                        'Markets/GetMarketSummaries',
                        'market/GetLatestTick',
                    ],
                },
                'public': {
                    'get': [
                        'currencies',
                        'markethistory',
                        'markets',
                        'marketsummaries',
                        'marketsummary',
                        'orderbook',
                        'ticker',
                    ],
                },
                'account': {
                    'get': [
                        'balance',
                        'balances',
                        'depositaddress',
                        'deposithistory',
                        'order',
                        'orderhistory',
                        'withdrawalhistory',
                        'withdraw',
                    ],
                },
                'market': {
                    'get': [
                        'buylimit',
                        'buymarket',
                        'cancel',
                        'openorders',
                        'selllimit',
                        'sellmarket',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'maker': 0.0025,
                    'taker': 0.0025,
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.001,
                        'LTC': 0.01,
                        'DOGE': 2,
                        'VTC': 0.02,
                        'PPC': 0.02,
                        'FTC': 0.2,
                        'RDD': 2,
                        'NXT': 2,
                        'DASH': 0.002,
                        'POT': 0.002,
                    },
                    'deposit': {
                        'BTC': 0,
                        'LTC': 0,
                        'DOGE': 0,
                        'VTC': 0,
                        'PPC': 0,
                        'FTC': 0,
                        'RDD': 0,
                        'NXT': 0,
                        'DASH': 0,
                        'POT': 0,
                    },
                },
            },
        });
    }

    costToPrecision (symbol, cost) {
        return this.truncate (parseFloat (cost), this.markets[symbol]['precision']['price']);
    }

    feeToPrecision (symbol, fee) {
        return this.truncate (parseFloat (fee), this.markets[symbol]['precision']['price']);
    }

    async fetchMarkets () {
        let response = await this.v2GetMarketsGetMarketSummaries ();
        let result = [];
        for (let i = 0; i < response['result'].length; i++) {
            let market = response['result'][i]['Market'];
            let id = market['MarketName'];
            let base = market['MarketCurrency'];
            let quote = market['BaseCurrency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': 8,
                'price': 8,
            };
            let active = market['IsActive'];
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': active,
                'info': market,
                'lot': Math.pow (10, -precision['amount']),
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': market['MinTradeSize'],
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.accountGetBalances ();
        let balances = response['result'];
        let result = { 'info': balances };
        let indexed = this.indexBy (balances, 'Currency');
        let keys = Object.keys (indexed);
        for (let i = 0; i < keys.length; i++) {
            let id = keys[i];
            let currency = this.commonCurrencyCode (id);
            let account = this.account ();
            let balance = indexed[id];
            let free = parseFloat (balance['Available']);
            let total = parseFloat (balance['Balance']);
            let used = total - free;
            account['free'] = free;
            account['used'] = used;
            account['total'] = total;
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (symbol),
            'type': 'both',
            'depth': 50,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.parse8601 (ticker['TimeStamp']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'High'),
            'low': this.safeFloat (ticker, 'Low'),
            'bid': this.safeFloat (ticker, 'Bid'),
            'ask': this.safeFloat (ticker, 'Ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'Last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'Volume'),
            'quoteVolume': this.safeFloat (ticker, 'BaseVolume'),
            'info': ticker,
        };
    }

    async fetchCurrencies (params = {}) {
        let response = await this.publicGetCurrencies (params);
        let currencies = response['result'];
        let result = {};
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let id = currency['Currency'];
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            let code = this.commonCurrencyCode (id);
            let precision = {
                'amount': 8, // default precision, todo: fix "magic constants"
                'price': 8,
            };
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': currency['CurrencyLong'],
                'active': currency['IsActive'],
                'status': 'ok',
                'fee': currency['TxFee'], // todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision['amount']),
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': currency['TxFee'],
                        'max': Math.pow (10, precision['amount']),
                    },
                },
            };
        }
        return result;
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarketsummaries (params);
        let tickers = response['result'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let id = ticker['MarketName'];
            let market = undefined;
            let symbol = id;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let [ quote, base ] = id.split ('-');
                base = this.commonCurrencyCode (base);
                quote = this.commonCurrencyCode (quote);
                symbol = base + '/' + quote;
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketsummary (this.extend ({
            'market': market['id'],
        }, params));
        let ticker = response['result'][0];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['TimeStamp']);
        let side = undefined;
        if (trade['OrderType'] == 'BUY') {
            side = 'buy';
        } else if (trade['OrderType'] == 'SELL') {
            side = 'sell';
        }
        let id = undefined;
        if ('Id' in trade)
            id = trade['Id'].toString ();
        return {
            'id': id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': 'limit',
            'side': side,
            'price': parseFloat (trade['Price']),
            'amount': parseFloat (trade['Quantity']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarkethistory (this.extend ({
            'market': market['id'],
        }, params));
        if ('result' in response) {
            if (typeof response['result'] != 'undefined')
                return this.parseTrades (response['result'], market, since, limit);
        }
        throw new ExchangeError (this.id + ' fetchTrades() returned undefined response');
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['T']);
        return [
            timestamp,
            ohlcv['O'],
            ohlcv['H'],
            ohlcv['L'],
            ohlcv['C'],
            ohlcv['V'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'tickInterval': this.timeframes[timeframe],
            'marketName': market['id'],
        };
        let response = await this.v2GetMarketGetTicks (this.extend (request, params));
        return this.parseOHLCVs (response['result'], market, timeframe, since, limit);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['market'] = market['id'];
        }
        let response = await this.marketGetOpenorders (this.extend (request, params));
        let orders = this.parseOrders (response['result'], market, since, limit);
        return this.filterOrdersBySymbol (orders, symbol);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'marketGet' + this.capitalize (side) + type;
        let order = {
            'market': market['id'],
            'quantity': this.amountToPrecision (symbol, amount),
        };
        if (type == 'limit')
            order['rate'] = this.priceToPrecision (symbol, price);
        let response = await this[method] (this.extend (order, params));
        let result = {
            'info': response,
            'id': response['result']['uuid'],
        };
        return result;
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.marketGetCancel (this.extend ({
                'uuid': id,
            }, params));
        } catch (e) {
            if (this.last_json_response) {
                let message = this.safeString (this.last_json_response, 'message');
                if (message == 'ORDER_NOT_OPEN')
                    throw new InvalidOrder (this.id + ' cancelOrder() error: ' + this.last_http_response);
                if (message == 'UUID_INVALID')
                    throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
            }
            throw e;
        }
        return response;
    }

    parseOrder (order, market = undefined) {
        let side = undefined;
        if ('OrderType' in order)
            side = (order['OrderType'] == 'LIMIT_BUY') ? 'buy' : 'sell';
        if ('Type' in order)
            side = (order['Type'] == 'LIMIT_BUY') ? 'buy' : 'sell';
        let status = 'open';
        if (order['Closed']) {
            status = 'closed';
        } else if (order['CancelInitiated']) {
            status = 'canceled';
        }
        let symbol = undefined;
        if (!market) {
            if ('Exchange' in order)
                if (order['Exchange'] in this.markets_by_id)
                    market = this.markets_by_id[order['Exchange']];
        }
        if (market)
            symbol = market['symbol'];
        let timestamp = undefined;
        if ('Opened' in order)
            timestamp = this.parse8601 (order['Opened']);
        if ('TimeStamp' in order)
            timestamp = this.parse8601 (order['TimeStamp']);
        let fee = undefined;
        let commission = undefined;
        if ('Commission' in order) {
            commission = 'Commission';
        } else if ('CommissionPaid' in order) {
            commission = 'CommissionPaid';
        }
        if (commission) {
            fee = {
                'cost': parseFloat (order[commission]),
                'currency': market['quote'],
            };
        }
        let price = this.safeFloat (order, 'Limit');
        let cost = this.safeFloat (order, 'Price');
        let amount = this.safeFloat (order, 'Quantity');
        let remaining = this.safeFloat (order, 'QuantityRemaining', 0.0);
        let filled = amount - remaining;
        if (!cost) {
            if (price && amount)
                cost = price * amount;
        }
        if (!price) {
            if (cost && filled)
                price = cost / filled;
        }
        let average = this.safeFloat (order, 'PricePerUnit');
        let result = {
            'info': order,
            'id': order['OrderUuid'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': 'limit',
            'side': side,
            'price': price,
            'cost': cost,
            'average': average,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
        };
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.accountGetOrder (this.extend ({ 'uuid': id }, params));
        } catch (e) {
            if (this.last_json_response) {
                let message = this.safeString (this.last_json_response, 'message');
                if (message == 'UUID_INVALID')
                    throw new OrderNotFound (this.id + ' fetchOrder() error: ' + this.last_http_response);
            }
            throw e;
        }
        return this.parseOrder (response['result']);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['market'] = market['id'];
        }
        let response = await this.accountGetOrderhistory (this.extend (request, params));
        let orders = this.parseOrders (response['result'], market, since, limit);
        return this.filterOrdersBySymbol (orders, symbol);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        return this.filterBy (orders, 'status', 'closed');
    }

    currencyId (currency) {
        if (currency == 'BCH')
            return 'BCC';
        return currency;
    }

    async fetchDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.accountGetDepositaddress (this.extend ({
            'currency': currencyId,
        }, params));
        let address = this.safeString (response['result'], 'Address');
        let message = this.safeString (response, 'message');
        let status = 'ok';
        if (!address || message == 'ADDRESS_GENERATING')
            status = 'pending';
        return {
            'currency': currency,
            'address': address,
            'status': status,
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.accountGetWithdraw (this.extend ({
            'currency': currencyId,
            'quantity': amount,
            'address': address,
        }, params));
        let id = undefined;
        if ('result' in response) {
            if ('uuid' in response['result'])
                id = response['result']['uuid'];
        }
        return {
            'info': response,
            'id': id,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/';
        if (api != 'v2')
            url += this.version + '/';
        if (api == 'public') {
            url += api + '/' + method.toLowerCase () + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else if (api == 'v2') {
            url += path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            url += api + '/';
            if (((api == 'account') && (path != 'withdraw')) || (path == 'openorders'))
                url += method.toLowerCase ();
            url += path + '?' + this.urlencode (this.extend ({
                'nonce': nonce,
                'apikey': this.apiKey,
            }, params));
            let signature = this.hmac (this.encode (url), this.encode (this.secret), 'sha512');
            headers = { 'apisign': signature };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code >= 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                if ('success' in response) {
                    if (!response['success']) {
                        if ('message' in response) {
                            if (response['message'] == 'MIN_TRADE_REQUIREMENT_NOT_MET')
                                throw new InvalidOrder (this.id + ' ' + this.json (response));
                            if (response['message'] == 'APIKEY_INVALID')
                                throw new AuthenticationError (this.id + ' ' + this.json (response));
                        }
                        throw new ExchangeError (this.id + ' ' + this.json (response));
                    }
                }
            }
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response) {
            if (response['success'])
                return response;
        }
        if ('message' in response) {
            if (response['message'] == 'ADDRESS_GENERATING')
                return response;
            if (response['message'] == "INSUFFICIENT_FUNDS")
                throw new InsufficientFunds (this.id + ' ' + this.json (response));
        }
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],28:[function(require,module,exports){
"use strict"

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

// ---------------------------------------------------------------------------

module.exports = class bl3p extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bl3p',
            'name': 'BL3P',
            'countries': [ 'NL', 'EU' ], // Netherlands, EU
            'rateLimit': 1000,
            'version': '1',
            'comment': 'An exchange market by BitonicNL',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg',
                'api': 'https://api.bl3p.eu',
                'www': [
                    'https://bl3p.eu',
                    'https://bitonic.nl',
                ],
                'doc': [
                    'https://github.com/BitonicNL/bl3p-api/tree/master/docs',
                    'https://bl3p.eu/api',
                    'https://bitonic.nl/en/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{market}/ticker',
                        '{market}/orderbook',
                        '{market}/trades',
                    ],
                },
                'private': {
                    'post': [
                        '{market}/money/depth/full',
                        '{market}/money/order/add',
                        '{market}/money/order/cancel',
                        '{market}/money/order/result',
                        '{market}/money/orders',
                        '{market}/money/orders/history',
                        '{market}/money/trades/fetch',
                        'GENMKT/money/info',
                        'GENMKT/money/deposit_address',
                        'GENMKT/money/new_deposit_address',
                        'GENMKT/money/wallet/history',
                        'GENMKT/money/withdraw',
                    ],
                },
            },
            'markets': {
                'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                // 'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostGENMKTMoneyInfo ();
        let data = response['data'];
        let balance = data['wallets'];
        let result = { 'info': data };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balance) {
                if ('available' in balance[currency]) {
                    account['free'] = parseFloat (balance[currency]['available']['value']);
                }
            }
            if (currency in balance) {
                if ('balance' in balance[currency]) {
                    account['total'] = parseFloat (balance[currency]['balance']['value']);
                }
            }
            if (account['total']) {
                if (account['free']) {
                    account['used'] = account['total'] - account['free'];
                }
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    parseBidAsk (bidask, priceKey = 0, amountKey = 0) {
        return [
            bidask['price_int'] / 100000.0,
            bidask['amount_int'] / 100000000.0,
        ];
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketOrderbook (this.extend ({
            'market': market['id'],
        }, params));
        let orderbook = response['data'];
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetMarketTicker (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume']['24h']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        return {
            'id': trade['trade_id'],
            'info': trade,
            'timestamp': trade['date'],
            'datetime': this.iso8601 (trade['date']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price_int'] / 100000.0,
            'amount': trade['amount_int'] / 100000000.0,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketTrades (this.extend ({
            'market': market['id'],
        }, params));
        let result = this.parseTrades (response['data']['trades'], market, since, limit);
        return result;
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let order = {
            'market': market['id'],
            'amount_int': amount,
            'fee_currency': market['quote'],
            'type': (side == 'buy') ? 'bid' : 'ask',
        };
        if (type == 'limit')
            order['price_int'] = price;
        let response = await this.privatePostMarketMoneyOrderAdd (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostMarketMoneyOrderCancel ({ 'order_id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.implodeParams (path, params);
        let url = this.urls['api'] + '/' + this.version + '/' + request;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let secret = this.base64ToBinary (this.secret);
            let auth = request + "\0" + body;
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Rest-Key': this.apiKey,
                'Rest-Sign': signature,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8}],29:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const bittrex = require ('./bittrex.js')

// ---------------------------------------------------------------------------

module.exports = class bleutrade extends bittrex {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bleutrade',
            'name': 'Bleutrade',
            'countries': 'BR', // Brazil
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30303000-b602dbe6-976d-11e7-956d-36c5049c01e7.jpg',
                'api': {
                    'public': 'https://bleutrade.com/api',
                    'account': 'https://bleutrade.com/api',
                    'market': 'https://bleutrade.com/api',
                },
                'www': 'https://bleutrade.com',
                'doc': 'https://bleutrade.com/help/API',
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets['result'].length; p++) {
            let market = markets['result'][p];
            let id = market['MarketName'];
            let base = market['MarketCurrency'];
            let quote = market['BaseCurrency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': 8,
                'price': 8,
            };
            let active = market['IsActive'];
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': active,
                'info': market,
                'lot': Math.pow (10, -precision['amount']),
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': market['MinTradeSize'],
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': 0,
                        'max': undefined,
                    },
                },
            }));
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (symbol),
            'type': 'ALL',
            'depth': 50,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    }
}

},{"./bittrex.js":27}],30:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcbox extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcbox',
            'name': 'BtcBox',
            'countries': 'JP',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchOHLCV': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/31275803-4df755a8-aaa1-11e7-9abb-11ec2fad9f2d.jpg',
                'api': 'https://www.btcbox.co.jp/api',
                'www': 'https://www.btcbox.co.jp/',
                'doc': 'https://www.btcbox.co.jp/help/asm',
            },
            'api': {
                'public': {
                    'get': [
                        'depth',
                        'orders',
                        'ticker',
                        'allticker',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'trade_add',
                        'trade_cancel',
                        'trade_list',
                        'trade_view',
                        'wallet',
                    ],
                },
            },
            'markets': {
                'BTC/JPY': { 'id': 'BTC/JPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
            },
        });
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            if (lowercase == 'dash')
                lowercase = 'drk';
            let account = this.account ();
            let free = lowercase + '_balance';
            let used = lowercase + '_lock';
            if (free in balances)
                account['free'] = parseFloat (balances[free]);
            if (used in balances)
                account['used'] = parseFloat (balances[used]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        let numSymbols = this.symbols.length;
        if (numSymbols > 1)
            request['coin'] = market['id'];
        let orderbook = await this.publicGetDepth (this.extend (request, params));
        let result = this.parseOrderBook (orderbook);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'vol'),
            'quoteVolume': this.safeFloat (ticker, 'volume'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetAllticker (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        let numSymbols = this.symbols.length;
        if (numSymbols > 1)
            request['coin'] = market['id'];
        let ticker = await this.publicGetTicker (this.extend (request, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'],
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        let numSymbols = this.symbols.length;
        if (numSymbols > 1)
            request['coin'] = market['id'];
        let response = await this.publicGetOrders (this.extend (request, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'amount': amount,
            'price': price,
            'type': side,
        };
        let numSymbols = this.symbols.length;
        if (numSymbols > 1)
            request['coin'] = market['id'];
        let response = await this.privatePostTradeAdd (this.extend (request, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostTradeCancel (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
            }, params);
            let request = this.urlencode (query);
            let secret = this.hash (this.encode (this.secret));
            query['signature'] = this.hmac (this.encode (request), this.encode (secret));
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (!response['result'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],31:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcchina extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcchina',
            'name': 'BTCChina',
            'countries': 'CN',
            'rateLimit': 1500,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766368-465b3286-5ed6-11e7-9a11-0f6467e1d82b.jpg',
                'api': {
                    'plus': 'https://plus-api.btcchina.com/market',
                    'public': 'https://data.btcchina.com/data',
                    'private': 'https://api.btcchina.com/api_trade_v1.php',
                },
                'www': 'https://www.btcchina.com',
                'doc': 'https://www.btcchina.com/apidocs'
            },
            'api': {
                'plus': {
                    'get': [
                        'orderbook',
                        'ticker',
                        'trade',
                    ],
                },
                'public': {
                    'get': [
                        'historydata',
                        'orderbook',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'BuyIcebergOrder',
                        'BuyOrder',
                        'BuyOrder2',
                        'BuyStopOrder',
                        'CancelIcebergOrder',
                        'CancelOrder',
                        'CancelStopOrder',
                        'GetAccountInfo',
                        'getArchivedOrder',
                        'getArchivedOrders',
                        'GetDeposits',
                        'GetIcebergOrder',
                        'GetIcebergOrders',
                        'GetMarketDepth',
                        'GetMarketDepth2',
                        'GetOrder',
                        'GetOrders',
                        'GetStopOrder',
                        'GetStopOrders',
                        'GetTransactions',
                        'GetWithdrawal',
                        'GetWithdrawals',
                        'RequestWithdrawal',
                        'SellIcebergOrder',
                        'SellOrder',
                        'SellOrder2',
                        'SellStopOrder',
                    ],
                },
            },
            'markets': {
                'BTC/CNY': { 'id': 'btccny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'api': 'public', 'plus': false },
                'LTC/CNY': { 'id': 'ltccny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'api': 'public', 'plus': false },
                'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'api': 'public', 'plus': false },
                'BCH/CNY': { 'id': 'bcccny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY', 'api': 'plus', 'plus': true },
                'ETH/CNY': { 'id': 'ethcny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY', 'api': 'plus', 'plus': true },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTicker ({
            'market': 'all',
        });
        let result = [];
        let keys = Object.keys (markets);
        for (let p = 0; p < keys.length; p++) {
            let key = keys[p];
            let market = markets[key];
            let parts = key.split ('_');
            let id = parts[1];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['result'];
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances['balance'])
                account['total'] = parseFloat (balances['balance'][lowercase]['amount']);
            if (lowercase in balances['frozen'])
                account['used'] = parseFloat (balances['frozen'][lowercase]['amount']);
            account['free'] = account['total'] - account['used'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    createMarketRequest (market) {
        let request = {};
        let field = (market['plus']) ? 'symbol' : 'market';
        request[field] = market['id'];
        return request;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetOrderbook';
        let request = this.createMarketRequest (market);
        let orderbook = await this[method] (this.extend (request, params));
        let timestamp = orderbook['date'] * 1000;
        let result = this.parseOrderBook (orderbook, timestamp);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market) {
        let timestamp = ticker['date'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': parseFloat (ticker['vwap']),
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['prev_close']),
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTickerPlus (ticker, market) {
        let timestamp = ticker['Timestamp'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['High']),
            'low': parseFloat (ticker['Low']),
            'bid': parseFloat (ticker['BidPrice']),
            'ask': parseFloat (ticker['AskPrice']),
            'vwap': undefined,
            'open': parseFloat (ticker['Open']),
            'close': parseFloat (ticker['PrevCls']),
            'first': undefined,
            'last': parseFloat (ticker['Last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['Volume24H']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetTicker';
        let request = this.createMarketRequest (market);
        let tickers = await this[method] (this.extend (request, params));
        let ticker = tickers['ticker'];
        if (market['plus'])
            return this.parseTickerPlus (ticker, market);
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    parseTradePlus (trade, market) {
        let timestamp = this.parse8601 (trade['timestamp']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['size'],
        };
    }

    parseTradesPlus (trades, market = undefined) {
        let result = [];
        for (let i = 0; i < trades.length; i++) {
            result.push (this.parseTradePlus (trades[i], market));
        }
        return result;
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetTrade';
        let request = this.createMarketRequest (market);
        if (market['plus']) {
            let now = this.milliseconds ();
            request['start_time'] = now - 86400 * 1000;
            request['end_time'] = now;
        } else {
            method += 's'; // trades vs trade
        }
        let response = await this[method] (this.extend (request, params));
        if (market['plus']) {
            return this.parseTradesPlus (response['trades'], market);
        }
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'Order2';
        let order = {};
        let id = market['id'].toUpperCase ();
        if (type == 'market') {
            order['params'] = [ undefined, amount, id ];
        } else {
            order['params'] = [ price, amount, id ];
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = params['market']; // TODO fixme
        return await this.privatePostCancelOrder (this.extend ({
            'params': [ id, market ],
        }, params));
    }

    nonce () {
        return this.microseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let p = [];
            if ('params' in params)
                p = params['params'];
            let nonce = this.nonce ();
            let request = {
                'method': path,
                'id': nonce,
                'params': p,
            };
            p = p.join (',');
            body = this.json (request);
            let query = (
                'tonce=' + nonce +
                '&accesskey=' + this.apiKey +
                '&requestmethod=' + method.toLowerCase () +
                '&id=' + nonce +
                '&method=' + path +
                '&params=' + p
            );
            let signature = this.hmac (this.encode (query), this.encode (this.secret), 'sha1');
            let auth = this.encode (this.apiKey + ':' + signature);
            headers = {
                'Authorization': 'Basic ' + this.stringToBase64 (auth),
                'Json-Rpc-Tonce': nonce,
            };
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],32:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const btcturk = require ('./btcturk.js')

// ---------------------------------------------------------------------------

module.exports = class btcexchange extends btcturk {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcexchange',
            'name': 'BTCExchange',
            'countries': 'PH', // Philippines
            'rateLimit': 1500,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27993052-4c92911a-64aa-11e7-96d8-ec6ac3435757.jpg',
                'api': 'https://www.btcexchange.ph/api',
                'www': 'https://www.btcexchange.ph',
                'doc': 'https://github.com/BTCTrader/broker-api-docs',
            },
            'markets': {
                'BTC/PHP': { 'id': 'BTC/PHP', 'symbol': 'BTC/PHP', 'base': 'BTC', 'quote': 'PHP' },
            },
        });
    }
}

},{"./btcturk.js":35}],33:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcmarkets extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcmarkets',
            'name': 'BTC Markets',
            'countries': 'AU', // Australia
            'rateLimit': 1000, // market data cached for 1 second (trades cached for 2 seconds)
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/29142911-0e1acfc2-7d5c-11e7-98c4-07d9532b29d7.jpg',
                'api': 'https://api.btcmarkets.net',
                'www': 'https://btcmarkets.net/',
                'doc': 'https://github.com/BTCMarkets/API',
            },
            'api': {
                'public': {
                    'get': [
                        'market/{id}/tick',
                        'market/{id}/orderbook',
                        'market/{id}/trades',
                    ],
                },
                'private': {
                    'get': [
                        'account/balance',
                        'account/{id}/tradingfee',
                    ],
                    'post': [
                        'fundtransfer/withdrawCrypto',
                        'fundtransfer/withdrawEFT',
                        'order/create',
                        'order/cancel',
                        'order/history',
                        'order/open',
                        'order/trade/history',
                        'order/createBatch', // they promise it's coming soon...
                        'order/detail',
                    ],
                },
            },
            'markets': {
                'BTC/AUD': { 'id': 'BTC/AUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'LTC/AUD': { 'id': 'LTC/AUD', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'ETH/AUD': { 'id': 'ETH/AUD', 'symbol': 'ETH/AUD', 'base': 'ETH', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'ETC/AUD': { 'id': 'ETC/AUD', 'symbol': 'ETC/AUD', 'base': 'ETC', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'XRP/AUD': { 'id': 'XRP/AUD', 'symbol': 'XRP/AUD', 'base': 'XRP', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'BCH/AUD': { 'id': 'BCH/AUD', 'symbol': 'BCH/AUD', 'base': 'BCH', 'quote': 'AUD', 'maker': 0.0085, 'taker': 0.0085 },
                'LTC/BTC': { 'id': 'LTC/BTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
                'ETH/BTC': { 'id': 'ETH/BTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
                'ETC/BTC': { 'id': 'ETC/BTC', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
                'XRP/BTC': { 'id': 'XRP/BTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
                'BCH/BTC': { 'id': 'BCH/BTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'maker': 0.0022, 'taker': 0.0022 },
            },
        });
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccountBalance ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let multiplier = 100000000;
            let total = parseFloat (balance['balance'] / multiplier);
            let used = parseFloat (balance['pendingFunds'] / multiplier);
            let free = total - used;
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetMarketIdOrderbook (this.extend ({
            'id': market['id'],
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['timestamp'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bestBid']),
            'ask': parseFloat (ticker['bestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume24h']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetMarketIdTick (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketIdTrades (this.extend ({
            // 'since': 59868345231,
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let multiplier = 100000000; // for price and volume
        // does BTC Markets support market orders at all?
        let orderSide = (side == 'buy') ? 'Bid' : 'Ask';
        let order = this.ordered ({
            'currency': market['quote'],
            'instrument': market['base'],
            'price': price * multiplier,
            'volume': amount * multiplier,
            'orderSide': orderSide,
            'ordertype': this.capitalize (type),
            'clientRequestId': this.nonce ().toString (),
        });
        let response = await this.privatePostOrderCreate (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrders (ids) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_ids': ids });
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.cancelOrders ([ id ]);
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let uri = '/' + this.implodeParams (path, params);
        let url = this.urls['api'] + uri;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = uri + "\n" + nonce + "\n";
            headers = {
                'Content-Type': 'application/json',
                'apikey': this.apiKey,
                'timestamp': nonce,
            };
            if (method == 'POST') {
                body = this.urlencode (query);
                auth += body;
            }
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers['signature'] = this.decode (signature);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'private') {
            if ('success' in response)
                if (!response['success'])
                    throw new ExchangeError (this.id + ' ' + this.json (response));
            return response;
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],34:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btctradeua extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btctradeua',
            'name': 'BTC Trade UA',
            'countries': 'UA', // Ukraine,
            'rateLimit': 3000,
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg',
                'api': 'https://btc-trade.com.ua/api',
                'www': 'https://btc-trade.com.ua',
                'doc': 'https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit',
            },
            'api': {
                'public': {
                    'get': [
                        'deals/{symbol}',
                        'trades/sell/{symbol}',
                        'trades/buy/{symbol}',
                        'japan_stat/high/{symbol}',
                    ],
                },
                'private': {
                    'post': [
                        'auth',
                        'ask/{symbol}',
                        'balance',
                        'bid/{symbol}',
                        'buy/{symbol}',
                        'my_orders/{symbol}',
                        'order/status/{id}',
                        'remove/order/{id}',
                        'sell/{symbol}',
                    ],
                },
            },
            'markets': {
                'BTC/UAH': { 'id': 'btc_uah', 'symbol': 'BTC/UAH', 'base': 'BTC', 'quote': 'UAH', 'precision': { 'price': 1 }, 'limits': { 'amount': { 'min': 0.0000000001 }}},
                'ETH/UAH': { 'id': 'eth_uah', 'symbol': 'ETH/UAH', 'base': 'ETH', 'quote': 'UAH' },
                'LTC/UAH': { 'id': 'ltc_uah', 'symbol': 'LTC/UAH', 'base': 'LTC', 'quote': 'UAH' },
                'DOGE/UAH': { 'id': 'doge_uah', 'symbol': 'DOGE/UAH', 'base': 'DOGE', 'quote': 'UAH' },
                'DASH/UAH': { 'id': 'dash_uah', 'symbol': 'DASH/UAH', 'base': 'DASH', 'quote': 'UAH' },
                'SIB/UAH': { 'id': 'sib_uah', 'symbol': 'SIB/UAH', 'base': 'SIB', 'quote': 'UAH' },
                'KRB/UAH': { 'id': 'krb_uah', 'symbol': 'KRB/UAH', 'base': 'KRB', 'quote': 'UAH' },
                'NVC/UAH': { 'id': 'nvc_uah', 'symbol': 'NVC/UAH', 'base': 'NVC', 'quote': 'UAH' },
                'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                'NVC/BTC': { 'id': 'nvc_btc', 'symbol': 'NVC/BTC', 'base': 'NVC', 'quote': 'BTC' },
                'ITI/UAH': { 'id': 'iti_uah', 'symbol': 'ITI/UAH', 'base': 'ITI', 'quote': 'UAH' },
                'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC' },
                'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
            },
            'fees': {
                'trading': {
                    'maker': 0.1 / 100,
                    'taker': 0.1 / 100,
                },
            },
        });
    }

    signIn () {
        return this.privatePostAuth ();
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalance ();
        let result = { 'info': response };
        if ('accounts' in response) {
            let accounts = response['accounts'];
            for (let b = 0; b < accounts.length; b++) {
                let account = accounts[b];
                let currency = account['currency'];
                let balance = parseFloat (account['balance']);
                result[currency] = {
                    'free': balance,
                    'used': 0.0,
                    'total': balance,
                };
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let bids = await this.publicGetTradesBuySymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let asks = await this.publicGetTradesSellSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let orderbook = {
            'bids': [],
            'asks': [],
        };
        if (bids) {
            if ('list' in bids)
                orderbook['bids'] = bids['list'];
        }
        if (asks) {
            if ('list' in asks)
                orderbook['asks'] = asks['list'];
        }
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'currency_trade');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetJapanStatHighSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        let orderbook = await this.fetchOrderBook (symbol);
        let bid = undefined;
        let numBids = orderbook['bids'].length;
        if (numBids > 0)
            bid = orderbook['bids'][0][0];
        let ask = undefined;
        let numAsks = orderbook['asks'].length;
        if (numAsks > 0)
            ask = orderbook['asks'][0][0];
        let ticker = response['trades'];
        let timestamp = this.milliseconds ();
        let result = {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
        let tickerLength = ticker.length;
        if (tickerLength > 0) {
            let start = Math.max (tickerLength - 48, 0);
            for (let t = start; t < ticker.length; t++) {
                let candle = ticker[t];
                if (typeof result['open'] == 'undefined')
                    result['open'] = candle[1];
                if ((typeof result['high'] == 'undefined') || (result['high'] < candle[2]))
                    result['high'] = candle[2];
                if ((typeof result['low'] == 'undefined') || (result['low'] > candle[3]))
                    result['low'] = candle[3];
                if (typeof result['baseVolume'] == 'undefined')
                    result['baseVolume'] = -candle[5];
                else
                    result['baseVolume'] -= candle[5];
            }
            let last = tickerLength - 1;
            result['close'] = ticker[last][4];
            result['baseVolume'] = -1 * result['baseVolume'];
        }
        return result;
    }

    convertCyrillicMonthNameToString (cyrillic) {
        let months = [
            'января',
            'февраля',
            'марта',
            'апреля',
            'мая',
            'июня',
            'июля',
            'августа',
            'сентября',
            'октября',
            'ноября',
            'декабря',
        ];
        let month = undefined;
        for (let i = 0; i < months.length; i++) {
            if (cyrillic == months[i]) {
                month = i + 1;
                month = month.toString ();
                if (i < 9)
                    month = '0' + month;
            }
        }
        return month;
    }

    parseCyrillicDatetime (cyrillic) {
        let parts = cyrillic.split (' ');
        let day = parts[0];
        let month = this.convertCyrillicMonthNameToString (parts[1]);
        if (!month)
            throw new ExchangeError (this.id + ' parseTrade() undefined month name: ' + cyrillic);
        let year = parts[2];
        let hms = parts[4];
        let hmsLength = hms.length;
        if (hmsLength == 7) {
            hms = '0' + hms;
        }
        let ymd = [ year, month, day ].join ('-');
        let ymdhms = ymd + 'T' + hms;
        let timestamp = this.parse8601 (ymdhms);
        timestamp = timestamp - 10800000; // server reports local GMT+3 time, adjust to UTC
        return timestamp;
    }

    parseTrade (trade, market) {
        let timestamp = this.parseCyrillicDatetime (trade['pub_date']);
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amnt_trade']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetDealsSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let trades = [];
        for (let i = 0; i < response.length; i++) {
            if (response[i]['id'] % 2) {
                trades.push (response[i]);
            }
        }
        return this.parseTrades (trades, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'Id';
        let order = {
            'count': amount,
            'currency1': market['quote'],
            'currency': market['base'],
            'price': price,
        };
        return this[method] (this.extend (order, params));
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostRemoveOrderId ({ 'id': id });
    }

    parseOrder (trade, market) {
        let timestamp = this.milliseconds;
        return {
            'id': trade['id'],
            'timestamp': timestamp, // until they fix their timestamp
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amnt_trade'],
            'filled': 0,
            'remaining': trade['amnt_trade'],
            'trades': undefined,
            'info': trade,
        };
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol param');
        let market = this.market (symbol);
        let response = await this.privatePostMyOrdersSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let orders = response['your_open_orders'];
        return this.parseOrders (orders, market, since, limit);
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += this.implodeParams (path, query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'out_order_id': nonce,
                'nonce': nonce,
            }, query));
            let auth = body + this.secret;
            headers = {
                'public-key': this.apiKey,
                'api-sign': this.hash (this.encode (auth), 'sha256'),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],35:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcturk extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcturk',
            'name': 'BTCTurk',
            'countries': 'TR', // Turkey
            'rateLimit': 1000,
            'hasCORS': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1d': '1d',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27992709-18e15646-64a3-11e7-9fa2-b0950ec7712f.jpg',
                'api': 'https://www.btcturk.com/api',
                'www': 'https://www.btcturk.com',
                'doc': 'https://github.com/BTCTrader/broker-api-docs',
            },
            'api': {
                'public': {
                    'get': [
                        'ohlcdata', // ?last=COUNT
                        'orderbook',
                        'ticker',
                        'trades',   // ?last=COUNT (max 50)
                    ],
                },
                'private': {
                    'get': [
                        'balance',
                        'openOrders',
                        'userTransactions', // ?offset=0&limit=25&sort=asc
                    ],
                    'post': [
                        'buy',
                        'cancelOrder',
                        'sell',
                    ],
                },
            },
            'markets': {
                'BTC/TRY': { 'id': 'BTCTRY', 'symbol': 'BTC/TRY', 'base': 'BTC', 'quote': 'TRY', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
                'ETH/TRY': { 'id': 'ETHTRY', 'symbol': 'ETH/TRY', 'base': 'ETH', 'quote': 'TRY', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
                'ETH/BTC': { 'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.002 * 1.18, 'taker': 0.0035 * 1.18 },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privateGetBalance ();
        let result = { 'info': response };
        let base = {
            'free': response['bitcoin_available'],
            'used': response['bitcoin_reserved'],
            'total': response['bitcoin_balance'],
        };
        let quote = {
            'free': response['money_available'],
            'used': response['money_reserved'],
            'total': response['money_balance'],
        };
        let symbol = this.symbols[0];
        let market = this.markets[symbol];
        result[market['base']] = base;
        result[market['quote']] = quote;
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetOrderbook (this.extend ({
            'pairSymbol': market['id'],
        }, params));
        let timestamp = parseInt (orderbook['timestamp'] * 1000);
        return this.parseOrderBook (orderbook, timestamp);
    }

    parseTicker (ticker, market = undefined) {
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['average']),
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker (params);
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let symbol = ticker['pair'];
            let market = undefined;
            if (symbol in this.markets_by_id) {
                market = this.markets_by_id[symbol];
                symbol = market['symbol'];
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.fetchTickers ();
        let result = undefined;
        if (symbol in tickers)
            result = tickers[symbol];
        return result;
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        // let maxCount = 50;
        let response = await this.publicGetTrades (this.extend ({
            'pairSymbol': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['Time']);
        return [
            timestamp,
            ohlcv['Open'],
            ohlcv['High'],
            ohlcv['Low'],
            ohlcv['Close'],
            ohlcv['Volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1d', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        if (limit)
            request['last'] = limit;
        let response = await this.publicGetOhlcdata (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'Type': (side == 'buy') ? 'BuyBtc' : 'SelBtc',
            'IsMarketOrder': (type == 'market') ? 1 : 0,
        };
        if (type == 'market') {
            if (side == 'buy')
                order['Total'] = amount;
            else
                order['Amount'] = amount;
        } else {
            order['Price'] = price;
            order['Amount'] = amount;
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder ({ 'id': id });
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (this.id == 'btctrader')
            throw new ExchangeError (this.id + ' is an abstract base API for BTCExchange, BTCTurk');
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.urlencode (params);
            let secret = this.base64ToBinary (this.secret);
            let auth = this.apiKey + nonce;
            headers = {
                'X-PCK': this.apiKey,
                'X-Stamp': nonce,
                'X-Signature': this.stringToBase64(this.hmac (this.encode (auth), secret, 'sha256', 'binary')),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],36:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class btcx extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'btcx',
            'name': 'BTCX',
            'countries': [ 'IS', 'US', 'EU' ],
            'rateLimit': 1500, // support in english is very poor, unable to tell rate limits
            'version': 'v1',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766385-9fdcc98c-5ed6-11e7-8f14-66d5e5cd47e6.jpg',
                'api': 'https://btc-x.is/api',
                'www': 'https://btc-x.is',
                'doc': 'https://btc-x.is/custom/api-document.html',
            },
            'api': {
                'public': {
                    'get': [
                        'depth/{id}/{limit}',
                        'ticker/{id}',
                        'trade/{id}/{limit}',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'cancel',
                        'history',
                        'order',
                        'redeem',
                        'trade',
                        'withdraw',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'btc/usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/EUR': { 'id': 'btc/eur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': balances[currency],
                'used': 0.0,
                'total': balances[currency],
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetDepthIdLimit (this.extend ({
            'id': this.marketId (symbol),
            'limit': 1000,
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetTickerId (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = ticker['time'] * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['sell']),
            'ask': parseFloat (ticker['buy']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        let side = (trade['type'] == 'ask') ? 'sell' : 'buy';
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTradeIdLimit (this.extend ({
            'id': market['id'],
            'limit': 1000,
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostTrade (this.extend ({
            'type': side.toUpperCase (),
            'market': this.marketId (symbol),
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['order']['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancel ({ 'order': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/';
        if (api == 'public') {
            url += this.implodeParams (path, params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            url += api;
            body = this.urlencode (this.extend ({
                'Method': path.toUpperCase (),
                'Nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Signature': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],37:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bter extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bter',
            'name': 'Bter',
            'countries': [ 'VG', 'CN' ], // British Virgin Islands, China
            'version': '2',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27980479-cfa3188c-6387-11e7-8191-93fc4184ba5c.jpg',
                'api': {
                    'public': 'https://data.bter.com/api',
                    'private': 'https://api.bter.com/api',
                },
                'www': 'https://bter.com',
                'doc': 'https://bter.com/api2',
            },
            'api': {
                'public': {
                    'get': [
                        'pairs',
                        'marketinfo',
                        'marketlist',
                        'tickers',
                        'ticker/{id}',
                        'orderBook/{id}',
                        'trade/{id}',
                        'tradeHistory/{id}',
                        'tradeHistory/{id}/{tid}',
                    ],
                },
                'private': {
                    'post': [
                        'balances',
                        'depositAddress',
                        'newAddress',
                        'depositsWithdrawals',
                        'buy',
                        'sell',
                        'cancelOrder',
                        'cancelAllOrders',
                        'getOrder',
                        'openOrders',
                        'tradeHistory',
                        'withdraw',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetMarketinfo ();
        let markets = response['pairs'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let keys = Object.keys (market);
            let id = keys[0];
            let details = market[id];
            let [ base, quote ] = id.split ('_');
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': details['decimal_places'],
                'price': details['decimal_places'],
            };
            let amountLimits = {
                'min': details['min_amount'],
                'max': undefined,
            };
            let priceLimits = {
                'min': undefined,
                'max': undefined,
            };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
            };
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'maker': details['fee'] / 100,
                'taker': details['fee'] / 100,
                'precision': precision,
                'limits': limits,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balance = await this.privatePostBalances ();
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let code = this.commonCurrencyCode (currency);
            let account = this.account ();
            if ('available' in balance) {
                if (currency in balance['available']) {
                    account['free'] = parseFloat (balance['available'][currency]);
                }
            }
            if ('locked' in balance) {
                if (currency in balance['locked']) {
                    account['used'] = parseFloat (balance['locked'][currency]);
                }
            }
            account['total'] = this.sum (account['free'], account['used']);
            result[code] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookId (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let result = this.parseOrderBook (orderbook);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24hr']),
            'low': parseFloat (ticker['low24hr']),
            'bid': parseFloat (ticker['highestBid']),
            'ask': parseFloat (ticker['lowestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': parseFloat (ticker['percentChange']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['quoteVolume']),
            'quoteVolume': parseFloat (ticker['baseVolume']),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers (params);
        let result = {};
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let [ baseId, quoteId ] = id.split ('_');
            let base = baseId.toUpperCase ();
            let quote = quoteId.toUpperCase ();
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let ticker = tickers[id];
            let market = undefined;
            if (symbol in this.markets)
                market = this.markets[symbol];
            if (id in this.markets_by_id)
                market = this.markets_by_id[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerId (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['date']);
        return {
            'id': trade['tradeID'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['rate'],
            'amount': this.safeFloat (trade, 'amount'),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradeHistoryId (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['data'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'currencyPair': this.marketId (symbol),
            'rate': price,
            'amount': amount,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderNumber'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'orderNumber': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdraw (this.extend ({
            'currency': currency.toLowerCase (),
            'amount': amount,
            'address': address, // Address must exist in you AddressBook in security settings
        }, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let prefix = (api == 'private') ? (api + '/') : '';
        let url = this.urls['api'][api] + this.version + '/1/' + prefix + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let request = { 'nonce': nonce };
            body = this.urlencode (this.extend (request, query));
            let signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512');
            headers = {
                'Key': this.apiKey,
                'Sign': signature,
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (response['result'] != 'true')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],38:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class bxinth extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'bxinth',
            'name': 'BX.in.th',
            'countries': 'TH', // Thailand
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766412-567b1eb4-5ed7-11e7-94a8-ff6a3884f6c5.jpg',
                'api': 'https://bx.in.th/api',
                'www': 'https://bx.in.th',
                'doc': 'https://bx.in.th/info/api',
            },
            'api': {
                'public': {
                    'get': [
                        '', // ticker
                        'options',
                        'optionbook',
                        'orderbook',
                        'pairing',
                        'trade',
                        'tradehistory',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'biller',
                        'billgroup',
                        'billpay',
                        'cancel',
                        'deposit',
                        'getorders',
                        'history',
                        'option-issue',
                        'option-bid',
                        'option-sell',
                        'option-myissue',
                        'option-mybid',
                        'option-myoptions',
                        'option-exercise',
                        'option-cancel',
                        'option-history',
                        'order',
                        'withdrawal',
                        'withdrawal-history',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.25 / 100,
                    'maker': 0.25 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetPairing ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let market = markets[keys[p]];
            let id = market['pairing_id'].toString ();
            let base = market['secondary_currency'];
            let quote = market['primary_currency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    commonCurrencyCode (currency) {
        // why would they use three letters instead of four for currency codes
        if (currency == 'DAS')
            return 'DASH';
        if (currency == 'DOG')
            return 'DOGE';
        return currency;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let balance = response['balance'];
        let result = { 'info': balance };
        let currencies = Object.keys (balance);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let code = this.commonCurrencyCode (currency);
            let account = {
                'free': parseFloat (balance[currency]['available']),
                'used': 0.0,
                'total': parseFloat (balance[currency]['total']),
            };
            account['used'] = account['total'] - account['free'];
            result[code] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbook (this.extend ({
            'pairing': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['orderbook']['bids']['highbid']),
            'ask': parseFloat (ticker['orderbook']['asks']['highbid']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_24hours']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGet (params);
        let result = {};
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let ticker = tickers[id];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGet (this.extend ({
            'pairing': market['id'],
        }, params));
        let id = market['id'].toString ();
        let ticker = tickers[id];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['trade_date']);
        return {
            'id': trade['trade_id'],
            'info': trade,
            'order': trade['order_id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['trade_type'],
            'price': parseFloat (trade['rate']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrade (this.extend ({
            'pairing': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrder (this.extend ({
            'pairing': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let pairing = undefined; // TODO fixme
        return await this.privatePostCancel ({
            'order_id': id,
            'pairing': pairing,
        });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (path)
            url += path + '/';
        if (Object.keys (params).length)
            url += '?' + this.urlencode (params);
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let auth = this.apiKey + nonce.toString () + this.secret;
            let signature = this.hash (this.encode (auth), 'sha256');
            body = this.urlencode (this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
                'signature': signature,
                // twofa: this.twofa,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'public')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],39:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class ccex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'ccex',
            'name': 'C-CEX',
            'countries': [ 'DE', 'EU' ],
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766433-16881f90-5ed8-11e7-92f8-3d92cc747a6c.jpg',
                'api': {
                    'tickers': 'https://c-cex.com/t',
                    'public': 'https://c-cex.com/t/api_pub.html',
                    'private': 'https://c-cex.com/t/api.html',
                },
                'www': 'https://c-cex.com',
                'doc': 'https://c-cex.com/?id=api',
            },
            'api': {
                'tickers': {
                    'get': [
                        'coinnames',
                        '{market}',
                        'pairs',
                        'prices',
                        'volume_{coin}',
                    ],
                },
                'public': {
                    'get': [
                        'balancedistribution',
                        'markethistory',
                        'markets',
                        'marketsummaries',
                        'orderbook',
                    ],
                },
                'private': {
                    'get': [
                        'buylimit',
                        'cancel',
                        'getbalance',
                        'getbalances',
                        'getopenorders',
                        'getorder',
                        'getorderhistory',
                        'mytrades',
                        'selllimit',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'taker': 0.2 / 100,
                    'maker': 0.2 / 100,
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (currency == 'IOT')
            return 'IoTcoin';
        if (currency == 'BLC')
            return 'Cryptobullcoin';
        if (currency == 'XID')
            return 'InternationalDiamond';
        return currency;
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets['result'].length; p++) {
            let market = markets['result'][p];
            let id = market['MarketName'];
            let base = market['MarketCurrency'];
            let quote = market['BaseCurrency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalances ();
        let balances = response['result'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let code = balance['Currency'];
            let currency = this.commonCurrencyCode (code);
            let account = {
                'free': balance['Available'],
                'used': balance['Pending'],
                'total': balance['Balance'],
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (symbol),
            'type': 'both',
            'depth': 100,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastprice']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']),
            'baseVolume': undefined,
            'quoteVolume': this.safeFloat (ticker, 'buysupport'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.tickersGetPrices (params);
        let result = { 'info': tickers };
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let ticker = tickers[id];
            let uppercase = id.toUpperCase ();
            let market = undefined;
            let symbol = undefined;
            if (uppercase in this.markets_by_id) {
                market = this.markets_by_id[uppercase];
                symbol = market['symbol'];
            } else {
                let [ base, quote ] = uppercase.split ('-');
                base = this.commonCurrencyCode (base);
                quote = this.commonCurrencyCode (quote);
                symbol = base + '/' + quote;
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.tickersGetMarket (this.extend ({
            'market': market['id'].toLowerCase (),
        }, params));
        let ticker = response['ticker'];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['TimeStamp']);
        return {
            'id': trade['Id'],
            'info': trade,
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['OrderType'].toLowerCase (),
            'price': trade['Price'],
            'amount': trade['Quantity'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarkethistory (this.extend ({
            'market': market['id'],
            'type': 'both',
            'depth': 100,
        }, params));
        return this.parseTrades (response['result'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privateGet' + this.capitalize (side) + type;
        let response = await this[method] (this.extend ({
            'market': this.marketId (symbol),
            'quantity': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['result']['uuid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateGetCancel ({ 'uuid': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let query = this.keysort (this.extend ({
                'a': path,
                'apikey': this.apiKey,
                'nonce': nonce,
            }, params));
            url += '?' + this.urlencode (query);
            headers = { 'apisign': this.hmac (this.encode (url), this.encode (this.secret), 'sha512') };
        } else if (api == 'public') {
            url += '?' + this.urlencode (this.extend ({
                'a': 'get' + path,
            }, params));
        } else {
            url += '/' + this.implodeParams (path, params) + '.json';
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'tickers')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],40:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class cex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'cex',
            'name': 'CEX.IO',
            'countries': [ 'GB', 'EU', 'CY', 'RU' ],
            'rateLimit': 1500,
            'hasCORS': true,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasFetchOpenOrders': true,
            'timeframes': {
                '1m': '1m',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg',
                'api': 'https://cex.io/api',
                'www': 'https://cex.io',
                'doc': 'https://cex.io/cex-api',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'currency_limits/',
                        'last_price/{pair}/',
                        'last_prices/{currencies}/',
                        'ohlcv/hd/{yyyymmdd}/{pair}',
                        'order_book/{pair}/',
                        'ticker/{pair}/',
                        'tickers/{currencies}/',
                        'trade_history/{pair}/',
                    ],
                    'post': [
                        'convert/{pair}',
                        'price_stats/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'active_orders_status/',
                        'archived_orders/{pair}/',
                        'balance/',
                        'cancel_order/',
                        'cancel_orders/{pair}/',
                        'cancel_replace_order/{pair}/',
                        'close_position/{pair}/',
                        'get_address/',
                        'get_myfee/',
                        'get_order/',
                        'get_order_tx/',
                        'open_orders/{pair}/',
                        'open_orders/',
                        'open_position/{pair}/',
                        'open_positions/{pair}/',
                        'place_order/{pair}/',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetCurrencyLimits ();
        let result = [];
        for (let p = 0; p < markets['data']['pairs'].length; p++) {
            let market = markets['data']['pairs'][p];
            let id = market['symbol1'] + '/' + market['symbol2'];
            let symbol = id;
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'info': market,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'precision': {
                    'price': this.precisionFromString (market['minPrice']),
                    'amount': -1 * Math.log10 (market['minLotSize']),
                },
                'limits': {
                    'amount': {
                        'min': market['minLotSize'],
                        'max': market['maxLotSize'],
                    },
                    'price': {
                        'min': parseFloat (market['minPrice']),
                        'max': parseFloat (market['maxPrice']),
                    },
                    'cost': {
                        'min': market['minLotSizeS2'],
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let result = { 'info': response };
        let ommited = [ 'username', 'timestamp' ];
        let balances = this.omit (response, ommited);
        let currencies = Object.keys (balances);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            if (currency in balances) {
                let account = {
                    'free': this.safeFloat (balances[currency], 'available', 0.0),
                    'used': this.safeFloat (balances[currency], 'orders', 0.0),
                    'total': 0.0,
                };
                account['total'] = this.sum (account['free'], account['used']);
                result[currency] = account;
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            ohlcv[1],
            ohlcv[2],
            ohlcv[3],
            ohlcv[4],
            ohlcv[5],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!since)
            since = this.milliseconds () - 86400000; // yesterday
        let ymd = this.Ymd (since);
        ymd = ymd.split ('-');
        ymd = ymd.join ('');
        let request = {
            'pair': market['id'],
            'yyyymmdd': ymd,
        };
        let response = await this.publicGetOhlcvHdYyyymmddPair (this.extend (request, params));
        let key = 'data' + this.timeframes[timeframe];
        let ohlcvs = JSON.parse (response[key]);
        return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = undefined;
        let iso8601 = undefined;
        if ('timestamp' in ticker) {
            timestamp = parseInt (ticker['timestamp']) * 1000;
            iso8601 = this.iso8601 (timestamp);
        }
        let volume = this.safeFloat (ticker, 'volume');
        let high = this.safeFloat (ticker, 'high');
        let low = this.safeFloat (ticker, 'low');
        let bid = this.safeFloat (ticker, 'bid');
        let ask = this.safeFloat (ticker, 'ask');
        let last = this.safeFloat (ticker, 'last');
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': iso8601,
            'high': high,
            'low': low,
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': volume,
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let currencies = Object.keys (this.currencies);
        let response = await this.publicGetTickersCurrencies (this.extend ({
            'currencies': currencies.join ('/'),
        }, params));
        let tickers = response['data'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let symbol = ticker['pair'].replace (':', '/');
            let market = this.markets[symbol];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradeHistoryPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'pair': this.marketId (symbol),
            'type': side,
            'amount': amount,
        };
        if (type == 'limit') {
            order['price'] = price;
        } else {
            // for market buy CEX.io requires the amount of quote currency to spend
            if (side == 'buy') {
                if (!price) {
                    throw new InvalidOrder ('For market buy orders ' + this.id + " requires the amount of quote currency to spend, to calculate proper costs call createOrder (symbol, 'market', 'buy', amount, price)");
                }
                order['amount'] = amount * price;
            }
            order['order_type'] = type;
        }
        let response = await this.privatePostPlaceOrderPair (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'id': id });
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostGetOrder (this.extend ({
            'id': id.toString (),
        }, params));
    }

    parseOrder (order, market = undefined) {
        let timestamp = parseInt (order['time']);
        let symbol = undefined;
        if (!market) {
            let symbol = order['symbol1'] + '/' + order['symbol2'];
            if (symbol in this.markets)
                market = this.market (symbol);
        }
        let status = order['status'];
        if (status == 'cd') {
            status = 'canceled';
        } else if (status == 'c') {
            status = 'canceled';
        } else if (status == 'd') {
            status = 'closed';
        }
        let price = this.safeFloat (order, 'price');
        let amount = this.safeFloat (order, 'amount');
        let remaining = this.safeFloat (order, 'pending');
        if (!remaining)
            remaining = this.safeFloat (order, 'remains');
        let filled = amount - remaining;
        let fee = undefined;
        let cost = undefined;
        if (market) {
            symbol = market['symbol'];
            cost = this.safeFloat (order, 'ta:' + market['quote']);
            let baseFee = 'fa:' + market['base'];
            let quoteFee = 'fa:' + market['quote'];
            let feeRate = this.safeFloat (order, 'tradingFeeMaker');
            if (!feeRate)
                feeRate = this.safeFloat (order, 'tradingFeeTaker', feeRate);
            if (feeRate)
                feeRate /= 100.0; // convert to mathematically-correct percentage coefficients: 1.0 = 100%
            if (baseFee in order) {
                fee = {
                    'currency': market['base'],
                    'rate': feeRate,
                    'cost': this.safeFloat (order, baseFee),
                };
            } else if (quoteFee in order) {
                fee = {
                    'currency': market['quote'],
                    'rate': feeRate,
                    'cost': this.safeFloat (order, quoteFee),
                };
            }
        }
        if (!cost)
            cost = price * filled;
        return {
            'id': order['id'],
            'datetime': this.iso8601 (timestamp),
            'timestamp': timestamp,
            'status': status,
            'symbol': symbol,
            'type': undefined,
            'side': order['type'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'trades': undefined,
            'fee': fee,
            'info': order,
        };
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let method = 'privatePostOpenOrders';
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['pair'] = market['id'];
            method += 'Pair';
        }
        let orders = await this[method] (this.extend (request, params));
        for (let i = 0; i < orders.length; i++) {
            orders[i] = this.extend (orders[i], { 'status': 'open' });
        }
        return this.parseOrders (orders, market, since, limit);
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.urlencode (this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (!response) {
            throw new ExchangeError (this.id + ' returned ' + this.json (response));
        } else if (response == true) {
            return response;
        } else if ('e' in response) {
            if ('ok' in response)
                if (response['ok'] == 'ok')
                    return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        } else if ('error' in response) {
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],41:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const zb = require ('./zb.js')

// ---------------------------------------------------------------------------

module.exports = class chbtc extends zb {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'chbtc',
            'name': 'CHBTC',
            'countries': 'CN',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchOrder': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28555659-f0040dc2-7109-11e7-9d99-688a438bf9f4.jpg',
                'api': {
                    'public': 'http://api.chbtc.com/data', // no https for public API
                    'private': 'https://trade.chbtc.com/api',
                },
                'www': 'https://trade.chbtc.com/api',
                'doc': 'https://www.chbtc.com/i/developer',
            },
        });
    }

    getMarketFieldName () {
        return 'currency';
    }

    async fetchMarkets () {
        return {
            'BTC/CNY': { 'id': 'btc_cny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY' },
            'LTC/CNY': { 'id': 'ltc_cny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY' },
            'ETH/CNY': { 'id': 'eth_cny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY' },
            'ETC/CNY': { 'id': 'etc_cny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY' },
            'BTS/CNY': { 'id': 'bts_cny', 'symbol': 'BTS/CNY', 'base': 'BTS', 'quote': 'CNY' },
            // 'EOS/CNY': { 'id': 'eos_cny', 'symbol': 'EOS/CNY', 'base': 'EOS', 'quote': 'CNY' },
            'BCH/CNY': { 'id': 'bcc_cny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY' },
            'HSR/CNY': { 'id': 'hsr_cny', 'symbol': 'HSR/CNY', 'base': 'HSR', 'quote': 'CNY' },
            'QTUM/CNY': { 'id': 'qtum_cny', 'symbol': 'QTUM/CNY', 'base': 'QTUM', 'quote': 'CNY' },
        };
    }
}

},{"./zb.js":101}],42:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const foxbit = require ('./foxbit.js')

// ---------------------------------------------------------------------------

module.exports = class chilebit extends foxbit {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'chilebit',
            'name': 'ChileBit',
            'countries': 'CL',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991414-1298f0d8-647f-11e7-9c40-d56409266336.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://chilebit.net',
                'doc': 'https://blinktrade.com/docs',
            },
        });
    }
}

},{"./foxbit.js":54}],43:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, NotSupported } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coincheck extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coincheck',
            'name': 'coincheck',
            'countries': [ 'JP', 'ID' ],
            'rateLimit': 1500,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766464-3b5c3c74-5ed9-11e7-840e-31b32968e1da.jpg',
                'api': 'https://coincheck.com/api',
                'www': 'https://coincheck.com',
                'doc': 'https://coincheck.com/documents/exchange/api',
            },
            'api': {
                'public': {
                    'get': [
                        'exchange/orders/rate',
                        'order_books',
                        'rate/{pair}',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'accounts',
                        'accounts/balance',
                        'accounts/leverage_balance',
                        'bank_accounts',
                        'deposit_money',
                        'exchange/orders/opens',
                        'exchange/orders/transactions',
                        'exchange/orders/transactions_pagination',
                        'exchange/leverage/positions',
                        'lending/borrows/matches',
                        'send_money',
                        'withdraws',
                    ],
                    'post': [
                        'bank_accounts',
                        'deposit_money/{id}/fast',
                        'exchange/orders',
                        'exchange/transfers/to_leverage',
                        'exchange/transfers/from_leverage',
                        'lending/borrows',
                        'lending/borrows/{id}/repay',
                        'send_money',
                        'withdraws',
                    ],
                    'delete': [
                        'bank_accounts/{id}',
                        'exchange/orders/{id}',
                        'withdraws/{id}',
                    ],
                },
            },
            'markets': {
                'BTC/JPY': { 'id': 'btc_jpy', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' }, // the only real pair
                // 'ETH/JPY': { 'id': 'eth_jpy', 'symbol': 'ETH/JPY', 'base': 'ETH', 'quote': 'JPY' },
                // 'ETC/JPY': { 'id': 'etc_jpy', 'symbol': 'ETC/JPY', 'base': 'ETC', 'quote': 'JPY' },
                // 'DAO/JPY': { 'id': 'dao_jpy', 'symbol': 'DAO/JPY', 'base': 'DAO', 'quote': 'JPY' },
                // 'LSK/JPY': { 'id': 'lsk_jpy', 'symbol': 'LSK/JPY', 'base': 'LSK', 'quote': 'JPY' },
                // 'FCT/JPY': { 'id': 'fct_jpy', 'symbol': 'FCT/JPY', 'base': 'FCT', 'quote': 'JPY' },
                // 'XMR/JPY': { 'id': 'xmr_jpy', 'symbol': 'XMR/JPY', 'base': 'XMR', 'quote': 'JPY' },
                // 'REP/JPY': { 'id': 'rep_jpy', 'symbol': 'REP/JPY', 'base': 'REP', 'quote': 'JPY' },
                // 'XRP/JPY': { 'id': 'xrp_jpy', 'symbol': 'XRP/JPY', 'base': 'XRP', 'quote': 'JPY' },
                // 'ZEC/JPY': { 'id': 'zec_jpy', 'symbol': 'ZEC/JPY', 'base': 'ZEC', 'quote': 'JPY' },
                // 'XEM/JPY': { 'id': 'xem_jpy', 'symbol': 'XEM/JPY', 'base': 'XEM', 'quote': 'JPY' },
                // 'LTC/JPY': { 'id': 'ltc_jpy', 'symbol': 'LTC/JPY', 'base': 'LTC', 'quote': 'JPY' },
                // 'DASH/JPY': { 'id': 'dash_jpy', 'symbol': 'DASH/JPY', 'base': 'DASH', 'quote': 'JPY' },
                // 'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
                // 'ETC/BTC': { 'id': 'etc_btc', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC' },
                // 'LSK/BTC': { 'id': 'lsk_btc', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC' },
                // 'FCT/BTC': { 'id': 'fct_btc', 'symbol': 'FCT/BTC', 'base': 'FCT', 'quote': 'BTC' },
                // 'XMR/BTC': { 'id': 'xmr_btc', 'symbol': 'XMR/BTC', 'base': 'XMR', 'quote': 'BTC' },
                // 'REP/BTC': { 'id': 'rep_btc', 'symbol': 'REP/BTC', 'base': 'REP', 'quote': 'BTC' },
                // 'XRP/BTC': { 'id': 'xrp_btc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
                // 'ZEC/BTC': { 'id': 'zec_btc', 'symbol': 'ZEC/BTC', 'base': 'ZEC', 'quote': 'BTC' },
                // 'XEM/BTC': { 'id': 'xem_btc', 'symbol': 'XEM/BTC', 'base': 'XEM', 'quote': 'BTC' },
                // 'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
                // 'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.privateGetAccountsBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances)
                account['free'] = parseFloat (balances[lowercase]);
            let reserved = lowercase + '_reserved';
            if (reserved in balances)
                account['used'] = parseFloat (balances[reserved]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        if (symbol != 'BTC/JPY')
            throw new NotSupported (this.id + ' fetchOrderBook () supports BTC/JPY only');
        let orderbook = await this.publicGetOrderBooks (params);
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        if (symbol != 'BTC/JPY')
            throw new NotSupported (this.id + ' fetchTicker () supports BTC/JPY only');
        let ticker = await this.publicGetTicker (params);
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['created_at']);
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['order_type'],
            'price': parseFloat (trade['rate']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        if (symbol != 'BTC/JPY')
            throw new NotSupported (this.id + ' fetchTrades () supports BTC/JPY only');
        let market = this.market (symbol);
        let response = await this.publicGetTrades (params);
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let prefix = '';
        let order = {
            'pair': this.marketId (symbol),
        };
        if (type == 'market') {
            let order_type = type + '_' + side;
            order['order_type'] = order_type;
            let prefix = (side == 'buy') ? (order_type + '_') : '';
            order[prefix + 'amount'] = amount;
        } else {
            order['order_type'] = side;
            order['rate'] = price;
            order['amount'] = amount;
        }
        let response = await this.privatePostExchangeOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privateDeleteExchangeOrdersId ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let queryString = '';
            if (method == 'POST') {
                if (Object.keys (query).length) {
                    body = this.urlencode (this.keysort (query));
                    queryString = body;
                }
            }
            let auth = nonce + url + queryString;
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'ACCESS-KEY': this.apiKey,
                'ACCESS-NONCE': nonce,
                'ACCESS-SIGNATURE': this.hmac (this.encode (auth), this.encode (this.secret)),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'public')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],44:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinfloor extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinfloor',
            'name': 'coinfloor',
            'rateLimit': 1000,
            'countries': 'UK',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28246081-623fc164-6a1c-11e7-913f-bac0d5576c90.jpg',
                'api': 'https://webapi.coinfloor.co.uk:8090/bist',
                'www': 'https://www.coinfloor.co.uk',
                'doc': [
                    'https://github.com/coinfloor/api',
                    'https://www.coinfloor.co.uk/api',
                ],
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        '{id}/ticker/',
                        '{id}/order_book/',
                        '{id}/transactions/',
                    ],
                },
                'private': {
                    'post': [
                        '{id}/balance/',
                        '{id}/user_transactions/',
                        '{id}/open_orders/',
                        '{id}/cancel_order/',
                        '{id}/buy/',
                        '{id}/sell/',
                        '{id}/buy_market/',
                        '{id}/sell_market/',
                        '{id}/estimate_sell_market/',
                        '{id}/estimate_buy_market/',
                    ],
                },
            },
            'markets': {
                'BTC/GBP': { 'id': 'XBT/GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
                'BTC/EUR': { 'id': 'XBT/EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
                'BTC/USD': { 'id': 'XBT/USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/PLN': { 'id': 'XBT/PLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
                'BCH/GBP': { 'id': 'BCH/GBP', 'symbol': 'BCH/GBP', 'base': 'BCH', 'quote': 'GBP' },
            },
        });
    }

    fetchBalance (params = {}) {
        let symbol = undefined;
        if ('symbol' in params)
            symbol = params['symbol'];
        if ('id' in params)
            symbol = params['id'];
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchBalance requires a symbol param');
        // todo parse balance
        return this.privatePostIdBalance ({
            'id': this.marketId (symbol),
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetIdOrderBook (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        // rewrite to get the timestamp from HTTP headers
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let vwap = this.safeFloat (ticker, 'vwap');
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = undefined;
        if (typeof vwap != 'undefined') {
            quoteVolume = baseVolume * vwap;
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let ticker = await this.publicGetIdTicker (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetIdTransactions (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = { 'id': this.marketId (symbol) };
        let method = 'privatePostId' + this.capitalize (side);
        if (type == 'market') {
            order['quantity'] = amount;
            method += 'Market';
        } else {
            order['price'] = price;
            order['amount'] = amount;
        }
        return this[method] (this.extend (order, params));
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostIdCancelOrder ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        // curl -k -u '[User ID]/[API key]:[Passphrase]' https://webapi.coinfloor.co.uk:8090/bist/XBT/GBP/balance/
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let auth = this.uid + '/' + this.apiKey + ':' + this.password;
            let signature = this.stringToBase64 (auth);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': 'Basic ' + signature,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],45:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coingi extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coingi',
            'name': 'Coingi',
            'rateLimit': 1000,
            'countries': [ 'PA', 'BG', 'CN', 'US' ], // Panama, Bulgaria, China, US
            'hasFetchTickers': true,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28619707-5c9232a8-7212-11e7-86d6-98fe5d15cc6e.jpg',
                'api': {
                    'www': 'https://coingi.com',
                    'current': 'https://api.coingi.com',
                    'user': 'https://api.coingi.com',
                },
                'www': 'https://coingi.com',
                'doc': 'http://docs.coingi.apiary.io/',
            },
            'api': {
                'www': {
                    'get': [
                        '',
                    ],
                },
                'current': {
                    'get': [
                        'order-book/{pair}/{askCount}/{bidCount}/{depth}',
                        'transactions/{pair}/{maxCount}',
                        '24hour-rolling-aggregation',
                    ],
                },
                'user': {
                    'post': [
                        'balance',
                        'add-order',
                        'cancel-order',
                        'orders',
                        'transactions',
                        'create-crypto-withdrawal',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'taker': 0.2 / 100,
                    'maker': 0.2 / 100,
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.001,
                        'LTC': 0.01,
                        'DOGE': 2,
                        'PPC': 0.02,
                        'VTC': 0.2,
                        'NMC': 2,
                        'DASH': 0.002,
                        'USD': 10,
                        'EUR': 10,
                    },
                    'deposit': {
                        'BTC': 0,
                        'LTC': 0,
                        'DOGE': 0,
                        'PPC': 0,
                        'VTC': 0,
                        'NMC': 0,
                        'DASH': 0,
                        'USD': 5,
                        'EUR': 1,
                    },
                },
            },
        });
    }

    async fetchMarkets () {
        this.parseJsonResponse = false;
        let response = await this.wwwGet ();
        this.parseJsonResponse = true;
        let parts = response.split ('do=currencyPairSelector-selectCurrencyPair" class="active">');
        let currencyParts = parts[1].split ('<div class="currency-pair-label">');
        let result = [];
        for (let i = 1; i < currencyParts.length; i++) {
            let currencyPart = currencyParts[i];
            let idParts = currencyPart.split ('</div>');
            let id = idParts[0];
            let symbol = id;
            id = id.replace ('/', '-');
            id = id.toLowerCase ();
            let [ base, quote ] = symbol.split ('/');
            let precision = {
                'amount': 8,
                'price': 8,
            };
            let lot = Math.pow (10, -precision['amount']);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': id,
                'lot': lot,
                'active': true,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': 0,
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let lowercaseCurrencies = [];
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            lowercaseCurrencies.push (currency.toLowerCase ());
        }
        let balances = await this.userPostBalance ({
            'currencies': lowercaseCurrencies.join (',')
        });
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency']['name'];
            currency = currency.toUpperCase ();
            let account = {
                'free': balance['available'],
                'used': balance['blocked'] + balance['inOrders'] + balance['withdrawing'],
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.currentGetOrderBookPairAskCountBidCountDepth (this.extend ({
            'pair': market['id'],
            'askCount': 512, // maximum returned number of asks 1-512
            'bidCount': 512, // maximum returned number of bids 1-512
            'depth': 32, // maximum number of depth range steps 1-32
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'baseAmount');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': ticker['highestBid'],
            'ask': ticker['lowestAsk'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': ticker['baseVolume'],
            'quoteVolume': ticker['counterVolume'],
            'info': ticker,
        };
        return ticker;
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.currentGet24hourRollingAggregation (params);
        let result = {};
        for (let t = 0; t < response.length; t++) {
            let ticker = response[t];
            let base = ticker['currencyPair']['base'].toUpperCase ();
            let quote = ticker['currencyPair']['counter'].toUpperCase ();
            let symbol = base + '/' + quote;
            let market = undefined;
            if (symbol in this.markets) {
                market = this.markets[symbol];
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.fetchTickers (undefined, params);
        if (symbol in tickers)
            return tickers[symbol];
        throw new ExchangeError (this.id + ' return did not contain ' + symbol);
    }

    parseTrade (trade, market = undefined) {
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined, // type
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.currentGetTransactionsPairMaxCount (this.extend ({
            'pair': market['id'],
            'maxCount': 128,
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'currencyPair': this.marketId (symbol),
            'volume': amount,
            'price': price,
            'orderType': (side == 'buy') ? 0 : 1,
        };
        let response = await this.userPostAddOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['result'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.userPostCancelOrder ({ 'orderId': id });
    }

    sign (path, api = 'current', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api != 'www') {
            url += '/' + api + '/' + this.implodeParams (path, params);
        }
        let query = this.omit (params, this.extractParams (path));
        if (api == 'current') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else if (api == 'user') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let request = this.extend ({
                'token': this.apiKey,
                'nonce': nonce,
            }, query);
            let auth = nonce.toString () + '$' + this.apiKey;
            request['signature'] = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.json (request);
            headers = {
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'current', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (typeof response != 'string') {
            if ('errors' in response)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],46:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinmarketcap extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinmarketcap',
            'name': 'CoinMarketCap',
            'rateLimit': 10000,
            'version': 'v1',
            'countries': 'US',
            'hasCORS': true,
            'hasPrivateAPI': false,
            'hasCreateOrder': false,
            'hasCancelOrder': false,
            'hasFetchBalance': false,
            'hasFetchOrderBook': false,
            'hasFetchTrades': false,
            'hasFetchTickers': true,
            'hasFetchCurrencies': true,
            'has': {
                'fetchCurrencies': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28244244-9be6312a-69ed-11e7-99c1-7c1797275265.jpg',
                'api': 'https://api.coinmarketcap.com',
                'www': 'https://coinmarketcap.com',
                'doc': 'https://coinmarketcap.com/api',
            },
            'requiredCredentials': {
                'apiKey': false,
                'secret': false,
            },
            'api': {
                'public': {
                    'get': [
                        'ticker/',
                        'ticker/{id}/',
                        'global/',
                    ],
                },
            },
            'currencyCodes': [
                'AUD',
                'BRL',
                'CAD',
                'CHF',
                'CNY',
                'EUR',
                'GBP',
                'HKD',
                'IDR',
                'INR',
                'JPY',
                'KRW',
                'MXN',
                'RUB',
                'USD',
            ],
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        throw new ExchangeError ('Fetching order books is not supported by the API of ' + this.id);
    }

    async fetchMarkets () {
        let markets = await this.publicGetTicker ({
            'limit': 0,
        });
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let currencies = this.currencyCodes;
            for (let i = 0; i < currencies.length; i++) {
                let quote = currencies[i];
                let quoteId = quote.toLowerCase ();
                let base = market['symbol'];
                let baseId = market['id'];
                let symbol = base + '/' + quote;
                let id = baseId + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                });
            }
        }
        return result;
    }

    async fetchGlobal (currency = 'USD') {
        await this.loadMarkets ();
        let request = {};
        if (currency)
            request['convert'] = currency;
        return await this.publicGetGlobal (request);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        if ('last_updated' in ticker)
            if (ticker['last_updated'])
                timestamp = parseInt (ticker['last_updated']) * 1000;
        let change = undefined;
        let changeKey = 'percent_change_24h';
        if (changeKey in ticker)
            change = parseFloat (ticker[changeKey]);
        let last = undefined;
        let symbol = undefined;
        let volume = undefined;
        if (market) {
            let price = 'price_' + market['quoteId'];
            if (price in ticker)
                if (ticker[price])
                    last = parseFloat (ticker[price]);
            symbol = market['symbol'];
            let volumeKey = '24h_volume_' + market['quoteId'];
            if (volumeKey in ticker)
                volume = parseFloat (ticker[volumeKey]);
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': change,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': volume,
            'info': ticker,
        };
    }

    async fetchTickers (currency = 'USD', params = {}) {
        await this.loadMarkets ();
        let request = {
            'limit': 10000,
        };
        if (currency)
            request['convert'] = currency;
        let response = await this.publicGetTicker (this.extend (request, params));
        let tickers = {};
        for (let t = 0; t < response.length; t++) {
            let ticker = response[t];
            let id = ticker['id'] + '/' + currency;
            let symbol = id;
            let market = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
            tickers[symbol] = this.parseTicker (ticker, market);
        }
        return tickers;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = this.extend ({
            'convert': market['quote'],
            'id': market['baseId'],
        }, params);
        let response = await this.publicGetTickerId (request);
        let ticker = response[0];
        return this.parseTicker (ticker, market);
    }

    async fetchCurrencies (params = {}) {
        let currencies = await this.publicGetTicker (this.extend ({
            'limit': 0
        }, params));
        let result = {};
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let id = currency['symbol'];
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            let precision = {
                'amount': 8, // default precision, todo: fix "magic constants"
                'price': 8,
            };
            let code = this.commonCurrencyCode (id);
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': currency['name'],
                'active': true,
                'status': 'ok',
                'fee': undefined, // todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision['amount']),
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            };
        }
        return result;
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (Object.keys (query).length)
            url += '?' + this.urlencode (query);
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response) {
            if (response['error']) {
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],47:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinmate extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinmate',
            'name': 'CoinMate',
            'countries': [ 'GB', 'CZ' ], // UK, Czech Republic
            'rateLimit': 1000,
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27811229-c1efb510-606c-11e7-9a36-84ba2ce412d8.jpg',
                'api': 'https://coinmate.io/api',
                'www': 'https://coinmate.io',
                'doc': [
                    'http://docs.coinmate.apiary.io',
                    'https://coinmate.io/developers',
                ],
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'orderBook',
                        'ticker',
                        'transactions',
                    ],
                },
                'private': {
                    'post': [
                        'balances',
                        'bitcoinWithdrawal',
                        'bitcoinDepositAddresses',
                        'buyInstant',
                        'buyLimit',
                        'cancelOrder',
                        'cancelOrderWithInfo',
                        'createVoucher',
                        'openOrders',
                        'redeemVoucher',
                        'sellInstant',
                        'sellLimit',
                        'transactionHistory',
                        'unconfirmedBitcoinDeposits',
                    ],
                },
            },
            'markets': {
                'BTC/EUR': { 'id': 'BTC_EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'precision': { 'amount': 4, 'price': 2 }},
                'BTC/CZK': { 'id': 'BTC_CZK', 'symbol': 'BTC/CZK', 'base': 'BTC', 'quote': 'CZK', 'precision': { 'amount': 4, 'price': 2 }},
                'LTC/BTC': { 'id': 'LTC_BTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'precision': { 'amount': 4, 'price': 5 }},
            },
            'fees': {
                'trading': {
                    'maker': 0.0005,
                    'taker': 0.0035,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalances ();
        let balances = response['data'];
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balances) {
                account['free'] = balances[currency]['available'];
                account['used'] = balances[currency]['reserved'];
                account['total'] = balances[currency]['balance'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetOrderBook (this.extend ({
            'currencyPair': this.marketId (symbol),
            'groupByPriceLimit': 'False',
        }, params));
        let orderbook = response['data'];
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetTicker (this.extend ({
            'currencyPair': this.marketId (symbol),
        }, params));
        let ticker = response['data'];
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['amount']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'id': trade['transactionId'],
            'info': trade,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'currencyPair': market['id'],
            'minutesIntoHistory': 10,
        }, params));
        return this.parseTrades (response['data'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'currencyPair': this.marketId (symbol),
        };
        if (type == 'market') {
            if (side == 'buy')
                order['total'] = amount; // amount in fiat
            else
                order['amount'] = amount; // amount in fiat
            method += 'Instant';
        } else {
            order['amount'] = amount; // amount in crypto
            order['price'] = price;
            method += this.capitalize (type);
        }
        let response = await this[method] (self.extend (order, params));
        return {
            'info': response,
            'id': response['data'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder ({ 'orderId': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.urlencode (this.extend ({
                'clientId': this.uid,
                'nonce': nonce,
                'publicKey': this.apiKey,
                'signature': signature.toUpperCase (),
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],48:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinsecure extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinsecure',
            'name': 'Coinsecure',
            'countries': 'IN', // India
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766472-9cbd200a-5ed9-11e7-9551-2267ad7bac08.jpg',
                'api': 'https://api.coinsecure.in',
                'www': 'https://coinsecure.in',
                'doc': [
                    'https://api.coinsecure.in',
                    'https://github.com/coinsecure/plugins',
                ],
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': false,
            },
            'api': {
                'public': {
                    'get': [
                        'bitcoin/search/confirmation/{txid}',
                        'exchange/ask/low',
                        'exchange/ask/orders',
                        'exchange/bid/high',
                        'exchange/bid/orders',
                        'exchange/lastTrade',
                        'exchange/max24Hr',
                        'exchange/min24Hr',
                        'exchange/ticker',
                        'exchange/trades',
                    ],
                },
                'private': {
                    'get': [
                        'mfa/authy/call',
                        'mfa/authy/sms',
                        'netki/search/{netkiName}',
                        'user/bank/otp/{number}',
                        'user/kyc/otp/{number}',
                        'user/profile/phone/otp/{number}',
                        'user/wallet/coin/address/{id}',
                        'user/wallet/coin/deposit/confirmed/all',
                        'user/wallet/coin/deposit/confirmed/{id}',
                        'user/wallet/coin/deposit/unconfirmed/all',
                        'user/wallet/coin/deposit/unconfirmed/{id}',
                        'user/wallet/coin/wallets',
                        'user/exchange/bank/fiat/accounts',
                        'user/exchange/bank/fiat/balance/available',
                        'user/exchange/bank/fiat/balance/pending',
                        'user/exchange/bank/fiat/balance/total',
                        'user/exchange/bank/fiat/deposit/cancelled',
                        'user/exchange/bank/fiat/deposit/unverified',
                        'user/exchange/bank/fiat/deposit/verified',
                        'user/exchange/bank/fiat/withdraw/cancelled',
                        'user/exchange/bank/fiat/withdraw/completed',
                        'user/exchange/bank/fiat/withdraw/unverified',
                        'user/exchange/bank/fiat/withdraw/verified',
                        'user/exchange/ask/cancelled',
                        'user/exchange/ask/completed',
                        'user/exchange/ask/pending',
                        'user/exchange/bid/cancelled',
                        'user/exchange/bid/completed',
                        'user/exchange/bid/pending',
                        'user/exchange/bank/coin/addresses',
                        'user/exchange/bank/coin/balance/available',
                        'user/exchange/bank/coin/balance/pending',
                        'user/exchange/bank/coin/balance/total',
                        'user/exchange/bank/coin/deposit/cancelled',
                        'user/exchange/bank/coin/deposit/unverified',
                        'user/exchange/bank/coin/deposit/verified',
                        'user/exchange/bank/coin/withdraw/cancelled',
                        'user/exchange/bank/coin/withdraw/completed',
                        'user/exchange/bank/coin/withdraw/unverified',
                        'user/exchange/bank/coin/withdraw/verified',
                        'user/exchange/bank/summary',
                        'user/exchange/coin/fee',
                        'user/exchange/fiat/fee',
                        'user/exchange/kycs',
                        'user/exchange/referral/coin/paid',
                        'user/exchange/referral/coin/successful',
                        'user/exchange/referral/fiat/paid',
                        'user/exchange/referrals',
                        'user/exchange/trade/summary',
                        'user/login/token/{token}',
                        'user/summary',
                        'user/wallet/summary',
                        'wallet/coin/withdraw/cancelled',
                        'wallet/coin/withdraw/completed',
                        'wallet/coin/withdraw/unverified',
                        'wallet/coin/withdraw/verified',
                    ],
                    'post': [
                        'login',
                        'login/initiate',
                        'login/password/forgot',
                        'mfa/authy/initiate',
                        'mfa/ga/initiate',
                        'signup',
                        'user/netki/update',
                        'user/profile/image/update',
                        'user/exchange/bank/coin/withdraw/initiate',
                        'user/exchange/bank/coin/withdraw/newVerifycode',
                        'user/exchange/bank/fiat/withdraw/initiate',
                        'user/exchange/bank/fiat/withdraw/newVerifycode',
                        'user/password/change',
                        'user/password/reset',
                        'user/wallet/coin/withdraw/initiate',
                        'wallet/coin/withdraw/newVerifycode',
                    ],
                    'put': [
                        'signup/verify/{token}',
                        'user/exchange/kyc',
                        'user/exchange/bank/fiat/deposit/new',
                        'user/exchange/ask/new',
                        'user/exchange/bid/new',
                        'user/exchange/instant/buy',
                        'user/exchange/instant/sell',
                        'user/exchange/bank/coin/withdraw/verify',
                        'user/exchange/bank/fiat/account/new',
                        'user/exchange/bank/fiat/withdraw/verify',
                        'user/mfa/authy/initiate/enable',
                        'user/mfa/ga/initiate/enable',
                        'user/netki/create',
                        'user/profile/phone/new',
                        'user/wallet/coin/address/new',
                        'user/wallet/coin/new',
                        'user/wallet/coin/withdraw/sendToExchange',
                        'user/wallet/coin/withdraw/verify',
                    ],
                    'delete': [
                        'user/gcm/{code}',
                        'user/logout',
                        'user/exchange/bank/coin/withdraw/unverified/cancel/{withdrawID}',
                        'user/exchange/bank/fiat/deposit/cancel/{depositID}',
                        'user/exchange/ask/cancel/{orderID}',
                        'user/exchange/bid/cancel/{orderID}',
                        'user/exchange/bank/fiat/withdraw/unverified/cancel/{withdrawID}',
                        'user/mfa/authy/disable/{code}',
                        'user/mfa/ga/disable/{code}',
                        'user/profile/phone/delete',
                        'user/profile/image/delete/{netkiName}',
                        'user/wallet/coin/withdraw/unverified/cancel/{withdrawID}',
                    ],
                },
            },
            'markets': {
                'BTC/INR': { 'id': 'BTC/INR', 'symbol': 'BTC/INR', 'base': 'BTC', 'quote': 'INR' },
            },
            'fees': {
                'trading': {
                    'maker': 0.4 / 100,
                    'taker': 0.4 / 100,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privateGetUserExchangeBankSummary ();
        let balance = response['message'];
        let coin = {
            'free': balance['availableCoinBalance'],
            'used': balance['pendingCoinBalance'],
            'total': balance['totalCoinBalance'],
        };
        let fiat = {
            'free': balance['availableFiatBalance'],
            'used': balance['pendingFiatBalance'],
            'total': balance['totalFiatBalance'],
        };
        let result = {
            'info': balance,
            'BTC': coin,
            'INR': fiat,
        };
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let bids = await this.publicGetExchangeBidOrders (params);
        let asks = await this.publicGetExchangeAskOrders (params);
        let orderbook = {
            'bids': bids['message'],
            'asks': asks['message'],
        };
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'rate', 'vol');
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetExchangeTicker (params);
        let ticker = response['message'];
        let timestamp = ticker['timestamp'];
        let baseVolume = parseFloat (ticker['coinvolume']);
        if (symbol == 'BTC/INR') {
            let satoshi = 0.00000001;
            baseVolume = baseVolume * satoshi;
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': parseFloat (ticker['fiatvolume']),
            'info': ticker,
        };
    }

    fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        return this.publicGetExchangeTrades (params);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePutUserExchange';
        let order = {};
        if (type == 'market') {
            method += 'Instant' + this.capitalize (side);
            if (side == 'buy')
                order['maxFiat'] = amount;
            else
                order['maxVol'] = amount;
        } else {
            let direction = (side == 'buy') ? 'Bid' : 'Ask';
            method += direction + 'New';
            order['rate'] = price;
            order['vol'] = amount;
        }
        let response = await this[method] (self.extend (order, params));
        return {
            'info': response,
            'id': response['message']['orderID'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        throw new ExchangeError (this.id + ' cancelOrder () is not fully implemented yet');
        let method = 'privateDeleteUserExchangeAskCancelOrderId'; // TODO fixme, have to specify order side here
        return await this[method] ({ 'orderID': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            headers = { 'Authorization': this.apiKey };
            if (Object.keys (query).length) {
                body = this.json (query);
                headers['Content-Type'] = 'application/json';
            }
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],49:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class coinspot extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'coinspot',
            'name': 'CoinSpot',
            'countries': 'AU', // Australia
            'rateLimit': 1000,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg',
                'api': {
                    'public': 'https://www.coinspot.com.au/pubapi',
                    'private': 'https://www.coinspot.com.au/api',
                },
                'www': 'https://www.coinspot.com.au',
                'doc': 'https://www.coinspot.com.au/api',
            },
            'api': {
                'public': {
                    'get': [
                        'latest',
                    ],
                },
                'private': {
                    'post': [
                        'orders',
                        'orders/history',
                        'my/coin/deposit',
                        'my/coin/send',
                        'quote/buy',
                        'quote/sell',
                        'my/balances',
                        'my/orders',
                        'my/buy',
                        'my/sell',
                        'my/buy/cancel',
                        'my/sell/cancel',
                    ],
                },
            },
            'markets': {
                'BTC/AUD': { 'id': 'BTC', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
                'LTC/AUD': { 'id': 'LTC', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD' },
                'DOGE/AUD': { 'id': 'DOGE', 'symbol': 'DOGE/AUD', 'base': 'DOGE', 'quote': 'AUD' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostMyBalances ();
        let result = { 'info': response };
        if ('balance' in response) {
            let balances = response['balance'];
            let currencies = Object.keys (balances);
            for (let c = 0; c < currencies.length; c++) {
                let currency = currencies[c];
                let uppercase = currency.toUpperCase ();
                let account = {
                    'free': balances[currency],
                    'used': 0.0,
                    'total': balances[currency],
                };
                if (uppercase == 'DRK')
                    uppercase = 'DASH';
                result[uppercase] = account;
            }
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.privatePostOrders (this.extend ({
            'cointype': market['id'],
        }, params));
        let result = this.parseOrderBook (orderbook, undefined, 'buyorders', 'sellorders', 'rate', 'amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetLatest (params);
        let id = this.marketId (symbol);
        id = id.toLowerCase ();
        let ticker = response['prices'][id];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        return this.privatePostOrdersHistory (this.extend ({
            'cointype': this.marketId (symbol),
        }, params));
    }

    createOrder (market, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePostMy' + this.capitalize (side);
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let order = {
            'cointype': this.marketId (market),
            'amount': amount,
            'rate': price,
        };
        return this[method] (this.extend (order, params));
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        throw new ExchangeError (this.id + ' cancelOrder () is not fully implemented yet');
        let method = 'privatePostMyBuy';
        return await this[method] ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (!this.apiKey)
            throw new AuthenticationError (this.id + ' requires apiKey for all requests');
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.json (this.extend ({ 'nonce': nonce }, params));
            headers = {
                'Content-Type': 'application/json',
                'key': this.apiKey,
                'sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}
},{"./base/Exchange":8,"./base/errors":10}],50:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, OrderNotFound, OrderNotCached } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class cryptopia extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'cryptopia',
            'name': 'Cryptopia',
            'rateLimit': 1500,
            'countries': 'NZ', // New Zealand
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchMyTrades': true,
            'hasFetchCurrencies': true,
            'hasDeposit': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchTickers': true,
                'fetchOrder': 'emulated',
                'fetchOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchMyTrades': true,
                'fetchCurrencies': true,
                'deposit': true,
                'withdraw': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/29484394-7b4ea6e2-84c6-11e7-83e5-1fccf4b2dc81.jpg',
                'api': 'https://www.cryptopia.co.nz/api',
                'www': 'https://www.cryptopia.co.nz',
                'doc': [
                    'https://www.cryptopia.co.nz/Forum/Category/45',
                    'https://www.cryptopia.co.nz/Forum/Thread/255',
                    'https://www.cryptopia.co.nz/Forum/Thread/256',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'GetCurrencies',
                        'GetTradePairs',
                        'GetMarkets',
                        'GetMarkets/{id}',
                        'GetMarkets/{hours}',
                        'GetMarkets/{id}/{hours}',
                        'GetMarket/{id}',
                        'GetMarket/{id}/{hours}',
                        'GetMarketHistory/{id}',
                        'GetMarketHistory/{id}/{hours}',
                        'GetMarketOrders/{id}',
                        'GetMarketOrders/{id}/{count}',
                        'GetMarketOrderGroups/{ids}/{count}',
                    ],
                },
                'private': {
                    'post': [
                        'CancelTrade',
                        'GetBalance',
                        'GetDepositAddress',
                        'GetOpenOrders',
                        'GetTradeHistory',
                        'GetTransactions',
                        'SubmitTip',
                        'SubmitTrade',
                        'SubmitTransfer',
                        'SubmitWithdraw',
                    ],
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (currency == 'CC')
            return 'CCX';
        if (currency == 'FCN')
            return 'Facilecoin';
        if (currency == 'NET')
            return 'NetCoin';
        if (currency == 'BTG')
            return 'Bitgem';
        return currency;
    }

    currencyId (currency) {
        if (currency == 'CCX')
            return 'CC';
        if (currency == 'Facilecoin')
            return 'FCN';
        if (currency == 'NetCoin')
            return 'NET';
        if (currency == 'Bitgem')
            return 'BTG';
        return currency;
    }

    async fetchMarkets () {
        let response = await this.publicGetTradePairs ();
        let result = [];
        let markets = response['Data'];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['Id'];
            let symbol = market['Label'];
            let [ base, quote ] = symbol.split ('/');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            symbol = base + '/' + quote;
            let precision = {
                'amount': 8,
                'price': 8,
            };
            let amountLimits = {
                'min': market['MinimumTrade'],
                'max': market['MaximumTrade']
            };
            let priceLimits = {
                'min': market['MinimumPrice'],
                'max': market['MaximumPrice'],
            };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
            };
            let active = market['Status'] == 'OK';
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'maker': market['TradeFee'] / 100,
                'taker': market['TradeFee'] / 100,
                'lot': amountLimits['min'],
                'active': active,
                'precision': precision,
                'limits': limits,
            });
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarketOrdersId (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let orderbook = response['Data'];
        return this.parseOrderBook (orderbook, undefined, 'Buy', 'Sell', 'Price', 'Volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'info': ticker,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['High']),
            'low': parseFloat (ticker['Low']),
            'bid': parseFloat (ticker['BidPrice']),
            'ask': parseFloat (ticker['AskPrice']),
            'vwap': undefined,
            'open': parseFloat (ticker['Open']),
            'close': parseFloat (ticker['Close']),
            'first': undefined,
            'last': parseFloat (ticker['LastPrice']),
            'change': parseFloat (ticker['Change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['Volume']),
            'quoteVolume': parseFloat (ticker['BaseVolume']),
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketId (this.extend ({
            'id': market['id'],
        }, params));
        let ticker = response['Data'];
        return this.parseTicker (ticker, market);
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarkets (params);
        let result = {};
        let tickers = response['Data'];
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker['TradePairId'];
            let recognized = (id in this.markets_by_id);
            if (!recognized)
                throw new ExchangeError (this.id + ' fetchTickers() returned unrecognized pair id ' + id);
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        if ('Timestamp' in trade) {
            timestamp = trade['Timestamp'] * 1000;
        } else if ('TimeStamp' in trade) {
            timestamp = this.parse8601 (trade['TimeStamp']);
        }
        let price = this.safeFloat (trade, 'Price');
        if (!price)
            price = this.safeFloat (trade, 'Rate');
        let cost = this.safeFloat (trade, 'Total');
        let id = this.safeString (trade, 'TradeId');
        if (!market) {
            if ('TradePairId' in trade)
                if (trade['TradePairId'] in this.markets_by_id)
                    market = this.markets_by_id[trade['TradePairId']];
        }
        let symbol = undefined;
        let fee = undefined;
        if (market) {
            symbol = market['symbol'];
            if ('Fee' in trade) {
                fee = {
                    'currency': market['quote'],
                    'cost': trade['Fee'],
                };
            }
        }
        return {
            'id': id,
            'info': trade,
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': 'limit',
            'side': trade['Type'].toLowerCase (),
            'price': price,
            'cost': cost,
            'amount': trade['Amount'],
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketHistoryIdHours (this.extend ({
            'id': market['id'],
            'hours': 24, // default
        }, params));
        let trades = response['Data'];
        return this.parseTrades (trades, market, since, limit);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchMyTrades requires a symbol');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privatePostGetTradeHistory (this.extend ({
            // 'Market': market['id'],
            'TradePairId': market['id'], // Cryptopia identifier (not required if 'Market' supplied)
            // 'Count': 10, // max = 100
        }, params));
        return this.parseTrades (response['Data'], market, since, limit);
    }

    async fetchCurrencies (params = {}) {
        let response = await this.publicGetCurrencies (params);
        let currencies = response['Data'];
        let result = {};
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let id = currency['Symbol'];
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            let precision = {
                'amount': 8, // default precision, todo: fix "magic constants"
                'price': 8,
            };
            let code = this.commonCurrencyCode (id);
            let active = (currency['ListingStatus'] == 'Active');
            let status = currency['Status'].toLowerCase ();
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': currency['Name'],
                'active': active,
                'status': status,
                'fee': currency['WithdrawFee'],
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': currency['MinBaseTrade'],
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': currency['MinWithdraw'],
                        'max': currency['MaxWithdraw'],
                    },
                },
            };
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetBalance ();
        let balances = response['Data'];
        let result = { 'info': response };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let code = balance['Symbol'];
            let currency = this.commonCurrencyCode (code);
            let account = {
                'free': balance['Available'],
                'used': 0.0,
                'total': balance['Total'],
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        price = parseFloat (price);
        amount = parseFloat (amount);
        let request = {
            'TradePairId': market['id'],
            'Type': this.capitalize (side),
            'Rate': this.priceToPrecision (symbol, price),
            'Amount': this.amountToPrecision (symbol, amount),
        };
        let response = await this.privatePostSubmitTrade (this.extend (request, params));
        if (!response)
            throw new ExchangeError (this.id + ' createOrder returned unknown error: ' + this.json (response));
        let id = undefined;
        let filled = 0.0;
        if ('Data' in response) {
            if ('OrderId' in response['Data']) {
                if (response['Data']['OrderId']) {
                    id = response['Data']['OrderId'].toString ();
                }
            }
            if ('FilledOrders' in response['Data']) {
                let filledOrders = response['Data']['FilledOrders'];
                let filledOrdersLength = filledOrders.length;
                if (filledOrdersLength) {
                    filled = undefined;
                }
            }
        }
        let timestamp = this.milliseconds ();
        let order = {
            'id': id,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'remaining': amount,
            'filled': filled,
            'fee': undefined,
            // 'trades': this.parseTrades (order['trades'], market),
        };
        if (id)
            this.orders[id] = order;
        return this.extend ({ 'info': response }, order);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.privatePostCancelTrade (this.extend ({
                'Type': 'Trade',
                'OrderId': id,
            }, params));
            if (id in this.orders)
                this.orders[id]['status'] = 'canceled';
        } catch (e) {
            if (this.last_json_response) {
                let message = this.safeString (this.last_json_response, 'Error');
                if (message) {
                    if (message.indexOf ('does not exist') >= 0)
                        throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
                }
            }
            throw e;
        }
        return response;
    }

    parseOrder (order, market = undefined) {
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else if ('Market' in order) {
            let id = order['Market'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
        }
        let timestamp = this.parse8601 (order['TimeStamp']);
        let amount = this.safeFloat (order, 'Amount');
        let remaining = this.safeFloat (order, 'Remaining');
        let filled = amount - remaining;
        return {
            'id': order['OrderId'].toString (),
            'info': this.omit (order, 'status'),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': order['status'],
            'symbol': symbol,
            'type': 'limit',
            'side': order['Type'].toLowerCase (),
            'price': this.safeFloat (order, 'Rate'),
            'cost': this.safeFloat (order, 'Total'),
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': undefined,
            // 'trades': this.parseTrades (order['trades'], market),
        };
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrders requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privatePostGetOpenOrders ({
            // 'Market': market['id'],
            'TradePairId': market['id'], // Cryptopia identifier (not required if 'Market' supplied)
            // 'Count': 100, // default = 100
        }, params);
        let orders = [];
        for (let i = 0; i < response['Data'].length; i++) {
            orders.push (this.extend (response['Data'][i], { 'status': 'open' }));
        }
        let openOrders = this.parseOrders (orders, market);
        for (let j = 0; j < openOrders.length; j++) {
            this.orders[openOrders[j]['id']] = openOrders[j];
        }
        let openOrdersIndexedById = this.indexBy (openOrders, 'id');
        let cachedOrderIds = Object.keys (this.orders);
        let result = [];
        for (let k = 0; k < cachedOrderIds.length; k++) {
            let id = cachedOrderIds[k];
            if (id in openOrdersIndexedById) {
                this.orders[id] = this.extend (this.orders[id], openOrdersIndexedById[id]);
            } else {
                let order = this.orders[id];
                if (order['status'] == 'open') {
                    this.orders[id] = this.extend (order, {
                        'status': 'closed',
                        'cost': order['amount'] * order['price'],
                        'filled': order['amount'],
                        'remaining': 0.0,
                    });
                }
            }
            let order = this.orders[id];
            if (order['symbol'] == symbol)
                result.push (order);
        }
        return this.filterBySinceLimit (result, since, limit);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        id = id.toString ();
        let orders = await this.fetchOrders (symbol, params);
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['id'] == id)
                return orders[i];
        }
        throw new OrderNotCached (this.id + ' order ' + id + ' not found in cached .orders, fetchOrder requires .orders (de)serialization implemented for this method to work properly');
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == 'open')
                result.push (orders[i]);
        }
        return result;
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == 'closed')
                result.push (orders[i]);
        }
        return result;
    }

    async fetchDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privatePostGetDepositAddress (this.extend ({
            'Currency': currencyId
        }, params));
        let address = this.safeString (response['Data'], 'BaseAddress');
        if (!address)
            address = this.safeString (response['Data'], 'Address');
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privatePostSubmitWithdraw (this.extend ({
            'Currency': currencyId,
            'Amount': amount,
            'Address': address, // Address must exist in you AddressBook in security settings
        }, params));
        return {
            'info': response,
            'id': response['Data'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.json (query);
            let hash = this.hash (this.encode (body), 'md5', 'base64');
            let secret = this.base64ToBinary (this.secret);
            let uri = this.encodeURIComponent (url);
            let lowercase = uri.toLowerCase ();
            let payload = this.apiKey + method + lowercase + nonce + this.binaryToString (hash);
            let signature = this.hmac (this.encode (payload), secret, 'sha256', 'base64');
            let auth = 'amx ' + this.apiKey + ':' + this.binaryToString (signature) + ':' + nonce;
            headers = {
                'Content-Type': 'application/json',
                'Authorization': auth,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (response) {
            if ('Success' in response)
                if (response['Success']) {
                    return response;
                } else if ('Error' in response) {
                    if (response['Error'] == 'Insufficient Funds.')
                        throw new InsufficientFunds (this.id + ' ' + this.json (response));
                }
        }
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],51:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const liqui = require ('./liqui.js')

// ---------------------------------------------------------------------------

module.exports = class dsx extends liqui {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'dsx',
            'name': 'DSX',
            'countries': 'UK',
            'rateLimit': 1500,
            'hasCORS': false,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchTickers': true,
            'hasFetchMyTrades': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27990275-1413158a-645a-11e7-931c-94717f7510e3.jpg',
                'api': {
                    'public': 'https://dsx.uk/mapi', // market data
                    'private': 'https://dsx.uk/tapi', // trading
                    'dwapi': 'https://dsx.uk/dwapi', // deposit/withdraw
                },
                'www': 'https://dsx.uk',
                'doc': [
                    'https://api.dsx.uk',
                    'https://dsx.uk/api_docs/public',
                    'https://dsx.uk/api_docs/private',
                    '',
                ],
            },
            'api': {
                // market data (public)
                'public': {
                    'get': [
                        'barsFromMoment/{id}/{period}/{start}', // empty reply :\
                        'depth/{pair}',
                        'info',
                        'lastBars/{id}/{period}/{amount}', // period is (m, h or d)
                        'periodBars/{id}/{period}/{start}/{end}',
                        'ticker/{pair}',
                        'trades/{pair}',
                    ],
                },
                // trading (private)
                'private': {
                    'post': [
                        'getInfo',
                        'TransHistory',
                        'TradeHistory',
                        'OrderHistory',
                        'ActiveOrders',
                        'Trade',
                        'CancelOrder',
                    ],
                },
                // deposit / withdraw (private)
                'dwapi': {
                    'post': [
                        'getCryptoDepositAddress',
                        'cryptoWithdraw',
                        'fiatWithdraw',
                        'getTransactionStatus',
                        'getTransactions',
                    ],
                },
            },
        });
    }

    getBaseQuoteFromMarketId (id) {
        let uppercase = id.toUpperCase ();
        let base = uppercase.slice (0, 3);
        let quote = uppercase.slice (3, 6);
        base = this.commonCurrencyCode (base);
        quote = this.commonCurrencyCode (quote);
        return [ base, quote ];
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let funds = balances['funds'];
        let currencies = Object.keys (funds);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let uppercase = currency.toUpperCase ();
            uppercase = this.commonCurrencyCode (uppercase);
            let account = {
                'free': funds[currency],
                'used': 0.0,
                'total': balances['total'][currency],
            };
            account['used'] = account['total'] - account['free'];
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': 1 / this.safeFloat (ticker, 'avg'),
            'baseVolume': this.safeFloat (ticker, 'vol'),
            'quoteVolume': this.safeFloat (ticker, 'vol_cur'),
            'info': ticker,
        };
    }

    getOrderIdKey () {
        return 'orderId';
    }

    signBodyWithSecret (body) {
        return this.decode (this.hmac (this.encode (body), this.encode (this.secret), 'sha512', 'base64'));
    }

    getVersionString () {
        return ''; // they don't prepend version number to public URLs as other BTC-e clones do
    }
}

},{"./liqui.js":74}],52:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class exmo extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'exmo',
            'name': 'EXMO',
            'countries': [ 'ES', 'RU' ], // Spain, Russia
            'rateLimit': 1000, // once every 350 ms ≈ 180 requests per minute ≈ 3 requests per second
            'version': 'v1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg',
                'api': 'https://api.exmo.com',
                'www': 'https://exmo.me',
                'doc': [
                    'https://exmo.me/en/api_doc',
                    'https://github.com/exmo-dev/exmo_api_lib/tree/master/nodejs',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'currency',
                        'order_book',
                        'pair_settings',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'user_info',
                        'order_create',
                        'order_cancel',
                        'user_open_orders',
                        'user_trades',
                        'user_cancelled_orders',
                        'order_trades',
                        'required_amount',
                        'deposit_address',
                        'withdraw_crypt',
                        'withdraw_get_txid',
                        'excode_create',
                        'excode_load',
                        'wallet_history',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.2 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetPairSettings ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let symbol = id.replace ('_', '/');
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'limits': {
                    'amount': {
                        'min': market['min_quantity'],
                        'max': market['max_quantity'],
                    },
                    'price': {
                        'min': market['min_price'],
                        'max': market['max_price'],
                    },
                    'cost': {
                        'min': market['min_amount'],
                        'max': market['max_amount'],
                    },
                },
                'precision': {
                    'amount': 8,
                    'price': 8,
                },
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostUserInfo ();
        let result = { 'info': response };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in response['balances'])
                account['free'] = parseFloat (response['balances'][currency]);
            if (currency in response['reserved'])
                account['used'] = parseFloat (response['reserved'][currency]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOrderBook (this.extend ({
            'pair': market['id'],
        }, params));
        let orderbook = response[market['id']];
        return this.parseOrderBook (orderbook, undefined, 'bid', 'ask');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy_price']),
            'ask': parseFloat (ticker['sell_price']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_trade']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']),
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': parseFloat (ticker['vol_curr']),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetTicker (params);
        let result = {};
        let ids = Object.keys (response);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = response[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetTicker (params);
        let market = this.market (symbol);
        return this.parseTicker (response[market['id']], market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['trade_id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['quantity']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response[market['id']], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let prefix = '';
        if (type == 'market')
            prefix = 'market_';
        if (typeof price == 'undefined')
            price = 0;
        let order = {
            'pair': this.marketId (symbol),
            'quantity': amount,
            'price': price,
            'type': prefix + side,
        };
        let response = await this.privatePostOrderCreate (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_id': id });
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let result = await this.privatePostWithdrawCrypt (this.extend ({
            'amount': amount,
            'currency': currency,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': result['task_id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response) {
            if (response['result'])
                return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],53:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class flowbtc extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'flowbtc',
            'name': 'flowBTC',
            'countries': 'BR', // Brazil
            'version': 'v1',
            'rateLimit': 1000,
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28162465-cd815d4c-67cf-11e7-8e57-438bea0523a2.jpg',
                'api': 'https://api.flowbtc.com:8400/ajax',
                'www': 'https://trader.flowbtc.com',
                'doc': 'http://www.flowbtc.com.br/api/',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'post': [
                        'GetTicker',
                        'GetTrades',
                        'GetTradesByDate',
                        'GetOrderBook',
                        'GetProductPairs',
                        'GetProducts',
                    ],
                },
                'private': {
                    'post': [
                        'CreateAccount',
                        'GetUserInfo',
                        'SetUserInfo',
                        'GetAccountInfo',
                        'GetAccountTrades',
                        'GetDepositAddresses',
                        'Withdraw',
                        'CreateOrder',
                        'ModifyOrder',
                        'CancelOrder',
                        'CancelAllOrders',
                        'GetAccountOpenOrders',
                        'GetOrderFee',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicPostGetProductPairs ();
        let markets = response['productPairs'];
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['name'];
            let base = market['product1Label'];
            let quote = market['product2Label'];
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['currencies'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['name'];
            let account = {
                'free': balance['balance'],
                'used': balance['hold'],
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicPostGetOrderBook (this.extend ({
            'productPair': market['id'],
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'px', 'qty');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicPostGetTicker (this.extend ({
            'productPair': market['id'],
        }, params));
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume24hr']),
            'quoteVolume': parseFloat (ticker['volume24hrProduct2']),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['unixtime'] * 1000;
        let side = (trade['incomingOrderSide'] == 0) ? 'buy' : 'sell';
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['px'],
            'amount': trade['qty'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicPostGetTrades (this.extend ({
            'ins': market['id'],
            'startIndex': -1,
        }, params));
        return this.parseTrades (response['trades'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let orderType = (type == 'market') ? 1 : 0;
        let order = {
            'ins': this.marketId (symbol),
            'side': side,
            'orderType': orderType,
            'qty': amount,
            'px': price,
        };
        let response = await this.privatePostCreateOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['serverOrderId'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        if ('ins' in params) {
            return await this.privatePostCancelOrder (this.extend ({
                'serverOrderId': id,
            }, params));
        }
        throw new ExchangeError (this.id + ' requires `ins` symbol parameter for cancelling an order');
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length) {
                body = this.json (params);
            }
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let auth = nonce.toString () + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.json (this.extend ({
                'apiKey': this.apiKey,
                'apiNonce': nonce,
                'apiSig': signature.toUpperCase (),
            }, params));
            headers = {
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('isAccepted' in response)
            if (response['isAccepted'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}
},{"./base/Exchange":8,"./base/errors":10}],54:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class foxbit extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'foxbit',
            'name': 'FoxBit',
            'countries': 'BR',
            'hasCORS': false,
            'rateLimit': 1000,
            'version': 'v1',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991413-11b40d42-647f-11e7-91ee-78ced874dd09.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://foxbit.exchange',
                'doc': 'https://blinktrade.com/docs',
            },
            'comment': 'Blinktrade API',
            'api': {
                'public': {
                    'get': [
                        '{currency}/ticker',    // ?crypto_currency=BTC
                        '{currency}/orderbook', // ?crypto_currency=BTC
                        '{currency}/trades',    // ?crypto_currency=BTC&since=<TIMESTAMP>&limit=<NUMBER>
                    ],
                },
                'private': {
                    'post': [
                        'D',   // order
                        'F',   // cancel order
                        'U2',  // balance
                        'U4',  // my orders
                        'U6',  // withdraw
                        'U18', // deposit
                        'U24', // confirm withdrawal
                        'U26', // list withdrawals
                        'U30', // list deposits
                        'U34', // ledger
                        'U70', // cancel withdrawal
                    ],
                },
            },
            'markets': {
                'BTC/VEF': { 'id': 'BTCVEF', 'symbol': 'BTC/VEF', 'base': 'BTC', 'quote': 'VEF', 'brokerId': 1, 'broker': 'SurBitcoin' },
                'BTC/VND': { 'id': 'BTCVND', 'symbol': 'BTC/VND', 'base': 'BTC', 'quote': 'VND', 'brokerId': 3, 'broker': 'VBTC' },
                'BTC/BRL': { 'id': 'BTCBRL', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'brokerId': 4, 'broker': 'FoxBit' },
                'BTC/PKR': { 'id': 'BTCPKR', 'symbol': 'BTC/PKR', 'base': 'BTC', 'quote': 'PKR', 'brokerId': 8, 'broker': 'UrduBit' },
                'BTC/CLP': { 'id': 'BTCCLP', 'symbol': 'BTC/CLP', 'base': 'BTC', 'quote': 'CLP', 'brokerId': 9, 'broker': 'ChileBit' },
            },
        });
    }

    fetchBalance (params = {}) {
        // todo parse balance
        return this.privatePostU2 ({
            'BalanceReqID': this.nonce (),
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetCurrencyOrderbook (this.extend ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let ticker = await this.publicGetCurrencyTicker (this.extend ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        }, params));
        let timestamp = this.milliseconds ();
        let lowercaseQuote = market['quote'].toLowerCase ();
        let quoteVolume = 'vol_' + lowercaseQuote;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': parseFloat (ticker[quoteVolume]),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetCurrencyTrades (this.extend ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let market = this.market (symbol);
        let orderSide = (side == 'buy') ? '1' : '2';
        let order = {
            'ClOrdID': this.nonce (),
            'Symbol': market['id'],
            'Side': orderSide,
            'OrdType': '2',
            'Price': price,
            'OrderQty': amount,
            'BrokerID': market['brokerId'],
        };
        let response = await this.privatePostD (this.extend (order, params));
        let indexed = this.indexBy (response['Responses'], 'MsgType');
        let execution = indexed['8'];
        return {
            'info': response,
            'id': execution['OrderID'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostF (this.extend ({
            'ClOrdID': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let request = this.extend ({ 'MsgType': path }, query);
            body = this.json (request);
            headers = {
                'APIKey': this.apiKey,
                'Nonce': nonce,
                'Signature': this.hmac (this.encode (nonce), this.encode (this.secret)),
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('Status' in response)
            if (response['Status'] != 200)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],55:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class fybse extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'fybse',
            'name': 'FYB-SE',
            'countries': 'SE', // Sweden
            'hasCORS': false,
            'rateLimit': 1500,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766512-31019772-5edb-11e7-8241-2e675e6797f1.jpg',
                'api': 'https://www.fybse.se/api/SEK',
                'www': 'https://www.fybse.se',
                'doc': 'http://docs.fyb.apiary.io',
            },
            'api': {
                'public': {
                    'get': [
                        'ticker',
                        'tickerdetailed',
                        'orderbook',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'test',
                        'getaccinfo',
                        'getpendingorders',
                        'getorderhistory',
                        'cancelpendingorder',
                        'placeorder',
                        'withdraw',
                    ],
                },
            },
            'markets': {
                'BTC/SEK': { 'id': 'SEK', 'symbol': 'BTC/SEK', 'base': 'BTC', 'quote': 'SEK' },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balance = await this.privatePostGetaccinfo ();
        let btc = parseFloat (balance['btcBal']);
        let symbol = this.symbols[0];
        let quote = this.markets[symbol]['quote'];
        let lowercase = quote.toLowerCase () + 'Bal';
        let fiat = parseFloat (balance[lowercase]);
        let crypto = {
            'free': btc,
            'used': 0.0,
            'total': btc,
        };
        let result = { 'BTC': crypto };
        result[quote] = {
            'free': fiat,
            'used': 0.0,
            'total': fiat,
        };
        result['info'] = balance;
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetOrderbook (params);
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetTickerdetailed (params);
        let timestamp = this.milliseconds ();
        let last = undefined;
        let volume = undefined;
        if ('last' in ticker)
            last = parseFloat (ticker['last']);
        if ('vol' in ticker)
            volume = parseFloat (ticker['vol']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': volume,
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (params);
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostPlaceorder (this.extend ({
            'qty': amount,
            'price': price,
            'type': side[0].toUpperCase ()
        }, params));
        return {
            'info': response,
            'id': response['pending_oid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelpendingorder ({ 'orderNo': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            url += '.json';
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'timestamp': nonce }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'key': this.apiKey,
                'sig': this.hmac (this.encode (body), this.encode (this.secret), 'sha1')
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'private')
            if ('error' in response)
                if (response['error'])
                    throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],56:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const fybse = require ('./fybse.js')

// ---------------------------------------------------------------------------

module.exports = class fybsg extends fybse {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'fybsg',
            'name': 'FYB-SG',
            'countries': 'SG', // Singapore
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766513-3364d56a-5edb-11e7-9e6b-d5898bb89c81.jpg',
                'api': 'https://www.fybsg.com/api/SGD',
                'www': 'https://www.fybsg.com',
                'doc': 'http://docs.fyb.apiary.io',
            },
            'markets': {
                'BTC/SGD': { 'id': 'SGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
            },
        });
    }
}

},{"./fybse.js":55}],57:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class gatecoin extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'gatecoin',
            'name': 'Gatecoin',
            'rateLimit': 2000,
            'countries': 'HK', // Hong Kong
            'comment': 'a regulated/licensed exchange',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1m': '1m',
                '15m': '15m',
                '1h': '1h',
                '6h': '6h',
                '1d': '24h',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28646817-508457f2-726c-11e7-9eeb-3528d2413a58.jpg',
                'api': 'https://api.gatecoin.com',
                'www': 'https://gatecoin.com',
                'doc': [
                    'https://gatecoin.com/api',
                    'https://github.com/Gatecoin/RESTful-API-Implementation',
                    'https://api.gatecoin.com/swagger-ui/index.html',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'Public/ExchangeRate', // Get the exchange rates
                        'Public/LiveTicker', // Get live ticker for all currency
                        'Public/LiveTicker/{CurrencyPair}', // Get live ticker by currency
                        'Public/LiveTickers', // Get live ticker for all currency
                        'Public/MarketDepth/{CurrencyPair}', // Gets prices and market depth for the currency pair.
                        'Public/NetworkStatistics/{DigiCurrency}', // Get the network status of a specific digital currency
                        'Public/StatisticHistory/{DigiCurrency}/{Typeofdata}', // Get the historical data of a specific digital currency
                        'Public/TickerHistory/{CurrencyPair}/{Timeframe}', // Get ticker history
                        'Public/Transactions/{CurrencyPair}', // Gets recent transactions
                        'Public/TransactionsHistory/{CurrencyPair}', // Gets all transactions
                        'Reference/BusinessNatureList', // Get the business nature list.
                        'Reference/Countries', // Get the country list.
                        'Reference/Currencies', // Get the currency list.
                        'Reference/CurrencyPairs', // Get the currency pair list.
                        'Reference/CurrentStatusList', // Get the current status list.
                        'Reference/IdentydocumentTypes', // Get the different types of identity documents possible.
                        'Reference/IncomeRangeList', // Get the income range list.
                        'Reference/IncomeSourceList', // Get the income source list.
                        'Reference/VerificationLevelList', // Get the verif level list.
                        'Stream/PublicChannel', // Get the public pubnub channel list
                    ],
                    'post': [
                        'Export/Transactions', // Request a export of all trades from based on currencypair, start date and end date
                        'Ping', // Post a string, then get it back.
                        'Public/Unsubscribe/{EmailCode}', // Lets the user unsubscribe from emails
                        'RegisterUser', // Initial trader registration.
                    ],
                },
                'private': {
                    'get': [
                        'Account/CorporateData', // Get corporate account data
                        'Account/DocumentAddress', // Check if residence proof uploaded
                        'Account/DocumentCorporation', // Check if registered document uploaded
                        'Account/DocumentID', // Check if ID document copy uploaded
                        'Account/DocumentInformation', // Get Step3 Data
                        'Account/Email', // Get user email
                        'Account/FeeRate', // Get fee rate of logged in user
                        'Account/Level', // Get verif level of logged in user
                        'Account/PersonalInformation', // Get Step1 Data
                        'Account/Phone', // Get user phone number
                        'Account/Profile', // Get trader profile
                        'Account/Questionnaire', // Fill the questionnaire
                        'Account/Referral', // Get referral information
                        'Account/ReferralCode', // Get the referral code of the logged in user
                        'Account/ReferralNames', // Get names of referred traders
                        'Account/ReferralReward', // Get referral reward information
                        'Account/ReferredCode', // Get referral code
                        'Account/ResidentInformation', // Get Step2 Data
                        'Account/SecuritySettings', // Get verif details of logged in user
                        'Account/User', // Get all user info
                        'APIKey/APIKey', // Get API Key for logged in user
                        'Auth/ConnectionHistory', // Gets connection history of logged in user
                        'Balance/Balances', // Gets the available balance for each currency for the logged in account.
                        'Balance/Balances/{Currency}', // Gets the available balance for s currency for the logged in account.
                        'Balance/Deposits', // Get all account deposits, including wire and digital currency, of the logged in user
                        'Balance/Withdrawals', // Get all account withdrawals, including wire and digital currency, of the logged in user
                        'Bank/Accounts/{Currency}/{Location}', // Get internal bank account for deposit
                        'Bank/Transactions', // Get all account transactions of the logged in user
                        'Bank/UserAccounts', // Gets all the bank accounts related to the logged in user.
                        'Bank/UserAccounts/{Currency}', // Gets all the bank accounts related to the logged in user.
                        'ElectronicWallet/DepositWallets', // Gets all crypto currency addresses related deposits to the logged in user.
                        'ElectronicWallet/DepositWallets/{DigiCurrency}', // Gets all crypto currency addresses related deposits to the logged in user by currency.
                        'ElectronicWallet/Transactions', // Get all digital currency transactions of the logged in user
                        'ElectronicWallet/Transactions/{DigiCurrency}', // Get all digital currency transactions of the logged in user
                        'ElectronicWallet/UserWallets', // Gets all external digital currency addresses related to the logged in user.
                        'ElectronicWallet/UserWallets/{DigiCurrency}', // Gets all external digital currency addresses related to the logged in user by currency.
                        'Info/ReferenceCurrency', // Get user's reference currency
                        'Info/ReferenceLanguage', // Get user's reference language
                        'Notification/Messages', // Get from oldest unread + 3 read message to newest messages
                        'Trade/Orders', // Gets open orders for the logged in trader.
                        'Trade/Orders/{OrderID}', // Gets an order for the logged in trader.
                        'Trade/StopOrders', // Gets all stop orders for the logged in trader. Max 1000 record.
                        'Trade/StopOrdersHistory', // Gets all stop orders for the logged in trader. Max 1000 record.
                        'Trade/Trades', // Gets all transactions of logged in user
                        'Trade/UserTrades', // Gets all transactions of logged in user
                    ],
                    'post': [
                        'Account/DocumentAddress', // Upload address proof document
                        'Account/DocumentCorporation', // Upload registered document document
                        'Account/DocumentID', // Upload ID document copy
                        'Account/Email/RequestVerify', // Request for verification email
                        'Account/Email/Verify', // Verification email
                        'Account/GoogleAuth', // Enable google auth
                        'Account/Level', // Request verif level of logged in user
                        'Account/Questionnaire', // Fill the questionnaire
                        'Account/Referral', // Post a referral email
                        'APIKey/APIKey', // Create a new API key for logged in user
                        'Auth/ChangePassword', // Change password.
                        'Auth/ForgotPassword', // Request reset password
                        'Auth/ForgotUserID', // Request user id
                        'Auth/Login', // Trader session log in.
                        'Auth/Logout', // Logout from the current session.
                        'Auth/LogoutOtherSessions', // Logout other sessions.
                        'Auth/ResetPassword', // Reset password
                        'Bank/Transactions', // Request a transfer from the traders account of the logged in user. This is only available for bank account
                        'Bank/UserAccounts', // Add an account the logged in user
                        'ElectronicWallet/DepositWallets/{DigiCurrency}', // Add an digital currency addresses to the logged in user.
                        'ElectronicWallet/Transactions/Deposits/{DigiCurrency}', // Get all internal digital currency transactions of the logged in user
                        'ElectronicWallet/Transactions/Withdrawals/{DigiCurrency}', // Get all external digital currency transactions of the logged in user
                        'ElectronicWallet/UserWallets/{DigiCurrency}', // Add an external digital currency addresses to the logged in user.
                        'ElectronicWallet/Withdrawals/{DigiCurrency}', // Request a transfer from the traders account to an external address. This is only available for crypto currencies.
                        'Notification/Messages', // Mark all as read
                        'Notification/Messages/{ID}', // Mark as read
                        'Trade/Orders', // Place an order at the exchange.
                        'Trade/StopOrders', // Place a stop order at the exchange.
                    ],
                    'put': [
                        'Account/CorporateData', // Update user company data for corporate account
                        'Account/DocumentID', // Update ID document meta data
                        'Account/DocumentInformation', // Update Step3 Data
                        'Account/Email', // Update user email
                        'Account/PersonalInformation', // Update Step1 Data
                        'Account/Phone', // Update user phone number
                        'Account/Questionnaire', // update the questionnaire
                        'Account/ReferredCode', // Update referral code
                        'Account/ResidentInformation', // Update Step2 Data
                        'Account/SecuritySettings', // Update verif details of logged in user
                        'Account/User', // Update all user info
                        'Bank/UserAccounts', // Update the label of existing user bank accounnt
                        'ElectronicWallet/DepositWallets/{DigiCurrency}/{AddressName}', // Update the name of an address
                        'ElectronicWallet/UserWallets/{DigiCurrency}', // Update the name of an external address
                        'Info/ReferenceCurrency', // User's reference currency
                        'Info/ReferenceLanguage', // Update user's reference language
                    ],
                    'delete': [
                        'APIKey/APIKey/{PublicKey}', // Remove an API key
                        'Bank/Transactions/{RequestID}', // Delete pending account withdraw of the logged in user
                        'Bank/UserAccounts/{Currency}/{Label}', // Delete an account of the logged in user
                        'ElectronicWallet/DepositWallets/{DigiCurrency}/{AddressName}', // Delete an digital currency addresses related to the logged in user.
                        'ElectronicWallet/UserWallets/{DigiCurrency}/{AddressName}', // Delete an external digital currency addresses related to the logged in user.
                        'Trade/Orders', // Cancels all existing order
                        'Trade/Orders/{OrderID}', // Cancels an existing order
                        'Trade/StopOrders', // Cancels all existing stop orders
                        'Trade/StopOrders/{ID}', // Cancels an existing stop order
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0025,
                    'taker': 0.0035,
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetPublicLiveTickers ();
        let markets = response['tickers'];
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['currencyPair'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalanceBalances ();
        let balances = response['balances'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': balance['availableBalance'],
                'used': this.sum (
                    balance['pendingIncoming'],
                    balance['pendingOutgoing'],
                    balance['openOrder']),
                'total': balance['balance'],
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetPublicMarketDepthCurrencyPair (this.extend ({
            'CurrencyPair': market['id'],
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = parseInt (ticker['createDateTime']) * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let baseVolume = parseFloat (ticker['volume']);
        let vwap = parseFloat (ticker['vwap']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetPublicLiveTickers (params);
        let tickers = response['tickers'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let id = ticker['currencyPair'];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetPublicLiveTickerCurrencyPair (this.extend ({
            'CurrencyPair': market['id'],
        }, params));
        let ticker = response['ticker'];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let side = undefined;
        let order = undefined;
        if ('way' in trade) {
            side = (trade['way'] == 'bid') ? 'buy' : 'sell';
            let orderId = trade['way'] + 'OrderId';
            order = trade[orderId];
        }
        let timestamp = parseInt (trade['transactionTime']) * 1000;
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'info': trade,
            'id': trade['transactionId'].toString (),
            'order': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['quantity'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetPublicTransactionsCurrencyPair (this.extend ({
            'CurrencyPair': market['id'],
        }, params));
        return this.parseTrades (response['transactions'], market, since, limit);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            parseInt (ohlcv['createDateTime']) * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            undefined,
            ohlcv['volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'CurrencyPair': market['id'],
            'Timeframe': this.timeframes[timeframe],
        };
        if (limit)
            request['Count'] = limit;
        request = this.extend (request, params);
        let response = await this.publicGetPublicTickerHistoryCurrencyPairTimeframe (request);
        return this.parseOHLCVs (response['tickers'], market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'Code': this.marketId (symbol),
            'Way': (side == 'buy') ? 'Bid' : 'Ask',
            'Amount': amount,
        };
        if (type == 'limit')
            order['Price'] = price;
        if (this.twofa) {
            if ('ValidationCode' in params)
                order['ValidationCode'] = params['ValidationCode'];
            else
                throw new AuthenticationError (this.id + ' two-factor authentication requires a missing ValidationCode parameter');
        }
        let response = await this.privatePostTradeOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['clOrderId'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteTradeOrdersOrderID ({ 'OrderID': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let contentType = (method == 'GET') ? '' : 'application/json';
            let auth = method + url + contentType + nonce.toString ();
            auth = auth.toLowerCase ();
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256', 'base64');
            headers = {
                'API_PUBLIC_KEY': this.apiKey,
                'API_REQUEST_SIGNATURE': signature,
                'API_REQUEST_DATE': nonce,
            };
            if (method != 'GET') {
                headers['Content-Type'] = contentType;
                body = this.json (this.extend ({ 'nonce': nonce }, params));
            }
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('responseStatus' in response)
            if ('message' in response['responseStatus'])
                if (response['responseStatus']['message'] == 'OK')
                    return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],58:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const bter = require ('./bter.js')

// ---------------------------------------------------------------------------

module.exports = class gateio extends bter {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'gateio',
            'name': 'Gate.io',
            'countries': 'CN',
            'rateLimit': 1000,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg',
                'api': {
                    'public': 'https://data.gate.io/api',
                    'private': 'https://data.gate.io/api',
                },
                'www': 'https://gate.io/',
                'doc': 'https://gate.io/api2',
            },
        });
    }
}

},{"./bter.js":37}],59:[function(require,module,exports){
"use strict";

// ----------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InvalidOrder, AuthenticationError, NotSupported } = require ('./base/errors')

// ----------------------------------------------------------------------------

module.exports = class gdax extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'gdax',
            'name': 'GDAX',
            'countries': 'US',
            'rateLimit': 1000,
            'userAgent': this.userAgents['chrome'],
            'hasCORS': true,
            'hasFetchOHLCV': true,
            'hasDeposit': true,
            'hasWithdraw': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'timeframes': {
                '1m': 60,
                '5m': 300,
                '15m': 900,
                '30m': 1800,
                '1h': 3600,
                '2h': 7200,
                '4h': 14400,
                '12h': 43200,
                '1d': 86400,
                '1w': 604800,
                '1M': 2592000,
                '1y': 31536000,
            },
            'urls': {
                'test': 'https://api-public.sandbox.gdax.com',
                'logo': 'https://user-images.githubusercontent.com/1294454/27766527-b1be41c6-5edb-11e7-95f6-5b496c469e2c.jpg',
                'api': 'https://api.gdax.com',
                'www': 'https://www.gdax.com',
                'doc': 'https://docs.gdax.com',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'password': true,
            },
            'api': {
                'public': {
                    'get': [
                        'currencies',
                        'products',
                        'products/{id}/book',
                        'products/{id}/candles',
                        'products/{id}/stats',
                        'products/{id}/ticker',
                        'products/{id}/trades',
                        'time',
                    ],
                },
                'private': {
                    'get': [
                        'accounts',
                        'accounts/{id}',
                        'accounts/{id}/holds',
                        'accounts/{id}/ledger',
                        'coinbase-accounts',
                        'fills',
                        'funding',
                        'orders',
                        'orders/{id}',
                        'payment-methods',
                        'position',
                        'reports/{id}',
                        'users/self/trailing-volume',
                    ],
                    'post': [
                        'deposits/coinbase-account',
                        'deposits/payment-method',
                        'funding/repay',
                        'orders',
                        'position/close',
                        'profiles/margin-transfer',
                        'reports',
                        'withdrawals/coinbase',
                        'withdrawals/crypto',
                        'withdrawals/payment-method',
                    ],
                    'delete': [
                        'orders',
                        'orders/{id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': true, // complicated tier system per coin
                    'percentage': true,
                    'maker': 0.0,
                    'taker': 0.30 / 100, // worst-case scenario: https://www.gdax.com/fees/BTC-USD
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.001,
                        'LTC': 0.001,
                        'ETH': 0.001,
                        'EUR': 0.15,
                        'USD': 25,
                    },
                    'deposit': {
                        'BTC': 0,
                        'LTC': 0,
                        'ETH': 0,
                        'EUR': 0.15,
                        'USD': 10,
                    },
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetProducts ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let base = market['base_currency'];
            let quote = market['quote_currency'];
            let symbol = base + '/' + quote;
            let amountLimits = {
                'min': market['base_min_size'],
                'max': market['base_max_size'],
            };
            let priceLimits = {
                'min': market['quote_increment'],
                'max': undefined,
            };
            let costLimits = {
                'min': priceLimits['min'],
                'max': undefined,
            };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
                'cost': costLimits,
            };
            let precision = {
                'amount': -Math.log10 (parseFloat (amountLimits['min'])),
                'price': -Math.log10 (parseFloat (priceLimits['min'])),
            };
            let taker = this.fees['trading']['taker'];
            if ((base == 'ETH') || (base == 'LTC')) {
                taker = 0.003;
            }
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'precision': precision,
                'limits': limits,
                'taker': taker,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccounts ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['hold']),
                'total': parseFloat (balance['balance']),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetProductsIdBook (this.extend ({
            'id': this.marketId (symbol),
            'level': 2, // 1 best bidask, 2 aggregated, 3 full
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = this.extend ({
            'id': market['id'],
        }, params);
        let ticker = await this.publicGetProductsIdTicker (request);
        let timestamp = this.parse8601 (ticker['time']);
        let bid = undefined;
        let ask = undefined;
        if ('bid' in ticker)
            bid = parseFloat (ticker['bid']);
        if ('ask' in ticker)
            ask = parseFloat (ticker['ask']);
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'price'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['time']);
        let side = (trade['side'] == 'buy') ? 'sell' : 'buy';
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let fee = undefined;
        if ('fill_fees' in trade) {
            fee = {
                'cost': parseFloat (trade['fill_fees']),
                'currency': market['quote'],
            };
        }
        return {
            'id': trade['trade_id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['size']),
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetProductsIdTrades (this.extend ({
            'id': market['id'], // fixes issue #2
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            ohlcv[3],
            ohlcv[2],
            ohlcv[1],
            ohlcv[4],
            ohlcv[5],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let granularity = this.timeframes[timeframe];
        let request = {
            'id': market['id'],
            'granularity': granularity,
        };
        if (since) {
            request['start'] = this.iso8601 (since);
            if (!limit)
                limit = 200; // max = 200
            request['end'] = this.iso8601 (limit * granularity * 1000 + since);
        }
        let response = await this.publicGetProductsIdCandles (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async fetchTime () {
        let response = this.publicGetTime ();
        return this.parse8601 (response['iso']);
    }

    getOrderStatus (status) {
        let statuses = {
            'pending': 'open',
            'active': 'open',
            'open': 'open',
            'done': 'closed',
            'canceled': 'canceled',
        };
        return this.safeString (statuses, status, status);
    }

    parseOrder (order, market = undefined) {
        let timestamp = this.parse8601 (order['created_at']);
        let symbol = undefined;
        if (!market) {
            if (order['product_id'] in this.markets_by_id)
                market = this.markets_by_id[order['product_id']];
        }
        let status = this.getOrderStatus (order['status']);
        let price = this.safeFloat (order, 'price');
        let amount = this.safeFloat (order, 'size');
        let filled = this.safeFloat (order, 'filled_size');
        let remaining = amount - filled;
        let cost = this.safeFloat (order, 'executed_value');
        if (market)
            symbol = market['symbol'];
        return {
            'id': order['id'],
            'info': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': status,
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': undefined,
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetOrdersId (this.extend ({
            'id': id,
        }, params));
        return this.parseOrder (response);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {
            'status': 'all',
        };
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['product_id'] = market['id'];
        }
        let response = await this.privateGetOrders (this.extend (request, params));
        return this.parseOrders (response, market, since, limit);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['product_id'] = market['id'];
        }
        let response = await this.privateGetOrders (this.extend (request, params));
        return this.parseOrders (response, market, since, limit);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {
            'status': 'done',
        };
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['product_id'] = market['id'];
        }
        let response = await this.privateGetOrders (this.extend (request, params));
        return this.parseOrders (response, market, since, limit);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        // let oid = this.nonce ().toString ();
        let order = {
            'product_id': this.marketId (market),
            'side': side,
            'size': amount,
            'type': type,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteOrdersId ({ 'id': id });
    }

    async getPaymentMethods () {
        let response = await this.privateGetPaymentMethods ();
        return response;
    }

    async deposit (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let request = {
            'currency': currency,
            'amount': amount,
        };
        let method = 'privatePostDeposits';
        if ('payment_method_id' in params) {
            // deposit from a payment_method, like a bank account
            method += 'PaymentMethod';
        } else if ('coinbase_account_id' in params) {
            // deposit into GDAX account from a Coinbase account
            method += 'CoinbaseAccount';
        } else {
            // deposit methodotherwise we did not receive a supported deposit location
            // relevant docs link for the Googlers
            // https://docs.gdax.com/#deposits
            throw new NotSupported (this.id + ' deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params');
        }
        let response = await this[method] (this.extend (request, params));
        if (!response)
            throw new ExchangeError (this.id + ' deposit() error: ' + this.json (response));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let request = {
            'currency': currency,
            'amount': amount,
        };
        let method = 'privatePostWithdrawals';
        if ('payment_method_id' in params) {
            method += 'PaymentMethod';
        } else if ('coinbase_account_id' in params) {
            method += 'CoinbaseAccount';
        } else {
            method += 'Crypto';
            request['crypto_address'] = address;
        }
        let response = await this[method] (this.extend (request, params));
        if (!response)
            throw new ExchangeError (this.id + ' withdraw() error: ' + this.json (response));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (method == 'GET') {
            if (Object.keys (query).length)
                request += '?' + this.urlencode (query);
        }
        let url = this.urls['api'] + request;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let payload = '';
            if (method != 'GET') {
                if (Object.keys (query).length) {
                    body = this.json (query);
                    payload = body;
                }
            }
            // let payload = (body) ? body : '';
            let what = nonce + method + request + payload;
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (this.encode (what), secret, 'sha256', 'base64');
            headers = {
                'CB-ACCESS-KEY': this.apiKey,
                'CB-ACCESS-SIGN': this.decode (signature),
                'CB-ACCESS-TIMESTAMP': nonce,
                'CB-ACCESS-PASSPHRASE': this.password,
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                let message = response['message'];
                if (message.indexOf ('price too small') >= 0) {
                    throw new InvalidOrder (this.id + ' ' + message);
                } else if (message.indexOf ('price too precise') >= 0) {
                    throw new InvalidOrder (this.id + ' ' + message);
                } else if (message == 'Invalid API Key') {
                    throw new AuthenticationError (this.id + ' ' + message);
                }
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
            throw new ExchangeError (this.id + ' ' + body);
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('message' in response) {
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],60:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class gemini extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'gemini',
            'name': 'Gemini',
            'countries': 'US',
            'rateLimit': 1500, // 200 for private API
            'version': 'v1',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg',
                'api': 'https://api.gemini.com',
                'www': 'https://gemini.com',
                'doc': 'https://docs.gemini.com/rest-api',
            },
            'api': {
                'public': {
                    'get': [
                        'symbols',
                        'pubticker/{symbol}',
                        'book/{symbol}',
                        'trades/{symbol}',
                        'auction/{symbol}',
                        'auction/{symbol}/history',
                    ],
                },
                'private': {
                    'post': [
                        'order/new',
                        'order/cancel',
                        'order/cancel/session',
                        'order/cancel/all',
                        'order/status',
                        'orders',
                        'mytrades',
                        'tradevolume',
                        'balances',
                        'deposit/{currency}/newAddress',
                        'withdraw/{currency}',
                        'heartbeat',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetSymbols ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let id = markets[p];
            let market = id;
            let uppercase = market.toUpperCase ();
            let base = uppercase.slice (0, 3);
            let quote = uppercase.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'taker': 0.0025
            });
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetPubtickerSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let timestamp = ticker['volume']['timestamp'];
        let baseVolume = market['base'];
        let quoteVolume = market['quote'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume'][baseVolume]),
            'quoteVolume': parseFloat (ticker['volume'][quoteVolume]),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['timestampms'];
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['available']),
                'used': 0.0,
                'total': parseFloat (balance['amount']),
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let nonce = this.nonce ();
        let order = {
            'client_order_id': nonce.toString (),
            'symbol': this.marketId (symbol),
            'amount': amount.toString (),
            'price': price.toString (),
            'side': side,
            'type': 'exchange limit', // gemini allows limit orders only
        };
        let response = await this.privatePostOrderNew (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'order_id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let request = this.extend ({
                'request': url,
                'nonce': nonce,
            }, query);
            let payload = this.json (request);
            payload = this.stringToBase64 (this.encode (payload));
            let signature = this.hmac (payload, this.encode (this.secret), 'sha384');
            headers = {
                'Content-Type': 'text/plain',
                'X-GEMINI-APIKEY': this.apiKey,
                'X-GEMINI-PAYLOAD': this.decode (payload),
                'X-GEMINI-SIGNATURE': signature,
            };
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (response['result'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],61:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const _1btcxe = require ('./_1btcxe.js')

// ---------------------------------------------------------------------------

module.exports = class getbtc extends _1btcxe {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'getbtc',
            'name': 'GetBTC',
            'countries': [ 'VC', 'RU' ], // Saint Vincent and the Grenadines, Russia, CIS
            'rateLimit': 1000,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/33801902-03c43462-dd7b-11e7-992e-077e4cd015b9.jpg',
                'api': 'https://getbtc.org/api',
                'www': 'https://getbtc.org',
                'doc': 'https://getbtc.org/api-docs.php',
            },
            'markets': {
                'BTC/EUR': { 'id': 'EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'precision': { 'amount': 8, 'price': 8 }, 'lot': 0.00000001, 'limits': { 'amount': { 'min': 0.00000001, 'max': undefined }, 'price': { 'min': 0.00000001, 'max': undefined }}},
                'BTC/RUB': { 'id': 'RUB', 'symbol': 'BTC/RUB', 'base': 'BTC', 'quote': 'RUB', 'precision': { 'amount': 8, 'price': 8 }, 'lot': 0.00000001, 'limits': { 'amount': { 'min': 0.00000001, 'max': undefined }, 'price': { 'min': 0.00000001, 'max': undefined }}},
                'BTC/USD': { 'id': 'USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'precision': { 'amount': 8, 'price': 8 }, 'lot': 0.00000001, 'limits': { 'amount': { 'min': 0.00000001, 'max': undefined }, 'price': { 'min': 0.00000001, 'max': undefined }}},
            },
            'fees': {
                'trading': {
                    'taker': 0.20 / 100,
                    'maker': 0.20 / 100,
                },
            },
        });
    }
}

},{"./_1btcxe.js":4}],62:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class hitbtc extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'hitbtc',
            'name': 'HitBTC',
            'countries': 'HK', // Hong Kong
            'rateLimit': 1500,
            'version': '1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOrder': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
                'api': 'http://api.hitbtc.com',
                'www': 'https://hitbtc.com',
                'doc': 'https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv1.md',
            },
            'api': {
                'public': {
                    'get': [
                        '{symbol}/orderbook',
                        '{symbol}/ticker',
                        '{symbol}/trades',
                        '{symbol}/trades/recent',
                        'symbols',
                        'ticker',
                        'time,'
                    ],
                },
                'trading': {
                    'get': [
                        'balance',
                        'orders/active',
                        'orders/recent',
                        'order',
                        'trades/by/order',
                        'trades',
                    ],
                    'post': [
                        'new_order',
                        'cancel_order',
                        'cancel_orders',
                    ],
                },
                'payment': {
                    'get': [
                        'balance',
                        'address/{currency}',
                        'transactions',
                        'transactions/{transaction}',
                    ],
                    'post': [
                        'transfer_to_trading',
                        'transfer_to_main',
                        'address/{currency}',
                        'payout',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'maker': -0.01 / 100,
                    'taker': 0.1 / 100,
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.0007,
                        'ETH': 0.00958,
                        'BCH': 0.0018,
                        'USDT': 5,
                        'BTG': 0.0005,
                        'LTC': 0.003,
                        'ZEC': 0.0001,
                        'XMR': 0.09,
                        '1ST': 0.84,
                        'ADX': 5.7,
                        'AE': 6.7,
                        'AEON': 0.01006,
                        'AIR': 565,
                        'AMP': 9,
                        'ANT': 6.7,
                        'ARDR': 2,
                        'ARN': 18.5,
                        'ART': 26,
                        'ATB': 0.0004,
                        'ATL': 27,
                        'ATM': 504,
                        'ATS': 860,
                        'AVT': 1.9,
                        'BAS': 113,
                        'BCN': 0.1,
                        'BET': 124,
                        'BKB': 46,
                        'BMC': 32,
                        'BMT': 100,
                        'BNT': 2.57,
                        'BQX': 4.7,
                        'BTM': 40,
                        'BTX': 0.04,
                        'BUS': 0.004,
                        'CCT': 115,
                        'CDT': 100,
                        'CDX': 30,
                        'CFI': 61,
                        'CLD': 0.88,
                        'CND': 574,
                        'CNX': 0.04,
                        'COSS': 65,
                        'CSNO': 16,
                        'CTR': 15,
                        'CTX': 146,
                        'CVC': 8.46,
                        'DBIX': 0.0168,
                        'DCN': 120000,
                        'DCT': 0.02,
                        'DDF': 342,
                        'DENT': 6240,
                        'DGB': 0.4,
                        'DGD': 0.01,
                        'DICE': 0.32,
                        'DLT': 0.26,
                        'DNT': 0.21,
                        'DOGE': 2,
                        'DOV': 34,
                        'DRPU': 24,
                        'DRT': 240,
                        'DSH': 0.017,
                        'EBET': 84,
                        'EBTC': 20,
                        'EBTCOLD': 6.6,
                        'ECAT': 14,
                        'EDG': 2,
                        'EDO': 2.9,
                        'ELE': 0.00172,
                        'ELM': 0.004,
                        'EMC': 0.03,
                        'EMGO': 14,
                        'ENJ': 163,
                        'EOS': 1.5,
                        'ERO': 34,
                        'ETBS': 15,
                        'ETC': 0.002,
                        'ETP': 0.004,
                        'EVX': 5.4,
                        'EXN': 456,
                        'FRD': 65,
                        'FUEL': 123.00105,
                        'FUN': 202.9598309,
                        'FYN': 1.849,
                        'FYP': 66.13,
                        'GNO': 0.0034,
                        'GUP': 4,
                        'GVT': 1.2,
                        'HAC': 144,
                        'HDG': 7,
                        'HGT': 1082,
                        'HPC': 0.4,
                        'HVN': 120,
                        'ICN': 0.55,
                        'ICO': 34,
                        'ICOS': 0.35,
                        'IND': 76,
                        'INDI': 5913,
                        'ITS': 15.0012,
                        'IXT': 11,
                        'KBR': 143,
                        'KICK': 112,
                        'LA': 41,
                        'LAT': 1.44,
                        'LIFE': 13000,
                        'LRC': 27,
                        'LSK': 0.3,
                        'LUN': 0.34,
                        'MAID': 5,
                        'MANA': 143,
                        'MCAP': 5.44,
                        'MIPS': 43,
                        'MNE': 1.33,
                        'MSP': 121,
                        'MTH': 92,
                        'MYB': 3.9,
                        'NDC': 165,
                        'NEBL': 0.04,
                        'NET': 3.96,
                        'NTO': 998,
                        'NXC': 13.39,
                        'NXT': 3,
                        'OAX': 15,
                        'ODN': 0.004,
                        'OMG': 2,
                        'OPT': 335,
                        'ORME': 2.8,
                        'OTN': 0.57,
                        'PAY': 3.1,
                        'PIX': 96,
                        'PLBT': 0.33,
                        'PLR': 114,
                        'PLU': 0.87,
                        'POE': 784,
                        'POLL': 3.5,
                        'PPT': 2,
                        'PRE': 32,
                        'PRG': 39,
                        'PRO': 41,
                        'PRS': 60,
                        'PTOY': 0.5,
                        'QAU': 63,
                        'QCN': 0.03,
                        'QTUM': 0.04,
                        'QVT': 64,
                        'REP': 0.02,
                        'RKC': 15,
                        'RVT': 14,
                        'SAN': 2.24,
                        'SBD': 0.03,
                        'SCL': 2.6,
                        'SISA': 1640,
                        'SKIN': 407,
                        'SMART': 0.4,
                        'SMS': 0.0375,
                        'SNC': 36,
                        'SNGLS': 4,
                        'SNM': 48,
                        'SNT': 233,
                        'STEEM': 0.01,
                        'STRAT': 0.01,
                        'STU': 14,
                        'STX': 11,
                        'SUB': 17,
                        'SUR': 3,
                        'SWT': 0.51,
                        'TAAS': 0.91,
                        'TBT': 2.37,
                        'TFL': 15,
                        'TIME': 0.03,
                        'TIX': 7.1,
                        'TKN': 1,
                        'TKR': 84,
                        'TNT': 90,
                        'TRST': 1.6,
                        'TRX': 1395,
                        'UET': 480,
                        'UGT': 15,
                        'VEN': 14,
                        'VERI': 0.037,
                        'VIB': 50,
                        'VIBE': 145,
                        'VOISE': 618,
                        'WEALTH': 0.0168,
                        'WINGS': 2.4,
                        'WTC': 0.75,
                        'XAUR': 3.23,
                        'XDN': 0.01,
                        'XEM': 15,
                        'XUC': 0.9,
                        'YOYOW': 140,
                        'ZAP': 24,
                        'ZRX': 23,
                        'ZSC': 191,
                    },
                    'deposit': {
                        'BTC': 0,
                        'ETH': 0,
                        'BCH': 0,
                        'USDT': 0,
                        'BTG': 0,
                        'LTC': 0,
                        'ZEC': 0,
                        'XMR': 0,
                        '1ST': 0,
                        'ADX': 0,
                        'AE': 0,
                        'AEON': 0,
                        'AIR': 0,
                        'AMP': 0,
                        'ANT': 0,
                        'ARDR': 0,
                        'ARN': 0,
                        'ART': 0,
                        'ATB': 0,
                        'ATL': 0,
                        'ATM': 0,
                        'ATS': 0,
                        'AVT': 0,
                        'BAS': 0,
                        'BCN': 0,
                        'BET': 0,
                        'BKB': 0,
                        'BMC': 0,
                        'BMT': 0,
                        'BNT': 0,
                        'BQX': 0,
                        'BTM': 0,
                        'BTX': 0,
                        'BUS': 0,
                        'CCT': 0,
                        'CDT': 0,
                        'CDX': 0,
                        'CFI': 0,
                        'CLD': 0,
                        'CND': 0,
                        'CNX': 0,
                        'COSS': 0,
                        'CSNO': 0,
                        'CTR': 0,
                        'CTX': 0,
                        'CVC': 0,
                        'DBIX': 0,
                        'DCN': 0,
                        'DCT': 0,
                        'DDF': 0,
                        'DENT': 0,
                        'DGB': 0,
                        'DGD': 0,
                        'DICE': 0,
                        'DLT': 0,
                        'DNT': 0,
                        'DOGE': 0,
                        'DOV': 0,
                        'DRPU': 0,
                        'DRT': 0,
                        'DSH': 0,
                        'EBET': 0,
                        'EBTC': 0,
                        'EBTCOLD': 0,
                        'ECAT': 0,
                        'EDG': 0,
                        'EDO': 0,
                        'ELE': 0,
                        'ELM': 0,
                        'EMC': 0,
                        'EMGO': 0,
                        'ENJ': 0,
                        'EOS': 0,
                        'ERO': 0,
                        'ETBS': 0,
                        'ETC': 0,
                        'ETP': 0,
                        'EVX': 0,
                        'EXN': 0,
                        'FRD': 0,
                        'FUEL': 0,
                        'FUN': 0,
                        'FYN': 0,
                        'FYP': 0,
                        'GNO': 0,
                        'GUP': 0,
                        'GVT': 0,
                        'HAC': 0,
                        'HDG': 0,
                        'HGT': 0,
                        'HPC': 0,
                        'HVN': 0,
                        'ICN': 0,
                        'ICO': 0,
                        'ICOS': 0,
                        'IND': 0,
                        'INDI': 0,
                        'ITS': 0,
                        'IXT': 0,
                        'KBR': 0,
                        'KICK': 0,
                        'LA': 0,
                        'LAT': 0,
                        'LIFE': 0,
                        'LRC': 0,
                        'LSK': 0,
                        'LUN': 0,
                        'MAID': 0,
                        'MANA': 0,
                        'MCAP': 0,
                        'MIPS': 0,
                        'MNE': 0,
                        'MSP': 0,
                        'MTH': 0,
                        'MYB': 0,
                        'NDC': 0,
                        'NEBL': 0,
                        'NET': 0,
                        'NTO': 0,
                        'NXC': 0,
                        'NXT': 0,
                        'OAX': 0,
                        'ODN': 0,
                        'OMG': 0,
                        'OPT': 0,
                        'ORME': 0,
                        'OTN': 0,
                        'PAY': 0,
                        'PIX': 0,
                        'PLBT': 0,
                        'PLR': 0,
                        'PLU': 0,
                        'POE': 0,
                        'POLL': 0,
                        'PPT': 0,
                        'PRE': 0,
                        'PRG': 0,
                        'PRO': 0,
                        'PRS': 0,
                        'PTOY': 0,
                        'QAU': 0,
                        'QCN': 0,
                        'QTUM': 0,
                        'QVT': 0,
                        'REP': 0,
                        'RKC': 0,
                        'RVT': 0,
                        'SAN': 0,
                        'SBD': 0,
                        'SCL': 0,
                        'SISA': 0,
                        'SKIN': 0,
                        'SMART': 0,
                        'SMS': 0,
                        'SNC': 0,
                        'SNGLS': 0,
                        'SNM': 0,
                        'SNT': 0,
                        'STEEM': 0,
                        'STRAT': 0,
                        'STU': 0,
                        'STX': 0,
                        'SUB': 0,
                        'SUR': 0,
                        'SWT': 0,
                        'TAAS': 0,
                        'TBT': 0,
                        'TFL': 0,
                        'TIME': 0,
                        'TIX': 0,
                        'TKN': 0,
                        'TKR': 0,
                        'TNT': 0,
                        'TRST': 0,
                        'TRX': 0,
                        'UET': 0,
                        'UGT': 0,
                        'VEN': 0,
                        'VERI': 0,
                        'VIB': 0,
                        'VIBE': 0,
                        'VOISE': 0,
                        'WEALTH': 0,
                        'WINGS': 0,
                        'WTC': 0,
                        'XAUR': 0,
                        'XDN': 0,
                        'XEM': 0,
                        'XUC': 0,
                        'YOYOW': 0,
                        'ZAP': 0,
                        'ZRX': 0,
                        'ZSC': 0,
                    },
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (currency == 'XBT')
            return 'BTC';
        if (currency == 'DRK')
            return 'DASH';
        if (currency == 'CAT')
            return 'BitClave';
        return currency;
    }

    async fetchMarkets () {
        let markets = await this.publicGetSymbols ();
        let result = [];
        for (let p = 0; p < markets['symbols'].length; p++) {
            let market = markets['symbols'][p];
            let id = market['symbol'];
            let base = market['commodity'];
            let quote = market['currency'];
            let lot = parseFloat (market['lot']);
            let step = parseFloat (market['step']);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'lot': lot,
                'step': step,
                'info': market,
                'precision': {
                    'amount': this.precisionFromString (market['lot']),
                    'price': this.precisionFromString (market['step']),
                },
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': step,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let method = this.safeString (params, 'type', 'trading');
        method += 'GetBalance';
        let query = this.omit (params, 'type');
        let response = await this[method] (query);
        let balances = response['balance'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let code = balance['currency_code'];
            let currency = this.commonCurrencyCode (code);
            let free = this.safeFloat (balance, 'cash', 0.0);
            free = this.safeFloat (balance, 'balance', free);
            let used = this.safeFloat (balance, 'reserved', 0.0);
            let account = {
                'free': free,
                'used': used,
                'total': this.sum (free, used),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetSymbolOrderbook (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['timestamp'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'open'),
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': this.safeFloat (ticker, 'volume_quote'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetSymbolTicker (this.extend ({
            'symbol': market['id'],
        }, params));
        if ('message' in ticker)
            throw new ExchangeError (this.id + ' ' + ticker['message']);
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        return {
            'info': trade,
            'id': trade[0],
            'timestamp': trade[3],
            'datetime': this.iso8601 (trade[3]),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade[4],
            'price': parseFloat (trade[1]),
            'amount': parseFloat (trade[2]),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetSymbolTrades (this.extend ({
            'symbol': market['id'],
            // 'from': 0,
            // 'till': 100,
            // 'by': 'ts', // or by trade_id
            // 'sort': 'desc', // or asc
            // 'start_index': 0,
            // 'max_results': 1000,
            // 'format_item': 'object',
            // 'format_price': 'number',
            // 'format_amount': 'number',
            // 'format_tid': 'string',
            // 'format_timestamp': 'millisecond',
            // 'format_wrap': false,
            'side': 'true',
        }, params));
        return this.parseTrades (response['trades'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        // check if amount can be evenly divided into lots
        // they want integer quantity in lot units
        let quantity = parseFloat (amount) / market['lot'];
        let wholeLots = Math.round (quantity);
        let difference = quantity - wholeLots;
        if (Math.abs (difference) > market['step'])
            throw new ExchangeError (this.id + ' order amount should be evenly divisible by lot unit size of ' + market['lot'].toString ());
        let clientOrderId = this.milliseconds ();
        let order = {
            'clientOrderId': clientOrderId.toString (),
            'symbol': market['id'],
            'side': side,
            'quantity': wholeLots.toString (), // quantity in integer lot units
            'type': type,
        };
        if (type == 'limit') {
            order['price'] = this.priceToPrecision (symbol, price);
        } else {
            order['timeInForce'] = 'FOK';
        }
        let response = await this.tradingPostNewOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['ExecutionReport']['clientOrderId'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.tradingPostCancelOrder (this.extend ({
            'clientOrderId': id,
        }, params));
    }

    getOrderStatus (status) {
        let statuses = {
            'new': 'open',
            'partiallyFilled': 'open',
            'filled': 'closed',
            'canceled': 'canceled',
            'rejected': 'rejected',
            'expired': 'expired',
        };
        return this.safeString (statuses, status);
    }

    parseOrder (order, market = undefined) {
        let timestamp = parseInt (order['lastTimestamp']);
        let symbol = undefined;
        if (!market)
            market = this.markets_by_id[order['symbol']];
        let status = this.safeString (order, 'orderStatus');
        if (status)
            status = this.getOrderStatus (status);
        let averagePrice = this.safeFloat (order, 'avgPrice', 0.0);
        let price = this.safeFloat (order, 'orderPrice');
        let amount = this.safeFloat (order, 'orderQuantity');
        let remaining = this.safeFloat (order, 'quantityLeaves');
        let filled = undefined;
        let cost = undefined;
        if (market) {
            symbol = market['symbol'];
            amount *= market['lot'];
            remaining *= market['lot'];
        }
        if (amount && remaining) {
            filled = amount - remaining;
            cost = averagePrice * filled;
        }
        return {
            'id': order['clientOrderId'].toString (),
            'info': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': status,
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': undefined,
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.tradingGetOrder (this.extend ({
            'clientOrderId': id,
        }, params));
        return this.parseOrder (response['orders'][0]);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let statuses = [ 'new', 'partiallyFiiled' ];
        let market = undefined;
        let request = {
            'sort': 'desc',
            'statuses': statuses.join (','),
        };
        if (symbol) {
            market = this.market (symbol);
            request['symbols'] = market['id'];
        }
        let response = await this.tradingGetOrdersActive (this.extend (request, params));
        return this.parseOrders (response['orders'], market, since, limit);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let statuses = [ 'filled', 'canceled', 'rejected', 'expired' ];
        let request = {
            'sort': 'desc',
            'statuses': statuses.join (','),
            'max_results': 1000,
        };
        if (symbol) {
            market = this.market (symbol);
            request['symbols'] = market['id'];
        }
        let response = await this.tradingGetOrdersRecent (this.extend (request, params));
        return this.parseOrders (response['orders'], market, since, limit);
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.paymentPostPayout (this.extend ({
            'currency_code': currency,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['transaction'],
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + 'api' + '/' + this.version + '/' + api + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let payload = { 'nonce': nonce, 'apikey': this.apiKey };
            query = this.extend (payload, query);
            if (method == 'GET')
                url += '?' + this.urlencode (query);
            else
                url += '?' + this.urlencode (payload);
            let auth = url;
            if (method == 'POST') {
                if (Object.keys (query).length) {
                    body = this.urlencode (query);
                    auth += body;
                }
            }
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Signature': this.hmac (this.encode (auth), this.encode (this.secret), 'sha512').toLowerCase (),
            };
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('code' in response) {
            if ('ExecutionReport' in response) {
                if (response['ExecutionReport']['orderRejectReason'] == 'orderExceedsLimit')
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
            }
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],63:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const hitbtc = require ('./hitbtc')
const { ExchangeError, OrderNotFound, InsufficientFunds } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class hitbtc2 extends hitbtc {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'hitbtc2',
            'name': 'HitBTC v2',
            'countries': 'HK', // Hong Kong
            'rateLimit': 1500,
            'version': '2',
            'hasCORS': true,
            // older metainfo interface
            'hasFetchOHLCV': true,
            'hasFetchTickers': true,
            'hasFetchOrder': true,
            'hasFetchOrders': false,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchMyTrades': true,
            'hasWithdraw': true,
            'hasFetchCurrencies': true,
            // new metainfo interface
            'has': {
                'fetchCurrencies': true,
                'fetchOHLCV': true,
                'fetchTickers': true,
                'fetchOrder': true,
                'fetchOrders': false,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
                'fetchMyTrades': true,
                'withdraw': true,
            },
            'timeframes': {
                '1m': 'M1',
                '3m': 'M3',
                '5m': 'M5',
                '15m': 'M15',
                '30m': 'M30', // default
                '1h': 'H1',
                '4h': 'H4',
                '1d': 'D1',
                '1w': 'D7',
                '1M': '1M',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
                'api': 'https://api.hitbtc.com',
                'www': 'https://hitbtc.com',
                'doc': 'https://api.hitbtc.com',
            },
            'api': {
                'public': {
                    'get': [
                        'symbol', // Available Currency Symbols
                        'symbol/{symbol}', // Get symbol info
                        'currency', // Available Currencies
                        'currency/{currency}', // Get currency info
                        'ticker', // Ticker list for all symbols
                        'ticker/{symbol}', // Ticker for symbol
                        'trades/{symbol}', // Trades
                        'orderbook/{symbol}', // Orderbook
                        'candles/{symbol}', // Candles
                    ],
                },
                'private': {
                    'get': [
                        'order', // List your current open orders
                        'order/{clientOrderId}', // Get a single order by clientOrderId
                        'trading/balance', // Get trading balance
                        'trading/fee/{symbol}', // Get trading fee rate
                        'history/trades', // Get historical trades
                        'history/order', // Get historical orders
                        'history/order/{id}/trades', // Get historical trades by specified order
                        'account/balance', // Get main acccount balance
                        'account/transactions', // Get account transactions
                        'account/transactions/{id}', // Get account transaction by id
                        'account/crypto/address/{currency}', // Get deposit crypro address
                    ],
                    'post': [
                        'order', // Create new order
                        'account/crypto/withdraw', // Withdraw crypro
                        'account/crypto/address/{currency}', // Create new deposit crypro address
                        'account/transfer', // Transfer amount to trading
                    ],
                    'put': [
                        'order/{clientOrderId}', // Create new order
                        'account/crypto/withdraw/{id}', // Commit withdraw crypro
                    ],
                    'delete': [
                        'order', // Cancel all open orders
                        'order/{clientOrderId}', // Cancel order
                        'account/crypto/withdraw/{id}', // Rollback withdraw crypro
                    ],
                    'patch': [
                        'order/{clientOrderId}', // Cancel Replace order
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'maker': -0.01 / 100,
                    'taker': 0.1 / 100,
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.0007,
                        'ETH': 0.00958,
                        'BCH': 0.0018,
                        'USDT': 5,
                        'BTG': 0.0005,
                        'LTC': 0.003,
                        'ZEC': 0.0001,
                        'XMR': 0.09,
                        '1ST': 0.84,
                        'ADX': 5.7,
                        'AE': 6.7,
                        'AEON': 0.01006,
                        'AIR': 565,
                        'AMP': 9,
                        'ANT': 6.7,
                        'ARDR': 2,
                        'ARN': 18.5,
                        'ART': 26,
                        'ATB': 0.0004,
                        'ATL': 27,
                        'ATM': 504,
                        'ATS': 860,
                        'AVT': 1.9,
                        'BAS': 113,
                        'BCN': 0.1,
                        'BET': 124,
                        'BKB': 46,
                        'BMC': 32,
                        'BMT': 100,
                        'BNT': 2.57,
                        'BQX': 4.7,
                        'BTM': 40,
                        'BTX': 0.04,
                        'BUS': 0.004,
                        'CCT': 115,
                        'CDT': 100,
                        'CDX': 30,
                        'CFI': 61,
                        'CLD': 0.88,
                        'CND': 574,
                        'CNX': 0.04,
                        'COSS': 65,
                        'CSNO': 16,
                        'CTR': 15,
                        'CTX': 146,
                        'CVC': 8.46,
                        'DBIX': 0.0168,
                        'DCN': 120000,
                        'DCT': 0.02,
                        'DDF': 342,
                        'DENT': 6240,
                        'DGB': 0.4,
                        'DGD': 0.01,
                        'DICE': 0.32,
                        'DLT': 0.26,
                        'DNT': 0.21,
                        'DOGE': 2,
                        'DOV': 34,
                        'DRPU': 24,
                        'DRT': 240,
                        'DSH': 0.017,
                        'EBET': 84,
                        'EBTC': 20,
                        'EBTCOLD': 6.6,
                        'ECAT': 14,
                        'EDG': 2,
                        'EDO': 2.9,
                        'ELE': 0.00172,
                        'ELM': 0.004,
                        'EMC': 0.03,
                        'EMGO': 14,
                        'ENJ': 163,
                        'EOS': 1.5,
                        'ERO': 34,
                        'ETBS': 15,
                        'ETC': 0.002,
                        'ETP': 0.004,
                        'EVX': 5.4,
                        'EXN': 456,
                        'FRD': 65,
                        'FUEL': 123.00105,
                        'FUN': 202.9598309,
                        'FYN': 1.849,
                        'FYP': 66.13,
                        'GNO': 0.0034,
                        'GUP': 4,
                        'GVT': 1.2,
                        'HAC': 144,
                        'HDG': 7,
                        'HGT': 1082,
                        'HPC': 0.4,
                        'HVN': 120,
                        'ICN': 0.55,
                        'ICO': 34,
                        'ICOS': 0.35,
                        'IND': 76,
                        'INDI': 5913,
                        'ITS': 15.0012,
                        'IXT': 11,
                        'KBR': 143,
                        'KICK': 112,
                        'LA': 41,
                        'LAT': 1.44,
                        'LIFE': 13000,
                        'LRC': 27,
                        'LSK': 0.3,
                        'LUN': 0.34,
                        'MAID': 5,
                        'MANA': 143,
                        'MCAP': 5.44,
                        'MIPS': 43,
                        'MNE': 1.33,
                        'MSP': 121,
                        'MTH': 92,
                        'MYB': 3.9,
                        'NDC': 165,
                        'NEBL': 0.04,
                        'NET': 3.96,
                        'NTO': 998,
                        'NXC': 13.39,
                        'NXT': 3,
                        'OAX': 15,
                        'ODN': 0.004,
                        'OMG': 2,
                        'OPT': 335,
                        'ORME': 2.8,
                        'OTN': 0.57,
                        'PAY': 3.1,
                        'PIX': 96,
                        'PLBT': 0.33,
                        'PLR': 114,
                        'PLU': 0.87,
                        'POE': 784,
                        'POLL': 3.5,
                        'PPT': 2,
                        'PRE': 32,
                        'PRG': 39,
                        'PRO': 41,
                        'PRS': 60,
                        'PTOY': 0.5,
                        'QAU': 63,
                        'QCN': 0.03,
                        'QTUM': 0.04,
                        'QVT': 64,
                        'REP': 0.02,
                        'RKC': 15,
                        'RVT': 14,
                        'SAN': 2.24,
                        'SBD': 0.03,
                        'SCL': 2.6,
                        'SISA': 1640,
                        'SKIN': 407,
                        'SMART': 0.4,
                        'SMS': 0.0375,
                        'SNC': 36,
                        'SNGLS': 4,
                        'SNM': 48,
                        'SNT': 233,
                        'STEEM': 0.01,
                        'STRAT': 0.01,
                        'STU': 14,
                        'STX': 11,
                        'SUB': 17,
                        'SUR': 3,
                        'SWT': 0.51,
                        'TAAS': 0.91,
                        'TBT': 2.37,
                        'TFL': 15,
                        'TIME': 0.03,
                        'TIX': 7.1,
                        'TKN': 1,
                        'TKR': 84,
                        'TNT': 90,
                        'TRST': 1.6,
                        'TRX': 1395,
                        'UET': 480,
                        'UGT': 15,
                        'VEN': 14,
                        'VERI': 0.037,
                        'VIB': 50,
                        'VIBE': 145,
                        'VOISE': 618,
                        'WEALTH': 0.0168,
                        'WINGS': 2.4,
                        'WTC': 0.75,
                        'XAUR': 3.23,
                        'XDN': 0.01,
                        'XEM': 15,
                        'XUC': 0.9,
                        'YOYOW': 140,
                        'ZAP': 24,
                        'ZRX': 23,
                        'ZSC': 191,
                    },
                    'deposit': {
                        'BTC': 0,
                        'ETH': 0,
                        'BCH': 0,
                        'USDT': 0,
                        'BTG': 0,
                        'LTC': 0,
                        'ZEC': 0,
                        'XMR': 0,
                        '1ST': 0,
                        'ADX': 0,
                        'AE': 0,
                        'AEON': 0,
                        'AIR': 0,
                        'AMP': 0,
                        'ANT': 0,
                        'ARDR': 0,
                        'ARN': 0,
                        'ART': 0,
                        'ATB': 0,
                        'ATL': 0,
                        'ATM': 0,
                        'ATS': 0,
                        'AVT': 0,
                        'BAS': 0,
                        'BCN': 0,
                        'BET': 0,
                        'BKB': 0,
                        'BMC': 0,
                        'BMT': 0,
                        'BNT': 0,
                        'BQX': 0,
                        'BTM': 0,
                        'BTX': 0,
                        'BUS': 0,
                        'CCT': 0,
                        'CDT': 0,
                        'CDX': 0,
                        'CFI': 0,
                        'CLD': 0,
                        'CND': 0,
                        'CNX': 0,
                        'COSS': 0,
                        'CSNO': 0,
                        'CTR': 0,
                        'CTX': 0,
                        'CVC': 0,
                        'DBIX': 0,
                        'DCN': 0,
                        'DCT': 0,
                        'DDF': 0,
                        'DENT': 0,
                        'DGB': 0,
                        'DGD': 0,
                        'DICE': 0,
                        'DLT': 0,
                        'DNT': 0,
                        'DOGE': 0,
                        'DOV': 0,
                        'DRPU': 0,
                        'DRT': 0,
                        'DSH': 0,
                        'EBET': 0,
                        'EBTC': 0,
                        'EBTCOLD': 0,
                        'ECAT': 0,
                        'EDG': 0,
                        'EDO': 0,
                        'ELE': 0,
                        'ELM': 0,
                        'EMC': 0,
                        'EMGO': 0,
                        'ENJ': 0,
                        'EOS': 0,
                        'ERO': 0,
                        'ETBS': 0,
                        'ETC': 0,
                        'ETP': 0,
                        'EVX': 0,
                        'EXN': 0,
                        'FRD': 0,
                        'FUEL': 0,
                        'FUN': 0,
                        'FYN': 0,
                        'FYP': 0,
                        'GNO': 0,
                        'GUP': 0,
                        'GVT': 0,
                        'HAC': 0,
                        'HDG': 0,
                        'HGT': 0,
                        'HPC': 0,
                        'HVN': 0,
                        'ICN': 0,
                        'ICO': 0,
                        'ICOS': 0,
                        'IND': 0,
                        'INDI': 0,
                        'ITS': 0,
                        'IXT': 0,
                        'KBR': 0,
                        'KICK': 0,
                        'LA': 0,
                        'LAT': 0,
                        'LIFE': 0,
                        'LRC': 0,
                        'LSK': 0,
                        'LUN': 0,
                        'MAID': 0,
                        'MANA': 0,
                        'MCAP': 0,
                        'MIPS': 0,
                        'MNE': 0,
                        'MSP': 0,
                        'MTH': 0,
                        'MYB': 0,
                        'NDC': 0,
                        'NEBL': 0,
                        'NET': 0,
                        'NTO': 0,
                        'NXC': 0,
                        'NXT': 0,
                        'OAX': 0,
                        'ODN': 0,
                        'OMG': 0,
                        'OPT': 0,
                        'ORME': 0,
                        'OTN': 0,
                        'PAY': 0,
                        'PIX': 0,
                        'PLBT': 0,
                        'PLR': 0,
                        'PLU': 0,
                        'POE': 0,
                        'POLL': 0,
                        'PPT': 0,
                        'PRE': 0,
                        'PRG': 0,
                        'PRO': 0,
                        'PRS': 0,
                        'PTOY': 0,
                        'QAU': 0,
                        'QCN': 0,
                        'QTUM': 0,
                        'QVT': 0,
                        'REP': 0,
                        'RKC': 0,
                        'RVT': 0,
                        'SAN': 0,
                        'SBD': 0,
                        'SCL': 0,
                        'SISA': 0,
                        'SKIN': 0,
                        'SMART': 0,
                        'SMS': 0,
                        'SNC': 0,
                        'SNGLS': 0,
                        'SNM': 0,
                        'SNT': 0,
                        'STEEM': 0,
                        'STRAT': 0,
                        'STU': 0,
                        'STX': 0,
                        'SUB': 0,
                        'SUR': 0,
                        'SWT': 0,
                        'TAAS': 0,
                        'TBT': 0,
                        'TFL': 0,
                        'TIME': 0,
                        'TIX': 0,
                        'TKN': 0,
                        'TKR': 0,
                        'TNT': 0,
                        'TRST': 0,
                        'TRX': 0,
                        'UET': 0,
                        'UGT': 0,
                        'VEN': 0,
                        'VERI': 0,
                        'VIB': 0,
                        'VIBE': 0,
                        'VOISE': 0,
                        'WEALTH': 0,
                        'WINGS': 0,
                        'WTC': 0,
                        'XAUR': 0,
                        'XDN': 0,
                        'XEM': 0,
                        'XUC': 0,
                        'YOYOW': 0,
                        'ZAP': 0,
                        'ZRX': 0,
                        'ZSC': 0,
                    },
                },
            },
        });
    }

    commonCurrencyCode (currency) {
        if (currency == 'CAT')
            return 'BitClave';
        return currency;
    }

    currencyId (currency) {
        if (currency == 'BitClave')
            return 'CAT';
        return currency;
    }

    feeToPrecision (symbol, fee) {
        return this.truncate (fee, 8);
    }

    async fetchMarkets () {
        let markets = await this.publicGetSymbol ();
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['id'];
            let base = market['baseCurrency'];
            let quote = market['quoteCurrency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let lot = parseFloat (market['quantityIncrement']);
            let step = parseFloat (market['tickSize']);
            let precision = {
                'price': this.precisionFromString (market['tickSize']),
                'amount': this.precisionFromString (market['quantityIncrement']),
            };
            let taker = parseFloat (market['takeLiquidityRate']);
            let maker = parseFloat (market['provideLiquidityRate']);
            result.push (this.extend (this.fees['trading'], {
                'info': market,
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': true,
                'lot': lot,
                'step': step,
                'taker': taker,
                'maker': maker,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': step,
                        'max': undefined,
                    },
                    'cost': {
                        'min': lot * step,
                        'max': undefined,
                    },
                },
            }));
        }
        return result;
    }

    async fetchCurrencies (params = {}) {
        let currencies = await this.publicGetCurrency (params);
        let result = {};
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let id = currency['id'];
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            let precision = {
                'amount': 8, // default precision, todo: fix "magic constants"
                'price': 8,
            };
            let code = this.commonCurrencyCode (id);
            let payin = currency['payinEnabled'];
            let payout = currency['payoutEnabled'];
            let transfer = currency['transferEnabled'];
            let active = payin && payout && transfer;
            let status = 'ok';
            if ('disabled' in currency)
                if (currency['disabled'])
                    status = 'disabled';
            let type = (currency['crypto']) ? 'crypto' : 'fiat';
            result[code] = {
                'id': id,
                'code': code,
                'type': type,
                'payin': payin,
                'payout': payout,
                'transfer': transfer,
                'info': currency,
                'name': currency['fullName'],
                'active': active,
                'status': status,
                'fee': undefined, // todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision['amount']),
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': undefined,
                        'max': Math.pow (10, precision['amount']),
                    },
                },
            };
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let type = this.safeString (params, 'type', 'trading');
        let method = 'privateGet' + this.capitalize (type) + 'Balance';
        let balances = await this[method] ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let code = balance['currency'];
            let currency = this.commonCurrencyCode (code);
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['reserved']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['timestamp']);
        return [
            timestamp,
            parseFloat (ohlcv['open']),
            parseFloat (ohlcv['max']),
            parseFloat (ohlcv['min']),
            parseFloat (ohlcv['close']),
            parseFloat (ohlcv['volumeQuote']),
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'period': this.timeframes[timeframe],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.publicGetCandlesSymbol (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bid', 'ask', 'price', 'size');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.parse8601 (ticker['timestamp']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'open'),
            'close': this.safeFloat (ticker, 'close'),
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': this.safeFloat (ticker, 'volumeQuote'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker (params);
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker['symbol'];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        if ('message' in ticker)
            throw new ExchangeError (this.id + ' ' + ticker['message']);
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['timestamp']);
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            let id = trade['symbol'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                symbol = id;
            }
        }
        let fee = undefined;
        if ('fee' in trade) {
            let currency = market ? market['quote'] : undefined;
            fee = {
                'cost': parseFloat (trade['fee']),
                'currency': currency,
            };
        }
        let orderId = undefined;
        if ('clientOrderId' in trade)
            orderId = trade['clientOrderId'];
        let price = parseFloat (trade['price']);
        let amount = parseFloat (trade['quantity']);
        let cost = price * amount;
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': orderId,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': undefined,
            'side': trade['side'],
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let clientOrderId = this.uuid ();
        // their max accepted length is 32 characters
        clientOrderId = clientOrderId.replace ('-', '');
        clientOrderId = clientOrderId.slice (0, 32);
        amount = parseFloat (amount);
        let request = {
            'clientOrderId': clientOrderId,
            'symbol': market['id'],
            'side': side,
            'quantity': this.amountToPrecision (symbol, amount),
            'type': type,
        };
        if (type == 'limit') {
            request['price'] = this.priceToPrecision (symbol, price);
        } else {
            request['timeInForce'] = 'FOK';
        }
        let response = await this.privatePostOrder (this.extend (request, params));
        let order = this.parseOrder (response);
        let id = order['id'];
        this.orders[id] = order;
        return order;
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteOrderClientOrderId (this.extend ({
            'clientOrderId': id,
        }, params));
    }

    parseOrder (order, market = undefined) {
        let created = undefined;
        if ('createdAt' in order)
            created = this.parse8601 (order['createdAt']);
        let updated = undefined;
        if ('updatedAt' in order)
            updated = this.parse8601 (order['updatedAt']);
        if (!market)
            market = this.markets_by_id[order['symbol']];
        let symbol = market['symbol'];
        let amount = this.safeFloat (order, 'quantity');
        let filled = this.safeFloat (order, 'cumQuantity');
        let status = order['status'];
        if (status == 'new') {
            status = 'open';
        } else if (status == 'suspended') {
            status = 'open';
        } else if (status == 'partiallyFilled') {
            status = 'open';
        } else if (status == 'filled') {
            status = 'closed';
        }
        let id = order['clientOrderId'].toString ();
        let price = this.safeFloat (order, 'price');
        if (typeof price == 'undefined') {
            if (id in this.orders)
                price = this.orders[id].price;
        }
        let remaining = undefined;
        let cost = undefined;
        if (typeof amount != 'undefined') {
            if (typeof filled != 'undefined') {
                remaining = amount - filled;
                if (typeof price != 'undefined') {
                    cost = filled * price;
                }
            }
        }
        return {
            'id': id,
            'timestamp': created,
            'datetime': this.iso8601 (created),
            'created': created,
            'updated': updated,
            'status': status,
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'amount': amount,
            'cost': cost,
            'filled': filled,
            'remaining': remaining,
            'fee': undefined,
            'info': order,
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetHistoryOrder (this.extend ({
            'clientOrderId': id,
        }, params));
        let numOrders = response.length;
        if (numOrders > 0)
            return this.parseOrder (response[0]);
        throw new OrderNotFound (this.id + ' order ' + id + ' not found');
    }

    async fetchActiveOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetOrderClientOrderId (this.extend ({
            'clientOrderId': id,
        }, params));
        return this.parseOrder (response);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {};
        if (symbol) {
            market = this.market (symbol);
            request['symbol'] = market['id'];
        }
        let response = await this.privateGetOrder (this.extend (request, params));
        return this.parseOrders (response, market, since, limit);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {};
        if (symbol) {
            market = this.market (symbol);
            request['symbol'] = market['id'];
        }
        if (limit)
            request['limit'] = limit;
        if (since) {
            request['from'] = this.iso8601 (since);
        }
        let response = await this.privateGetHistoryOrder (this.extend (request, params));
        return this.parseOrders (response, market, since, limit);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {
            // 'symbol': 'BTC/USD', // optional
            // 'sort': 'DESC', // or 'ASC'
            // 'by': 'timestamp', // or 'id'	String	timestamp by default, or id
            // 'from':	'Datetime or Number', // ISO 8601
            // 'till':	'Datetime or Number',
            // 'limit': 100,
            // 'offset': 0,
        };
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['symbol'] = market['id'];
        }
        if (since)
            request['from'] = this.iso8601 (since);
        if (limit)
            request['limit'] = limit;
        let response = await this.privateGetHistoryTrades (this.extend (request, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privatePostAccountCryptoAddressCurrency ({
            'currency': currencyId,
        });
        let address = response['address'];
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async fetchDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privateGetAccountCryptoAddressCurrency ({
            'currency': currencyId,
        });
        let address = response['address'];
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        let currencyId = this.currencyId (currency);
        amount = parseFloat (amount);
        let response = await this.privatePostAccountCryptoWithdraw (this.extend ({
            'currency': currencyId,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/api' + '/' + this.version + '/';
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            url += api + '/' + this.implodeParams (path, params);
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            url += this.implodeParams (path, params);
            if (method == 'GET') {
                if (Object.keys (query).length)
                    url += '?' + this.urlencode (query);
            } else {
                if (Object.keys (query).length)
                    body = this.json (query);
            }
            let payload = this.encode (this.apiKey + ':' + this.secret);
            let auth = this.stringToBase64 (payload);
            headers = {
                'Authorization': "Basic " + this.decode (auth),
                'Content-Type': 'application/json',
            };
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                if ('error' in response) {
                    if ('message' in response['error']) {
                        let message = response['error']['message'];
                        if (message == 'Order not found') {
                            throw new OrderNotFound (this.id + ' order not found in active orders');
                        } else if (message == 'Insufficient funds') {
                            throw new InsufficientFunds (this.id + ' ' + message);
                        }
                    }
                }
            }
            throw new ExchangeError (this.id + ' ' + body);
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/errors":10,"./hitbtc":62}],64:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class huobi extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'huobi',
            'name': 'Huobi',
            'countries': 'CN',
            'rateLimit': 2000,
            'version': 'v3',
            'hasCORS': false,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1m': '001',
                '5m': '005',
                '15m': '015',
                '30m': '030',
                '1h': '060',
                '1d': '100',
                '1w': '200',
                '1M': '300',
                '1y': '400',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                'api': 'http://api.huobi.com',
                'www': 'https://www.huobi.com',
                'doc': 'https://github.com/huobiapi/API_Docs_en/wiki',
            },
            'api': {
                'staticmarket': {
                    'get': [
                        '{id}_kline_{period}',
                        'ticker_{id}',
                        'depth_{id}',
                        'depth_{id}_{length}',
                        'detail_{id}',
                    ],
                },
                'usdmarket': {
                    'get': [
                        '{id}_kline_{period}',
                        'ticker_{id}',
                        'depth_{id}',
                        'depth_{id}_{length}',
                        'detail_{id}',
                    ],
                },
                'trade': {
                    'post': [
                        'get_account_info',
                        'get_orders',
                        'order_info',
                        'buy',
                        'sell',
                        'buy_market',
                        'sell_market',
                        'cancel_order',
                        'get_new_deal_orders',
                        'get_order_id_by_trade_id',
                        'withdraw_coin',
                        'cancel_withdraw_coin',
                        'get_withdraw_coin_result',
                        'transfer',
                        'loan',
                        'repayment',
                        'get_loan_available',
                        'get_loans',
                    ],
                },
            },
            'markets': {
                'BTC/CNY': { 'id': 'btc', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'type': 'staticmarket', 'coinType': 1 },
                'LTC/CNY': { 'id': 'ltc', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'type': 'staticmarket', 'coinType': 2 },
                // 'BTC/USD': { 'id': 'btc', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'type': 'usdmarket',    'coinType': 1 },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.tradePostGetAccountInfo ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            let available = 'available_' + lowercase + '_display';
            let frozen = 'frozen_' + lowercase + '_display';
            let loan = 'loan_' + lowercase + '_display';
            if (available in balances)
                account['free'] = parseFloat (balances[available]);
            if (frozen in balances)
                account['used'] = parseFloat (balances[frozen]);
            if (loan in balances)
                account['used'] = this.sum (account['used'], parseFloat (balances[loan]));
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetDepthId';
        let orderbook = await this[method] (this.extend ({ 'id': market['id'] }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetTickerId';
        let response = await this[method] (this.extend ({
            'id': market['id'],
        }, params));
        let ticker = response['ticker'];
        let timestamp = parseInt (response['time']) * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'open'),
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': this.safeFloat (ticker, 'vol'),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['ts'];
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['direction'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetDetailId';
        let response = await this[method] (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market, since, limit);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        // not implemented yet
        return [
            ohlcv[0],
            ohlcv[1],
            ohlcv[2],
            ohlcv[3],
            ohlcv[4],
            ohlcv[6],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetIdKlinePeriod';
        let ohlcvs = await this[method] (this.extend ({
            'id': market['id'],
            'period': this.timeframes[timeframe],
        }, params));
        return ohlcvs;
        // return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let method = 'tradePost' + this.capitalize (side);
        let order = {
            'coin_type': market['coinType'],
            'amount': amount,
            'market': market['quote'].toLowerCase (),
        };
        if (type == 'limit')
            order['price'] = price;
        else
            method += this.capitalize (type);
        let response = this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.tradePostCancelOrder ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'];
        if (api == 'trade') {
            this.checkRequiredCredentials ();
            url += '/api' + this.version;
            let query = this.keysort (this.extend ({
                'method': path,
                'access_key': this.apiKey,
                'created': this.nonce (),
            }, params));
            let queryString = this.urlencode (this.omit (query, 'market'));
            // secret key must be appended to the query before signing
            queryString += '&secret_key=' + this.secret;
            query['sign'] = this.hash (this.encode (queryString));
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        } else {
            url += '/' + api + '/' + this.implodeParams (path, params) + '_json.js';
            let query = this.omit (params, this.extractParams (path));
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'trade', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        if ('code' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],65:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const huobipro = require ('./huobipro.js')

// ---------------------------------------------------------------------------

module.exports = class huobicny extends huobipro {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'huobicny',
            'name': 'Huobi CNY',
            'hostname': 'be.huobi.com',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                'api': 'https://be.huobi.com',
                'www': 'https://www.huobi.com',
                'doc': 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
            },
        });
    }
}

},{"./huobipro.js":66}],66:[function(require,module,exports){
"use strict";


//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class huobipro extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'huobipro',
            'name': 'Huobi Pro',
            'countries': 'CN',
            'rateLimit': 2000,
            'version': 'v1',
            'accounts': undefined,
            'accountsById': undefined,
            'hostname': 'api.huobi.pro',
            'hasCORS': false,
            // obsolete metainfo structure
            'hasFetchOHLCV': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            // new metainfo structure
            'has': {
                'fetchOHCLV': true,
                'fetchOrders': true,
                'fetchOpenOrders': true,
            },
            'timeframes': {
                '1m': '1min',
                '5m': '5min',
                '15m': '15min',
                '30m': '30min',
                '1h': '60min',
                '1d': '1day',
                '1w': '1week',
                '1M': '1mon',
                '1y': '1year',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
                'api': 'https://api.huobi.pro',
                'www': 'https://www.huobi.pro',
                'doc': 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
            },
            'api': {
                'market': {
                    'get': [
                        'history/kline', // 获取K线数据
                        'detail/merged', // 获取聚合行情(Ticker)
                        'depth', // 获取 Market Depth 数据
                        'trade', // 获取 Trade Detail 数据
                        'history/trade', // 批量获取最近的交易记录
                        'detail', // 获取 Market Detail 24小时成交量数据
                    ],
                },
                'public': {
                    'get': [
                        'common/symbols', // 查询系统支持的所有交易对
                        'common/currencys', // 查询系统支持的所有币种
                        'common/timestamp', // 查询系统当前时间
                    ],
                },
                'private': {
                    'get': [
                        'account/accounts', // 查询当前用户的所有账户(即account-id)
                        'account/accounts/{id}/balance', // 查询指定账户的余额
                        'order/orders/{id}', // 查询某个订单详情
                        'order/orders/{id}/matchresults', // 查询某个订单的成交明细
                        'order/orders', // 查询当前委托、历史委托
                        'order/matchresults', // 查询当前成交、历史成交
                        'dw/withdraw-virtual/addresses', // 查询虚拟币提现地址
                    ],
                    'post': [
                        'order/orders/place', // 创建并执行一个新订单 (一步下单， 推荐使用)
                        'order/orders', // 创建一个新的订单请求 （仅创建订单，不执行下单）
                        'order/orders/{id}/place', // 执行一个订单 （仅执行已创建的订单）
                        'order/orders/{id}/submitcancel', // 申请撤销一个订单请求
                        'order/orders/batchcancel', // 批量撤销订单
                        'dw/balance/transfer', // 资产划转
                        'dw/withdraw-virtual/create', // 申请提现虚拟币
                        'dw/withdraw-virtual/{id}/place', // 确认申请虚拟币提现
                        'dw/withdraw-virtual/{id}/cancel', // 申请取消提现虚拟币
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetCommonSymbols ();
        let markets = response['data'];
        let numMarkets = markets.length;
        if (numMarkets < 1)
            throw new ExchangeError (this.id + ' publicGetCommonSymbols returned empty response: ' + this.json (response));
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let baseId = market['base-currency'];
            let quoteId = market['quote-currency'];
            let base = baseId.toUpperCase ();
            let quote = quoteId.toUpperCase ();
            let id = baseId + quoteId;
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': market['amount-precision'],
                'price': market['price-precision'],
            };
            let lot = Math.pow (10, -precision['amount']);
            let maker = (base == 'OMG') ? 0 : 0.2 / 100;
            let taker = (base == 'OMG') ? 0 : 0.2 / 100;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'lot': lot,
                'precision': precision,
                'taker': taker,
                'maker': maker,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': 0,
                        'max': undefined,
                    },
                },
                'info': market,
            });
        }
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let last = undefined;
        if ('last' in ticker)
            last = ticker['last'];
        let timestamp = this.milliseconds ();
        if ('ts' in ticker)
            timestamp = ticker['ts'];
        let bid = undefined;
        let ask = undefined;
        if ('bid' in ticker) {
            if (ticker['bid'])
                bid = this.safeFloat (ticker['bid'], 0);
        }
        if ('ask' in ticker) {
            if (ticker['ask'])
                ask = this.safeFloat (ticker['ask'], 0);
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': ticker['open'],
            'close': ticker['close'],
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['amount']),
            'quoteVolume': ticker['vol'],
            'info': ticker,
        };
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetDepth (this.extend ({
            'symbol': market['id'],
            'type': 'step0',
        }, params));
        return this.parseOrderBook (response['tick'], response['tick']['ts']);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetDetailMerged (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (response['tick'], market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['ts'];
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['direction'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    parseTradesData (data, market, since = undefined, limit = undefined) {
        let result = [];
        for (let i = 0; i < data.length; i++) {
            let trades = this.parseTrades (data[i]['data'], market, since, limit);
            for (let k = 0; k < trades.length; k++) {
                result.push (trades[k]);
            }
        }
        return result;
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetHistoryTrade (this.extend ({
            'symbol': market['id'],
            'size': 2000,
        }, params));
        return this.parseTradesData (response['data'], market, since, limit);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv['id'] * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['vol'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetHistoryKline (this.extend ({
            'symbol': market['id'],
            'period': this.timeframes[timeframe],
            'size': 2000, // max = 2000
        }, params));
        return this.parseOHLCVs (response['data'], market, timeframe, since, limit);
    }

    async loadAccounts (reload = false) {
        if (reload) {
            this.accounts = await this.fetchAccounts ();
        } else {
            if (this.accounts) {
                return this.accounts;
            } else {
                this.accounts = await this.fetchAccounts ();
                this.accountsById = this.indexBy (this.accounts, 'id');
            }
        }
        return this.accounts;
    }

    async fetchAccounts () {
        await this.loadMarkets ();
        let response = await this.privateGetAccountAccounts ();
        return response['data'];
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        await this.loadAccounts ();
        let response = await this.privateGetAccountAccountsIdBalance (this.extend ({
            'id': this.accounts[0]['id'],
        }, params));
        let balances = response['data']['list'];
        let result = { 'info': response };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let uppercase = balance['currency'].toUpperCase ();
            let currency = this.commonCurrencyCode (uppercase);
            let account = undefined;
            if (currency in result)
                account = result[currency];
            else
                account = this.account ();
            if (balance['type'] == 'trade')
                account['free'] = parseFloat (balance['balance']);
            if (balance['type'] == 'frozen')
                account['used'] = parseFloat (balance['balance']);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrders() requires a symbol parameter');
        this.load_markets ();
        let market = this.market (symbol);
        let status = undefined;
        if ('type' in params) {
            status = params['type'];
        } else if ('status' in params) {
            status = params['status'];
        } else {
            throw new ExchangeError (this.id + ' fetchOrders() requires type param or status param for spot market ' + symbol + '(0 or "open" for unfilled or partial filled orders, 1 or "closed" for filled orders)');
        }
        if ((status == 0) || (status == 'open')) {
            status = 'submitted,partial-filled';
        } else if ((status == 1) || (status == 'closed')) {
            status = 'filled,partial-canceled';
        } else {
            throw new ExchangeError (this.id + ' fetchOrders() wrong type param or status param for spot market ' + symbol + '(0 or "open" for unfilled or partial filled orders, 1 or "closed" for filled orders)');
        }
        let response = await this.privateGetOrderOrders (this.extend ({
            'symbol': market['id'],
            'states': status,
        }));
        return this.parseOrders (response['data'], market, since, limit);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let open = 0; // 0 for unfilled orders, 1 for filled orders
        return this.fetchOrders (symbol, undefined, undefined, this.extend ({
            'status': open,
        }, params));
    }

    parseOrderStatus (status) {
        if (status == 'partial-filled') {
            return 'open';
        } else if (status == 'filled') {
            return 'closed';
        } else if (status == 'canceled') {
            return 'canceled';
        } else if (status == 'submitted') {
            return 'open';
        }
        return status;
    }

    parseOrder (order, market = undefined) {
        let side = undefined;
        let type = undefined;
        let status = undefined;
        if ('type' in order) {
            let orderType = order['type'].split ('-');
            side = orderType[0];
            type = orderType[1];
            status = this.parseOrderStatus (order['state']);
        }
        let symbol = undefined;
        if (!market) {
            if ('symbol' in order) {
                if (order['symbol'] in this.markets_by_id) {
                    let marketId = order['symbol'];
                    market = this.markets_by_id[marketId];
                }
            }
        }
        if (market)
            symbol = market['symbol'];
        let timestamp = order['created-at'];
        let amount = parseFloat (order['amount']);
        let filled = parseFloat (order['field-amount']);
        let remaining = amount - filled;
        let price = parseFloat (order['price']);
        let cost = parseFloat (order['field-cash-amount']);
        let average = 0;
        if (filled)
            average = parseFloat (cost / filled);
        let result = {
            'info': order,
            'id': order['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'average': average,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': undefined,
        };
        return result;
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        await this.loadAccounts ();
        let market = this.market (symbol);
        let order = {
            'account-id': this.accounts[0]['id'],
            'amount': this.amountToPrecision (symbol, amount),
            'symbol': market['id'],
            'type': side + '-' + type,
        };
        if (type == 'limit')
            order['price'] = this.priceToPrecision (symbol, price);
        let response = await this.privatePostOrderOrdersPlace (this.extend (order, params));
        return {
            'info': response,
            'id': response['data'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostOrderOrdersIdSubmitcancel ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/';
        if (api == 'market')
            url += api;
        else
            url += this.version;
        url += '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let timestamp = this.YmdHMS (this.milliseconds (), 'T');
            let request = this.keysort (this.extend ({
                'SignatureMethod': 'HmacSHA256',
                'SignatureVersion': '2',
                'AccessKeyId': this.apiKey,
                'Timestamp': timestamp,
            }, query));
            let auth = this.urlencode (request);
            let payload = [ method, this.hostname, url, auth ].join ("\n");
            let signature = this.hmac (this.encode (payload), this.encode (this.secret), 'sha256', 'base64');
            auth += '&' + this.urlencode ({ 'Signature': signature });
            url += '?' + auth;
            if (method == 'POST') {
                body = this.json (query);
                headers = {
                    'Content-Type': 'application/json',
                };
            }
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],67:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

//  ---------------------------------------------------------------------------

module.exports = class independentreserve extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'independentreserve',
            'name': 'Independent Reserve',
            'countries': [ 'AU', 'NZ' ], // Australia, New Zealand
            'rateLimit': 1000,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30521662-cf3f477c-9bcb-11e7-89bc-d1ac85012eda.jpg',
                'api': {
                    'public': 'https://api.independentreserve.com/Public',
                    'private': 'https://api.independentreserve.com/Private',
                },
                'www': 'https://www.independentreserve.com',
                'doc': 'https://www.independentreserve.com/API',
            },
            'api': {
                'public': {
                    'get': [
                        'GetValidPrimaryCurrencyCodes',
                        'GetValidSecondaryCurrencyCodes',
                        'GetValidLimitOrderTypes',
                        'GetValidMarketOrderTypes',
                        'GetValidOrderTypes',
                        'GetValidTransactionTypes',
                        'GetMarketSummary',
                        'GetOrderBook',
                        'GetTradeHistorySummary',
                        'GetRecentTrades',
                        'GetFxRates',
                    ],
                },
                'private': {
                    'post': [
                        'PlaceLimitOrder',
                        'PlaceMarketOrder',
                        'CancelOrder',
                        'GetOpenOrders',
                        'GetClosedOrders',
                        'GetClosedFilledOrders',
                        'GetOrderDetails',
                        'GetAccounts',
                        'GetTransactions',
                        'GetDigitalCurrencyDepositAddress',
                        'GetDigitalCurrencyDepositAddresses',
                        'SynchDigitalCurrencyDepositAddressWithBlockchain',
                        'WithdrawDigitalCurrency',
                        'RequestFiatWithdrawal',
                        'GetTrades',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let baseCurrencies = await this.publicGetValidPrimaryCurrencyCodes ();
        let quoteCurrencies = await this.publicGetValidSecondaryCurrencyCodes ();
        let result = [];
        for (let i = 0; i < baseCurrencies.length; i++) {
            let baseId = baseCurrencies[i];
            let baseIdUppercase = baseId.toUpperCase ();
            let base = this.commonCurrencyCode (baseIdUppercase);
            for (let j = 0; j < quoteCurrencies.length; j++) {
                let quoteId = quoteCurrencies[j];
                let quoteIdUppercase = quoteId.toUpperCase ();
                let quote = this.commonCurrencyCode (quoteIdUppercase);
                let id = baseId + '/' + quoteId;
                let symbol = base + '/' + quote;
                let taker = 0.5 / 100;
                let maker = 0.5 / 100;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'taker': taker,
                    'maker': maker,
                    'info': id,
                });
            }
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostGetAccounts ();
        let result = { 'info': balances };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let currencyCode = balance['CurrencyCode'];
            let uppercase = currencyCode.toUpperCase ();
            let currency = this.commonCurrencyCode (uppercase);
            let account = this.account ();
            account['free'] = balance['AvailableBalance'];
            account['total'] = balance['TotalBalance'];
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOrderBook (this.extend ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
        }, params));
        let timestamp = this.parse8601 (response['CreatedTimestampUtc']);
        return this.parseOrderBook (response, timestamp, 'BuyOrders', 'SellOrders', 'Price', 'Volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.parse8601 (ticker['CreatedTimestampUtc']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['DayHighestPrice'],
            'low': ticker['DayLowestPrice'],
            'bid': ticker['CurrentHighestBidPrice'],
            'ask': ticker['CurrentLowestOfferPrice'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': ticker['LastPrice'],
            'change': undefined,
            'percentage': undefined,
            'average': ticker['DayAvgPrice'],
            'baseVolume': ticker['DayVolumeXbtInSecondaryCurrrency'],
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketSummary (this.extend ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
        }, params));
        return this.parseTicker (response, market);
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['TradeTimestampUtc']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['SecondaryCurrencyTradePrice'],
            'amount': trade['PrimaryCurrencyAmount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetRecentTrades (this.extend ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
            'numberOfRecentTradesToRetrieve': 50, // max = 50
        }, params));
        return this.parseTrades (response['Trades'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let capitalizedOrderType = this.capitalize (type);
        let method = 'Place' + capitalizedOrderType + 'Order';
        let orderType = capitalizedOrderType;
        orderType += (side == 'sell') ?  'Offer' : 'Bid';
        let order = this.ordered ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
            'orderType': orderType,
        });
        if (type == 'limit')
            order['price'] = price;
        order['volume'] = amount;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['OrderGuid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'orderGuid': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let auth = [
                url,
                'apiKey=' + this.apiKey,
                'nonce=' + nonce.toString (),
            ];
            let keysorted = this.keysort (params);
            let keys = Object.keys (keysorted);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                auth.push (key + '=' + params[key]);
            }
            let message = auth.join (',');
            let signature = this.hmac (this.encode (message), this.encode (this.secret));
            let query = this.keysort (this.extend ({
                'apiKey': this.apiKey,
                'nonce': nonce,
                'signature': signature,
            }, params));
            body = this.json (query);
            headers = { 'Content-Type': 'application/json' };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        // todo error handling
        return response;
    }
}

},{"./base/Exchange":8}],68:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class itbit extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'itbit',
            'name': 'itBit',
            'countries': 'US',
            'rateLimit': 2000,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg',
                'api': 'https://api.itbit.com',
                'www': 'https://www.itbit.com',
                'doc': [
                    'https://api.itbit.com/docs',
                    'https://www.itbit.com/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'markets/{symbol}/ticker',
                        'markets/{symbol}/order_book',
                        'markets/{symbol}/trades',
                    ],
                },
                'private': {
                    'get': [
                        'wallets',
                        'wallets/{walletId}',
                        'wallets/{walletId}/balances/{currencyCode}',
                        'wallets/{walletId}/funding_history',
                        'wallets/{walletId}/trades',
                        'wallets/{walletId}/orders/{id}',
                    ],
                    'post': [
                        'wallet_transfers',
                        'wallets',
                        'wallets/{walletId}/cryptocurrency_deposits',
                        'wallets/{walletId}/cryptocurrency_withdrawals',
                        'wallets/{walletId}/orders',
                        'wire_withdrawal',
                    ],
                    'delete': [
                        'wallets/{walletId}/orders/{id}',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'XBTUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
                'BTC/SGD': { 'id': 'XBTSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
                'BTC/EUR': { 'id': 'XBTEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
            },
            'fees': {
                'trading': {
                    'maker': 0,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetMarketsSymbolOrderBook (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetMarketsSymbolTicker (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        let serverTimeUTC = ('serverTimeUTC' in ticker);
        if (!serverTimeUTC)
            throw new ExchangeError (this.id + ' fetchTicker returned a bad response: ' + this.json (ticker));
        let timestamp = this.parse8601 (ticker['serverTimeUTC']);
        let vwap = parseFloat (ticker['vwap24h']);
        let baseVolume = parseFloat (ticker['volume24h']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24h']),
            'low': parseFloat (ticker['low24h']),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': vwap,
            'open': parseFloat (ticker['openToday']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['timestamp']);
        let id = trade['matchNumber'].toString ();
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': id,
            'order': id,
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketsSymbolTrades (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response['recentTrades'], market, since, limit);
    }

    async fetchBalance (params = {}) {
        let response = await this.privateGetBalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['availableBalance']),
                'used': 0.0,
                'total': parseFloat (balance['totalBalance']),
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    fetchWallets () {
        return this.privateGetWallets ();
    }

    nonce () {
        return this.milliseconds ();
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let walletIdInParams = ('walletId' in params);
        if (!walletIdInParams)
            throw new ExchangeError (this.id + ' createOrder requires a walletId parameter');
        amount = amount.toString ();
        price = price.toString ();
        let market = this.market (symbol);
        let order = {
            'side': side,
            'type': type,
            'currency': market['base'],
            'amount': amount,
            'display': amount,
            'price': price,
            'instrument': market['id'],
        };
        let response = await this.privatePostTradeAdd (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        let walletIdInParams = ('walletId' in params);
        if (!walletIdInParams)
            throw new ExchangeError (this.id + ' cancelOrder requires a walletId parameter');
        return await this.privateDeleteWalletsWalletIdOrdersId (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            if (Object.keys (query).length)
                body = this.json (query);
            else
                body = '';
            let nonce = this.nonce ().toString ();
            let timestamp = nonce;
            let auth = [ method, url, body, nonce, timestamp ];
            let message = nonce + this.json (auth);
            let hash = this.hash (this.encode (message), 'sha256', 'binary');
            let binhash = this.binaryConcat (url, hash);
            let signature = this.hmac (binhash, this.encode (this.secret), 'sha512', 'base64');
            headers = {
                'Authorization': self.apiKey + ':' + signature,
                'Content-Type': 'application/json',
                'X-Auth-Timestamp': timestamp,
                'X-Auth-Nonce': nonce,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('code' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],69:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const btcbox = require ('./btcbox.js')

// ---------------------------------------------------------------------------

module.exports = class jubi extends btcbox {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'jubi',
            'name': 'jubi.com',
            'countries': 'CN',
            'rateLimit': 1500,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766581-9d397d9a-5edd-11e7-8fb9-5d8236c0e692.jpg',
                'api': 'https://www.jubi.com/api',
                'www': 'https://www.jubi.com',
                'doc': 'https://www.jubi.com/help/api.html',
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetAllticker ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let base = id.toUpperCase ();
            let quote = 'CNY'; // todo
            let symbol = base + '/' + quote;
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': id,
            });
        }
        return result;
    }
}

},{"./btcbox.js":30}],70:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeNotAvailable, ExchangeError, OrderNotFound, DDoSProtection, InvalidNonce, InsufficientFunds, CancelPending, InvalidOrder } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class kraken extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'kraken',
            'name': 'Kraken',
            'countries': 'US',
            'version': '0',
            'rateLimit': 3000,
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'hasFetchOrder': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchMyTrades': true,
            'hasWithdraw': true,
            'hasFetchCurrencies': true,
            // new metainfo interface
            'has': {
                'fetchCurrencies': true,
                'fetchTickers': true,
                'fetchOHLCV': true,
                'fetchOrder': true,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
                'fetchMyTrades': true,
                'withdraw': true,
            },
            'marketsByAltname': {},
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '4h': '240',
                '1d': '1440',
                '1w': '10080',
                '2w': '21600',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766599-22709304-5ede-11e7-9de1-9f33732e1509.jpg',
                'api': 'https://api.kraken.com',
                'www': 'https://www.kraken.com',
                'doc': [
                    'https://www.kraken.com/en-us/help/api',
                    'https://github.com/nothingisdead/npm-kraken-api',
                ],
                'fees': [
                    'https://www.kraken.com/en-us/help/fees',
                    'https://support.kraken.com/hc/en-us/articles/201396777-What-are-the-deposit-fees-',
                    'https://support.kraken.com/hc/en-us/articles/201893608-What-are-the-withdrawal-fees-',
                ],
            },
            'fees': {
                'trading': {
                    'tierBased': true,
                    'percentage': true,
                    'taker': 0.26 / 100,
                    'maker': 0.16 / 100,
                    'tiers': {
                        'taker': [
                            [0, 0.26 / 100],
                            [50000, 0.24 / 100],
                            [100000, 0.22 / 100],
                            [250000, 0.2 / 100],
                            [500000, 0.18 / 100],
                            [1000000, 0.16 / 100],
                            [2500000, 0.14 / 100],
                            [5000000, 0.12 / 100],
                            [10000000, 0.1 / 100],
                        ],
                        'maker': [
                            [0, 0.16 / 100],
                            [50000, 0.14 / 100],
                            [100000, 0.12 / 100],
                            [250000, 0.10 / 100],
                            [500000, 0.8 / 100],
                            [1000000, 0.6 / 100],
                            [2500000, 0.4 / 100],
                            [5000000, 0.2 / 100],
                            [10000000, 0.0 / 100],
                        ],
                    },
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.001,
                        'ETH': 0.005,
                        'XRP': 0.02,
                        'XLM': 0.00002,
                        'LTC': 0.02,
                        'DOGE': 2,
                        'ZEC': 0.00010,
                        'ICN': 0.02,
                        'REP': 0.01,
                        'ETC': 0.005,
                        'MLN': 0.003,
                        'XMR': 0.05,
                        'DASH': 0.005,
                        'GNO': 0.01,
                        'EOS': 0.5,
                        'BCH': 0.001,
                        'USD': 5, // if domestic wire
                        'EUR': 5, // if domestic wire
                        'CAD': 10, // CAD EFT Withdrawal
                        'JPY': 300, // if domestic wire
                    },
                    'deposit': {
                        'BTC': 0,
                        'ETH': 0,
                        'XRP': 0,
                        'XLM': 0,
                        'LTC': 0,
                        'DOGE': 0,
                        'ZEC': 0,
                        'ICN': 0,
                        'REP': 0,
                        'ETC': 0,
                        'MLN': 0,
                        'XMR': 0,
                        'DASH': 0,
                        'GNO': 0,
                        'EOS': 0,
                        'BCH': 0,
                        'USD': 5, // if domestic wire
                        'EUR': 0, // free deposit if EUR SEPA Deposit
                        'CAD': 5, // if domestic wire
                        'JPY': 0, // Domestic Deposit (Free, ¥5,000 deposit minimum)
                    },
                },
            },
            'api': {
                'public': {
                    'get': [
                        'Assets',
                        'AssetPairs',
                        'Depth',
                        'OHLC',
                        'Spread',
                        'Ticker',
                        'Time',
                        'Trades',
                    ],
                },
                'private': {
                    'post': [
                        'AddOrder',
                        'Balance',
                        'CancelOrder',
                        'ClosedOrders',
                        'DepositAddresses',
                        'DepositMethods',
                        'DepositStatus',
                        'Ledgers',
                        'OpenOrders',
                        'OpenPositions',
                        'QueryLedgers',
                        'QueryOrders',
                        'QueryTrades',
                        'TradeBalance',
                        'TradesHistory',
                        'TradeVolume',
                        'Withdraw',
                        'WithdrawCancel',
                        'WithdrawInfo',
                        'WithdrawStatus',
                    ],
                },
            },
        });
    }

    costToPrecision (symbol, cost) {
        return this.truncate (parseFloat (cost), this.markets[symbol]['precision']['price']);
    }

    feeToPrecision (symbol, fee) {
        return this.truncate (parseFloat (fee), this.markets[symbol]['precision']['amount']);
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (body.indexOf ('Invalid nonce') >= 0)
            throw new InvalidNonce (this.id + ' ' + body);
        if (body.indexOf ('Insufficient funds') >= 0)
            throw new InsufficientFunds (this.id + ' ' + body);
        if (body.indexOf ('Cancel pending') >= 0)
            throw new CancelPending (this.id + ' ' + body);
        if (body.indexOf ('Invalid arguments:volume') >= 0)
            throw new InvalidOrder (this.id + ' ' + body);
    }

    async fetchMarkets () {
        let markets = await this.publicGetAssetPairs ();
        let keys = Object.keys (markets['result']);
        let result = [];
        for (let i = 0; i < keys.length; i++) {
            let id = keys[i];
            let market = markets['result'][id];
            let base = market['base'];
            let quote = market['quote'];
            if ((base[0] == 'X') || (base[0] == 'Z'))
                base = base.slice (1);
            if ((quote[0] == 'X') || (quote[0] == 'Z'))
                quote = quote.slice (1);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let darkpool = id.indexOf ('.d') >= 0;
            let symbol = darkpool ? market['altname'] : (base + '/' + quote);
            let maker = undefined;
            if ('fees_maker' in market) {
                maker = parseFloat (market['fees_maker'][0][1]) / 100;
            }
            let precision = {
                'amount': market['lot_decimals'],
                'price': market['pair_decimals'],
            };
            let lot = Math.pow (10, -precision['amount']);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'darkpool': darkpool,
                'info': market,
                'altname': market['altname'],
                'maker': maker,
                'taker': parseFloat (market['fees'][0][1]) / 100,
                'lot': lot,
                'active': true,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': 0,
                        'max': undefined,
                    },
                },
            });
        }
        result = this.appendInactiveMarkets (result);
        this.marketsByAltname = this.indexBy (result, 'altname');
        return result;
    }

    appendInactiveMarkets (result = []) {
        let precision = { 'amount': 8, 'price': 8 };
        let costLimits = { 'min': 0, 'max': undefined };
        let priceLimits = { 'min': Math.pow (10, -precision['price']), 'max': undefined };
        let amountLimits = { 'min': Math.pow (10, -precision['amount']), 'max': Math.pow (10, precision['amount']) };
        let limits = { 'amount': amountLimits, 'price': priceLimits, 'cost': costLimits };
        let defaults = {
            'darkpool': false,
            'info': undefined,
            'maker': undefined,
            'taker': undefined,
            'lot': amountLimits['min'],
            'active': false,
            'precision': precision,
            'limits': limits,
        };
        let markets = [
            { 'id': 'XXLMZEUR', 'symbol': 'XLM/EUR', 'base': 'XLM', 'quote': 'EUR', 'altname': 'XLMEUR' },
        ];
        for (let i = 0; i < markets.length; i++) {
            result.push (this.extend (defaults, markets[i]));
        }
        return result;
    }

    async fetchCurrencies (params = {}) {
        let response = await this.publicGetAssets (params);
        let currencies = response['result'];
        let ids = Object.keys (currencies);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let currency = currencies[id];
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            let code = this.commonCurrencyCode (currency['altname']);
            let precision = {
                'amount': currency['decimals'], // default precision, todo: fix "magic constants"
                'price': currency['decimals'],
            };
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': code,
                'active': true,
                'status': 'ok',
                'fee': undefined,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision['amount']),
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': undefined,
                        'max': Math.pow (10, precision['amount']),
                    },
                },
            };
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let darkpool = symbol.indexOf ('.d') >= 0;
        if (darkpool)
            throw new ExchangeError (this.id + ' does not provide an order book for darkpool symbol ' + symbol);
        let market = this.market (symbol);
        let response = await this.publicGetDepth (this.extend ({
            'pair': market['id'],
        }, params));
        let orderbook = response['result'][market['id']];
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let baseVolume = parseFloat (ticker['v'][1]);
        let vwap = parseFloat (ticker['p'][1]);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['h'][1]),
            'low': parseFloat (ticker['l'][1]),
            'bid': parseFloat (ticker['b'][0]),
            'ask': parseFloat (ticker['a'][0]),
            'vwap': vwap,
            'open': parseFloat (ticker['o']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['c'][0]),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let pairs = [];
        for (let s = 0; s < this.symbols.length; s++) {
            let symbol = this.symbols[s];
            let market = this.markets[symbol];
            if (market['active'])
                if (!market['darkpool'])
                    pairs.push (market['id']);
        }
        let filter = pairs.join (',');
        let response = await this.publicGetTicker (this.extend ({
            'pair': filter,
        }, params));
        let tickers = response['result'];
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let darkpool = symbol.indexOf ('.d') >= 0;
        if (darkpool)
            throw new ExchangeError (this.id + ' does not provide a ticker for darkpool symbol ' + symbol);
        let market = this.market (symbol);
        let response = await this.publicGetTicker (this.extend ({
            'pair': market['id'],
        }, params));
        let ticker = response['result'][market['id']];
        return this.parseTicker (ticker, market);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            parseFloat (ohlcv[1]),
            parseFloat (ohlcv[2]),
            parseFloat (ohlcv[3]),
            parseFloat (ohlcv[4]),
            parseFloat (ohlcv[6]),
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'pair': market['id'],
            'interval': this.timeframes[timeframe],
        };
        if (since)
            request['since'] = parseInt (since / 1000);
        let response = await this.publicGetOHLC (this.extend (request, params));
        let ohlcvs = response['result'][market['id']];
        return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        let side = undefined;
        let type = undefined;
        let price = undefined;
        let amount = undefined;
        let id = undefined;
        let order = undefined;
        let fee = undefined;
        if (!market)
            market = this.findMarketByAltnameOrId (trade['pair']);
        if ('ordertxid' in trade) {
            order = trade['ordertxid'];
            id = trade['id'];
            timestamp = parseInt (trade['time'] * 1000);
            side = trade['type'];
            type = trade['ordertype'];
            price = parseFloat (trade['price']);
            amount = parseFloat (trade['vol']);
            if ('fee' in trade) {
                let currency = undefined;
                if (market)
                    currency = market['quote'];
                fee = {
                    'cost': parseFloat (trade['fee']),
                    'currency': currency,
                };
            }
        } else {
            timestamp = parseInt (trade[2] * 1000);
            side = (trade[3] == 's') ? 'sell' : 'buy';
            type = (trade[4] == 'l') ? 'limit' : 'market';
            price = parseFloat (trade[0]);
            amount = parseFloat (trade[1]);
        }
        let symbol = (market) ? market['symbol'] : undefined;
        return {
            'id': id,
            'order': order,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let id = market['id'];
        let response = await this.publicGetTrades (this.extend ({
            'pair': id,
        }, params));
        let trades = response['result'][id];
        return this.parseTrades (trades, market, since, limit);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let balances = response['result'];
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let code = currency;
            // X-ISO4217-A3 standard currency codes
            if (code[0] == 'X') {
                code = code.slice (1);
            } else if (code[0] == 'Z') {
                code = code.slice (1);
            }
            code = this.commonCurrencyCode (code);
            let balance = parseFloat (balances[currency]);
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            result[code] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let order = {
            'pair': market['id'],
            'type': side,
            'ordertype': type,
            'volume': this.amountToPrecision (symbol, amount),
        };
        if (type == 'limit')
            order['price'] = this.priceToPrecision (symbol, price);
        let response = await this.privatePostAddOrder (this.extend (order, params));
        let length = response['result']['txid'].length;
        let id = (length > 1) ? response['result']['txid'] : response['result']['txid'][0];
        return {
            'info': response,
            'id': id,
        };
    }

    findMarketByAltnameOrId (id) {
        let result = undefined;
        if (id in this.marketsByAltname) {
            result = this.marketsByAltname[id];
        } else if (id in this.markets_by_id) {
            result = this.markets_by_id[id];
        }
        return result;
    }

    parseOrder (order, market = undefined) {
        let description = order['descr'];
        let side = description['type'];
        let type = description['ordertype'];
        let symbol = undefined;
        if (!market)
            market = this.findMarketByAltnameOrId (description['pair']);
        let timestamp = parseInt (order['opentm'] * 1000);
        let amount = parseFloat (order['vol']);
        let filled = parseFloat (order['vol_exec']);
        let remaining = amount - filled;
        let fee = undefined;
        let cost = this.safeFloat (order, 'cost');
        let price = this.safeFloat (description, 'price');
        if (!price)
            price = this.safeFloat (order, 'price');
        if (market) {
            symbol = market['symbol'];
            if ('fee' in order) {
                let flags = order['oflags'];
                let feeCost = this.safeFloat (order, 'fee');
                fee = {
                    'cost': feeCost,
                    'rate': undefined,
                };
                if (flags.indexOf ('fciq') >= 0) {
                    fee['currency'] = market['quote'];
                } else if (flags.indexOf ('fcib') >= 0) {
                    fee['currency'] = market['base'];
                }
            }
        }
        return {
            'id': order['id'],
            'info': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': order['status'],
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'fee': fee,
            // 'trades': this.parseTrades (order['trades'], market),
        };
    }

    parseOrders (orders, market = undefined, since = undefined, limit = undefined) {
        let result = [];
        let ids = Object.keys (orders);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = this.extend ({ 'id': id }, orders[id]);
            result.push (this.parseOrder (order, market));
        }
        return this.filterBySinceLimit (result, since, limit);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostQueryOrders (this.extend ({
            'trades': true, // whether or not to include trades in output (optional, default false)
            'txid': id, // comma delimited list of transaction ids to query info about (20 maximum)
            // 'userref': 'optional', // restrict results to given user reference id (optional)
        }, params));
        let orders = response['result'];
        let order = this.parseOrder (this.extend ({ 'id': id }, orders[id]));
        return this.extend ({ 'info': response }, order);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {
            // 'type': 'all', // any position, closed position, closing position, no position
            // 'trades': false, // whether or not to include trades related to position in output
            // 'start': 1234567890, // starting unix timestamp or trade tx id of results (exclusive)
            // 'end': 1234567890, // ending unix timestamp or trade tx id of results (inclusive)
            // 'ofs' = result offset
        };
        if (since)
            request['start'] = parseInt (since / 1000);
        let response = await this.privatePostTradesHistory (this.extend (request, params));
        let trades = response['result']['trades'];
        let ids = Object.keys (trades);
        for (let i = 0; i < ids.length; i++) {
            trades[ids[i]]['id'] = ids[i];
        }
        return this.parseTrades (trades, undefined, since, limit);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.privatePostCancelOrder (this.extend ({
                'txid': id,
            }, params));
        } catch (e) {
            if (this.last_http_response)
                if (this.last_http_response.indexOf ('EOrder:Unknown order') >= 0)
                    throw new OrderNotFound (this.id + ' cancelOrder() error ' + this.last_http_response);
            throw e;
        }
        return response;
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        if (since)
            request['start'] = parseInt (since / 1000);
        let response = await this.privatePostOpenOrders (this.extend (request, params));
        let orders = this.parseOrders (response['result']['open'], undefined, since, limit);
        return this.filterOrdersBySymbol (orders, symbol);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        if (since)
            request['start'] = parseInt (since / 1000);
        let response = await this.privatePostClosedOrders (this.extend (request, params));
        let orders = this.parseOrders (response['result']['closed'], undefined, since, limit);
        return this.filterOrdersBySymbol (orders, symbol);
    }

    async fetchDepositMethods (code = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        if (code) {
            let currency = this.currency (code);
            request['asset'] = currency['id'];
        }
        let response = await this.privatePostDepositMethods (this.extend (request, params));
        return response['result'];
    }

    async createDepositAddress (currency, params = {}) {
        let request = {
            'new': 'true',
        };
        let response = await this.fetchDepositAddress (currency, this.extend (request, params));
        return {
            'currency': currency,
            'address': response['address'],
            'status': 'ok',
            'info': response,
        };
    }

    async fetchDepositAddress (code, params = {}) {
        let method = this.safeValue (params, 'method');
        if (!method)
            throw new ExchangeError (this.id + ' fetchDepositAddress() requires an extra `method` parameter');
        await this.loadMarkets ();
        let currency = this.currency (code);
        let request = {
            'asset': currency['id'],
            'method': method,
            'new': 'false',
        };
        let response = await this.privatePostDepositAddresses (this.extend (request, params));
        let result = response['result'];
        let numResults = result.length;
        if (numResults < 1)
            throw new ExchangeError (this.id + ' privatePostDepositAddresses() returned no addresses');
        let address = this.safeString (result[0], 'address');
        return {
            'currency': code,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        if ('key' in params) {
            await this.loadMarkets ();
            let response = await this.privatePostWithdraw (this.extend ({
                'asset': currency,
                'amount': amount,
                // 'address': address, // they don't allow withdrawals to direct addresses
            }, params));
            return {
                'info': response,
                'id': response['result'],
            };
        }
        throw new ExchangeError (this.id + " withdraw requires a 'key' parameter (withdrawal key name, as set up on your account)");
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.version + '/' + api + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, params));
            let auth = this.encode (nonce + body);
            let hash = this.hash (auth, 'sha256', 'binary');
            let binary = this.stringToBinary (this.encode (url));
            let binhash = this.binaryConcat (binary, hash);
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (binhash, secret, 'sha512', 'base64');
            headers = {
                'API-Key': this.apiKey,
                'API-Sign': this.decode (signature),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    nonce () {
        return this.milliseconds ();
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response) {
            let numErrors = response['error'].length;
            if (numErrors) {
                for (let i = 0; i < response['error'].length; i++) {
                    if (response['error'][i] == 'EService:Unavailable')
                        throw new ExchangeNotAvailable (this.id + ' ' + this.json (response));
                    if (response['error'][i] == 'EService:Busy')
                        throw new DDoSProtection (this.id + ' ' + this.json (response));
                }
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],71:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InvalidOrder, InsufficientFunds, OrderNotFound } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class kucoin extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'kucoin',
            'name': 'Kucoin',
            'countries': 'HK', // Hong Kong
            'version': 'v1',
            'rateLimit': 1500,
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchTickers': true,
            'hasFetchOHLCV': false, // see the method implementation below
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchMyTrades': false,
            'hasFetchCurrencies': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchTickers': true,
                'fetchOHLCV': true, // see the method implementation below
                'fetchOrder': true,
                'fetchOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchMyTrades': false,
                'fetchCurrencies': true,
                'withdraw': true,
            },
            'timeframes': {
                '1m': '1min',
                '5m': '5min',
                '15m': '15min',
                '30m': '30min',
                '1h': '1hour',
                '8h': '8hour',
                '1d': '1day',
                '1w': '1week',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/33795655-b3c46e48-dcf6-11e7-8abe-dc4588ba7901.jpg',
                'api': 'https://api.kucoin.com',
                'www': 'https://kucoin.com',
                'doc': 'https://kucoinapidocs.docs.apiary.io',
                'fees': 'https://news.kucoin.com/en/fee',
            },
            'api': {
                'public': {
                    'get': [
                        'open/chart/config',
                        'open/chart/history',
                        'open/chart/symbol',
                        'open/currencies',
                        'open/deal-orders',
                        'open/kline',
                        'open/lang-list',
                        'open/orders',
                        'open/orders-buy',
                        'open/orders-sell',
                        'open/tick',
                        'market/open/coin-info',
                        'market/open/coins',
                        'market/open/coins-trending',
                        'market/open/symbols',
                    ],
                },
                'private': {
                    'get': [
                        'account/balance',
                        'account/{coin}/wallet/address',
                        'account/{coin}/wallet/records',
                        'account/{coin}/balance',
                        'account/promotion/info',
                        'account/promotion/sum',
                        'deal-orders',
                        'order/active',
                        'order/dealt',
                        'referrer/descendant/count',
                        'user/info',
                    ],
                    'post': [
                        'account/{coin}/withdraw/apply',
                        'account/{coin}/withdraw/cancel',
                        'cancel-order',
                        'order',
                        'user/change-lang',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0010,
                    'taker': 0.0010,
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetMarketOpenSymbols ();
        let markets = response['data'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['symbol'];
            let base = market['coinType'];
            let quote = market['coinTypePair'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': 8,
                'price': 8,
            };
            let active = market['trading'];
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': active,
                'info': market,
                'lot': Math.pow (10, -precision['amount']),
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision['amount']),
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            }));
        }
        return result;
    }

    async fetchCurrencies (params = {}) {
        let response = await this.publicGetMarketOpenCoins (params);
        let currencies = response['data'];
        let result = {};
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let id = currency['coin'];
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            let code = this.commonCurrencyCode (id);
            let precision = {
                'amount': currency['tradePrecision'],
                'price': currency['tradePrecision'],
            };
            let deposit = currency['enableDeposit'];
            let withdraw = currency['enableWithdraw'];
            let active = (deposit && withdraw);
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': currency['name'],
                'active': active,
                'status': 'ok',
                'fee': currency['withdrawFeeRate'], // todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision['amount']),
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': currency['withdrawMinAmount'],
                        'max': Math.pow (10, precision['amount']),
                    },
                },
            };
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        throw new ExchangeError (this.id + ' fetchBalance() / private API not implemented yet');
        //  JUNK FROM SOME OTHER EXCHANGE, TEMPLATE
        //  let response = await this.accountGetBalances ();
        //  let balances = response['result'];
        //  let result = { 'info': balances };
        //  let indexed = this.indexBy (balances, 'Currency');
        //  let keys = Object.keys (indexed);
        //  for (let i = 0; i < keys.length; i++) {
        //      let id = keys[i];
        //      let currency = this.commonCurrencyCode (id);
        //      let account = this.account ();
        //      let balance = indexed[id];
        //      let free = parseFloat (balance['Available']);
        //      let total = parseFloat (balance['Balance']);
        //      let used = total - free;
        //      account['free'] = free;
        //      account['used'] = used;
        //      account['total'] = total;
        //      result[currency] = account;
        //  }
        // return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOpenOrders (this.extend ({
            'symbol': market['id'],
        }, params));
        let orderbook = response['data'];
        return this.parseOrderBook (orderbook, undefined, 'BUY', 'SELL');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['datetime'];
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            symbol = ticker['coinType'] + '/' + ticker['coinTypePair'];
        }
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'lastDealPrice'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'vol'),
            'quoteVolume': this.safeFloat (ticker, 'volValue'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        let response = await this.publicGetMarketOpenSymbols (params);
        let tickers = response['data'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = this.parseTicker (tickers[t]);
            let symbol = ticker['symbol'];
            result[symbol] = ticker;
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOpenTick (this.extend ({
            'symbol': market['id'],
        }, params));
        let ticker = response['data'];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = trade[0];
        let side = undefined;
        if (trade[1] == 'BUY') {
            side = 'buy';
        } else if (trade[1] == 'SELL') {
            side = 'sell';
        }
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': 'limit',
            'side': side,
            'price': trade[2],
            'amount': trade[3],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOpenDealOrders (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response['data'], market, since, limit);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['T']);
        return [
            timestamp,
            ohlcv['O'],
            ohlcv['H'],
            ohlcv['L'],
            ohlcv['C'],
            ohlcv['V'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let to = this.seconds ();
        // whatever I try with from + to + limit it does not work (always an empty response)
        // tried all combinations:
        // - reversing them
        // - changing directions
        // - seconds
        // - milliseconds
        // - datetime strings
        // the endpoint doesn't seem to work, or something is missing in their docs
        let request = {
            'symbol': market['id'],
            'type': this.timeframes[timeframe],
            'from': to - 86400,
            'to': to,
        };
        if (since) {
            request['from'] = parseInt (since / 1000);
        }
        if (limit) {
            request['limit'] = limit;
        }
        let response = await this.publicGetOpenKline (this.extend (request, params));
        return this.parseOHLCVs (response['data'], market, timeframe, since, limit);
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let endpoint = '/' + this.version + '/' + this.implodeParams (path, params);
        let url = this.urls['api'] + endpoint;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            throw new ExchangeError (this.id + ' private API not implemented yet');
            // ---------------------------------
            // FROM KUCOIN:
            // String host = "https://api.kucoin.com";
            // String endpoint = "/v1/KCS-BTC/order"; // API endpoint
            // String secret; // The secret assigned when the API created
            // POST parameters：
            //     type: BUY
            //     amount: 10
            //     price: 1.1
            //     Arrange the parameters in ascending alphabetical order (lower cases first), then combine them with & (don't urlencode them, don't add ?, don't add extra &), e.g. amount=10&price=1.1&type=BUY
            //     将查询参数按照字母升序(小字母在前)排列后用&进行连接(请不要进行urlencode操作,开头不要带?,首位不要有额外的&符号)得到的queryString如:  amount=10&price=1.1&type=BUY
            // String queryString;
            // // splice string for signing
            // String strForSign = endpoint + "/" + nonce + "/" + queryString;
            // // Make a Base64 encoding of the completed string
            // String signatureStr = Base64.getEncoder().encodeToString(strForSign.getBytes("UTF-8"));
            // // KC-API-SIGNATURE in header
            // String signatureResult = hmacEncrypt("HmacSHA256", signatureStr, secret);
            // ----------------------------------
            // TEMPLATE (it is close, but it still needs testing and debugging):
            this.checkRequiredCredentials ();
            // their nonce is always a calibrated synched milliseconds-timestamp
            let nonce = this.milliseconds ();
            let queryString = '';
            nonce = nonce.toString ();
            if (Object.keys (query).length) {
                queryString = this.rawencode (this.keysort (query));
                if (method == 'GET') {
                    url += '?' + queryString;
                } else {
                    body = queryString;
                }
            }
            let auth = endpoint + '/' + nonce + '/' + queryString;
            let payload = this.stringToBase64 (this.encode (auth));
            // payload should be "encoded" as returned from stringToBase64
            let signature = this.hmac (payload, this.encode (this.secret), 'sha512');
            headers = {
                'KC-API-KEY': this.apiKey (),
                'KC-API-NONCE': nonce,
                'KC-API-SIGNATURE': signature,
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code >= 400) {
            if (body[0] == "{") {
                let response = JSON.parse (body);
                if ('success' in response) {
                    if (!response['success']) {
                        if ('message' in response) {
                            if (response['message'] == 'MIN_TRADE_REQUIREMENT_NOT_MET')
                                throw new InvalidOrder (this.id + ' ' + this.json (response));
                            if (response['message'] == 'APIKEY_INVALID')
                                throw new AuthenticationError (this.id + ' ' + this.json (response));
                        }
                        throw new ExchangeError (this.id + ' ' + this.json (response));
                    }
                }
            }
        }
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],72:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const acx = require ('./acx.js')
const { ExchangeError, InsufficientFunds, OrderNotFound } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class kuna extends acx {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'kuna',
            'name': 'Kuna',
            'countries': 'UA',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': false,
            'hasFetchTickers': false,
            'hasFetchOHLCV': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/31697638-912824fa-b3c1-11e7-8c36-cf9606eb94ac.jpg',
                'api': 'https://kuna.io',
                'www': 'https://kuna.io',
                'doc': 'https://kuna.io/documents/api',
            },
            'api': {
                'public': {
                    'get': [
                        'tickers/{market}',
                        'order_book',
                        'order_book/{market}',
                        'trades',
                        'trades/{market}',
                        'timestamp',
                    ],
                },
                'private': {
                    'get': [
                        'members/me',
                        'orders',
                        'trades/my',
                    ],
                    'post': [
                        'orders',
                        'order/delete',
                    ],
                },
            },
            'markets': {
                'BTC/UAH': { 'id': 'btcuah', 'symbol': 'BTC/UAH', 'base': 'BTC', 'quote': 'UAH', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }}},
                'ETH/UAH': { 'id': 'ethuah', 'symbol': 'ETH/UAH', 'base': 'ETH', 'quote': 'UAH', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }}},
                'GBG/UAH': { 'id': 'gbguah', 'symbol': 'GBG/UAH', 'base': 'GBG', 'quote': 'UAH', 'precision': { 'amount': 3, 'price': 2 }, 'lot': 0.001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.01, 'max': undefined }}}, // Golos Gold (GBG != GOLOS)
                'KUN/BTC': { 'id': 'kunbtc', 'symbol': 'KUN/BTC', 'base': 'KUN', 'quote': 'BTC', 'precision': { 'amount': 6, 'price': 6 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.000001, 'max': undefined }}},
                'BCH/BTC': { 'id': 'bchbtc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'precision': { 'amount': 6, 'price': 6 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 0.000001, 'max': undefined }}},
                'WAVES/UAH': { 'id': 'wavesuah', 'symbol': 'WAVES/UAH', 'base': 'WAVES', 'quote': 'UAH', 'precision': { 'amount': 6, 'price': 0 }, 'lot': 0.000001, 'limits': { 'amount': { 'min': 0.000001, 'max': undefined }, 'price': { 'min': 1, 'max': undefined }}},
            },
            'fees': {
                'trading': {
                    'taker': 0.25 / 100,
                    'maker': 0.25 / 100,
                },
            },
        });
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 400) {
            let data = JSON.parse (body);
            let error = data['error'];
            let errorCode = error['code'];
            if (errorCode == 2002) {
                throw new InsufficientFunds ([ this.id, method, url, code, reason, body ].join (' '));
            } else if (errorCode == 2003) {
                throw new OrderNotFound ([ this.id, method, url, code, reason, body ].join (' '));
            }
        }
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderBook = await this.publicGetOrderBook (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseOrderBook (orderBook, undefined, 'bids', 'asks', 'price', 'remaining_volume');
    }

    async fetchL3OrderBook (symbol, params) {
        return this.fetchOrderBook (symbol, params);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol argument');
        let market = this.market (symbol);
        let orders = await this.privateGetOrders (this.extend ({
            'market': market['id'],
        }, params));
        // todo emulation of fetchClosedOrders, fetchOrders, fetchOrder
        // with order cache + fetchOpenOrders
        // as in BTC-e, Liqui, Yobit, DSX, Tidex, WEX
        return this.parseOrders (orders, market, since, limit);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['created_at']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['volume']),
            'info': trade,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    parseMyTrade (trade, market) {
        let timestamp = this.parse8601 (trade['created_at']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'price': trade['price'],
            'amount': trade['volume'],
            'cost': trade['funds'],
            'symbol': symbol,
            'side': trade['side'],
            'order': trade['order_id'],
        };
    }

    parseMyTrades (trades, market = undefined) {
        let parsedTrades = [];
        for (let i = 0; i < trades.length; i++) {
            let trade = trades[i];
            let parsedTrade = this.parseMyTrade (trade, market);
            parsedTrades.push (parsedTrade);
        }
        return parsedTrades;
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol argument');
        let market = this.market (symbol);
        let response = await this.privateGetTradesMy ({ 'market': market['id'] });
        return this.parseMyTrades (response, market);
    }
}

},{"./acx.js":5,"./base/errors":10}],73:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class lakebtc extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'lakebtc',
            'name': 'LakeBTC',
            'countries': 'US',
            'version': 'api_v2',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28074120-72b7c38a-6660-11e7-92d9-d9027502281d.jpg',
                'api': 'https://api.lakebtc.com',
                'www': 'https://www.lakebtc.com',
                'doc': [
                    'https://www.lakebtc.com/s/api_v2',
                    'https://www.lakebtc.com/s/api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'bcorderbook',
                        'bctrades',
                        'ticker',
                    ],
                },
                'private': {
                    'post': [
                        'buyOrder',
                        'cancelOrders',
                        'getAccountInfo',
                        'getExternalAccounts',
                        'getOrders',
                        'getTrades',
                        'openOrders',
                        'sellOrder',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.15 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTicker ();
        let result = [];
        let keys = Object.keys (markets);
        for (let k = 0; k < keys.length; k++) {
            let id = keys[k];
            let market = markets[id];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['balance'];
        let result = { 'info': response };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let balance = parseFloat (balances[currency]);
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBcorderbook (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTicker (this.extend ({
            'symbol': market['id'],
        }, params));
        let ticker = tickers[market['id']];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetBctrades (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let method = 'privatePost' + this.capitalize (side) + 'Order';
        let marketId = this.marketId (market);
        let order = {
            'params': [ price, amount, marketId ],
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder ({ 'params': id });
    }

    nonce () {
        return this.microseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version;
        if (api == 'public') {
            url += '/' + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            if (Object.keys (params).length)
                params = params.join (',');
            else
                params = '';
            let query = this.urlencode ({
                'tonce': nonce,
                'accesskey': this.apiKey,
                'requestmethod': method.toLowerCase (),
                'id': nonce,
                'method': path,
                'params': params,
            });
            body = this.json ({
                'method': path,
                'params': params,
                'id': nonce,
            });
            let signature = this.hmac (this.encode (query), this.encode (this.secret), 'sha1');
            let auth = this.encode (this.apiKey + ':' + signature);
            headers = {
                'Json-Rpc-Tonce': nonce,
                'Authorization': "Basic " + this.decode (this.stringToBase64 (auth)),
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],74:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, OrderNotFound, DDoSProtection } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class liqui extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'liqui',
            'name': 'Liqui',
            'countries': 'UA',
            'rateLimit': 2500,
            'version': '3',
            'hasCORS': false,
            // obsolete metainfo interface
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchTickers': true,
            'hasFetchMyTrades': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchOrder': true,
                'fetchOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchTickers': true,
                'fetchMyTrades': true,
                'withdraw': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27982022-75aea828-63a0-11e7-9511-ca584a8edd74.jpg',
                'api': {
                    'public': 'https://api.liqui.io/api',
                    'private': 'https://api.liqui.io/tapi',
                },
                'www': 'https://liqui.io',
                'doc': 'https://liqui.io/api',
                'fees': 'https://liqui.io/fee',
            },
            'api': {
                'public': {
                    'get': [
                        'info',
                        'ticker/{pair}',
                        'depth/{pair}',
                        'trades/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'getInfo',
                        'Trade',
                        'ActiveOrders',
                        'OrderInfo',
                        'CancelOrder',
                        'TradeHistory',
                        'TransHistory',
                        'CoinDepositAddress',
                        'WithdrawCoin',
                        'CreateCoupon',
                        'RedeemCoupon',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.001,
                    'taker': 0.0025,
                },
                'funding': 0.0,
            },
        });
    }

    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let market = this.markets[symbol];
        let key = 'quote';
        let rate = market[takerOrMaker];
        let cost = parseFloat (this.costToPrecision (symbol, amount * rate));
        if (side == 'sell') {
            cost *= price;
        } else {
            key = 'base';
        }
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': cost,
        };
    }

    commonCurrencyCode (currency) {
        if (!this.substituteCommonCurrencyCodes)
            return currency;
        if (currency == 'XBT')
            return 'BTC';
        if (currency == 'BCC')
            return 'BCH';
        if (currency == 'DRK')
            return 'DASH';
        // they misspell DASH as dsh :/
        if (currency == 'DSH')
            return 'DASH';
        return currency;
    }

    getBaseQuoteFromMarketId (id) {
        let uppercase = id.toUpperCase ();
        let [ base, quote ] = uppercase.split ('_');
        base = this.commonCurrencyCode (base);
        quote = this.commonCurrencyCode (quote);
        return [ base, quote ];
    }

    async fetchMarkets () {
        let response = await this.publicGetInfo ();
        let markets = response['pairs'];
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let [ base, quote ] = this.getBaseQuoteFromMarketId (id);
            let symbol = base + '/' + quote;
            let precision = {
                'amount': this.safeInteger (market, 'decimal_places'),
                'price': this.safeInteger (market, 'decimal_places'),
            };
            let amountLimits = {
                'min': this.safeFloat (market, 'min_amount'),
                'max': this.safeFloat (market, 'max_amount'),
            };
            let priceLimits = {
                'min': this.safeFloat (market, 'min_price'),
                'max': this.safeFloat (market, 'max_price'),
            };
            let costLimits = {
                'min': this.safeFloat (market, 'min_total'),
            };
            let limits = {
                'amount': amountLimits,
                'price': priceLimits,
                'cost': costLimits,
            };
            let active = (market['hidden'] == 0);
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': active,
                'taker': market['fee'] / 100,
                'lot': amountLimits['min'],
                'precision': precision,
                'limits': limits,
                'info': market,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let funds = balances['funds'];
        let currencies = Object.keys (funds);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let uppercase = currency.toUpperCase ();
            uppercase = this.commonCurrencyCode (uppercase);
            let total = undefined;
            let used = undefined;
            if (balances['open_orders'] == 0) {
                total = funds[currency];
                used = 0.0;
            }
            let account = {
                'free': funds[currency],
                'used': used,
                'total': total,
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetDepthPair (this.extend ({
            'pair': market['id'],
        }, params));
        let market_id_in_reponse = (market['id'] in response);
        if (!market_id_in_reponse)
            throw new ExchangeError (this.id + ' ' + market['symbol'] + ' order book is empty or not available');
        let orderbook = response[market['id']];
        let result = this.parseOrderBook (orderbook);
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'avg'),
            'baseVolume': this.safeFloat (ticker, 'vol_cur'),
            'quoteVolume': this.safeFloat (ticker, 'vol'),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let ids = undefined;
        if (!symbols) {
            let numIds = this.ids.length;
            if (numIds > 256)
                throw new ExchangeError (this.id + ' fetchTickers() requires symbols argument');
            ids = this.ids;
        } else {
            ids = this.marketIds (symbols);
        }
        let tickers = await this.publicGetTickerPair (this.extend ({
            'pair': ids.join ('-'),
        }, params));
        let result = {};
        let keys = Object.keys (tickers);
        for (let k = 0; k < keys.length; k++) {
            let id = keys[k];
            let ticker = tickers[id];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let tickers = await this.fetchTickers ([ symbol ], params);
        return tickers[symbol];
    }

    parseTrade (trade, market = undefined) {
        let timestamp = trade['timestamp'] * 1000;
        let side = trade['type'];
        if (side == 'ask')
            side = 'sell';
        if (side == 'bid')
            side = 'buy';
        let price = this.safeFloat (trade, 'price');
        if ('rate' in trade)
            price = this.safeFloat (trade, 'rate');
        let id = this.safeString (trade, 'tid');
        if ('trade_id' in trade)
            id = this.safeString (trade, 'trade_id');
        let order = this.safeString (trade, this.getOrderIdKey ());
        if ('pair' in trade) {
            let marketId = trade['pair'];
            market = this.markets_by_id[marketId];
        }
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let amount = trade['amount'];
        let type = 'limit'; // all trades are still limit trades
        let fee = undefined;
        // this is filled by fetchMyTrades() only
        // is_your_order is always false :\
        // let isYourOrder = this.safeValue (trade, 'is_your_order');
        // let takerOrMaker = 'taker';
        // if (isYourOrder)
        //     takerOrMaker = 'maker';
        // let fee = this.calculateFee (symbol, type, side, amount, price, takerOrMaker);
        return {
            'id': id,
            'order': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'fee': fee,
            'info': trade,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'pair': market['id'],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.publicGetTradesPair (this.extend (request, params));
        return this.parseTrades (response[market['id']], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'pair': market['id'],
            'type': side,
            'amount': this.amountToPrecision (symbol, amount),
            'rate': this.priceToPrecision (symbol, price),
        };
        let response = await this.privatePostTrade (this.extend (request, params));
        let id = this.safeString (response['return'], this.getOrderIdKey ());
        if (!id)
            id = this.safeString (response['return'], 'init_order_id');
        let timestamp = this.milliseconds ();
        price = parseFloat (price);
        amount = parseFloat (amount);
        let order = {
            'id': id,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'remaining': amount,
            'filled': 0.0,
            'fee': undefined,
            // 'trades': this.parseTrades (order['trades'], market),
        };
        this.orders[id] = order;
        return this.extend ({ 'info': response }, order);
    }

    getOrderIdKey () {
        return 'order_id';
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            let request = {};
            let idKey = this.getOrderIdKey ();
            request[idKey] = id;
            response = await this.privatePostCancelOrder (this.extend (request, params));
            if (id in this.orders)
                this.orders[id]['status'] = 'canceled';
        } catch (e) {
            if (this.last_json_response) {
                let message = this.safeString (this.last_json_response, 'error');
                if (message) {
                    if (message.indexOf ('not found') >= 0)
                        throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
                }
            }
            throw e;
        }
        return response;
    }

    parseOrder (order, market = undefined) {
        let id = order['id'].toString ();
        let status = order['status'];
        if (status == 0) {
            status = 'open';
        } else if (status == 1) {
            status = 'closed';
        } else if ((status == 2) || (status == 3)) {
            status = 'canceled';
        }
        let timestamp = parseInt (order['timestamp_created']) * 1000;
        let symbol = undefined;
        if (!market)
            market = this.markets_by_id[order['pair']];
        if (market)
            symbol = market['symbol'];
        let remaining = this.safeFloat (order, 'amount');
        let amount = this.safeFloat (order, 'start_amount', remaining);
        if (typeof amount == 'undefined') {
            if (id in this.orders) {
                amount = this.safeFloat (this.orders[id], 'amount');
            }
        }
        let price = this.safeFloat (order, 'rate');
        let filled = undefined;
        let cost = undefined;
        if (typeof amount != 'undefined') {
            if (typeof remaining != 'undefined') {
                filled = amount - remaining;
                cost = price * filled;
            }
        }
        let fee = undefined;
        let result = {
            'info': order,
            'id': id,
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'type': 'limit',
            'side': order['type'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'remaining': remaining,
            'filled': filled,
            'status': status,
            'fee': fee,
        };
        return result;
    }

    parseOrders (orders, market = undefined, since = undefined, limit = undefined) {
        let ids = Object.keys (orders);
        let result = [];
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = orders[id];
            let extended = this.extend (order, { 'id': id });
            result.push (this.parseOrder (extended, market));
        }
        return this.filterBySinceLimit (result, since, limit);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderInfo (this.extend ({
            'order_id': parseInt (id),
        }, params));
        id = id.toString ();
        let newOrder = this.parseOrder (this.extend ({ 'id': id }, response['return'][id]));
        let oldOrder = (id in this.orders) ? this.orders[id] : {};
        this.orders[id] = this.extend (oldOrder, newOrder);
        return this.orders[id];
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrders requires a symbol');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = { 'pair': market['id'] };
        let response = await this.privatePostActiveOrders (this.extend (request, params));
        let openOrders = [];
        if ('return' in response)
            openOrders = this.parseOrders (response['return'], market);
        for (let j = 0; j < openOrders.length; j++) {
            this.orders[openOrders[j]['id']] = openOrders[j];
        }
        let openOrdersIndexedById = this.indexBy (openOrders, 'id');
        let cachedOrderIds = Object.keys (this.orders);
        let result = [];
        for (let k = 0; k < cachedOrderIds.length; k++) {
            let id = cachedOrderIds[k];
            if (id in openOrdersIndexedById) {
                this.orders[id] = this.extend (this.orders[id], openOrdersIndexedById[id]);
            } else {
                let order = this.orders[id];
                if (order['status'] == 'open') {
                    this.orders[id] = this.extend (order, {
                        'status': 'closed',
                        'cost': order['amount'] * order['price'],
                        'filled': order['amount'],
                        'remaining': 0.0,
                    });
                }
            }
            let order = this.orders[id];
            if (order['symbol'] == symbol)
                result.push (order);
        }
        return this.filterBySinceLimit (result, since, limit);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == 'open')
                result.push (orders[i]);
        }
        return result;
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, params);
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == 'closed')
                result.push (orders[i]);
        }
        return result;
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {
            // 'from': 123456789, // trade ID, from which the display starts numerical 0
            // 'count': 1000, // the number of trades for display numerical, default = 1000
            // 'from_id': trade ID, from which the display starts numerical 0
            // 'end_id': trade ID on which the display ends numerical ∞
            // 'order': 'ASC', // sorting, default = DESC
            // 'since': 1234567890, // UTC start time, default = 0
            // 'end': 1234567890, // UTC end time, default = ∞
            // 'pair': 'eth_btc', // default = all markets
        };
        if (symbol) {
            market = this.market (symbol);
            request['pair'] = market['id'];
        }
        if (limit)
            request['count'] = parseInt (limit);
        if (since)
            request['since'] = parseInt (since / 1000);
        let response = await this.privatePostTradeHistory (this.extend (request, params));
        let trades = [];
        if ('return' in response)
            trades = response['return'];
        return this.parseTrades (trades, market, since, limit);
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdrawCoin (this.extend ({
            'coinName': currency,
            'amount': parseFloat (amount),
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['return']['tId'],
        };
    }

    signBodyWithSecret (body) {
        return this.hmac (this.encode (body), this.encode (this.secret), 'sha512');
    }

    getVersionString () {
        return '/' + this.version;
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'nonce': nonce,
                'method': path,
            }, query));
            let signature = this.signBodyWithSecret (body);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': signature,
            };
        } else {
            url += this.getVersionString () + '/' + this.implodeParams (path, params);
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response) {
            if (!response['success']) {
                if (response['error'].indexOf ('Not enougth') >= 0) { // not enougTh is a typo inside Liqui's own API...
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
                } else if (response['error'] == 'Requests too often') {
                    throw new DDoSProtection (this.id + ' ' + this.json (response));
                } else if ((response['error'] == 'not available') || (response['error'] == 'external service unavailable')) {
                    throw new DDoSProtection (this.id + ' ' + this.json (response));
                } else {
                    throw new ExchangeError (this.id + ' ' + this.json (response));
                }
            }
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],75:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class livecoin extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'livecoin',
            'name': 'LiveCoin',
            'countries': [ 'US', 'UK', 'RU' ],
            'rateLimit': 1000,
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27980768-f22fc424-638a-11e7-89c9-6010a54ff9be.jpg',
                'api': 'https://api.livecoin.net',
                'www': 'https://www.livecoin.net',
                'doc': 'https://www.livecoin.net/api?lang=en',
            },
            'api': {
                'public': {
                    'get': [
                        'exchange/all/order_book',
                        'exchange/last_trades',
                        'exchange/maxbid_minask',
                        'exchange/order_book',
                        'exchange/restrictions',
                        'exchange/ticker', // omit params to get all tickers at once
                        'info/coinInfo',
                    ],
                },
                'private': {
                    'get': [
                        'exchange/client_orders',
                        'exchange/order',
                        'exchange/trades',
                        'exchange/commission',
                        'exchange/commissionCommonInfo',
                        'payment/balances',
                        'payment/balance',
                        'payment/get/address',
                        'payment/history/size',
                        'payment/history/transactions',
                    ],
                    'post': [
                        'exchange/buylimit',
                        'exchange/buymarket',
                        'exchange/cancellimit',
                        'exchange/selllimit',
                        'exchange/sellmarket',
                        'payment/out/capitalist',
                        'payment/out/card',
                        'payment/out/coin',
                        'payment/out/okpay',
                        'payment/out/payeer',
                        'payment/out/perfectmoney',
                        'payment/voucher/amount',
                        'payment/voucher/make',
                        'payment/voucher/redeem',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetExchangeTicker ();
        let restrictions = await this.publicGetExchangeRestrictions ();
        let restrictionsById = this.indexBy (restrictions['restrictions'], 'currencyPair');
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['symbol'];
            let symbol = id;
            let [ base, quote ] = symbol.split ('/');
            let commission = 0.18 / 100;
            let coinRestrictions = this.safeValue (restrictionsById, symbol);
            let pricePrecision = undefined;
            let amountMin = undefined;
            if (coinRestrictions) {
                let pricePrecision = this.safeInteger (coinRestrictions, 'priceScale', 5);
                let amountMin = this.safeFloat (coinRestrictions, 'minLimitQuantity', 0.00000001);
                amountMin *= (1 + commission);
            }
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'precision': {
                    'price': pricePrecision,
                    'amount': 8,
                    'cost': 8,
                },
                'limits': {
                    'amount': {
                        'min': amountMin,
                        'max': 1000000000,
                    },
                    'price': {
                        'min': 0.00000001,
                        'max': 1000000000,
                    },
                },
                'maker': commission,
                'taker': commission,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetPaymentBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = undefined;
            if (currency in result)
                account = result[currency];
            else
                account = this.account ();
            if (balance['type'] == 'total')
                account['total'] = parseFloat (balance['value']);
            if (balance['type'] == 'available')
                account['free'] = parseFloat (balance['value']);
            if (balance['type'] == 'trade')
                account['used'] = parseFloat (balance['value']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchFees (params = {}) {
        await this.loadMarkets ();
        let commissionInfo = await this.privateGetExchangeCommissionCommonInfo ();
        let commission = this.safeFloat (commissionInfo, 'commission');
        return {
            'info': commissionInfo,
            'maker': commission,
            'taker': commission,
            'withdraw': 0.0,
        };
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetExchangeOrderBook (this.extend ({
            'currencyPair': this.marketId (symbol),
            'groupByPrice': 'false',
            'depth': 100,
        }, params));
        let timestamp = orderbook['timestamp'];
        return this.parseOrderBook (orderbook, timestamp);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['best_bid']),
            'ask': parseFloat (ticker['best_ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetExchangeTicker (params);
        let tickers = this.indexBy (response, 'symbol');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetExchangeTicker (this.extend ({
            'currencyPair': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['time'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['id'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['type'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['quantity'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetExchangeLastTrades (this.extend ({
            'currencyPair': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    parseOrder (order, market = undefined) {
        let timestamp = this.safeInteger (order, 'lastModificationTime');
        if (!timestamp)
            timestamp = this.parse8601 (order['lastModificationTime']);
        let trades = undefined;
        if ('trades' in order)
            // TODO currently not supported by livecoin
            // trades = this.parseTrades (order['trades'], market, since, limit);
            trades = undefined;
        let status = undefined;
        if (order['orderStatus'] == 'OPEN' || order['orderStatus'] == 'PARTIALLY_FILLED') {
            status = 'open';
        } else if (order['orderStatus'] == 'EXECUTED' || order['orderStatus'] == 'PARTIALLY_FILLED_AND_CANCELLED') {
            status = 'closed';
        } else {
            status = 'canceled';
        }
        let symbol = order['currencyPair'];
        let [ base, quote ] = symbol.split ('/');
        let type = undefined;
        let side = undefined;
        if (order['type'].indexOf ('MARKET') >= 0) {
            type = 'market';
        } else {
            type = 'limit';
        }
        if (order['type'].indexOf ('SELL') >= 0) {
            side = 'sell';
        } else {
            side = 'buy';
        }
        let price = this.safeFloat (order, 'price', 0.0);
        let cost = this.safeFloat (order, 'commissionByTrade', 0.0);
        let remaining = this.safeFloat (order, 'remainingQuantity', 0.0);
        let amount = this.safeFloat (order, 'quantity', remaining);
        let filled = amount - remaining;
        return {
            'info': order,
            'id': order['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'trades': trades,
            'fee': {
                'cost': cost,
                'currency': quote,
            },
        };
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : undefined;
        let request = {};
        if (pair)
            request['currencyPair'] = pair;
        if (since)
            request['issuedFrom'] = parseInt (since);
        if (limit)
            request['endRow'] = limit - 1;
        let response = await this.privateGetExchangeClientOrders (this.extend (request, params));
        let result = [];
        let rawOrders = [];
        if (response['data'])
            rawOrders = response['data'];
        for (let i = 0; i < rawOrders.length; i++) {
            let order = rawOrders[i];
            result.push (this.parseOrder (order, market));
        }
        return result;
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let result = await this.fetchOrders (symbol, since, limit, this.extend ({
            'openClosed': 'OPEN',
        }, params));
        return result;
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let result = await this.fetchOrders (symbol, since, limit, this.extend ({
            'openClosed': 'CLOSED',
        }, params));
        return result;
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privatePostExchange' + this.capitalize (side) + type;
        let market = this.market (symbol);
        let order = {
            'quantity': amount,
            'currencyPair': market['id'],
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderId'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' cancelOrder requires a symbol argument');
        await this.loadMarkets ();
        let market = this.market (symbol);
        return await this.privatePostExchangeCancellimit (this.extend ({
            'orderId': id,
            'currencyPair': market['id'],
        }, params));
    }

    async fetchDepositAddress (currency, params = {}) {
        let request = {
            'currency': currency,
        };
        let response = await this.privateGetPaymentGetAddress (this.extend (request, params));
        let address = this.safeString (response, 'wallet');
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        let query = this.urlencode (this.keysort (params));
        if (method == 'GET') {
            if (Object.keys (params).length) {
                url += '?' + query;
            }
        }
        if (api == 'private') {
            this.checkRequiredCredentials ();
            if (method == 'POST')
                body = query;
            let signature = this.hmac (this.encode (query), this.encode (this.secret), 'sha256');
            headers = {
                'Api-Key': this.apiKey,
                'Sign': signature.toUpperCase (),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response)
            if (!response['success'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],76:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class luno extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'luno',
            'name': 'luno',
            'countries': [ 'GB', 'SG', 'ZA' ],
            'rateLimit': 10000,
            'version': '1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOrder': true,
            'has': {
                'fetchTickers': true,
                'fetchOrder': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg',
                'api': 'https://api.mybitx.com/api',
                'www': 'https://www.luno.com',
                'doc': [
                    'https://www.luno.com/en/api',
                    'https://npmjs.org/package/bitx',
                    'https://github.com/bausmeier/node-bitx',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'orderbook',
                        'ticker',
                        'tickers',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'accounts/{id}/pending',
                        'accounts/{id}/transactions',
                        'balance',
                        'fee_info',
                        'funding_address',
                        'listorders',
                        'listtrades',
                        'orders/{id}',
                        'quotes/{id}',
                        'withdrawals',
                        'withdrawals/{id}',
                    ],
                    'post': [
                        'accounts',
                        'postorder',
                        'marketorder',
                        'stoporder',
                        'funding_address',
                        'withdrawals',
                        'send',
                        'quotes',
                        'oauth2/grant',
                    ],
                    'put': [
                        'quotes/{id}',
                    ],
                    'delete': [
                        'quotes/{id}',
                        'withdrawals/{id}',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetTickers ();
        let result = [];
        for (let p = 0; p < markets['tickers'].length; p++) {
            let market = markets['tickers'][p];
            let id = market['pair'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['balance'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = this.commonCurrencyCode (balance['asset']);
            let reserved = parseFloat (balance['reserved']);
            let unconfirmed = parseFloat (balance['unconfirmed']);
            let account = {
                'free': parseFloat (balance['balance']),
                'used': this.sum (reserved, unconfirmed),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbook (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = orderbook['timestamp'];
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'volume');
    }

    parseOrder (order, market = undefined) {
        let timestamp = order['creation_timestamp'];
        let status = (order['state'] == 'PENDING') ? 'open' : 'closed';
        let side = (order['type'] == 'ASK') ? 'sell' : 'buy';
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let price = this.safeFloat (order, 'limit_price');
        let amount = this.safeFloat (order, 'limit_volume');
        let quoteFee = this.safeFloat (order, 'fee_counter');
        let baseFee = this.safeFloat (order, 'fee_base');
        let fee = { 'currency': undefined };
        if (quoteFee) {
            fee['side'] = 'quote';
            fee['cost'] = quoteFee;
        } else {
            fee['side'] = 'base';
            fee['cost'] = baseFee;
        }
        return {
            'id': order['order_id'],
            'datetime': this.iso8601 (timestamp),
            'timestamp': timestamp,
            'status': status,
            'symbol': symbol,
            'type': undefined,
            'side': side,
            'price': price,
            'amount': amount,
            'filled': undefined,
            'remaining': undefined,
            'trades': undefined,
            'fee': fee,
            'info': order,
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetOrders (this.extend ({
            'id': id.toString (),
        }, params));
        return this.parseOrder (response);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['timestamp'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_trade']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['rolling_24_hour_volume']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetTickers (params);
        let tickers = this.indexBy (response['tickers'], 'pair');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTicker (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let side = (trade['is_buy']) ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': undefined,
            'order': undefined,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['volume']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market, since, limit);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privatePost';
        let order = { 'pair': this.marketId (market) };
        if (type == 'market') {
            method += 'Marketorder';
            order['type'] = side.toUpperCase ();
            if (side == 'buy')
                order['counter_volume'] = amount;
            else
                order['base_volume'] = amount;
        } else {
            method += 'Order';
            order['volume'] = amount;
            order['price'] = price;
            if (side == 'buy')
                order['type'] = 'BID';
            else
                order['type'] = 'ASK';
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostStoporder ({ 'order_id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (Object.keys (query).length)
            url += '?' + this.urlencode (query);
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let auth = this.encode (this.apiKey + ':' + this.secret);
            auth = this.stringToBase64 (auth);
            headers = { 'Authorization': 'Basic ' + this.decode (auth) };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],77:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class mercado extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'mercado',
            'name': 'Mercado Bitcoin',
            'countries': 'BR', // Brazil
            'rateLimit': 1000,
            'version': 'v3',
            'hasCORS': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg',
                'api': {
                    'public': 'https://www.mercadobitcoin.net/api',
                    'private': 'https://www.mercadobitcoin.net/tapi',
                },
                'www': 'https://www.mercadobitcoin.com.br',
                'doc': [
                    'https://www.mercadobitcoin.com.br/api-doc',
                    'https://www.mercadobitcoin.com.br/trade-api',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        '{coin}/orderbook/', // last slash critical
                        '{coin}/ticker/',
                        '{coin}/trades/',
                        '{coin}/trades/{from}/',
                        '{coin}/trades/{from}/{to}',
                        '{coin}/day-summary/{year}/{month}/{day}/',
                    ],
                },
                'private': {
                    'post': [
                        'cancel_order',
                        'get_account_info',
                        'get_order',
                        'get_withdrawal',
                        'list_system_messages',
                        'list_orders',
                        'list_orderbook',
                        'place_buy_order',
                        'place_sell_order',
                        'withdraw_coin',
                    ],
                },
            },
            'markets': {
                'BTC/BRL': { 'id': 'BRLBTC', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'suffix': 'Bitcoin' },
                'LTC/BRL': { 'id': 'BRLLTC', 'symbol': 'LTC/BRL', 'base': 'LTC', 'quote': 'BRL', 'suffix': 'Litecoin' },
                'BCH/BRL': { 'id': 'BRLBCH', 'symbol': 'BCH/BRL', 'base': 'BCH', 'quote': 'BRL', 'suffix': 'BCash' },
            },
            'fees': {
                'trading': {
                    'maker': 0.3 / 100,
                    'taker': 0.7 / 100,
                },
            },
        });
    }

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetCoinOrderbook (this.extend ({
            'coin': market['base'],
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetCoinTicker (this.extend ({
            'coin': market['base'],
        }, params));
        let ticker = response['ticker'];
        let timestamp = parseInt (ticker['date']) * 1000;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetCoinTrades (this.extend ({
            'coin': market['base'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['response_data']['balance'];
        let result = { 'info': response };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances) {
                account['free'] = parseFloat (balances[lowercase]['available']);
                account['total'] = parseFloat (balances[lowercase]['total']);
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let method = 'privatePostPlace' + this.capitalize (side) + 'Order';
        let order = {
            'coin_pair': this.marketId (symbol),
            'quantity': amount,
            'limit_price': price,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['response_data']['order']['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' cancelOrder() requires a symbol argument');
        await this.loadMarkets ();
        let market = this.market (symbol);
        return await this.privatePostCancelOrder (this.extend ({
            'coin_pair': market['id'],
            'order_id': id,
        }, params));
    }

    parseOrder (order, market = undefined) {
        let side = undefined;
        if ('order_type' in order)
            side = (order['order_type'] == 1) ? 'buy' : 'sell';
        let status = order['status'];
        let symbol = undefined;
        if (!market) {
            if ('coin_pair' in order)
                if (order['coin_pair'] in this.markets_by_id)
                    market = this.markets_by_id[order['coin_pair']];
        }
        if (market)
            symbol = market['symbol'];
        let timestamp = undefined;
        if ('created_timestamp' in order)
            timestamp = parseInt (order['created_timestamp']) * 1000;
        if ('updated_timestamp' in order)
            timestamp = parseInt (order['updated_timestamp']) * 1000;
        let fee = {
            'cost': parseFloat (order['fee']),
            'currency': market['quote'],
        };
        let price = this.safeFloat (order, 'limit_price');
        // price = this.safeFloat (order, 'executed_price_avg', price);
        let average = this.safeFloat (order, 'executed_price_avg');
        let amount = this.safeFloat (order, 'quantity');
        let filled = this.safeFloat (order, 'executed_quantity');
        let remaining = amount - filled;
        let cost = amount * average;
        let result = {
            'info': order,
            'id': order['order_id'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': 'limit',
            'side': side,
            'price': price,
            'cost': cost,
            'average': average,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
        };
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' cancelOrder() requires a symbol argument');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = undefined;
        response = await this.privatePostGetOrder (this.extend ({
            'coin_pair': market['id'],
            'order_id': parseInt (id),
        }, params));
        return this.parseOrder (response['response_data']['order']);
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let request = {
            'coin': currency,
            'quantity': amount.toFixed (10),
            'address': address,
        };
        if (currency == 'BRL') {
            let account_ref = ('account_ref' in params);
            if (!account_ref)
                throw new ExchangeError (this.id + ' requires account_ref parameter to withdraw ' + currency);
        } else if (currency != 'LTC') {
            let tx_fee = ('tx_fee' in params);
            if (!tx_fee)
                throw new ExchangeError (this.id + ' requires tx_fee parameter to withdraw ' + currency);
        }
        let response = await this.privatePostWithdrawCoin (this.extend (request, params));
        return {
            'info': response,
            'id': response['response_data']['withdrawal']['id'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/';
        if (api == 'public') {
            url += this.implodeParams (path, params);
        } else {
            this.checkRequiredCredentials ();
            url += this.version + '/';
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'tapi_method': path,
                'tapi_nonce': nonce,
            }, params));
            let auth = '/tapi/' + this.version + '/' + '?' + body;
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'TAPI-ID': this.apiKey,
                'TAPI-MAC': this.hmac (this.encode (auth), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error_message' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],78:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class mixcoins extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'mixcoins',
            'name': 'MixCoins',
            'countries': [ 'GB', 'HK' ],
            'rateLimit': 1500,
            'version': 'v1',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30237212-ed29303c-9535-11e7-8af8-fcd381cfa20c.jpg',
                'api': 'https://mixcoins.com/api',
                'www': 'https://mixcoins.com',
                'doc': 'https://mixcoins.com/help/api/',
            },
            'api': {
                'public': {
                    'get': [
                        'ticker',
                        'trades',
                        'depth',
                    ],
                },
                'private': {
                    'post': [
                        'cancel',
                        'info',
                        'orders',
                        'order',
                        'transactions',
                        'trade',
                    ],
                },
            },
            'markets': {
                'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.0015, 'taker': 0.0025 },
                'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.001, 'taker': 0.0015 },
                'BCH/BTC': { 'id': 'bcc_btc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'maker': 0.001, 'taker': 0.0015 },
                'LSK/BTC': { 'id': 'lsk_btc', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC', 'maker': 0.0015, 'taker': 0.0025 },
                'BCH/USD': { 'id': 'bcc_usd', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD', 'maker': 0.001, 'taker': 0.0015 },
                'ETH/USD': { 'id': 'eth_usd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'maker': 0.001, 'taker': 0.0015 },
            },
        });
    }

    async fetchBalance (params = {}) {
        let response = await this.privatePostInfo ();
        let balance = response['result']['wallet'];
        let result = { 'info': balance };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balance) {
                account['free'] = parseFloat (balance[lowercase]['avail']);
                account['used'] = parseFloat (balance[lowercase]['lock']);
                account['total'] = this.sum (account['free'], account['used']);
            }
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetDepth (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (response['result']);
    }

    async fetchTicker (symbol, params = {}) {
        let response = await this.publicGetTicker (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let ticker = response['result'];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response['result'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = {
            'market': this.marketId (symbol),
            'op': side,
            'amount': amount,
        };
        if (type == 'market') {
            order['order_type'] = 1;
            order['price'] = price;
        } else {
            order['order_type'] = 0;
        }
        let response = await this.privatePostTrade (this.extend (order, params));
        return {
            'info': response,
            'id': response['result']['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancel ({ 'id': id });
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.secret, 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] == 200)
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    }
}

},{"./base/Exchange":8,"./base/errors":10}],79:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class nova extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'nova',
            'name': 'Novaexchange',
            'countries': 'TZ', // Tanzania
            'rateLimit': 2000,
            'version': 'v2',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30518571-78ca0bca-9b8a-11e7-8840-64b83a4a94b2.jpg',
                'api': 'https://novaexchange.com/remote',
                'www': 'https://novaexchange.com',
                'doc': 'https://novaexchange.com/remote/faq',
            },
            'api': {
                'public': {
                    'get': [
                        'markets/',
                        'markets/{basecurrency}/',
                        'market/info/{pair}/',
                        'market/orderhistory/{pair}/',
                        'market/openorders/{pair}/buy/',
                        'market/openorders/{pair}/sell/',
                        'market/openorders/{pair}/both/',
                        'market/openorders/{pair}/{ordertype}/',
                    ],
                },
                'private': {
                    'post': [
                        'getbalances/',
                        'getbalance/{currency}/',
                        'getdeposits/',
                        'getwithdrawals/',
                        'getnewdepositaddress/{currency}/',
                        'getdepositaddress/{currency}/',
                        'myopenorders/',
                        'myopenorders_market/{pair}/',
                        'cancelorder/{orderid}/',
                        'withdraw/{currency}/',
                        'trade/{pair}/',
                        'tradehistory/',
                        'getdeposithistory/',
                        'getwithdrawalhistory/',
                        'walletstatus/',
                        'walletstatus/{currency}/',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let response = await this.publicGetMarkets ();
        let markets = response['markets'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            if (!market['disabled']) {
                let id = market['marketname'];
                let [ quote, base ] = id.split ('_');
                let symbol = base + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'info': market,
                });
            }
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetMarketOpenordersPairBoth (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buyorders', 'sellorders', 'price', 'amount');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarketInfoPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let ticker = response['markets'][0];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24h']),
            'low': parseFloat (ticker['low24h']),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['change24h']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume24h']),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = trade['unix_t_datestamp'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': undefined,
            'order': undefined,
            'type': undefined,
            'side': trade['tradetype'].toLowerCase (),
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketOrderhistoryPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response['items'], market, since, limit);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetbalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let lockbox = parseFloat (balance['amount_lockbox']);
            let trades = parseFloat (balance['amount_trades']);
            let account = {
                'free': parseFloat (balance['amount']),
                'used': this.sum (lockbox, trades),
                'total': parseFloat (balance['amount_total']),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        amount = amount.toString ();
        price = price.toString ();
        let market = this.market (symbol);
        let order = {
            'tradetype': side.toUpperCase (),
            'tradeamount': amount,
            'tradeprice': price,
            'tradebase': 1,
            'pair': market['id'],
        };
        let response = await this.privatePostTradePair (this.extend (order, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelorder (this.extend ({
            'orderid': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/';
        if (api == 'private')
            url += api + '/';
        url += this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            url += '?' + this.urlencode ({ 'nonce': nonce });
            let signature = this.hmac (this.encode (url), this.encode (this.secret), 'sha512', 'base64');
            body = this.urlencode (this.extend ({
                'apikey': this.apiKey,
                'signature': signature,
            }, query));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('status' in response)
            if (response['status'] != 'success')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],80:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const okcoinusd = require ('./okcoinusd.js')

// ---------------------------------------------------------------------------

module.exports = class okcoincny extends okcoinusd {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'okcoincny',
            'name': 'OKCoin CNY',
            'countries': 'CN',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766792-8be9157a-5ee5-11e7-926c-6d69b8d3378d.jpg',
                'api': {
                    'web': 'https://www.okcoin.cn',
                    'public': 'https://www.okcoin.cn/pai',
                    'private': 'https://www.okcoin.cn/api',
                },
                'www': 'https://www.okcoin.cn',
                'doc': 'https://www.okcoin.cn/rest_getStarted.html',
            },
            'markets': {
                'BTC/CNY': { 'id': 'btc_cny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                'LTC/CNY': { 'id': 'ltc_cny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                'ETH/CNY': { 'id': 'eth_cny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                'ETC/CNY': { 'id': 'etc_cny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
                'BCH/CNY': { 'id': 'bcc_cny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
            },
        });
    }
}

},{"./okcoinusd.js":81}],81:[function(require,module,exports){
"use strict"

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class okcoinusd extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'okcoinusd',
            'name': 'OKCoin USD',
            'countries': [ 'CN', 'US' ],
            'hasCORS': false,
            'version': 'v1',
            'rateLimit': 1000, // up to 3000 requests per 5 minutes ≈ 600 requests per minute ≈ 10 requests per second ≈ 100 ms
            // obsolete metainfo interface
            'hasFetchOHLCV': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'fetchOHLCV': true,
                'fetchOrder': true,
                'fetchOrders': true,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
                'withdraw': true,
            },
            'extension': '.do', // appended to endpoint URL
            'hasFutureMarkets': false,
            'timeframes': {
                '1m': '1min',
                '3m': '3min',
                '5m': '5min',
                '15m': '15min',
                '30m': '30min',
                '1h': '1hour',
                '2h': '2hour',
                '4h': '4hour',
                '6h': '6hour',
                '12h': '12hour',
                '1d': '1day',
                '3d': '3day',
                '1w': '1week',
            },
            'api': {
                'web': {
                    'get': [
                        'markets/currencies',
                        'markets/products',
                    ],
                },
                'public': {
                    'get': [
                        'depth',
                        'exchange_rate',
                        'future_depth',
                        'future_estimated_price',
                        'future_hold_amount',
                        'future_index',
                        'future_kline',
                        'future_price_limit',
                        'future_ticker',
                        'future_trades',
                        'kline',
                        'otcs',
                        'ticker',
                        'trades',
                    ],
                },
                'private': {
                    'post': [
                        'account_records',
                        'batch_trade',
                        'borrow_money',
                        'borrow_order_info',
                        'borrows_info',
                        'cancel_borrow',
                        'cancel_order',
                        'cancel_otc_order',
                        'cancel_withdraw',
                        'future_batch_trade',
                        'future_cancel',
                        'future_devolve',
                        'future_explosive',
                        'future_order_info',
                        'future_orders_info',
                        'future_position',
                        'future_position_4fix',
                        'future_trade',
                        'future_trades_history',
                        'future_userinfo',
                        'future_userinfo_4fix',
                        'lend_depth',
                        'order_fee',
                        'order_history',
                        'order_info',
                        'orders_info',
                        'otc_order_history',
                        'otc_order_info',
                        'repayment',
                        'submit_otc_order',
                        'trade',
                        'trade_history',
                        'trade_otc_order',
                        'withdraw',
                        'withdraw_info',
                        'unrepayments_info',
                        'userinfo',
                    ],
                },
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg',
                'api': {
                    'web': 'https://www.okcoin.com/v2',
                    'public': 'https://www.okcoin.com/api',
                    'private': 'https://www.okcoin.com/api',
                },
                'www': 'https://www.okcoin.com',
                'doc': [
                    'https://www.okcoin.com/rest_getStarted.html',
                    'https://www.npmjs.com/package/okcoin.com',
                ],
            },
        });
    }

    async fetchMarkets () {
        let response = await this.webGetMarketsProducts ();
        let markets = response['data'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let id = markets[i]['symbol'];
            let uppercase = id.toUpperCase ();
            let [ base, quote ] = uppercase.split ('_');
            let symbol = base + '/' + quote;
            let precision = {
                'amount': markets[i]['maxSizeDigit'],
                'price': markets[i]['maxPriceDigit'],
            };
            let lot = Math.pow (10, -precision['amount']);
            let market = this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': markets[i],
                'type': 'spot',
                'spot': true,
                'future': false,
                'lot': lot,
                'active': true,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': markets[i]['minTradeSize'],
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            });
            result.push (market);
            if ((this.hasFutureMarkets) && (market['quote'] == 'USDT')) {
                result.push (this.extend (market, {
                    'quote': 'USD',
                    'symbol': market['base'] + '/USD',
                    'id': market['id'].replace ('usdt', 'usd'),
                    'type': 'future',
                    'spot': false,
                    'future': true,
                }));
            }
        }
        return result;
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Depth';
        let orderbook = await this[method] (this.extend (request, params));
        let timestamp = this.milliseconds ();
        return {
            'bids': orderbook['bids'],
            'asks': this.sortBy (orderbook['asks'], 0),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['timestamp'];
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Ticker';
        let response = await this[method] (this.extend (request, params));
        let timestamp = parseInt (response['date']) * 1000;
        let ticker = this.extend (response['ticker'], { 'timestamp': timestamp });
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'info': trade,
            'timestamp': trade['date_ms'],
            'datetime': this.iso8601 (trade['date_ms']),
            'symbol': symbol,
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Trades';
        let response = await this[method] (this.extend (request, params));
        return this.parseTrades (response, market, since, limit);
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = 1440, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
            'type': this.timeframes[timeframe],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Kline';
        if (limit)
            request['size'] = parseInt (limit);
        if (since) {
            request['since'] = since;
        } else {
            request['since'] = this.milliseconds () - 86400000; // last 24 hours
        }
        let response = await this[method] (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostUserinfo ();
        let balances = response['info']['funds'];
        let result = { 'info': response };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            account['free'] = this.safeFloat (balances['free'], lowercase, 0.0);
            account['used'] = this.safeFloat (balances['freezed'], lowercase, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost';
        let order = {
            'symbol': market['id'],
            'type': side,
        };
        if (market['future']) {
            method += 'Future';
            order = this.extend (order, {
                'contract_type': 'this_week', // next_week, quarter
                'match_price': 0, // match best counter party price? 0 or 1, ignores price if 1
                'lever_rate': 10, // leverage rate value: 10 or 20 (10 by default)
                'price': price,
                'amount': amount,
            });
        } else {
            if (type == 'limit') {
                order['price'] = price;
                order['amount'] = amount;
            } else {
                order['type'] += '_market';
                if (side == 'buy') {
                    order['price'] = this.safeFloat (params, 'cost');
                    if (!order['price'])
                        throw new ExchangeError (this.id + ' market buy orders require an additional cost parameter, cost = price * amount');
                } else {
                    order['amount'] = amount;
                }
            }
        }
        params = this.omit (params, 'cost');
        method += 'Trade';
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' cancelOrder() requires a symbol argument');
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'order_id': id,
        };
        let method = 'privatePost';
        if (market['future']) {
            method += 'FutureCancel';
            request['contract_type'] = 'this_week'; // next_week, quarter
        } else {
            method += 'CancelOrder';
        }
        let response = await this[method] (this.extend (request, params));
        return response;
    }

    parseOrderStatus (status) {
        if (status == -1)
            return 'canceled';
        if (status == 0)
            return 'open';
        if (status == 1)
            return 'partial';
        if (status == 2)
            return 'closed';
        if (status == 4)
            return 'canceled';
        return status;
    }

    parseOrder (order, market = undefined) {
        let side = undefined;
        let type = undefined;
        if ('type' in order) {
            if ((order['type'] == 'buy') || (order['type'] == 'sell')) {
                side = order['type'];
                type = 'limit';
            } else {
                side = (order['type'] == 'buy_market') ? 'buy' : 'sell';
                type = 'market';
            }
        }
        let status = this.parseOrderStatus (order['status']);
        let symbol = undefined;
        if (!market) {
            if ('symbol' in order)
                if (order['symbol'] in this.markets_by_id)
                    market = this.markets_by_id[order['symbol']];
        }
        if (market)
            symbol = market['symbol'];
        let timestamp = undefined;
        if ('create_date' in order)
            timestamp = order['create_date'];
        let amount = order['amount'];
        let filled = order['deal_amount'];
        let remaining = amount - filled;
        let average = order['avg_price'];
        let cost = average * filled;
        let result = {
            'info': order,
            'id': order['order_id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': order['price'],
            'average': average,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': undefined,
        };
        return result;
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + 'fetchOrders requires a symbol parameter');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost';
        let request = {
            'order_id': id,
            'symbol': market['id'],
            // 'status': 0, // 0 for unfilled orders, 1 for filled orders
            // 'current_page': 1, // current page number
            // 'page_length': 200, // number of orders returned per page, maximum 200
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'OrderInfo';
        let response = await this[method] (this.extend (request, params));
        return this.parseOrder (response['orders'][0]);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + 'fetchOrders requires a symbol parameter');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost';
        let request = {
            'symbol': market['id'],
        };
        let order_id_in_params = ('order_id' in params);
        if (market['future']) {
            method += 'FutureOrdersInfo';
            request['contract_type'] = 'this_week'; // next_week, quarter
            if (!order_id_in_params)
                throw new ExchangeError (this.id + ' fetchOrders() requires order_id param for futures market ' + symbol + ' (a string of one or more order ids, comma-separated)');
        } else {
            let status = undefined;
            if ('type' in params) {
                status = params['type'];
            } else if ('status' in params) {
                status = params['status'];
            } else {
                throw new ExchangeError (this.id + ' fetchOrders() requires type param or status param for spot market ' + symbol + ' (0 or "open" for unfilled orders, 1 or "closed" for filled orders)');
            }
            if (status == 'open')
                status = 0;
            if (status == 'closed')
                status = 1;
            if (order_id_in_params) {
                method += 'OrdersInfo';
                request = this.extend (request, {
                    'type': status,
                });
            } else {
                method += 'OrderHistory';
                request = this.extend (request, {
                    'status': status,
                    'current_page': 1, // current page number
                    'page_length': 200, // number of orders returned per page, maximum 200
                });
            }
            params = this.omit (params, [ 'type', 'status' ]);
        }
        let response = await this[method] (this.extend (request, params));
        return this.parseOrders (response['orders'], market, since, limit);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let open = 0; // 0 for unfilled orders, 1 for filled orders
        return await this.fetchOrders (symbol, undefined, undefined, this.extend ({
            'status': open,
        }, params));
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let closed = 1; // 0 for unfilled orders, 1 for filled orders
        return await this.fetchOrders (symbol, undefined, undefined, this.extend ({
            'status': closed,
        }, params));
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let lowercase = currency.toLowerCase () + '_usd';
        // if (amount < 0.01)
        //     throw new ExchangeError (this.id + ' withdraw() requires amount > 0.01');
        let request = {
            'symbol': lowercase,
            'withdraw_address': address,
            'withdraw_amount': amount,
            'target': 'address', // or okcn, okcom, okex
        };
        let query = params;
        if ('chargefee' in query) {
            request['chargefee'] = query['chargefee'];
            query = this.omit (query, 'chargefee');
        } else {
            throw new ExchangeError (this.id + ' withdraw() requires a `chargefee` parameter');
        }
        let password = undefined;
        if (this.password) {
            password = this.password;
        } else if ('password' in query) {
            request['trade_pwd'] = query['password'];
            query = this.omit (query, 'password');
        } else if ('trade_pwd' in query) {
            request['trade_pwd'] = query['trade_pwd'];
            query = this.omit (query, 'trade_pwd');
        }
        if (!password)
            throw new ExchangeError (this.id + ' withdraw() requires this.password set on the exchange instance or a password / trade_pwd parameter');
        let response = await this.privatePostWithdraw (this.extend (request, query));
        return {
            'info': response,
            'id': this.safeString (response, 'withdraw_id'),
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/';
        if (api != 'web')
            url += this.version + '/';
        url += path + this.extension;
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let query = this.keysort (this.extend ({
                'api_key': this.apiKey,
            }, params));
            // secret key must be at the end of query
            let queryString = this.rawencode (query) + '&secret_key=' + this.secret;
            query['sign'] = this.hash (this.encode (queryString)).toUpperCase ();
            body = this.urlencode (query);
            headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        url = this.urls['api'][api] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('result' in response)
            if (!response['result'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        if ('error_code' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],82:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const okcoinusd = require ('./okcoinusd.js')

// ---------------------------------------------------------------------------

module.exports = class okex extends okcoinusd {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'okex',
            'name': 'OKEX',
            'countries': [ 'CN', 'US' ],
            'hasCORS': false,
            'hasFutureMarkets': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg',
                'api': {
                    'web': 'https://www.okex.com/v2',
                    'public': 'https://www.okex.com/api',
                    'private': 'https://www.okex.com/api',
                },
                'www': 'https://www.okex.com',
                'doc': 'https://www.okex.com/rest_getStarted.html',
            },
        });
    }
}

},{"./okcoinusd.js":81}],83:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class paymium extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'paymium',
            'name': 'Paymium',
            'countries': [ 'FR', 'EU' ],
            'rateLimit': 2000,
            'version': 'v1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27790564-a945a9d4-5ff9-11e7-9d2d-b635763f2f24.jpg',
                'api': 'https://paymium.com/api',
                'www': 'https://www.paymium.com',
                'doc': [
                    'https://github.com/Paymium/api-documentation',
                    'https://www.paymium.com/page/developers',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'countries',
                        'data/{id}/ticker',
                        'data/{id}/trades',
                        'data/{id}/depth',
                        'bitcoin_charts/{id}/trades',
                        'bitcoin_charts/{id}/depth',
                    ],
                },
                'private': {
                    'get': [
                        'merchant/get_payment/{UUID}',
                        'user',
                        'user/addresses',
                        'user/addresses/{btc_address}',
                        'user/orders',
                        'user/orders/{UUID}',
                        'user/price_alerts',
                    ],
                    'post': [
                        'user/orders',
                        'user/addresses',
                        'user/payment_requests',
                        'user/price_alerts',
                        'merchant/create_payment',
                    ],
                    'delete': [
                        'user/orders/{UUID}/cancel',
                        'user/price_alerts/{id}',
                    ],
                },
            },
            'markets': {
                'BTC/EUR': { 'id': 'eur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
            },
            'fees': {
                'trading': {
                    'maker': 0.0059,
                    'taker': 0.0059,
                },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.privateGetUser ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            let balance = 'balance_' + lowercase;
            let locked = 'locked_' + lowercase;
            if (balance in balances)
                account['free'] = balances[balance];
            if (locked in balances)
                account['used'] = balances[locked];
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetDataIdDepth (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let result = this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetDataIdTicker (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = ticker['at'] * 1000;
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': vwap,
            'open': this.safeFloat (ticker, 'open'),
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'price'),
            'change': undefined,
            'percentage': this.safeFloat (ticker, 'variation'),
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['created_at_int']) * 1000;
        let volume = 'traded_' + market['base'].toLowerCase ();
        return {
            'info': trade,
            'id': trade['uuid'],
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade[volume],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetDataIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        let order = {
            'type': this.capitalize (type) + 'Order',
            'currency': this.marketId (market),
            'direction': side,
            'amount': amount,
        };
        if (type == 'market')
            order['price'] = price;
        let response = await this.privatePostUserOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['uuid'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'orderNumber': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            body = this.json (params);
            let nonce = this.nonce ().toString ();
            let auth = nonce + url + body;
            headers = {
                'Api-Key': this.apiKey,
                'Api-Signature': this.hmac (this.encode (auth), this.secret),
                'Api-Nonce': nonce,
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('errors' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],84:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, InsufficientFunds, OrderNotFound, OrderNotCached } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class poloniex extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'poloniex',
            'name': 'Poloniex',
            'countries': 'US',
            'rateLimit': 1000, // up to 6 calls per second
            'hasCORS': true,
            // obsolete metainfo interface
            'hasFetchMyTrades': true,
            'hasFetchOrder': true,
            'hasFetchOrders': true,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasFetchTickers': true,
            'hasFetchCurrencies': true,
            'hasWithdraw': true,
            'hasFetchOHLCV': true,
            // new metainfo interface
            'has': {
                'fetchOHLCV': true,
                'fetchMyTrades': true,
                'fetchOrder': 'emulated',
                'fetchOrders': 'emulated',
                'fetchOpenOrders': true,
                'fetchClosedOrders': 'emulated',
                'fetchTickers': true,
                'fetchCurrencies': true,
                'withdraw': true,
            },
            'timeframes': {
                '5m': 300,
                '15m': 900,
                '30m': 1800,
                '2h': 7200,
                '4h': 14400,
                '1d': 86400,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg',
                'api': {
                    'public': 'https://poloniex.com/public',
                    'private': 'https://poloniex.com/tradingApi',
                },
                'www': 'https://poloniex.com',
                'doc': [
                    'https://poloniex.com/support/api/',
                    'http://pastebin.com/dMX7mZE0',
                ],
                'fees': 'https://poloniex.com/fees',
            },
            'api': {
                'public': {
                    'get': [
                        'return24hVolume',
                        'returnChartData',
                        'returnCurrencies',
                        'returnLoanOrders',
                        'returnOrderBook',
                        'returnTicker',
                        'returnTradeHistory',
                    ],
                },
                'private': {
                    'post': [
                        'buy',
                        'cancelLoanOffer',
                        'cancelOrder',
                        'closeMarginPosition',
                        'createLoanOffer',
                        'generateNewAddress',
                        'getMarginPosition',
                        'marginBuy',
                        'marginSell',
                        'moveOrder',
                        'returnActiveLoans',
                        'returnAvailableAccountBalances',
                        'returnBalances',
                        'returnCompleteBalances',
                        'returnDepositAddresses',
                        'returnDepositsWithdrawals',
                        'returnFeeInfo',
                        'returnLendingHistory',
                        'returnMarginAccountSummary',
                        'returnOpenLoanOffers',
                        'returnOpenOrders',
                        'returnOrderTrades',
                        'returnTradableBalances',
                        'returnTradeHistory',
                        'sell',
                        'toggleAutoRenew',
                        'transferBalance',
                        'withdraw',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.0015,
                    'taker': 0.0025,
                },
                'funding': 0.0,
            },
            'limits': {
                'amount': {
                    'min': 0.00000001,
                    'max': 1000000000,
                },
                'price': {
                    'min': 0.00000001,
                    'max': 1000000000,
                },
                'cost': {
                    'min': 0.00000000,
                    'max': 1000000000,
                },
            },
            'precision': {
                'amount': 8,
                'price': 8,
            },
        });
    }

    calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let market = this.markets[symbol];
        let key = 'quote';
        let rate = market[takerOrMaker];
        let cost = parseFloat (this.costToPrecision (symbol, amount * rate));
        if (side == 'sell') {
            cost *= price;
        } else {
            key = 'base';
        }
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': parseFloat (this.feeToPrecision (symbol, cost)),
        };
    }

    commonCurrencyCode (currency) {
        if (currency == 'BTM')
            return 'Bitmark';
        return currency;
    }

    currencyId (currency) {
        if (currency == 'Bitmark')
            return 'BTM';
        return currency;
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '5m', since = undefined, limit = undefined) {
        return [
            ohlcv['date'] * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '5m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!since)
            since = 0;
        let request = {
            'currencyPair': market['id'],
            'period': this.timeframes[timeframe],
            'start': parseInt (since / 1000),
        };
        if (limit)
            request['end'] = this.sum (request['start'], limit * this.timeframes[timeframe]);
        let response = await this.publicGetReturnChartData (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    }

    async fetchMarkets () {
        let markets = await this.publicGetReturnTicker ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let [ quote, base ] = id.split ('_');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'active': true,
                'lot': this.limits['amount']['min'],
                'info': market,
            }));
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostReturnCompleteBalances (this.extend ({
            'account': 'all',
        }, params));
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let id = currencies[c];
            let balance = balances[id];
            let currency = this.commonCurrencyCode (id);
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['onOrders']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchFees (params = {}) {
        await this.loadMarkets ();
        let fees = await this.privatePostReturnFeeInfo ();
        return {
            'info': fees,
            'maker': parseFloat (fees['makerFee']),
            'taker': parseFloat (fees['takerFee']),
            'withdraw': 0.0,
        };
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetReturnOrderBook (this.extend ({
            'currencyPair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24hr']),
            'low': parseFloat (ticker['low24hr']),
            'bid': parseFloat (ticker['highestBid']),
            'ask': parseFloat (ticker['lowestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': parseFloat (ticker['percentChange']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['quoteVolume']),
            'quoteVolume': parseFloat (ticker['baseVolume']),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetReturnTicker (params);
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchCurrencies (params = {}) {
        let currencies = await this.publicGetReturnCurrencies (params);
        let ids = Object.keys (currencies);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let currency = currencies[id];
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            let precision = {
                'amount': 8, // default precision, todo: fix "magic constants"
                'price': 8,
            };
            let code = this.commonCurrencyCode (id);
            let active = (currency['delisted'] == 0);
            let status = (currency['disabled']) ? 'disabled' : 'ok';
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': currency['name'],
                'active': active,
                'status': status,
                'fee': currency['txFee'], // todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision['amount']),
                        'max': Math.pow (10, precision['amount']),
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': Math.pow (10, precision['price']),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': currency['txFee'],
                        'max': Math.pow (10, precision['amount']),
                    },
                },
            };
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetReturnTicker (params);
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['date']);
        let symbol = undefined;
        if ((!market) && ('currencyPair' in trade))
            market = this.markets_by_id[trade['currencyPair']];
        if (market)
            symbol = market['symbol'];
        let side = trade['type'];
        let fee = undefined;
        let cost = this.safeFloat (trade, 'total');
        let amount = parseFloat (trade['amount']);
        if ('fee' in trade) {
            let rate = parseFloat (trade['fee']);
            let feeCost = undefined;
            let currency = undefined;
            if (side == 'buy') {
                currency = market['base'];
                feeCost = amount * rate;
            } else {
                currency = market['quote'];
                if (typeof cost != 'undefined')
                    feeCost = cost * rate;
            }
            fee = {
                'type': undefined,
                'rate': rate,
                'cost': feeCost,
                'currency': currency,
            };
        }
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'id': this.safeString (trade, 'tradeID'),
            'order': this.safeString (trade, 'orderNumber'),
            'type': 'limit',
            'side': side,
            'price': parseFloat (trade['rate']),
            'amount': amount,
            'cost': cost,
            'fee': fee,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'currencyPair': market['id'],
        };
        if (since) {
            request['start'] = parseInt (since / 1000);
            request['end'] = this.seconds (); // last 50000 trades by default
        }
        let trades = await this.publicGetReturnTradeHistory (this.extend (request, params));
        return this.parseTrades (trades, market, since, limit);
    }

    async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = { 'currencyPair': pair };
        if (since) {
            request['start'] = parseInt (since / 1000);
            request['end'] = this.seconds ();
        }
        // limit is disabled (does not really work as expected)
        // if (limit)
        //     request['limit'] = parseInt (limit);
        let response = await this.privatePostReturnTradeHistory (this.extend (request, params));
        let result = [];
        if (market) {
            result = this.parseTrades (response, market);
        } else {
            if (response) {
                let ids = Object.keys (response);
                for (let i = 0; i < ids.length; i++) {
                    let id = ids[i];
                    let market = this.markets_by_id[id];
                    let symbol = market['symbol'];
                    let trades = this.parseTrades (response[id], market);
                    for (let j = 0; j < trades.length; j++) {
                        result.push (trades[j]);
                    }
                }
            }
        }
        return this.filterBySinceLimit (result, since, limit);
    }

    parseOrder (order, market = undefined) {
        let timestamp = this.safeInteger (order, 'timestamp');
        if (!timestamp)
            timestamp = this.parse8601 (order['date']);
        let trades = undefined;
        if ('resultingTrades' in order)
            trades = this.parseTrades (order['resultingTrades'], market);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        let price = parseFloat (order['price']);
        let cost = this.safeFloat (order, 'total', 0.0);
        let remaining = this.safeFloat (order, 'amount');
        let amount = this.safeFloat (order, 'startingAmount', remaining);
        let filled = amount - remaining;
        return {
            'info': order,
            'id': order['orderNumber'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': order['status'],
            'symbol': symbol,
            'type': order['type'],
            'side': order['side'],
            'price': price,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'trades': trades,
            'fee': undefined,
        };
    }

    parseOpenOrders (orders, market, result = []) {
        for (let i = 0; i < orders.length; i++) {
            let order = orders[i];
            let extended = this.extend (order, {
                'status': 'open',
                'type': 'limit',
                'side': order['type'],
                'price': order['rate'],
            });
            result.push (this.parseOrder (extended, market));
        }
        return result;
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let response = await this.privatePostReturnOpenOrders (this.extend ({
            'currencyPair': pair,
        }));
        let openOrders = [];
        if (market) {
            openOrders = this.parseOpenOrders (response, market, openOrders);
        } else {
            let marketIds = Object.keys (response);
            for (let i = 0; i < marketIds.length; i++) {
                let marketId = marketIds[i];
                let orders = response[marketId];
                let m = this.markets_by_id[marketId];
                openOrders = this.parseOpenOrders (orders, m, openOrders);
            }
        }
        for (let j = 0; j < openOrders.length; j++) {
            this.orders[openOrders[j]['id']] = openOrders[j];
        }
        let openOrdersIndexedById = this.indexBy (openOrders, 'id');
        let cachedOrderIds = Object.keys (this.orders);
        let result = [];
        for (let k = 0; k < cachedOrderIds.length; k++) {
            let id = cachedOrderIds[k];
            if (id in openOrdersIndexedById) {
                this.orders[id] = this.extend (this.orders[id], openOrdersIndexedById[id]);
            } else {
                let order = this.orders[id];
                if (order['status'] == 'open') {
                    this.orders[id] = this.extend (order, {
                        'status': 'closed',
                        'cost': order['amount'] * order['price'],
                        'filled': order['amount'],
                        'remaining': 0.0,
                    });
                }
            }
            let order = this.orders[id];
            if (market) {
                if (order['symbol'] == symbol)
                    result.push (order);
            } else {
                result.push (order);
            }
        }
        return this.filterBySinceLimit (result, since, limit);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        let since = this.safeValue (params, 'since');
        let limit = this.safeValue (params, 'limit');
        let request = this.omit (params, [ 'since', 'limit' ]);
        let orders = await this.fetchOrders (symbol, since, limit, request);
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['id'] == id)
                return orders[i];
        }
        throw new OrderNotCached (this.id + ' order id ' + id.toString () + ' not found in cache');
    }

    filterOrdersByStatus (orders, status) {
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            if (orders[i]['status'] == status)
                result.push (orders[i]);
        }
        return result;
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, since, limit, params);
        return this.filterOrdersByStatus (orders, 'open');
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        let orders = await this.fetchOrders (symbol, since, limit, params);
        return this.filterOrdersByStatus (orders, 'closed');
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        let method = 'privatePost' + this.capitalize (side);
        let market = this.market (symbol);
        price = parseFloat (price);
        amount = parseFloat (amount);
        let response = await this[method] (this.extend ({
            'currencyPair': market['id'],
            'rate': this.priceToPrecision (symbol, price),
            'amount': this.amountToPrecision (symbol, amount),
        }, params));
        let timestamp = this.milliseconds ();
        let order = this.parseOrder (this.extend ({
            'timestamp': timestamp,
            'status': 'open',
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
        }, response), market);
        let id = order['id'];
        this.orders[id] = order;
        return this.extend ({ 'info': response }, order);
    }

    async editOrder (id, symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        price = parseFloat (price);
        amount = parseFloat (amount);
        let request = {
            'orderNumber': id,
            'rate': this.priceToPrecision (symbol, price),
            'amount': this.amountToPrecision (symbol, amount),
        };
        let response = await this.privatePostMoveOrder (this.extend (request, params));
        let result = undefined;
        if (id in this.orders) {
            this.orders[id]['status'] = 'canceled';
            let newid = response['orderNumber'];
            this.orders[newid] = this.extend (this.orders[id], {
                'id': newid,
                'price': price,
                'amount': amount,
                'status': 'open',
            });
            result = this.extend (this.orders[newid], { 'info': response });
        } else {
            result = {
                'info': response,
                'id': response['orderNumber'],
            };
        }
        return result;
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let response = undefined;
        try {
            response = await this.privatePostCancelOrder (this.extend ({
                'orderNumber': id,
            }, params));
            if (id in this.orders)
                this.orders[id]['status'] = 'canceled';
        } catch (e) {
            if (this.last_http_response) {
                if (this.last_http_response.indexOf ('Invalid order') >= 0)
                    throw new OrderNotFound (this.id + ' cancelOrder() error: ' + this.last_http_response);
            }
            throw e;
        }
        return response;
    }

    async fetchOrderStatus (id, symbol = undefined) {
        await this.loadMarkets ();
        let orders = await this.fetchOpenOrders (symbol);
        let indexed = this.indexBy (orders, 'id');
        return (id in indexed) ? 'open' : 'closed';
    }

    async fetchOrderTrades (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let trades = await this.privatePostReturnOrderTrades (this.extend ({
            'orderNumber': id,
        }, params));
        return this.parseTrades (trades);
    }

    async createDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let response = await this.privatePostGenerateNewAddress ({
            'currency': currencyId
        });
        let address = undefined;
        if (response['success'] == 1)
            address = this.safeString (response, 'response');
        if (!address)
            throw new ExchangeError (this.id + ' createDepositAddress failed: ' + this.last_http_response);
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async fetchDepositAddress (currency, params = {}) {
        let response = await this.privatePostReturnDepositAddresses ();
        let currencyId = this.currencyId (currency);
        let address = this.safeString (response, currencyId);
        let status = address ? 'ok' : 'none';
        return {
            'currency': currency,
            'address': address,
            'status': status,
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let currencyId = this.currencyId (currency);
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currencyId,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': result['response'],
        };
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let query = this.extend ({ 'command': path }, params);
        if (api == 'public') {
            url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            query['nonce'] = this.nonce ();
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response) {
            let error = this.id + ' ' + this.json (response);
            let failed = response['error'].indexOf ('Not enough') >= 0;
            if (failed)
                throw new InsufficientFunds (error);
            throw new ExchangeError (error);
        }
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],85:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, OrderNotFound, InvalidOrder, InsufficientFunds } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class qryptos extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'qryptos',
            'name': 'QRYPTOS',
            'countries': [ 'CN', 'TW' ],
            'version': '2',
            'rateLimit': 1000,
            'hasFetchTickers': true,
            'hasCORS': false,
            'has': {
                'fetchOrder': true,
                'fetchOrders': true,
                'fetchOpenOrders': true,
                'fetchClosedOrders': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30953915-b1611dc0-a436-11e7-8947-c95bd5a42086.jpg',
                'api': 'https://api.qryptos.com',
                'www': 'https://www.qryptos.com',
                'doc': 'https://developers.quoine.com',
            },
            'api': {
                'public': {
                    'get': [
                        'products',
                        'products/{id}',
                        'products/{id}/price_levels',
                        'executions',
                        'ir_ladders/{currency}',
                    ],
                },
                'private': {
                    'get': [
                        'accounts/balance',
                        'crypto_accounts',
                        'executions/me',
                        'fiat_accounts',
                        'loan_bids',
                        'loans',
                        'orders',
                        'orders/{id}',
                        'orders/{id}/trades',
                        'trades',
                        'trades/{id}/loans',
                        'trading_accounts',
                        'trading_accounts/{id}',
                    ],
                    'post': [
                        'fiat_accounts',
                        'loan_bids',
                        'orders',
                    ],
                    'put': [
                        'loan_bids/{id}/close',
                        'loans/{id}',
                        'orders/{id}',
                        'orders/{id}/cancel',
                        'trades/{id}',
                        'trades/{id}/close',
                        'trades/close_all',
                        'trading_accounts/{id}',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetProducts ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let base = market['base_currency'];
            let quote = market['quoted_currency'];
            let symbol = base + '/' + quote;
            let maker = parseFloat (market['maker_fee']);
            let taker = parseFloat (market['taker_fee']);
            let active = !market['disabled'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'maker': maker,
                'taker': taker,
                'active': active,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccountsBalance ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let total = parseFloat (balance['balance']);
            let account = {
                'free': total,
                'used': 0.0,
                'total': total,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetProductsIdPriceLevels (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buy_price_levels', 'sell_price_levels');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let last = undefined;
        if ('last_traded_price' in ticker) {
            if (ticker['last_traded_price']) {
                let length = ticker['last_traded_price'].length;
                if (length > 0)
                    last = parseFloat (ticker['last_traded_price']);
            }
        }
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high_market_ask']),
            'low': parseFloat (ticker['low_market_bid']),
            'bid': parseFloat (ticker['market_bid']),
            'ask': parseFloat (ticker['market_ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_24h']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetProducts (params);
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let base = ticker['base_currency'];
            let quote = ticker['quoted_currency'];
            let symbol = base + '/' + quote;
            let market = this.markets[symbol];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetProductsId (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['created_at'] * 1000;
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['taker_side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['quantity']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'product_id': market['id'],
        };
        if (limit)
            request['limit'] = limit;
        let response = await this.publicGetExecutions (this.extend (request, params));
        return this.parseTrades (response['models'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'order_type': type,
            'product_id': this.marketId (symbol),
            'side': side,
            'quantity': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrders (this.extend ({
            'order': order,
        }, params));
        return this.parseOrder(response);
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let result = await this.privatePutOrdersIdCancel (this.extend ({
            'id': id,
        }, params));
        let order = this.parseOrder(result);
        if (!order['type'])
            throw new OrderNotFound (this.id + ' ' + order);
        return order;
    }

    parseOrder (order) {
        let timestamp = order['created_at'] * 1000;
        let marketId = order['product_id'];
        let market = this.marketsById[marketId];
        let status = undefined;
        if ('status' in order) {
            if (order['status'] == 'live') {
                status = 'open';
            } else if (order['status'] == 'filled') {
                status = 'closed';
            } else if (order['status'] == 'cancelled') { // 'll' intended
                status = 'canceled';
            }
        }
        let amount = parseFloat (order['quantity']);
        let filled = parseFloat (order['filled_quantity']);
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        }
        return {
            'id': order['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'type': order['order_type'],
            'status': status,
            'symbol': symbol,
            'side': order['side'],
            'price': order['price'],
            'amount': amount,
            'filled': filled,
            'remaining': amount - filled,
            'trades': undefined,
            'fee': {
                'currency': undefined,
                'cost': parseFloat (order['order_fee']),
            },
            'info': order,
        };
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let order = await this.privateGetOrdersId (this.extend ({
            'id': id,
        }, params));
        return this.parseOrder (order);
    }

    async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params={}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {};
        if (symbol) {
            market = this.market (symbol);
            request['product_id'] = market['id'];
        }
        let status = params['status'];
        if (status == 'open') {
            request['status'] = 'live';
        } else if (status == 'closed') {
            request['status'] = 'filled';
        } else if (status == 'canceled') {
            request['status'] = 'cancelled';
        }
        let result = await this.privateGetOrders (request);
        let orders = result['models'];
        return this.parseOrders (orders, market, since, limit);
    }

    fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        return this.fetchOrders (symbol, since, limit, this.extend ({ 'status': 'open' }, params));
    }

    fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        return this.fetchOrders (symbol, since, limit, this.extend ({ 'status': 'closed' }, params));
    }

    handleErrors (code, reason, url, method, headers, body) {
        let response = undefined;
        if (code == 200 || code == 404 || code == 422) {
            if ((body[0] == '{') || (body[0] == '[')) {
                response = JSON.parse (body);
            } else {
                // if not a JSON response
                throw new ExchangeError (this.id + ' returned a non-JSON reply: ' + body);
            }
        }
        if (code == 404) {
            if ('message' in response) {
                if (response['message'] == 'Order not found') {
                    throw new OrderNotFound (this.id + ' ' + body);
                }
            }
        } else if (code == 422) {
            if ('errors' in response) {
                let errors = response['errors'];
                if ('user' in errors) {
                    let messages = errors['user'];
                    if (messages.indexOf ('not_enough_free_balance') >= 0) {
                        throw new InsufficientFunds (this.id + ' ' + body);
                    }
                } else if ('quantity' in errors) {
                    let messages = errors['quantity'];
                    if (messages.indexOf ('less_than_order_size') >= 0) {
                        throw new InvalidOrder (this.id + ' ' + body);
                    }
                }
            }
        }
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        headers = {
            'X-Quoine-API-Version': this.version,
            'Content-Type': 'application/json',
        };
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            if (method == 'GET') {
                if (Object.keys (query).length)
                    url += '?' + this.urlencode (query);
            } else if (Object.keys (query).length) {
                body = this.json (query);
            }
            let nonce = this.nonce ();
            let request = {
                'path': url,
                'nonce': nonce,
                'token_id': this.apiKey,
                'iat': Math.floor (nonce / 1000), // issued at
            };
            headers['X-Quoine-Auth'] = this.jwt (request, this.secret);
        }
        url = this.urls['api'] + url;
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],86:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, AuthenticationError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class quadrigacx extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'quadrigacx',
            'name': 'QuadrigaCX',
            'countries': 'CA',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': true,
            // obsolete metainfo interface
            'hasWithdraw': true,
            // new metainfo interface
            'has': {
                'withdraw': true,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766825-98a6d0de-5ee7-11e7-9fa4-38e11a2c6f52.jpg',
                'api': 'https://api.quadrigacx.com',
                'www': 'https://www.quadrigacx.com',
                'doc': 'https://www.quadrigacx.com/api_info',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'order_book',
                        'ticker',
                        'transactions',
                    ],
                },
                'private': {
                    'post': [
                        'balance',
                        'bitcoin_deposit_address',
                        'bitcoin_withdrawal',
                        'buy',
                        'cancel_order',
                        'ether_deposit_address',
                        'ether_withdrawal',
                        'lookup_order',
                        'open_orders',
                        'sell',
                        'user_transactions',
                    ],
                },
            },
            'markets': {
                'BTC/CAD': { 'id': 'btc_cad', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'maker': 0.005, 'taker': 0.005 },
                'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'maker': 0.002, 'taker': 0.002 },
                'ETH/CAD': { 'id': 'eth_cad', 'symbol': 'ETH/CAD', 'base': 'ETH', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                'LTC/CAD': { 'id': 'ltc_cad', 'symbol': 'LTC/CAD', 'base': 'LTC', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                'BCH/CAD': { 'id': 'btc_cad', 'symbol': 'BCH/CAD', 'base': 'BCH', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
                'BTG/CAD': { 'id': 'btg_cad', 'symbol': 'BTG/CAD', 'base': 'BTG', 'quote': 'CAD', 'maker': 0.005, 'taker': 0.005 },
            },
        });
    }

    async fetchBalance (params = {}) {
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let lowercase = currency.toLowerCase ();
            let account = {
                'free': parseFloat (balances[lowercase + '_available']),
                'used': parseFloat (balances[lowercase + '_reserved']),
                'total': parseFloat (balances[lowercase + '_balance']),
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetOrderBook (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    }

    async fetchTicker (symbol, params = {}) {
        let ticker = await this.publicGetTicker (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        let vwap = parseFloat (ticker['vwap']);
        let baseVolume = parseFloat (ticker['volume']);
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'book': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'amount': amount,
            'book': this.marketId (symbol),
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'id': id,
        }, params));
    }

    withdrawalMethod (currency) {
        if (currency == 'ETH')
            return 'Ether';
        if (currency == 'BTC')
            return 'Bitcoin';
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let request = {
            'amount': amount,
            'address': address
        };
        let method = 'privatePost' + this.withdrawalMethod (currency) + 'Withdrawal';
        let response = await this[method] (this.extend (request, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            let request = [ nonce.toString (), this.uid, this.apiKey ].join ('');
            let signature = this.hmac (this.encode (request), this.encode (this.secret));
            let query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
                'signature': signature,
            }, params);
            body = this.json (query);
            headers = {
                'Content-Type': 'application/json',
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (typeof response == 'string')
            return response;
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],87:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const qryptos = require ('./qryptos.js')

// ---------------------------------------------------------------------------

module.exports = class quoine extends qryptos {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'quoine',
            'name': 'QUOINE',
            'countries': [ 'JP', 'SG', 'VN' ],
            'version': '2',
            'rateLimit': 1000,
            'hasFetchTickers': true,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766844-9615a4e8-5ee8-11e7-8814-fcd004db8cdd.jpg',
                'api': 'https://api.quoine.com',
                'www': 'https://www.quoine.com',
                'doc': 'https://developers.quoine.com',
            },
        });
    }
}

},{"./qryptos.js":85}],88:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

//  ---------------------------------------------------------------------------

module.exports = class southxchange extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'southxchange',
            'name': 'SouthXchange',
            'countries': 'AR', // Argentina
            'rateLimit': 1000,
            'hasFetchTickers': true,
            'hasCORS': false,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27838912-4f94ec8a-60f6-11e7-9e5d-bbf9bd50a559.jpg',
                'api': 'https://www.southxchange.com/api',
                'www': 'https://www.southxchange.com',
                'doc': 'https://www.southxchange.com/Home/Api',
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'price/{symbol}',
                        'prices',
                        'book/{symbol}',
                        'trades/{symbol}',
                    ],
                },
                'private': {
                    'post': [
                        'cancelMarketOrders',
                        'cancelOrder',
                        'generatenewaddress',
                        'listOrders',
                        'listBalances',
                        'placeOrder',
                        'withdraw',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'maker': 0.2 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let base = market[0];
            let quote = market[1];
            let symbol = base + '/' + quote;
            let id = symbol;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostListBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['Currency'];
            let uppercase = currency.toUpperCase ();
            let free = parseFloat (balance['Available']);
            let used = parseFloat (balance['Unconfirmed']);
            let total = this.sum (free, used);
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'BuyOrders', 'SellOrders', 'Price', 'Amount');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': this.safeFloat (ticker, 'Bid'),
            'ask': this.safeFloat (ticker, 'Ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'Last'),
            'change': this.safeFloat (ticker, 'Variation24Hr'),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'Volume24Hr'),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetPrices (params);
        let tickers = this.indexBy (response, 'Market');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let symbol = id;
            let market = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetPriceSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market) {
        let timestamp = trade['At'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': undefined,
            'order': undefined,
            'type': undefined,
            'side': trade['Type'],
            'price': trade['Price'],
            'amount': trade['Amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let order = {
            'listingCurrency': market['base'],
            'referenceCurrency': market['quote'],
            'type': side,
            'amount': amount,
        };
        if (type == 'limit')
            order['limitPrice'] = price;
        let response = await this.privatePostPlaceOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response.toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelOrder (this.extend ({
            'orderCode': id,
        }, params));
    }

    async withdraw (currency, amount, address, params = {}) {
        let response = await this.privatePostWithdraw (this.extend ({
            'currency': currency,
            'address': address,
            'amount': amount,
        }, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
            }, query);
            body = this.json (query);
            headers = {
                'Content-Type': 'application/json',
                'Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        return response;
    }
}

},{"./base/Exchange":8}],89:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const foxbit = require ('./foxbit.js')

// ---------------------------------------------------------------------------

module.exports = class surbitcoin extends foxbit {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'surbitcoin',
            'name': 'SurBitcoin',
            'countries': 'VE',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991511-f0a50194-6481-11e7-99b5-8f02932424cc.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://surbitcoin.com',
                'doc': 'https://blinktrade.com/docs',
            },
        });
    }
}

},{"./foxbit.js":54}],90:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class therock extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'therock',
            'name': 'TheRockTrading',
            'countries': 'MT',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg',
                'api': 'https://api.therocktrading.com',
                'www': 'https://therocktrading.com',
                'doc': [
                    'https://api.therocktrading.com/doc/v1/index.html',
                    'https://api.therocktrading.com/doc/',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'funds/{id}/orderbook',
                        'funds/{id}/ticker',
                        'funds/{id}/trades',
                        'funds/tickers',
                    ],
                },
                'private': {
                    'get': [
                        'balances',
                        'balances/{id}',
                        'discounts',
                        'discounts/{id}',
                        'funds',
                        'funds/{id}',
                        'funds/{id}/trades',
                        'funds/{fund_id}/orders',
                        'funds/{fund_id}/orders/{id}',
                        'funds/{fund_id}/position_balances',
                        'funds/{fund_id}/positions',
                        'funds/{fund_id}/positions/{id}',
                        'transactions',
                        'transactions/{id}',
                        'withdraw_limits/{id}',
                        'withdraw_limits',
                    ],
                    'post': [
                        'atms/withdraw',
                        'funds/{fund_id}/orders',
                    ],
                    'delete': [
                        'funds/{fund_id}/orders/{id}',
                        'funds/{fund_id}/orders/remove_all',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.02 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetFundsTickers ();
        let result = [];
        for (let p = 0; p < markets['tickers'].length; p++) {
            let market = markets['tickers'][p];
            let id = market['fund_id'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let free = balance['trading_balance'];
            let total = balance['balance'];
            let used = total - free;
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetFundsIdOrderbook (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = this.parse8601 (orderbook['date']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = this.parse8601 (ticker['date']);
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_traded']),
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetFundsTickers (params);
        let tickers = this.indexBy (response['tickers'], 'fund_id');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetFundsIdTicker (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTicker (ticker, market);
    }

    parseTrade (trade, market = undefined) {
        if (!market)
            market = this.markets_by_id[trade['fund_id']];
        let timestamp = this.parse8601 (trade['date']);
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetFundsIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.privatePostFundsFundIdOrders (this.extend ({
            'fund_id': this.marketId (symbol),
            'side': side,
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privateDeleteFundsFundIdOrdersId (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ().toString ();
            let auth = nonce + url;
            headers = {
                'X-TRT-KEY': this.apiKey,
                'X-TRT-NONCE': nonce,
                'X-TRT-SIGN': this.hmac (this.encode (auth), this.encode (this.secret), 'sha512'),
            };
            if (Object.keys (query).length) {
                body = this.json (query);
                headers['Content-Type'] = 'application/json';
            }
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('errors' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],91:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const liqui = require ('./liqui.js')

// ---------------------------------------------------------------------------

module.exports = class tidex extends liqui {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'tidex',
            'name': 'Tidex',
            'countries': 'UK',
            'rateLimit': 2000,
            'version': '3',
            // 'hasCORS': false,
            // 'hasFetchTickers': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30781780-03149dc4-a12e-11e7-82bb-313b269d24d4.jpg',
                'api': {
                    'public': 'https://api.tidex.com/api',
                    'private': 'https://api.tidex.com/tapi',
                },
                'www': 'https://tidex.com',
                'doc': 'https://tidex.com/public-api',
                'fees': 'https://tidex.com/pairs-spec',
            },
            'fees': {
                'trading': {
                    'tierBased': false,
                    'percentage': true,
                    'taker': 0.1 / 100,
                    'maker': 0.1 / 100,
                },
                'funding': {
                    'tierBased': false,
                    'percentage': false,
                    'withdraw': {
                        'BTC': 0.0012,
                        'ETH': 0.01,
                        'LTC': 0.001,
                        'DOGE': 0.01,
                        'ICN': 2,
                        'DASH': 0.002,
                        'GNO': 2,
                        'EOS': 2,
                        'BCH': 2,
                        'USDT': 0,
                    },
                    'deposit': {
                        'BTC': 0,
                        'ETH': 0,
                        'LTC': 0,
                        'DOGE': 0,
                        'ICN': 0,
                        'DASH': 0,
                        'GNO': 0,
                        'EOS': 0,
                        'BCH': 0,
                        'USDT': 0,
                    },
                },
            },
        });
    }
}

},{"./liqui.js":74}],92:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const foxbit = require ('./foxbit.js')

// ---------------------------------------------------------------------------

module.exports = class urdubit extends foxbit {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'urdubit',
            'name': 'UrduBit',
            'countries': 'PK',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991453-156bf3ae-6480-11e7-82eb-7295fe1b5bb4.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://urdubit.com',
                'doc': 'https://blinktrade.com/docs',
            },
        });
    }
}

},{"./foxbit.js":54}],93:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')

// ---------------------------------------------------------------------------

module.exports = class vaultoro extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'vaultoro',
            'name': 'Vaultoro',
            'countries': 'CH',
            'rateLimit': 1000,
            'version': '1',
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766880-f205e870-5ee9-11e7-8fe2-0d5b15880752.jpg',
                'api': 'https://api.vaultoro.com',
                'www': 'https://www.vaultoro.com',
                'doc': 'https://api.vaultoro.com',
            },
            'api': {
                'public': {
                    'get': [
                        'bidandask',
                        'buyorders',
                        'latest',
                        'latesttrades',
                        'markets',
                        'orderbook',
                        'sellorders',
                        'transactions/day',
                        'transactions/hour',
                        'transactions/month',
                    ],
                },
                'private': {
                    'get': [
                        'balance',
                        'mytrades',
                        'orders',
                    ],
                    'post': [
                        'buy/{symbol}/{type}',
                        'cancel/{id}',
                        'sell/{symbol}/{type}',
                        'withdraw',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let result = [];
        let markets = await this.publicGetMarkets ();
        let market = markets['data'];
        let base = market['BaseCurrency'];
        let quote = market['MarketCurrency'];
        let symbol = base + '/' + quote;
        let baseId = base;
        let quoteId = quote;
        let id = market['MarketName'];
        result.push ({
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'info': market,
        });
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['data'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency_code'];
            let uppercase = currency.toUpperCase ();
            let free = balance['cash'];
            let used = balance['reserved'];
            let total = this.sum (free, used);
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (params);
        let orderbook = {
            'bids': response['data'][0]['b'],
            'asks': response['data'][1]['s'],
        };
        let result = this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'Gold_Price', 'Gold_Amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let quote = await this.publicGetBidandask (params);
        let bidsLength = quote['bids'].length;
        let bid = quote['bids'][bidsLength - 1];
        let ask = quote['asks'][0];
        let response = await this.publicGetMarkets (params);
        let ticker = response['data'];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['24hHigh']),
            'low': parseFloat (ticker['24hLow']),
            'bid': bid[0],
            'ask': ask[0],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['LastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['24hVolume']),
            'info': ticker,
        };
    }

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['Time']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['Gold_Price'],
            'amount': trade['Gold_Amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTransactionsDay (params);
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'SymbolType';
        let response = await this[method] (this.extend ({
            'symbol': market['quoteId'].toLowerCase (),
            'type': type,
            'gld': amount,
            'price': price || 1,
        }, params));
        return {
            'info': response,
            'id': response['data']['Order_ID'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        return await this.privatePostCancelId (this.extend ({
            'id': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (api == 'public') {
            url += path;
        } else {
            this.checkRequiredCredentials ();
            let nonce = this.nonce ();
            url += this.version + '/' + this.implodeParams (path, params);
            let query = this.extend ({
                'nonce': nonce,
                'apikey': this.apiKey,
            }, this.omit (params, this.extractParams (path)));
            url += '?' + this.urlencode (query);
            headers = {
                'Content-Type': 'application/json',
                'X-Signature': this.hmac (this.encode (url), this.encode (this.secret))
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8}],94:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const foxbit = require ('./foxbit.js')

// ---------------------------------------------------------------------------

module.exports = class vbtc extends foxbit {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'vbtc',
            'name': 'VBTC',
            'countries': 'VN',
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27991481-1f53d1d8-6481-11e7-884e-21d17e7939db.jpg',
                'api': {
                    'public': 'https://api.blinktrade.com/api',
                    'private': 'https://api.blinktrade.com/tapi',
                },
                'www': 'https://vbtc.exchange',
                'doc': 'https://blinktrade.com/docs',
            },
        });
    }
}

},{"./foxbit.js":54}],95:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class virwox extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'virwox',
            'name': 'VirWoX',
            'countries': [ 'AT', 'EU' ],
            'rateLimit': 1000,
            'hasCORS': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766894-6da9d360-5eea-11e7-90aa-41f2711b7405.jpg',
                'api': {
                    'public': 'http://api.virwox.com/api/json.php',
                    'private': 'https://www.virwox.com/api/trading.php',
                },
                'www': 'https://www.virwox.com',
                'doc': 'https://www.virwox.com/developers.php',
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': false,
                'login': true,
                'password': true
            },
            'api': {
                'public': {
                    'get': [
                        'getInstruments',
                        'getBestPrices',
                        'getMarketDepth',
                        'estimateMarketOrder',
                        'getTradedPriceVolume',
                        'getRawTradeData',
                        'getStatistics',
                        'getTerminalList',
                        'getGridList',
                        'getGridStatistics',
                    ],
                    'post': [
                        'getInstruments',
                        'getBestPrices',
                        'getMarketDepth',
                        'estimateMarketOrder',
                        'getTradedPriceVolume',
                        'getRawTradeData',
                        'getStatistics',
                        'getTerminalList',
                        'getGridList',
                        'getGridStatistics',
                    ],
                },
                'private': {
                    'get': [
                        'cancelOrder',
                        'getBalances',
                        'getCommissionDiscount',
                        'getOrders',
                        'getTransactions',
                        'placeOrder',
                    ],
                    'post': [
                        'cancelOrder',
                        'getBalances',
                        'getCommissionDiscount',
                        'getOrders',
                        'getTransactions',
                        'placeOrder',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetInstruments ();
        let keys = Object.keys (markets['result']);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let market = markets['result'][keys[p]];
            let id = market['instrumentID'];
            let symbol = market['symbol'];
            let base = market['longCurrency'];
            let quote = market['shortCurrency'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetBalances ();
        let balances = response['result']['accountList'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let total = balance['balance'];
            let account = {
                'free': total,
                'used': 0.0,
                'total': total,
            };
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    async fetchMarketPrice (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicPostGetBestPrices (this.extend ({
            'symbols': [ symbol ],
        }, params));
        let result = response['result'];
        return {
            'bid': this.safeFloat (result[0], 'bestBuyPrice'),
            'ask': this.safeFloat (result[0], 'bestSellPrice'),
        };
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicPostGetMarketDepth (this.extend ({
            'symbols': [ symbol ],
            'buyDepth': 100,
            'sellDepth': 100,
        }, params));
        let orderbook = response['result'][0];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'price', 'volume');
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let end = this.milliseconds ();
        let start = end - 86400000;
        let response = await this.publicGetTradedPriceVolume (this.extend ({
            'instrument': symbol,
            'endDate': this.YmdHMS (end),
            'startDate': this.YmdHMS (start),
            'HLOC': 1,
        }, params));
        let marketPrice = await this.fetchMarketPrice (symbol, params);
        let tickers = response['result']['priceVolumeList'];
        let keys = Object.keys (tickers);
        let length = keys.length;
        let lastKey = keys[length - 1];
        let ticker = tickers[lastKey];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': marketPrice['bid'],
            'ask': marketPrice['ask'],
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['longVolume']),
            'quoteVolume': parseFloat (ticker['shortVolume']),
            'info': ticker,
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        return await this.publicGetRawTradeData (this.extend ({
            'instrument': market['id'],
            'timespan': 3600,
        }, params));
    }

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'instrument': this.symbol (market),
            'orderType': side.toUpperCase (),
            'amount': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostPlaceOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderID'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'orderID': id,
        }, params));
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let auth = {};
        if (api == 'private') {
            this.checkRequiredCredentials ();
            auth['key'] = this.apiKey;
            auth['user'] = this.login;
            auth['pass'] = this.password;
        }
        let nonce = this.nonce ();
        if (method == 'GET') {
            url += '?' + this.urlencode (this.extend ({
                'method': path,
                'id': nonce,
            }, auth, params));
        } else {
            headers = { 'Content-Type': 'application/json' };
            body = this.json ({
                'method': path,
                'params': this.extend (auth, params),
                'id': nonce,
            });
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],96:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const liqui = require ('./liqui.js')
const { ExchangeError, InsufficientFunds, OrderNotFound, DDoSProtection } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class wex extends liqui {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'wex',
            'name': 'WEX',
            'countries': 'NZ', // New Zealand
            'version': '3',
            'hasFetchTickers': true,
            'hasCORS': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/30652751-d74ec8f8-9e31-11e7-98c5-71469fcef03e.jpg',
                'api': {
                    'public': 'https://wex.nz/api',
                    'private': 'https://wex.nz/tapi',
                },
                'www': 'https://wex.nz',
                'doc': [
                    'https://wex.nz/api/3/docs',
                    'https://wex.nz/tapi/docs',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'info',
                        'ticker/{pair}',
                        'depth/{pair}',
                        'trades/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'getInfo',
                        'Trade',
                        'ActiveOrders',
                        'OrderInfo',
                        'CancelOrder',
                        'TradeHistory',
                        'TransHistory',
                        'CoinDepositAddress',
                        'WithdrawCoin',
                        'CreateCoupon',
                        'RedeemCoupon',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.2 / 100,
                    'taker': 0.2 / 100,
                },
            },
        });
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'sell'),
            'ask': this.safeFloat (ticker, 'buy'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'avg'),
            'baseVolume': this.safeFloat (ticker, 'vol_cur'),
            'quoteVolume': this.safeFloat (ticker, 'vol'),
            'info': ticker,
        };
    }

    handleErrors (code, reason, url, method, headers, body) {
        if (code == 200) {
            if (body[0] != '{') {
                // response is not JSON
                throw new ExchangeError (this.id + ' returned a non-JSON reply: ' + body);
            }
            let response = JSON.parse (body);
            if ('success' in response) {
                if (!response['success']) {
                    let error = this.safeValue (response, 'error');
                    if (!error) {
                        throw new ExchangeError (this.id + ' returned a malformed error: ' + body);
                    } else if (error == 'bad status') {
                        throw new OrderNotFound (this.id + ' ' + error);
                    } else if (error.indexOf ('It is not enough') >= 0) {
                        throw new InsufficientFunds (this.id + ' ' + error);
                    } else if (error == 'Requests too often') {
                        throw new DDoSProtection (this.id + ' ' + error);
                    } else if (error == 'not available') {
                        throw new DDoSProtection (this.id + ' ' + error);
                    } else if (error == 'external service unavailable') {
                        throw new DDoSProtection (this.id + ' ' + error);
                    // that's what fetchOpenOrders return if no open orders (fix for #489)
                    } else if (error != 'no orders') {
                        throw new ExchangeError (this.id + ' ' + error);
                    }
                }
            }
        }
    }

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        return this.fetch2 (path, api, method, params, headers, body);
    }
}

},{"./base/errors":10,"./liqui.js":74}],97:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError, NotSupported, AuthenticationError } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class xbtce extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'xbtce',
            'name': 'xBTCe',
            'countries': 'RU',
            'rateLimit': 2000, // responses are cached every 2 seconds
            'version': 'v1',
            'hasPublicAPI': false,
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOHLCV': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28059414-e235970c-662c-11e7-8c3a-08e31f78684b.jpg',
                'api': 'https://cryptottlivewebapi.xbtce.net:8443/api',
                'www': 'https://www.xbtce.com',
                'doc': [
                    'https://www.xbtce.com/tradeapi',
                    'https://support.xbtce.info/Knowledgebase/Article/View/52/25/xbtce-exchange-api',
                ],
            },
            'requiredCredentials': {
                'apiKey': true,
                'secret': true,
                'uid': true,
            },
            'api': {
                'public': {
                    'get': [
                        'currency',
                        'currency/{filter}',
                        'level2',
                        'level2/{filter}',
                        'quotehistory/{symbol}/{periodicity}/bars/ask',
                        'quotehistory/{symbol}/{periodicity}/bars/bid',
                        'quotehistory/{symbol}/level2',
                        'quotehistory/{symbol}/ticks',
                        'symbol',
                        'symbol/{filter}',
                        'tick',
                        'tick/{filter}',
                        'ticker',
                        'ticker/{filter}',
                        'tradesession',
                    ],
                },
                'private': {
                    'get': [
                        'tradeserverinfo',
                        'tradesession',
                        'currency',
                        'currency/{filter}',
                        'level2',
                        'level2/{filter}',
                        'symbol',
                        'symbol/{filter}',
                        'tick',
                        'tick/{filter}',
                        'account',
                        'asset',
                        'asset/{id}',
                        'position',
                        'position/{id}',
                        'trade',
                        'trade/{id}',
                        'quotehistory/{symbol}/{periodicity}/bars/ask',
                        'quotehistory/{symbol}/{periodicity}/bars/ask/info',
                        'quotehistory/{symbol}/{periodicity}/bars/bid',
                        'quotehistory/{symbol}/{periodicity}/bars/bid/info',
                        'quotehistory/{symbol}/level2',
                        'quotehistory/{symbol}/level2/info',
                        'quotehistory/{symbol}/periodicities',
                        'quotehistory/{symbol}/ticks',
                        'quotehistory/{symbol}/ticks/info',
                        'quotehistory/cache/{symbol}/{periodicity}/bars/ask',
                        'quotehistory/cache/{symbol}/{periodicity}/bars/bid',
                        'quotehistory/cache/{symbol}/level2',
                        'quotehistory/cache/{symbol}/ticks',
                        'quotehistory/symbols',
                        'quotehistory/version',
                    ],
                    'post': [
                        'trade',
                        'tradehistory',
                    ],
                    'put': [
                        'trade',
                    ],
                    'delete': [
                        'trade',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.privateGetSymbol ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['Symbol'];
            let base = market['MarginCurrency'];
            let quote = market['ProfitCurrency'];
            if (base == 'DSH')
                base = 'DASH';
            let symbol = base + '/' + quote;
            symbol = market['IsTradeAllowed'] ? symbol : id;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAsset ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['Currency'];
            let uppercase = currency.toUpperCase ();
            // xbtce names DASH incorrectly as DSH
            if (uppercase == 'DSH')
                uppercase = 'DASH';
            let account = {
                'free': balance['FreeAmount'],
                'used': balance['LockedAmount'],
                'total': balance['Amount'],
            };
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.privateGetLevel2Filter (this.extend ({
            'filter': market['id'],
        }, params));
        orderbook = orderbook[0];
        let timestamp = orderbook['Timestamp'];
        return this.parseOrderBook (orderbook, timestamp, 'Bids', 'Asks', 'Price', 'Volume');
    }

    parseTicker (ticker, market = undefined) {
        let timestamp = 0;
        let last = undefined;
        if ('LastBuyTimestamp' in ticker)
            if (timestamp < ticker['LastBuyTimestamp']) {
                timestamp = ticker['LastBuyTimestamp'];
                last = ticker['LastBuyPrice'];
            }
        if ('LastSellTimestamp' in ticker)
            if (timestamp < ticker['LastSellTimestamp']) {
                timestamp = ticker['LastSellTimestamp'];
                last = ticker['LastSellPrice'];
            }
        if (!timestamp)
            timestamp = this.milliseconds ();
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['DailyBestBuyPrice'],
            'low': ticker['DailyBestSellPrice'],
            'bid': ticker['BestBid'],
            'ask': ticker['BestAsk'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': ticker['DailyTradedTotalVolume'],
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    async fetchTickers (symbols = undefined, params = {}) {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker (params);
        tickers = this.indexBy (tickers, 'Symbol');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = undefined;
            let symbol = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let base = id.slice (0, 3);
                let quote = id.slice (3, 6);
                if (base == 'DSH')
                    base = 'DASH';
                if (quote == 'DSH')
                    quote = 'DASH';
                symbol = base + '/' + quote;
            }
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTickerFilter (this.extend ({
            'filter': market['id'],
        }, params));
        let length = tickers.length;
        if (length < 1)
            throw new ExchangeError (this.id + ' fetchTicker returned empty response, xBTCe public API error');
        tickers = this.indexBy (tickers, 'Symbol');
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        // no method for trades?
        return await this.privateGetTrade (params);
    }

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv['Timestamp'],
            ohlcv['Open'],
            ohlcv['High'],
            ohlcv['Low'],
            ohlcv['Close'],
            ohlcv['Volume'],
        ];
    }

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOHLCV is disabled by the exchange');
        let minutes = parseInt (timeframe / 60); // 1 minute by default
        let periodicity = minutes.toString ();
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!since)
            since = this.seconds () - 86400 * 7; // last day by defulat
        if (!limit)
            limit = 1000; // default
        let response = await this.privateGetQuotehistorySymbolPeriodicityBarsBid (this.extend ({
            'symbol': market['id'],
            'periodicity': periodicity,
            'timestamp': since,
            'count': limit,
        }, params));
        return this.parseOHLCVs (response['Bars'], market, timeframe, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.tapiPostTrade (this.extend ({
            'pair': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['Id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privateDeleteTrade (this.extend ({
            'Type': 'Cancel',
            'Id': id,
        }, params));
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (!this.apiKey)
            throw new AuthenticationError (this.id + ' requires apiKey for all requests, their public API is always busy');
        if (!this.uid)
            throw new AuthenticationError (this.id + ' requires uid property for authentication and trading, their public API is always busy');
        let url = this.urls['api'] + '/' + this.version;
        if (api == 'public')
            url += '/' + api;
        url += '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            this.checkRequiredCredentials ();
            headers = { 'Accept-Encoding': 'gzip, deflate' };
            let nonce = this.nonce ().toString ();
            if (method == 'POST') {
                if (Object.keys (query).length) {
                    headers['Content-Type'] = 'application/json';
                    body = this.json (query);
                } else {
                    url += '?' + this.urlencode (query);
                }
            }
            let auth = nonce + this.uid + this.apiKey + method + url;
            if (body)
                auth += body;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256', 'base64');
            let credentials = this.uid + ':' + this.apiKey + ':' + nonce + ':' + this.binaryToString (signature);
            headers['Authorization'] = 'HMAC ' + credentials;
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }
}

},{"./base/Exchange":8,"./base/errors":10}],98:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const liqui = require ('./liqui.js')
const { ExchangeError, InsufficientFunds, DDoSProtection } = require ('./base/errors')

// ---------------------------------------------------------------------------

module.exports = class yobit extends liqui {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'yobit',
            'name': 'YoBit',
            'countries': 'RU',
            'rateLimit': 3000, // responses are cached every 2 seconds
            'version': '3',
            'hasCORS': false,
            'hasWithdraw': true,
            'hasFetchTickers': false,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg',
                'api': {
                    'public': 'https://yobit.net/api',
                    'private': 'https://yobit.net/tapi',
                },
                'www': 'https://www.yobit.net',
                'doc': 'https://www.yobit.net/en/api/',
            },
            'api': {
                'public': {
                    'get': [
                        'depth/{pair}',
                        'info',
                        'ticker/{pair}',
                        'trades/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'ActiveOrders',
                        'CancelOrder',
                        'GetDepositAddress',
                        'getInfo',
                        'OrderInfo',
                        'Trade',
                        'TradeHistory',
                        'WithdrawCoinsToAddress',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'maker': 0.002,
                    'taker': 0.002,
                },
                'funding': 0.0,
            },
        });
    }

    commonCurrencyCode (currency) {
        let substitutions = {
            'AIR': 'AirCoin',
            'ANI': 'ANICoin',
            'ANT': 'AntsCoin',
            'ATM': 'Autumncoin',
            'BCC': 'BCH',
            'BTS': 'Bitshares2',
            'DCT': 'Discount',
            'DGD': 'DarkGoldCoin',
            'ICN': 'iCoin',
            'LIZI': 'LiZi',
            'LUN': 'LunarCoin',
            'NAV': 'NavajoCoin',
            'OMG': 'OMGame',
            'PAY': 'EPAY',
            'REP': 'Republicoin',
        };
        if (currency in substitutions)
            return substitutions[currency];
        return currency;
    }

    currencyId (commonCode) {
        let substitutions = {
            'AirCoin': 'AIR',
            'ANICoin': 'ANI',
            'AntsCoin': 'ANT',
            'Autumncoin': 'ATM',
            'BCH': 'BCC',
            'Bitshares2': 'BTS',
            'Discount': 'DCT',
            'DarkGoldCoin': 'DGD',
            'iCoin': 'ICN',
            'LiZi': 'LIZI',
            'LunarCoin': 'LUN',
            'NavajoCoin': 'NAV',
            'OMGame': 'OMG',
            'EPAY': 'PAY',
            'Republicoin': 'REP',
        };
        if (commonCode in substitutions)
            return substitutions[commonCode];
        return commonCode;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let sides = { 'free': 'funds', 'total': 'funds_incl_orders' };
        let keys = Object.keys (sides);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let side = sides[key];
            if (side in balances) {
                let currencies = Object.keys (balances[side]);
                for (let j = 0; j < currencies.length; j++) {
                    let lowercase = currencies[j];
                    let uppercase = lowercase.toUpperCase ();
                    let currency = this.commonCurrencyCode (uppercase);
                    let account = undefined;
                    if (currency in result) {
                        account = result[currency];
                    } else {
                        account = this.account ();
                    }
                    account[key] = balances[side][lowercase];
                    if (account['total'] && account['free'])
                        account['used'] = account['total'] - account['free'];
                    result[currency] = account;
                }
            }
        }
        return this.parseBalance (result);
    }

    async createDepositAddress (currency, params = {}) {
        let response = await this.fetchDepositAddress (currency, this.extend ({
            'need_new': 1,
        }, params));
        return {
            'currency': currency,
            'address': response['address'],
            'status': 'ok',
            'info': response['info'],
        };
    }

    async fetchDepositAddress (currency, params = {}) {
        let currencyId = this.currencyId (currency);
        let request = {
            'coinName': currencyId,
            'need_new': 0,
        };
        let response = await this.privatePostGetDepositAddress (this.extend (request, params));
        let address = this.safeString (response['return'], 'address');
        return {
            'currency': currency,
            'address': address,
            'status': 'ok',
            'info': response,
        };
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdrawCoinsToAddress (this.extend ({
            'coinName': currency,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': undefined,
        };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('success' in response) {
            if (!response['success']) {
                if (response['error'].indexOf ('Insufficient funds') >= 0) { // not enougTh is a typo inside Liqui's own API...
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
                } else if (response['error'] == 'Requests too often') {
                    throw new DDoSProtection (this.id + ' ' + this.json (response));
                } else if ((response['error'] == 'not available') || (response['error'] == 'external service unavailable')) {
                    throw new DDoSProtection (this.id + ' ' + this.json (response));
                } else {
                    throw new ExchangeError (this.id + ' ' + this.json (response));
                }
            }
        }
        return response;
    }

}

},{"./base/errors":10,"./liqui.js":74}],99:[function(require,module,exports){
"use strict";

// ---------------------------------------------------------------------------

const acx = require ('./acx.js')

// ---------------------------------------------------------------------------

module.exports = class yunbi extends acx {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'yunbi',
            'name': 'YUNBI',
            'countries': 'CN',
            'rateLimit': 1000,
            'version': 'v2',
            'hasCORS': false,
            'hasFetchTickers': true,
            'hasFetchOHLCV': true,
            'timeframes': {
                '1m': '1',
                '5m': '5',
                '15m': '15',
                '30m': '30',
                '1h': '60',
                '2h': '120',
                '4h': '240',
                '12h': '720',
                '1d': '1440',
                '3d': '4320',
                '1w': '10080',
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/28570548-4d646c40-7147-11e7-9cf6-839b93e6d622.jpg',
                'extension': '.json', // default extension appended to endpoint URLs
                'api': 'https://yunbi.com',
                'www': 'https://yunbi.com',
                'doc': [
                    'https://yunbi.com/documents/api/guide',
                    'https://yunbi.com/swagger/',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'tickers',
                        'tickers/{market}',
                        'markets',
                        'order_book',
                        'k',
                        'depth',
                        'trades',
                        'k_with_pending_trades',
                        'timestamp',
                        'addresses/{address}',
                        'partners/orders/{id}/trades',
                    ],
                },
                'private': {
                    'get': [
                        'deposits',
                        'members/me',
                        'deposit',
                        'deposit_address',
                        'order',
                        'orders',
                        'trades/my',
                    ],
                    'post': [
                        'order/delete',
                        'orders',
                        'orders/multi',
                        'orders/clear',
                    ],
                },
            },
        });
    }
}

},{"./acx.js":5}],100:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class zaif extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'zaif',
            'name': 'Zaif',
            'countries': 'JP',
            'rateLimit': 2000,
            'version': '1',
            'hasCORS': false,
            'hasFetchOpenOrders': true,
            'hasFetchClosedOrders': true,
            'hasWithdraw': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg',
                'api': 'https://api.zaif.jp',
                'www': 'https://zaif.jp',
                'doc': [
                    'http://techbureau-api-document.readthedocs.io/ja/latest/index.html',
                    'https://corp.zaif.jp/api-docs',
                    'https://corp.zaif.jp/api-docs/api_links',
                    'https://www.npmjs.com/package/zaif.jp',
                    'https://github.com/you21979/node-zaif',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'depth/{pair}',
                        'currencies/{pair}',
                        'currencies/all',
                        'currency_pairs/{pair}',
                        'currency_pairs/all',
                        'last_price/{pair}',
                        'ticker/{pair}',
                        'trades/{pair}',
                    ],
                },
                'private': {
                    'post': [
                        'active_orders',
                        'cancel_order',
                        'deposit_history',
                        'get_id_info',
                        'get_info',
                        'get_info2',
                        'get_personal_info',
                        'trade',
                        'trade_history',
                        'withdraw',
                        'withdraw_history',
                    ],
                },
                'ecapi': {
                    'post': [
                        'createInvoice',
                        'getInvoice',
                        'getInvoiceIdsByOrderNumber',
                        'cancelInvoice',
                    ],
                },
                'tlapi': {
                    'post': [
                        'get_positions',
                        'position_history',
                        'active_positions',
                        'create_position',
                        'change_position',
                        'cancel_position',
                    ],
                },
                'fapi': {
                    'get': [
                        'groups/{group_id}',
                        'last_price/{group_id}/{pair}',
                        'ticker/{group_id}/{pair}',
                        'trades/{group_id}/{pair}',
                        'depth/{group_id}/{pair}',
                    ],
                },
            },
        });
    }

    async fetchMarkets () {
        let markets = await this.publicGetCurrencyPairsAll ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['currency_pair'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let currencies = Object.keys (balances['funds']);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let balance = balances['funds'][currency];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            if ('deposit' in balances) {
                if (currency in balances['deposit']) {
                    account['total'] = balances['deposit'][currency];
                    account['used'] = account['total'] - account['free'];
                }
            }
            result[uppercase] = account;
        }
        return this.parseBalance (result);
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetDepthPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let ticker = await this.publicGetTickerPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let vwap = ticker['vwap'];
        let baseVolume = ticker['volume'];
        let quoteVolume = baseVolume * vwap;
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': ticker['bid'],
            'ask': ticker['ask'],
            'vwap': vwap,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': ticker['last'],
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let side = (trade['trade_type'] == 'bid') ? 'buy' : 'sell';
        let timestamp = trade['date'] * 1000;
        let id = this.safeString (trade, 'id');
        id = this.safeString (trade, 'tid', id);
        if (!market)
            market = this.markets_by_id[trade['currency_pair']];
        return {
            'id': id.toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.privatePostTrade (this.extend ({
            'currency_pair': this.marketId (symbol),
            'action': (side == 'buy') ? 'bid' : 'ask',
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['return']['order_id'].toString (),
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        return await this.privatePostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    }

    parseOrder (order, market = undefined) {
        let side = (order['action'] == 'bid') ? 'buy' : 'sell';
        let timestamp = parseInt (order['timestamp']) * 1000;
        if (!market)
            market = this.markets_by_id[order['currency_pair']];
        let price = order['price'];
        let amount = order['amount'];
        return {
            'id': order['id'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': market['symbol'],
            'type': 'limit',
            'side': side,
            'price': price,
            'cost': price * amount,
            'amount': amount,
            'filled': undefined,
            'remaining': undefined,
            'trades': undefined,
            'fee': undefined,
        };
    }

    parseOrders (orders, market = undefined, since = undefined, limit = undefined) {
        let ids = Object.keys (orders);
        let result = [];
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = orders[id];
            let extended = this.extend (order, { 'id': id });
            result.push (this.parseOrder (extended, market));
        }
        return this.filterBySinceLimit (result, since, limit);
    }

    async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {
            // 'is_token': false,
            // 'is_token_both': false,
        };
        if (symbol) {
            market = this.market (symbol);
            request['currency_pair'] = market['id'];
        }
        let response = await this.privatePostActiveOrders (this.extend (request, params));
        return this.parseOrders (response['return'], market, since, limit);
    }

    async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        let request = {
            // 'from': 0,
            // 'count': 1000,
            // 'from_id': 0,
            // 'end_id': 1000,
            // 'order': 'DESC',
            // 'since': 1503821051,
            // 'end': 1503821051,
            // 'is_token': false,
        };
        if (symbol) {
            market = this.market (symbol);
            request['currency_pair'] = market['id'];
        }
        let response = await this.privatePostTradeHistory (this.extend (request, params));
        return this.parseOrders (response['return'], market, since, limit);
    }

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency == 'JPY')
            throw new ExchangeError (this.id + ' does not allow ' + currency + ' withdrawals');
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currency,
            'amount': amount,
            'address': address,
            // 'message': 'Hi!', // XEM only
            // 'opt_fee': 0.003, // BTC and MONA only
        }, params));
        return {
            'info': result,
            'id': result['return']['txid'],
            'fee': result['return']['fee'],
        };
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (api == 'public') {
            url += 'api/' + this.version + '/' + this.implodeParams (path, params);
        } else if (api == 'fapi') {
            url += 'fapi/' + this.version + '/' + this.implodeParams (path, params);
        } else {
            this.checkRequiredCredentials ();
            if (api == 'ecapi') {
                url += 'ecapi';
            } else if (api == 'tlapi') {
                url += 'tlapi';
            } else {
                url += 'tapi';
            }
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'method': path,
                'nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'api', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + response['error']);
        if ('success' in response)
            if (!response['success'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],101:[function(require,module,exports){
"use strict";

//  ---------------------------------------------------------------------------

const Exchange = require ('./base/Exchange')
const { ExchangeError } = require ('./base/errors')

//  ---------------------------------------------------------------------------

module.exports = class zb extends Exchange {

    describe () {
        return this.deepExtend (super.describe (), {
            'id': 'zb',
            'name': 'ZB',
            'countries': 'CN',
            'rateLimit': 1000,
            'version': 'v1',
            'hasCORS': false,
            'hasFetchOrder': true,
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/32859187-cd5214f0-ca5e-11e7-967d-96568e2e2bd1.jpg',
                'api': {
                    'public': 'http://api.zb.com/data', // no https for public API
                    'private': 'https://trade.zb.com/api',
                },
                'www': 'https://trade.zb.com/api',
                'doc': 'https://www.zb.com/i/developer',
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'ticker',
                        'depth',
                        'trades',
                        'kline',
                    ],
                },
                'private': {
                    'post': [
                        'order',
                        'cancelOrder',
                        'getOrder',
                        'getOrders',
                        'getOrdersNew',
                        'getOrdersIgnoreTradeType',
                        'getUnfinishedOrdersIgnoreTradeType',
                        'getAccountInfo',
                        'getUserAddress',
                        'getWithdrawAddress',
                        'getWithdrawRecord',
                        'getChargeRecord',
                        'getCnyWithdrawRecord',
                        'getCnyChargeRecord',
                        'withdraw',
                    ],
                },
            },
        });
    }

    getTradingFeeFromBaseQuote (base, quote) {
        // base: quote
        let fees = {
            'BTC': { 'USDT': 0.0 },
            'BCH': { 'BTC': 0.001, 'USDT': 0.001 },
            'LTC': { 'BTC': 0.001, 'USDT': 0.0 },
            'ETH': { 'BTC': 0.001, 'USDT': 0.0 },
            'ETC': { 'BTC': 0.001, 'USDT': 0.0 },
            'BTS': { 'BTC': 0.001, 'USDT': 0.001 },
            'EOS': { 'BTC': 0.001, 'USDT': 0.001 },
            'HSR': { 'BTC': 0.001, 'USDT': 0.001 },
            'QTUM': { 'BTC': 0.001, 'USDT': 0.001 },
            'USDT': { 'BTC': 0.0 },
        };
        if (base in fees) {
            let quoteFees = fees[base];
            if (quote in quoteFees)
                return quoteFees[quote];
        }
        return undefined;
    }

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let keys = Object.keys (markets);
        let result = [];
        for (let i = 0; i < keys.length; i++) {
            let id = keys[i];
            let market = markets[id];
            let [ baseId, quoteId ] = id.split ('_');
            let base = this.commonCurrencyCode (baseId.toUpperCase ());
            let quote = this.commonCurrencyCode (quoteId.toUpperCase ());
            let symbol = base + '/' + quote;
            let fee = this.getTradingFeeFromBaseQuote (base, quote);
            let precision = {
                'amount': market['amountScale'],
                'price': market['priceScale'],
            };
            let lot = Math.pow (10, -precision['amount']);
            result.push ({
                'id': id,
                'symbol': symbol,
                'baseId': baseId,
                'quoteId': quoteId,
                'base': base,
                'quote': quote,
                'info': market,
                'maker': fee,
                'taker': fee,
                'lot': lot,
                'active': true,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': lot,
                        'max': undefined,
                    },
                    'price': {
                        'min': Math.pow (10, -precision['price']),
                        'max': undefined,
                    },
                    'cost': {
                        'min': 0,
                        'max': undefined,
                    },
                },
            });
        }
        return result;
    }

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['result'];
        let result = { 'info': balances };
        let currencies = Object.keys (this.currencies);
        for (let i = 0; i < currencies.length; i++) {
            let currency = currencies[i];
            let account = this.account ();
            if (currency in balances['balance'])
                account['free'] = parseFloat (balances['balance'][currency]['amount']);
            if (currency in balances['frozen'])
                account['used'] = parseFloat (balances['frozen'][currency]['amount']);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return this.parseBalance (result);
    }

    getMarketFieldName () {
        return 'market';
    }

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let marketFieldName = this.getMarketFieldName ();
        let request = {};
        request[marketFieldName] = market['id'];
        let orderbook = await this.publicGetDepth (this.extend (request, params));
        let timestamp = this.milliseconds ();
        let bids = undefined;
        let asks = undefined;
        if ('bids' in orderbook)
            bids = orderbook['bids'];
        if ('asks' in orderbook)
            asks = orderbook['asks'];
        let result = {
            'bids': bids,
            'asks': asks,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        if (result['bids'])
            result['bids'] = this.sortBy (result['bids'], 0, true);
        if (result['asks'])
            result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    }

    async fetchTicker (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let marketFieldName = this.getMarketFieldName ();
        let request = {};
        request[marketFieldName] = market['id'];
        let response = await this.publicGetTicker (this.extend (request, params));
        let ticker = response['ticker'];
        let timestamp = this.milliseconds ();
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    }

    parseTrade (trade, market = undefined) {
        let timestamp = trade['date'] * 1000;
        let side = (trade['trade_type'] == 'bid') ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    }

    async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let marketFieldName = this.getMarketFieldName ();
        let request = {};
        request[marketFieldName] = market['id'];
        let response = await this.publicGetTrades (this.extend (request, params));
        return this.parseTrades (response, market, since, limit);
    }

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let paramString = '&price=' + price.toString ();
        paramString += '&amount=' + amount.toString ();
        let tradeType = (side == 'buy') ? '1' : '0';
        paramString += '&tradeType=' + tradeType;
        paramString += '&currency=' + this.marketId (symbol);
        let response = await this.privatePostOrder (paramString);
        return {
            'info': response,
            'id': response['id'],
        };
    }

    async cancelOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let paramString = '&id=' + id.toString ();
        if ('currency' in params)
            paramString += '&currency=' + params['currency'];
        return await this.privatePostCancelOrder (paramString);
    }

    async fetchOrder (id, symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let paramString = '&id=' + id.toString ();
        if ('currency' in params)
            paramString += '&currency=' + params['currency'];
        return await this.privatePostGetOrder (paramString);
    }

    nonce () {
        return this.milliseconds ();
    }

    sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.version + '/' + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            this.checkRequiredCredentials ();
            let paramsLength = params.length; // params should be a string here
            let nonce = this.nonce ();
            let auth = 'method=' + path;
            auth += '&accesskey=' + this.apiKey;
            auth += paramsLength ? params : '';
            let secret = this.hash (this.encode (this.secret), 'sha1');
            let signature = this.hmac (this.encode (auth), this.encode (secret), 'md5');
            let suffix = 'sign=' + signature + '&reqTime=' + nonce.toString ();
            url += '/' + path + '?' + auth + '&' + suffix;
        }
        return { 'url': url, 'method': method, 'body': body, 'headers': headers };
    }

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let response = await this.fetch2 (path, api, method, params, headers, body);
        if (api == 'private')
            if ('code' in response)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    }
}

},{"./base/Exchange":8,"./base/errors":10}],102:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));
},{"./cipher-core":103,"./core":104,"./enc-base64":105,"./evpkdf":107,"./md5":112}],103:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./evpkdf"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./evpkdf"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));
},{"./core":104,"./evpkdf":107}],104:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
},{}],105:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));
},{"./core":104}],106:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));
},{"./core":104}],107:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));
},{"./core":104,"./hmac":109,"./sha1":128}],108:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));
},{"./cipher-core":103,"./core":104}],109:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
},{"./core":104}],110:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./lib-typedarrays"), require("./enc-utf16"), require("./enc-base64"), require("./md5"), require("./sha1"), require("./sha256"), require("./sha224"), require("./sha512"), require("./sha384"), require("./sha3"), require("./ripemd160"), require("./hmac"), require("./pbkdf2"), require("./evpkdf"), require("./cipher-core"), require("./mode-cfb"), require("./mode-ctr"), require("./mode-ctr-gladman"), require("./mode-ofb"), require("./mode-ecb"), require("./pad-ansix923"), require("./pad-iso10126"), require("./pad-iso97971"), require("./pad-zeropadding"), require("./pad-nopadding"), require("./format-hex"), require("./aes"), require("./tripledes"), require("./rc4"), require("./rabbit"), require("./rabbit-legacy"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS;

}));
},{"./aes":102,"./cipher-core":103,"./core":104,"./enc-base64":105,"./enc-utf16":106,"./evpkdf":107,"./format-hex":108,"./hmac":109,"./lib-typedarrays":111,"./md5":112,"./mode-cfb":113,"./mode-ctr":115,"./mode-ctr-gladman":114,"./mode-ecb":116,"./mode-ofb":117,"./pad-ansix923":118,"./pad-iso10126":119,"./pad-iso97971":120,"./pad-nopadding":121,"./pad-zeropadding":122,"./pbkdf2":123,"./rabbit":125,"./rabbit-legacy":124,"./rc4":126,"./ripemd160":127,"./sha1":128,"./sha224":129,"./sha256":130,"./sha3":131,"./sha384":132,"./sha512":133,"./tripledes":134,"./x64-core":135}],111:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));
},{"./core":104}],112:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
},{"./core":104}],113:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));
},{"./cipher-core":103,"./core":104}],114:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));
},{"./cipher-core":103,"./core":104}],115:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));
},{"./cipher-core":103,"./core":104}],116:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));
},{"./cipher-core":103,"./core":104}],117:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));
},{"./cipher-core":103,"./core":104}],118:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));
},{"./cipher-core":103,"./core":104}],119:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));
},{"./cipher-core":103,"./core":104}],120:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));
},{"./cipher-core":103,"./core":104}],121:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));
},{"./cipher-core":103,"./core":104}],122:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));
},{"./cipher-core":103,"./core":104}],123:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));
},{"./core":104,"./hmac":109,"./sha1":128}],124:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));
},{"./cipher-core":103,"./core":104,"./enc-base64":105,"./evpkdf":107,"./md5":112}],125:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));
},{"./cipher-core":103,"./core":104,"./enc-base64":105,"./evpkdf":107,"./md5":112}],126:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));
},{"./cipher-core":103,"./core":104,"./enc-base64":105,"./evpkdf":107,"./md5":112}],127:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));
},{"./core":104}],128:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));
},{"./core":104}],129:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha256"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));
},{"./core":104,"./sha256":130}],130:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));
},{"./core":104}],131:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));
},{"./core":104,"./x64-core":135}],132:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./sha512"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));
},{"./core":104,"./sha512":133,"./x64-core":135}],133:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));
},{"./core":104,"./x64-core":135}],134:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));
},{"./cipher-core":103,"./core":104,"./enc-base64":105,"./evpkdf":107,"./md5":112}],135:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));
},{"./core":104}],136:[function(require,module,exports){
(function (self) {
  'use strict';

  function fetchPonyfill(options) {
    var Promise = options && options.Promise || self.Promise;
    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
    var global = self;

    return (function () {
      var self = Object.create(global, {
        fetch: {
          value: undefined,
          writable: true
        }
      });

      (function(self) {
        'use strict';

        if (self.fetch) {
          return
        }

        var support = {
          searchParams: 'URLSearchParams' in self,
          iterable: 'Symbol' in self && 'iterator' in Symbol,
          blob: 'FileReader' in self && 'Blob' in self && (function() {
            try {
              new Blob()
              return true
            } catch(e) {
              return false
            }
          })(),
          formData: 'FormData' in self,
          arrayBuffer: 'ArrayBuffer' in self
        }

        if (support.arrayBuffer) {
          var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]'
          ]

          var isDataView = function(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj)
          }

          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
          }
        }

        function normalizeName(name) {
          if (typeof name !== 'string') {
            name = String(name)
          }
          if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name')
          }
          return name.toLowerCase()
        }

        function normalizeValue(value) {
          if (typeof value !== 'string') {
            value = String(value)
          }
          return value
        }

        // Build a destructive iterator for the value list
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift()
              return {done: value === undefined, value: value}
            }
          }

          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator
            }
          }

          return iterator
        }

        function Headers(headers) {
          this.map = {}

          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value)
            }, this)
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1])
            }, this)
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name])
            }, this)
          }
        }

        Headers.prototype.append = function(name, value) {
          name = normalizeName(name)
          value = normalizeValue(value)
          var oldValue = this.map[name]
          this.map[name] = oldValue ? oldValue+','+value : value
        }

        Headers.prototype['delete'] = function(name) {
          delete this.map[normalizeName(name)]
        }

        Headers.prototype.get = function(name) {
          name = normalizeName(name)
          return this.has(name) ? this.map[name] : null
        }

        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name))
        }

        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value)
        }

        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this)
            }
          }
        }

        Headers.prototype.keys = function() {
          var items = []
          this.forEach(function(value, name) { items.push(name) })
          return iteratorFor(items)
        }

        Headers.prototype.values = function() {
          var items = []
          this.forEach(function(value) { items.push(value) })
          return iteratorFor(items)
        }

        Headers.prototype.entries = function() {
          var items = []
          this.forEach(function(value, name) { items.push([name, value]) })
          return iteratorFor(items)
        }

        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries
        }

        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'))
          }
          body.bodyUsed = true
        }

        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result)
            }
            reader.onerror = function() {
              reject(reader.error)
            }
          })
        }

        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsArrayBuffer(blob)
          return promise
        }

        function readBlobAsText(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsText(blob)
          return promise
        }

        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf)
          var chars = new Array(view.length)

          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i])
          }
          return chars.join('')
        }

        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0)
          } else {
            var view = new Uint8Array(buf.byteLength)
            view.set(new Uint8Array(buf))
            return view.buffer
          }
        }

        function Body() {
          this.bodyUsed = false

          this._initBody = function(body) {
            this._bodyInit = body
            if (!body) {
              this._bodyText = ''
            } else if (typeof body === 'string') {
              this._bodyText = body
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString()
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer)
              // IE 10-11 can't handle a DataView body.
              this._bodyInit = new Blob([this._bodyArrayBuffer])
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body)
            } else {
              throw new Error('unsupported BodyInit type')
            }

            if (!this.headers.get('content-type')) {
              if (typeof body === 'string') {
                this.headers.set('content-type', 'text/plain;charset=UTF-8')
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set('content-type', this._bodyBlob.type)
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
              }
            }
          }

          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this)
              if (rejected) {
                return rejected
              }

              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob)
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]))
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as blob')
              } else {
                return Promise.resolve(new Blob([this._bodyText]))
              }
            }

            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
              } else {
                return this.blob().then(readBlobAsArrayBuffer)
              }
            }
          }

          this.text = function() {
            var rejected = consumed(this)
            if (rejected) {
              return rejected
            }

            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob)
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text')
            } else {
              return Promise.resolve(this._bodyText)
            }
          }

          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode)
            }
          }

          this.json = function() {
            return this.text().then(JSON.parse)
          }

          return this
        }

        // HTTP methods whose capitalization should be normalized
        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

        function normalizeMethod(method) {
          var upcased = method.toUpperCase()
          return (methods.indexOf(upcased) > -1) ? upcased : method
        }

        function Request(input, options) {
          options = options || {}
          var body = options.body

          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError('Already read')
            }
            this.url = input.url
            this.credentials = input.credentials
            if (!options.headers) {
              this.headers = new Headers(input.headers)
            }
            this.method = input.method
            this.mode = input.mode
            if (!body && input._bodyInit != null) {
              body = input._bodyInit
              input.bodyUsed = true
            }
          } else {
            this.url = String(input)
          }

          this.credentials = options.credentials || this.credentials || 'omit'
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers)
          }
          this.method = normalizeMethod(options.method || this.method || 'GET')
          this.mode = options.mode || this.mode || null
          this.referrer = null

          if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests')
          }
          this._initBody(body)
        }

        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit })
        }

        function decode(body) {
          var form = new FormData()
          body.trim().split('&').forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split('=')
              var name = split.shift().replace(/\+/g, ' ')
              var value = split.join('=').replace(/\+/g, ' ')
              form.append(decodeURIComponent(name), decodeURIComponent(value))
            }
          })
          return form
        }

        function parseHeaders(rawHeaders) {
          var headers = new Headers()
          rawHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(':')
            var key = parts.shift().trim()
            if (key) {
              var value = parts.join(':').trim()
              headers.append(key, value)
            }
          })
          return headers
        }

        Body.call(Request.prototype)

        function Response(bodyInit, options) {
          if (!options) {
            options = {}
          }

          this.type = 'default'
          this.status = 'status' in options ? options.status : 200
          this.ok = this.status >= 200 && this.status < 300
          this.statusText = 'statusText' in options ? options.statusText : 'OK'
          this.headers = new Headers(options.headers)
          this.url = options.url || ''
          this._initBody(bodyInit)
        }

        Body.call(Response.prototype)

        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          })
        }

        Response.error = function() {
          var response = new Response(null, {status: 0, statusText: ''})
          response.type = 'error'
          return response
        }

        var redirectStatuses = [301, 302, 303, 307, 308]

        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code')
          }

          return new Response(null, {status: status, headers: {location: url}})
        }

        self.Headers = Headers
        self.Request = Request
        self.Response = Response

        self.fetch = function(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init)
            var xhr = new XMLHttpRequest()

            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
              }
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
              var body = 'response' in xhr ? xhr.response : xhr.responseText
              resolve(new Response(body, options))
            }

            xhr.onerror = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.ontimeout = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.open(request.method, request.url, true)

            if (request.credentials === 'include') {
              xhr.withCredentials = true
            }

            if ('responseType' in xhr && support.blob) {
              xhr.responseType = 'blob'
            }

            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value)
            })

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
          })
        }
        self.fetch.polyfill = true
      })(typeof self !== 'undefined' ? self : this);


      return {
        fetch: self.fetch,
        Headers: self.Headers,
        Request: self.Request,
        Response: self.Response
      };
    }());
  }

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return fetchPonyfill;
    });
  } else if (typeof exports === 'object') {
    module.exports = fetchPonyfill;
  } else {
    self.fetchPonyfill = fetchPonyfill;
  }
}(typeof self === 'undefined' ? this : self));


},{}],137:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],138:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

},{}],139:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":138,"./parse":140,"./stringify":141}],140:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

},{"./utils":142}],141:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var formats = require('./formats');

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":138,"./utils":142}],142:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

exports.arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

exports.merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = exports.arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = exports.merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = exports.merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

exports.assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

exports.decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

exports.encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

exports.compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

exports.isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

exports.isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjY3h0LmJyb3dzZXIuanMiLCJjY3h0LmpzIiwianMvXzFicm9rZXIuanMiLCJqcy9fMWJ0Y3hlLmpzIiwianMvYWN4LmpzIiwianMvYWxsY29pbi5qcyIsImpzL2FueHByby5qcyIsImpzL2Jhc2UvRXhjaGFuZ2UuanMiLCJqcy9iYXNlL01hcmtldC5qcyIsImpzL2Jhc2UvZXJyb3JzLmpzIiwianMvYmFzZS9mdW5jdGlvbnMuanMiLCJqcy9iYXNlL3Rocm90dGxlLmpzIiwianMvYmluYW5jZS5qcyIsImpzL2JpdDJjLmpzIiwianMvYml0YmF5LmpzIiwianMvYml0Y29pbmNvaWQuanMiLCJqcy9iaXRmaW5leC5qcyIsImpzL2JpdGZpbmV4Mi5qcyIsImpzL2JpdGZseWVyLmpzIiwianMvYml0aHVtYi5qcyIsImpzL2JpdGxpc2guanMiLCJqcy9iaXRtYXJrZXQuanMiLCJqcy9iaXRtZXguanMiLCJqcy9iaXRzby5qcyIsImpzL2JpdHN0YW1wLmpzIiwianMvYml0c3RhbXAxLmpzIiwianMvYml0dHJleC5qcyIsImpzL2JsM3AuanMiLCJqcy9ibGV1dHJhZGUuanMiLCJqcy9idGNib3guanMiLCJqcy9idGNjaGluYS5qcyIsImpzL2J0Y2V4Y2hhbmdlLmpzIiwianMvYnRjbWFya2V0cy5qcyIsImpzL2J0Y3RyYWRldWEuanMiLCJqcy9idGN0dXJrLmpzIiwianMvYnRjeC5qcyIsImpzL2J0ZXIuanMiLCJqcy9ieGludGguanMiLCJqcy9jY2V4LmpzIiwianMvY2V4LmpzIiwianMvY2hidGMuanMiLCJqcy9jaGlsZWJpdC5qcyIsImpzL2NvaW5jaGVjay5qcyIsImpzL2NvaW5mbG9vci5qcyIsImpzL2NvaW5naS5qcyIsImpzL2NvaW5tYXJrZXRjYXAuanMiLCJqcy9jb2lubWF0ZS5qcyIsImpzL2NvaW5zZWN1cmUuanMiLCJqcy9jb2luc3BvdC5qcyIsImpzL2NyeXB0b3BpYS5qcyIsImpzL2RzeC5qcyIsImpzL2V4bW8uanMiLCJqcy9mbG93YnRjLmpzIiwianMvZm94Yml0LmpzIiwianMvZnlic2UuanMiLCJqcy9meWJzZy5qcyIsImpzL2dhdGVjb2luLmpzIiwianMvZ2F0ZWlvLmpzIiwianMvZ2RheC5qcyIsImpzL2dlbWluaS5qcyIsImpzL2dldGJ0Yy5qcyIsImpzL2hpdGJ0Yy5qcyIsImpzL2hpdGJ0YzIuanMiLCJqcy9odW9iaS5qcyIsImpzL2h1b2JpY255LmpzIiwianMvaHVvYmlwcm8uanMiLCJqcy9pbmRlcGVuZGVudHJlc2VydmUuanMiLCJqcy9pdGJpdC5qcyIsImpzL2p1YmkuanMiLCJqcy9rcmFrZW4uanMiLCJqcy9rdWNvaW4uanMiLCJqcy9rdW5hLmpzIiwianMvbGFrZWJ0Yy5qcyIsImpzL2xpcXVpLmpzIiwianMvbGl2ZWNvaW4uanMiLCJqcy9sdW5vLmpzIiwianMvbWVyY2Fkby5qcyIsImpzL21peGNvaW5zLmpzIiwianMvbm92YS5qcyIsImpzL29rY29pbmNueS5qcyIsImpzL29rY29pbnVzZC5qcyIsImpzL29rZXguanMiLCJqcy9wYXltaXVtLmpzIiwianMvcG9sb25pZXguanMiLCJqcy9xcnlwdG9zLmpzIiwianMvcXVhZHJpZ2FjeC5qcyIsImpzL3F1b2luZS5qcyIsImpzL3NvdXRoeGNoYW5nZS5qcyIsImpzL3N1cmJpdGNvaW4uanMiLCJqcy90aGVyb2NrLmpzIiwianMvdGlkZXguanMiLCJqcy91cmR1Yml0LmpzIiwianMvdmF1bHRvcm8uanMiLCJqcy92YnRjLmpzIiwianMvdmlyd294LmpzIiwianMvd2V4LmpzIiwianMveGJ0Y2UuanMiLCJqcy95b2JpdC5qcyIsImpzL3l1bmJpLmpzIiwianMvemFpZi5qcyIsImpzL3piLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtdXRmMTYuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWNmYi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHIuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtZWNiLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWFuc2l4OTIzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvMTAxMjYuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLW5vcGFkZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLXplcm9wYWRkaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC1sZWdhY3kuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmM0LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yaXBlbWQxNjAuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTUxMi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvdHJpcGxlZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9mZXRjaC1wb255ZmlsbC9idWlsZC9mZXRjaC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcyIsIm5vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3YxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2dkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25mQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiAgQSBlbnRyeSBwb2ludCBmb3IgdGhlIGJyb3dzZXIgYnVuZGxlIHZlcnNpb24uIFRoaXMgZ2V0cyBjb21waWxlZCBieTpcbiAgICAgICAgXG4gICAgICAgIGJyb3dzZXJpZnkgLS1kZWJ1ZyAuL2NjeHQuYnJvd3Nlci5qcyA+IC4vYnVpbGQvY2N4dC5icm93c2VyLmpzXG4gKi9cblxud2luZG93LmNjeHQgPSByZXF1aXJlICgnLi9jY3h0JykiLCJcInVzZSBzdHJpY3RcIjtcblxuLypcblxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE3IElnb3IgS3JvaXRvclxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG5cbiovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlICA9IHJlcXVpcmUgKCcuL2pzL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgZnVuY3Rpb25zID0gcmVxdWlyZSAoJy4vanMvYmFzZS9mdW5jdGlvbnMnKVxuY29uc3QgZXJyb3JzICAgID0gcmVxdWlyZSAoJy4vanMvYmFzZS9lcnJvcnMnKVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB0aGlzIGlzIHVwZGF0ZWQgYnkgdnNzLmpzIHdoZW4gYnVpbGRpbmdcblxuY29uc3QgdmVyc2lvbiA9ICcxLjEwLjM5OSdcblxuRXhjaGFuZ2UuY2N4dFZlcnNpb24gPSB2ZXJzaW9uXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZXhjaGFuZ2VzID0ge1xuICAgICdfMWJyb2tlcic6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL18xYnJva2VyLmpzJyksXG4gICAgJ18xYnRjeGUnOiAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvXzFidGN4ZS5qcycpLFxuICAgICdhY3gnOiAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2FjeC5qcycpLFxuICAgICdhbGxjb2luJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2FsbGNvaW4uanMnKSxcbiAgICAnYW54cHJvJzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9hbnhwcm8uanMnKSxcbiAgICAnYmluYW5jZSc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaW5hbmNlLmpzJyksXG4gICAgJ2JpdDJjJzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0MmMuanMnKSxcbiAgICAnYml0YmF5JzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXRiYXkuanMnKSxcbiAgICAnYml0Y29pbmNvaWQnOiAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXRjb2luY29pZC5qcycpLFxuICAgICdiaXRmaW5leCc6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdGZpbmV4LmpzJyksXG4gICAgJ2JpdGZpbmV4Mic6ICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0ZmluZXgyLmpzJyksXG4gICAgJ2JpdGZseWVyJzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0Zmx5ZXIuanMnKSxcbiAgICAnYml0aHVtYic6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXRodW1iLmpzJyksXG4gICAgJ2JpdGxpc2gnOiAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0bGlzaC5qcycpLFxuICAgICdiaXRtYXJrZXQnOiAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdG1hcmtldC5qcycpLFxuICAgICdiaXRtZXgnOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdG1leC5qcycpLFxuICAgICdiaXRzbyc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JpdHNvLmpzJyksXG4gICAgJ2JpdHN0YW1wJzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYml0c3RhbXAuanMnKSxcbiAgICAnYml0c3RhbXAxJzogICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXRzdGFtcDEuanMnKSxcbiAgICAnYml0dHJleCc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9iaXR0cmV4LmpzJyksXG4gICAgJ2JsM3AnOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYmwzcC5qcycpLFxuICAgICdibGV1dHJhZGUnOiAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2JsZXV0cmFkZS5qcycpLFxuICAgICdidGNib3gnOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2J0Y2JveC5qcycpLFxuICAgICdidGNjaGluYSc6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2J0Y2NoaW5hLmpzJyksXG4gICAgJ2J0Y2V4Y2hhbmdlJzogICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYnRjZXhjaGFuZ2UuanMnKSxcbiAgICAnYnRjbWFya2V0cyc6ICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9idGNtYXJrZXRzLmpzJyksXG4gICAgJ2J0Y3RyYWRldWEnOiAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYnRjdHJhZGV1YS5qcycpLFxuICAgICdidGN0dXJrJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2J0Y3R1cmsuanMnKSxcbiAgICAnYnRjeCc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9idGN4LmpzJyksXG4gICAgJ2J0ZXInOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvYnRlci5qcycpLFxuICAgICdieGludGgnOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2J4aW50aC5qcycpLFxuICAgICdjY2V4JzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NjZXguanMnKSxcbiAgICAnY2V4JzogICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9jZXguanMnKSxcbiAgICAnY2hidGMnOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9jaGJ0Yy5qcycpLFxuICAgICdjaGlsZWJpdCc6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NoaWxlYml0LmpzJyksXG4gICAgJ2NvaW5jaGVjayc6ICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvY29pbmNoZWNrLmpzJyksXG4gICAgJ2NvaW5mbG9vcic6ICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvY29pbmZsb29yLmpzJyksXG4gICAgJ2NvaW5naSc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvY29pbmdpLmpzJyksXG4gICAgJ2NvaW5tYXJrZXRjYXAnOiAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvY29pbm1hcmtldGNhcC5qcycpLFxuICAgICdjb2lubWF0ZSc6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NvaW5tYXRlLmpzJyksXG4gICAgJ2NvaW5zZWN1cmUnOiAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvY29pbnNlY3VyZS5qcycpLFxuICAgICdjb2luc3BvdCc6ICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2NvaW5zcG90LmpzJyksXG4gICAgJ2NyeXB0b3BpYSc6ICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvY3J5cHRvcGlhLmpzJyksXG4gICAgJ2RzeCc6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZHN4LmpzJyksXG4gICAgJ2V4bW8nOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZXhtby5qcycpLFxuICAgICdmbG93YnRjJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2Zsb3didGMuanMnKSxcbiAgICAnZm94Yml0JzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9mb3hiaXQuanMnKSxcbiAgICAnZnlic2UnOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9meWJzZS5qcycpLFxuICAgICdmeWJzZyc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2Z5YnNnLmpzJyksXG4gICAgJ2dhdGVjb2luJzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZ2F0ZWNvaW4uanMnKSxcbiAgICAnZ2F0ZWlvJzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9nYXRlaW8uanMnKSxcbiAgICAnZ2RheCc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9nZGF4LmpzJyksXG4gICAgJ2dlbWluaSc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZ2VtaW5pLmpzJyksXG4gICAgJ2dldGJ0Yyc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvZ2V0YnRjLmpzJyksXG4gICAgJ2hpdGJ0Yyc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvaGl0YnRjLmpzJyksXG4gICAgJ2hpdGJ0YzInOiAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvaGl0YnRjMi5qcycpLFxuICAgICdodW9iaSc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2h1b2JpLmpzJyksXG4gICAgJ2h1b2JpY255JzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvaHVvYmljbnkuanMnKSxcbiAgICAnaHVvYmlwcm8nOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9odW9iaXByby5qcycpLFxuICAgICdpbmRlcGVuZGVudHJlc2VydmUnOiAgICAgIHJlcXVpcmUgKCcuL2pzL2luZGVwZW5kZW50cmVzZXJ2ZS5qcycpLFxuICAgICdpdGJpdCc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2l0Yml0LmpzJyksXG4gICAgJ2p1YmknOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvanViaS5qcycpLFxuICAgICdrcmFrZW4nOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2tyYWtlbi5qcycpLFxuICAgICdrdWNvaW4nOiAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2t1Y29pbi5qcycpLFxuICAgICdrdW5hJzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2t1bmEuanMnKSxcbiAgICAnbGFrZWJ0Yyc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9sYWtlYnRjLmpzJyksXG4gICAgJ2xpcXVpJzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvbGlxdWkuanMnKSxcbiAgICAnbGl2ZWNvaW4nOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9saXZlY29pbi5qcycpLFxuICAgICdsdW5vJzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL2x1bm8uanMnKSxcbiAgICAnbWVyY2Fkbyc6ICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9tZXJjYWRvLmpzJyksXG4gICAgJ21peGNvaW5zJzogICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvbWl4Y29pbnMuanMnKSxcbiAgICAnbm92YSc6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9ub3ZhLmpzJyksXG4gICAgJ29rY29pbmNueSc6ICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvb2tjb2luY255LmpzJyksXG4gICAgJ29rY29pbnVzZCc6ICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvb2tjb2ludXNkLmpzJyksXG4gICAgJ29rZXgnOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvb2tleC5qcycpLFxuICAgICdwYXltaXVtJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3BheW1pdW0uanMnKSxcbiAgICAncG9sb25pZXgnOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9wb2xvbmlleC5qcycpLFxuICAgICdxcnlwdG9zJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3FyeXB0b3MuanMnKSxcbiAgICAncXVhZHJpZ2FjeCc6ICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy9xdWFkcmlnYWN4LmpzJyksXG4gICAgJ3F1b2luZSc6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvcXVvaW5lLmpzJyksXG4gICAgJ3NvdXRoeGNoYW5nZSc6ICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvc291dGh4Y2hhbmdlLmpzJyksXG4gICAgJ3N1cmJpdGNvaW4nOiAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvc3VyYml0Y29pbi5qcycpLFxuICAgICd0aGVyb2NrJzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3RoZXJvY2suanMnKSxcbiAgICAndGlkZXgnOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy90aWRleC5qcycpLFxuICAgICd1cmR1Yml0JzogICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3VyZHViaXQuanMnKSxcbiAgICAndmF1bHRvcm8nOiAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy92YXVsdG9yby5qcycpLFxuICAgICd2YnRjJzogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3ZidGMuanMnKSxcbiAgICAndmlyd294JzogICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy92aXJ3b3guanMnKSxcbiAgICAnd2V4JzogICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy93ZXguanMnKSxcbiAgICAneGJ0Y2UnOiAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy94YnRjZS5qcycpLFxuICAgICd5b2JpdCc6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCcuL2pzL3lvYml0LmpzJyksXG4gICAgJ3l1bmJpJzogICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMveXVuYmkuanMnKSxcbiAgICAnemFpZic6ICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnLi9qcy96YWlmLmpzJyksXG4gICAgJ3piJzogICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJy4vanMvemIuanMnKSwgICAgXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduICh7IHZlcnNpb24sIEV4Y2hhbmdlLCBleGNoYW5nZXM6IE9iamVjdC5rZXlzIChleGNoYW5nZXMpIH0sIGV4Y2hhbmdlcywgZnVuY3Rpb25zLCBlcnJvcnMpXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBfMWJyb2tlciBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdfMWJyb2tlcicsXG4gICAgICAgICAgICAnbmFtZSc6ICcxQnJva2VyJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MicsXG4gICAgICAgICAgICAnaGFzUHVibGljQVBJJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUcmFkZXMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICc2MCcsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICc5MDAnLFxuICAgICAgICAgICAgICAgICcxaCc6ICczNjAwJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnODY0MDAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYwMjEtNDIwYmQ5ZmMtNWVjYi0xMWU3LThlZDYtNTZkMDA4MWVmZWQyLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovLzFicm9rZXIuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovLzFicm9rZXIuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vMWJyb2tlci5jb20vP2M9ZW4vY29udGVudC9hcGktZG9jdW1lbnRhdGlvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L2JhcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9jYXRlZ29yaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvZGV0YWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L2xpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9xdW90ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC90aWNrcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9jcmVhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2Nsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9jbG9zZV9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2VkaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL29wZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL3NoYXJlZC9nZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NvY2lhbC9wcm9maWxlX3N0YXRpc3RpY3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NvY2lhbC9wcm9maWxlX3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9iaXRjb2luX2RlcG9zaXRfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9kZXRhaWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL292ZXJ2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3F1b3RhX3N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci90cmFuc2FjdGlvbl9sb2cnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaENhdGVnb3JpZXMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRNYXJrZXRDYXRlZ29yaWVzICgpO1xuICAgICAgICAvLyB0aGV5IHJldHVybiBhbiBlbXB0eSBzdHJpbmcgYW1vbmcgdGhlaXIgY2F0ZWdvcmllcywgd3RmP1xuICAgICAgICBsZXQgY2F0ZWdvcmllcyA9IHJlc3BvbnNlWydyZXNwb25zZSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2F0ZWdvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNhdGVnb3JpZXNbaV0pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKGNhdGVnb3JpZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHRoaXNfID0gdGhpczsgLy8gd29ya2Fyb3VuZCBmb3IgQmFiZWwgYnVnIChub3QgcGFzc2luZyBgdGhpc2AgdG8gX3JlY3Vyc2l2ZSgpIGNhbGwpXG4gICAgICAgIGxldCBjYXRlZ29yaWVzID0gYXdhaXQgdGhpcy5mZXRjaENhdGVnb3JpZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjYXRlZ29yaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY2F0ZWdvcnkgPSBjYXRlZ29yaWVzW2NdO1xuICAgICAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzXy5wcml2YXRlR2V0TWFya2V0TGlzdCAoe1xuICAgICAgICAgICAgICAgICdjYXRlZ29yeSc6IGNhdGVnb3J5LnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHNbJ3Jlc3BvbnNlJ10ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sncmVzcG9uc2UnXVtwXTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICgoY2F0ZWdvcnkgPT0gJ0ZPUkVYJykgfHwgKGNhdGVnb3J5ID09ICdDUllQVE8nKSkge1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ25hbWUnXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRzID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGlkO1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9ICdVU0QnO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhc2UgPSB0aGlzXy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgICAgIHF1b3RlID0gdGhpc18uY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldFVzZXJPdmVydmlldyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYmFsYW5jZVsncmVzcG9uc2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsID0gcGFyc2VGbG9hdCAocmVzcG9uc2VbJ2JhbGFuY2UnXSk7XG4gICAgICAgIHJlc3VsdFsnQlRDJ11bJ2ZyZWUnXSA9IHRvdGFsO1xuICAgICAgICByZXN1bHRbJ0JUQyddWyd0b3RhbCddID0gdG90YWw7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRNYXJrZXRRdW90ZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9scyc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ3Jlc3BvbnNlJ11bMF07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob3JkZXJib29rWyd1cGRhdGVkJ10pO1xuICAgICAgICBsZXQgYmlkUHJpY2UgPSBwYXJzZUZsb2F0IChvcmRlcmJvb2tbJ2JpZCddKTtcbiAgICAgICAgbGV0IGFza1ByaWNlID0gcGFyc2VGbG9hdCAob3JkZXJib29rWydhc2snXSk7XG4gICAgICAgIGxldCBiaWQgPSBbIGJpZFByaWNlLCB1bmRlZmluZWQgXTtcbiAgICAgICAgbGV0IGFzayA9IFsgYXNrUHJpY2UsIHVuZGVmaW5lZCBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdiaWRzJzogWyBiaWQgXSxcbiAgICAgICAgICAgICdhc2tzJzogWyBhc2sgXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaFRyYWRlcyAoKSBtZXRob2Qgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRNYXJrZXRCYXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncmVzb2x1dGlvbic6IDYwLFxuICAgICAgICAgICAgJ2xpbWl0JzogMSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJCb29rIChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzdWx0WydyZXNwb25zZSddWzBdO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsJ10pLFxuICAgICAgICAgICAgJ2JpZCc6IG9yZGVyYm9va1snYmlkcyddWzBdWzBdLFxuICAgICAgICAgICAgJ2Fzayc6IG9yZGVyYm9va1snYXNrcyddWzBdWzBdLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnbyddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYyddKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5wYXJzZTg2MDEgKG9obGN2WydkYXRlJ10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ28nXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnaCddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydsJ10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ2MnXSksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3Jlc29sdXRpb24nOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNpbmNlKVxuICAgICAgICAgICAgcmVxdWVzdFsnZGF0ZV9zdGFydCddID0gdGhpcy5pc284NjAxIChzaW5jZSk7IC8vIHRoZXkgYWxzbyBzdXBwb3J0IGRhdGVfZW5kXG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE1hcmtldEJhcnMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3VsdFsncmVzcG9uc2UnXSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnbWFyZ2luJzogYW1vdW50LFxuICAgICAgICAgICAgJ2RpcmVjdGlvbic6IChzaWRlID09ICdzZWxsJykgPyAnc2hvcnQnIDogJ2xvbmcnLFxuICAgICAgICAgICAgJ2xldmVyYWdlJzogMSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9yZGVyWyd0eXBlJ10gKz0gJ19tYXJrZXQnO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXJDcmVhdGUgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHJlc3VsdFsncmVzcG9uc2UnXVsnb3JkZXJfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlckNhbmNlbCAoeyAnb3JkZXJfaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHBhdGggKyAnLnBocCc7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7ICd0b2tlbic6IHRoaXMuYXBpS2V5IH0sIHBhcmFtcyk7XG4gICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3dhcm5pbmcnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWyd3YXJuaW5nJ10pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgXzFidGN4ZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdfMWJ0Y3hlJyxcbiAgICAgICAgICAgICduYW1lJzogJzFCVENYRScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1BBJywgLy8gUGFuYW1hXG4gICAgICAgICAgICAnY29tbWVudCc6ICdDcnlwdG8gQ2FwaXRhbCBBUEknLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxZCc6ICcxeWVhcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjA0OS0yYjI5NDQwOC01ZWNjLTExZTctODVjYy1hZGFmZjAxM2RjMWEuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vMWJ0Y3hlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly8xYnRjeGUuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vMWJ0Y3hlLmNvbS9hcGktZG9jcy5waHAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGF0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yaWNhbC1wcmljZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyLWJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZXMtYW5kLWluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW4tb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyLXRyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnRjLWRlcG9zaXQtYWRkcmVzcy9nZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J0Yy1kZXBvc2l0LWFkZHJlc3MvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0cy9nZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL2dldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL25ldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL2VkaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy9zdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL25ldycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ1VTRCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdFVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvQ05ZJzogeyAnaWQnOiAnQ05ZJywgJ3N5bWJvbCc6ICdCVEMvQ05ZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1JVQic6IHsgJ2lkJzogJ1JVQicsICdzeW1ib2wnOiAnQlRDL1JVQicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdSVUInIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9DSEYnOiB7ICdpZCc6ICdDSEYnLCAnc3ltYm9sJzogJ0JUQy9DSEYnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ0hGJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvSlBZJzogeyAnaWQnOiAnSlBZJywgJ3N5bWJvbCc6ICdCVEMvSlBZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0dCUCc6IHsgJ2lkJzogJ0dCUCcsICdzeW1ib2wnOiAnQlRDL0dCUCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdHQlAnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9DQUQnOiB7ICdpZCc6ICdDQUQnLCAnc3ltYm9sJzogJ0JUQy9DQUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ0FEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvQVVEJzogeyAnaWQnOiAnQVVEJywgJ3N5bWJvbCc6ICdCVEMvQVVEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0FVRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0FFRCc6IHsgJ2lkJzogJ0FFRCcsICdzeW1ib2wnOiAnQlRDL0FFRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdBRUQnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9CR04nOiB7ICdpZCc6ICdCR04nLCAnc3ltYm9sJzogJ0JUQy9CR04nLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQkdOJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvQ1pLJzogeyAnaWQnOiAnQ1pLJywgJ3N5bWJvbCc6ICdCVEMvQ1pLJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NaSycgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0RLSyc6IHsgJ2lkJzogJ0RLSycsICdzeW1ib2wnOiAnQlRDL0RLSycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdES0snIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9IS0QnOiB7ICdpZCc6ICdIS0QnLCAnc3ltYm9sJzogJ0JUQy9IS0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSEtEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvSFJLJzogeyAnaWQnOiAnSFJLJywgJ3N5bWJvbCc6ICdCVEMvSFJLJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0hSSycgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0hVRic6IHsgJ2lkJzogJ0hVRicsICdzeW1ib2wnOiAnQlRDL0hVRicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdIVUYnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9JTFMnOiB7ICdpZCc6ICdJTFMnLCAnc3ltYm9sJzogJ0JUQy9JTFMnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSUxTJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvSU5SJzogeyAnaWQnOiAnSU5SJywgJ3N5bWJvbCc6ICdCVEMvSU5SJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0lOUicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL01VUic6IHsgJ2lkJzogJ01VUicsICdzeW1ib2wnOiAnQlRDL01VUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdNVVInIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9NWE4nOiB7ICdpZCc6ICdNWE4nLCAnc3ltYm9sJzogJ0JUQy9NWE4nLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnTVhOJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvTk9LJzogeyAnaWQnOiAnTk9LJywgJ3N5bWJvbCc6ICdCVEMvTk9LJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ05PSycgfSxcbiAgICAgICAgICAgICAgICAnQlRDL05aRCc6IHsgJ2lkJzogJ05aRCcsICdzeW1ib2wnOiAnQlRDL05aRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdOWkQnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9QTE4nOiB7ICdpZCc6ICdQTE4nLCAnc3ltYm9sJzogJ0JUQy9QTE4nLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnUExOJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvUk9OJzogeyAnaWQnOiAnUk9OJywgJ3N5bWJvbCc6ICdCVEMvUk9OJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1JPTicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1NFSyc6IHsgJ2lkJzogJ1NFSycsICdzeW1ib2wnOiAnQlRDL1NFSycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdTRUsnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9TR0QnOiB7ICdpZCc6ICdTR0QnLCAnc3ltYm9sJzogJ0JUQy9TR0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnU0dEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvVEhCJzogeyAnaWQnOiAnVEhCJywgJ3N5bWJvbCc6ICdCVEMvVEhCJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1RIQicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1RSWSc6IHsgJ2lkJzogJ1RSWScsICdzeW1ib2wnOiAnQlRDL1RSWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdUUlknIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9aQVInOiB7ICdpZCc6ICdaQVInLCAnc3ltYm9sJzogJ0JUQy9aQVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnWkFSJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZXNBbmRJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlWydiYWxhbmNlcy1hbmQtaW5mbyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2UgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ10sIGN1cnJlbmN5LCAwLjApO1xuICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2VbJ29uX2hvbGQnXSwgY3VycmVuY3ksIDAuMCk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAocmVzcG9uc2VbJ29yZGVyLWJvb2snXSwgdW5kZWZpbmVkLCAnYmlkJywgJ2FzaycsICdwcmljZScsICdvcmRlcl9hbW91bnQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFN0YXRzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnc3RhdHMnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbWF4J10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbWluJ10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0X3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnZGFpbHlfY2hhbmdlJ10pLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd0b3RhbF9idGNfdHJhZGVkJ10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxZCcsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5wYXJzZTg2MDEgKG9obGN2WydkYXRlJ10gKyAnIDAwOjAwOjAwJyksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsncHJpY2UnXSksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMWQnLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRIaXN0b3JpY2FsUHJpY2VzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZSc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9obGN2cyA9IHRoaXMub21pdCAocmVzcG9uc2VbJ2hpc3RvcmljYWwtcHJpY2VzJ10sICdyZXF1ZXN0X2N1cnJlbmN5Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChvaGxjdnMsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnbWFrZXJfdHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhbnNhY3Rpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRyYWRlcyA9IHRoaXMub21pdCAocmVzcG9uc2VbJ3RyYW5zYWN0aW9ucyddLCAncmVxdWVzdF9jdXJyZW5jeScpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAodHJhZGVzLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsnbGltaXRfcHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyc05ldyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyc0NhbmNlbCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3YWxzTmV3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAoYW1vdW50KSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3Jlc3VsdCddWyd1dWlkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5pZCA9PSAnY3J5cHRvY2FwaXRhbCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgaXMgYW4gYWJzdHJhY3QgYmFzZSBBUEkgZm9yIF8xYnRjeGUnKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpX2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIHF1ZXJ5WydzaWduYXR1cmUnXSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9ycycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgcmVzcG9uc2VbJ2Vycm9ycyddLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yID0gcmVzcG9uc2VbJ2Vycm9ycyddW2VdO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoIChlcnJvclsnY29kZSddICsgJzogJyArIGVycm9yWydtZXNzYWdlJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmpvaW4gKCcgJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIE9yZGVyTm90Rm91bmQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYWN4IGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2FjeCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdBQ1gnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdBVScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcxJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnNScsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICcxNScsXG4gICAgICAgICAgICAgICAgJzMwbSc6ICczMCcsXG4gICAgICAgICAgICAgICAgJzFoJzogJzYwJyxcbiAgICAgICAgICAgICAgICAnMmgnOiAnMTIwJyxcbiAgICAgICAgICAgICAgICAnNGgnOiAnMjQwJyxcbiAgICAgICAgICAgICAgICAnMTJoJzogJzcyMCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJzE0NDAnLFxuICAgICAgICAgICAgICAgICczZCc6ICc0MzIwJyxcbiAgICAgICAgICAgICAgICAnMXcnOiAnMTAwODAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzAyNDc2MTQtMWZlNjFjNzQtOTYyMS0xMWU3LTllOGMtZjFhNjI3YWZhMjc5LmpwZycsXG4gICAgICAgICAgICAgICAgJ2V4dGVuc2lvbic6ICcuanNvbicsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FjeC5pby9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9hY3guaW8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9hY3guaW8vZG9jdW1lbnRzL2FwaV92MicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldHMnLCAvLyBHZXQgYWxsIGF2YWlsYWJsZSBtYXJrZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VycycsIC8vIEdldCB0aWNrZXIgb2YgYWxsIG1hcmtldHNcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzL3ttYXJrZXR9JywgLy8gR2V0IHRpY2tlciBvZiBzcGVjaWZpYyBtYXJrZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMnLCAvLyBHZXQgcmVjZW50IHRyYWRlcyBvbiBtYXJrZXQsIGVhY2ggdHJhZGUgaXMgaW5jbHVkZWQgb25seSBvbmNlIFRyYWRlcyBhcmUgc29ydGVkIGluIHJldmVyc2UgY3JlYXRpb24gb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfYm9vaycsIC8vIEdldCB0aGUgb3JkZXIgYm9vayBvZiBzcGVjaWZpZWQgbWFya2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgnLCAvLyBHZXQgZGVwdGggb3Igc3BlY2lmaWVkIG1hcmtldCBCb3RoIGFza3MgYW5kIGJpZHMgYXJlIHNvcnRlZCBmcm9tIGhpZ2hlc3QgcHJpY2UgdG8gbG93ZXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJ2snLCAvLyBHZXQgT0hMQyhrIGxpbmUpIG9mIHNwZWNpZmljIG1hcmtldFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2tfd2l0aF9wZW5kaW5nX3RyYWRlcycsIC8vIEdldCBLIGRhdGEgd2l0aCBwZW5kaW5nIHRyYWRlcywgd2hpY2ggYXJlIHRoZSB0cmFkZXMgbm90IGluY2x1ZGVkIGluIEsgZGF0YSB5ZXQsIGJlY2F1c2UgdGhlcmUncyBkZWxheSBiZXR3ZWVuIHRyYWRlIGdlbmVyYXRlZCBhbmQgcHJvY2Vzc2VkIGJ5IEsgZGF0YSBnZW5lcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aW1lc3RhbXAnLCAvLyBHZXQgc2VydmVyIGN1cnJlbnQgdGltZSwgaW4gc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZW1iZXJzL21lJywgLy8gR2V0IHlvdXIgcHJvZmlsZSBhbmQgYWNjb3VudHMgaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRzJywgLy8gR2V0IHlvdXIgZGVwb3NpdHMgaGlzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnLCAvLyBHZXQgZGV0YWlscyBvZiBzcGVjaWZpYyBkZXBvc2l0XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdF9hZGRyZXNzJywgLy8gV2hlcmUgdG8gZGVwb3NpdCBUaGUgYWRkcmVzcyBmaWVsZCBjb3VsZCBiZSBlbXB0eSB3aGVuIGEgbmV3IGFkZHJlc3MgaXMgZ2VuZXJhdGluZyAoZS5nLiBmb3IgYml0Y29pbiksIHlvdSBzaG91bGQgdHJ5IGFnYWluIGxhdGVyIGluIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLCAvLyBHZXQgeW91ciBvcmRlcnMsIHJlc3VsdHMgaXMgcGFnaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLCAvLyBHZXQgaW5mb3JtYXRpb24gb2Ygc3BlY2lmaWVkIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL215JywgLy8gR2V0IHlvdXIgZXhlY3V0ZWQgdHJhZGVzIFRyYWRlcyBhcmUgc29ydGVkIGluIHJldmVyc2UgY3JlYXRpb24gb3JkZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdzJywgLy8gR2V0IHlvdXIgY3J5cHRvY3VycmVuY3kgd2l0aGRyYXdzXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLCAvLyBHZXQgeW91ciBjcnlwdG9jdXJyZW5jeSB3aXRoZHJhd1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLCAvLyBDcmVhdGUgYSBTZWxsL0J1eSBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy9tdWx0aScsIC8vIENyZWF0ZSBtdWx0aXBsZSBzZWxsL2J1eSBvcmRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvY2xlYXInLCAvLyBDYW5jZWwgYWxsIG15IG9yZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2RlbGV0ZScsIC8vIENhbmNlbCBhbiBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JywgLy8gQ3JlYXRlIGEgd2l0aGRyYXdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZnVuZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RpZXJCYXNlZCc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAncGVyY2VudGFnZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IDAuMCwgLy8gVGhlcmUgaXMgb25seSAxJSBmZWUgb24gd2l0aGRyYXdhbHMgdG8geW91ciBiYW5rIGFjY291bnQuXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TWVtYmVyc01lICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnYWNjb3VudHMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2xvY2tlZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2xpbWl0JzogMzAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyYm9va1sndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsnYXQnXSAqIDEwMDA7XG4gICAgICAgIHRpY2tlciA9IHRpY2tlclsndGlja2VyJ107XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdoaWdoJywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5JywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnc2VsbCcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbCcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlID0gaWQuc2xpY2UgKDMsIDYpO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIHF1b3RlID0gcXVvdGUudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnNNYXJrZXQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWyd0eXBlJ10gPT0gJ2JpZCcpID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIC8vIGxvb2tzIGxpa2UgdGhleSBzd2l0Y2hlZCB0aGlzIGVuZHBvaW50IG9mZlxuICAgICAgICAvLyBpdCByZXR1cm5zIDUwMyBTZXJ2aWNlIFRlbXBvcmFyaWx5IFVuYXZhaWxhYmxlIGFsd2F5c1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbMF0gKiAxMDAwLFxuICAgICAgICAgICAgb2hsY3ZbMV0sXG4gICAgICAgICAgICBvaGxjdlsyXSxcbiAgICAgICAgICAgIG9obGN2WzNdLFxuICAgICAgICAgICAgb2hsY3ZbNF0sXG4gICAgICAgICAgICBvaGxjdls1XSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBpZiAoIWxpbWl0KVxuICAgICAgICAgICAgbGltaXQgPSA1MDA7IC8vIGRlZmF1bHQgaXMgMzBcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3BlcmlvZCc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICAgICAgJ2xpbWl0JzogbGltaXQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3RpbWVzdGFtcCddID0gc2luY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0SyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXRJZCA9IG9yZGVyWydtYXJrZXQnXTtcbiAgICAgICAgICAgIHN5bWJvbCA9IHRoaXMubWFya2V0c0J5SWRbbWFya2V0SWRdWydzeW1ib2wnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydjcmVhdGVkX2F0J10pO1xuICAgICAgICBsZXQgc3RhdGUgPSBvcmRlclsnc3RhdGUnXTtcbiAgICAgICAgbGV0IHN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN0YXRlID09ICdkb25lJykge1xuICAgICAgICAgICAgc3RhdHVzID0gJ2Nsb3NlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gJ3dhaXQnKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXMsXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiBvcmRlclsnb3JkX3R5cGUnXSxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKG9yZGVyWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0IChvcmRlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IHBhcnNlRmxvYXQgKG9yZGVyWydleGVjdXRlZF92b2x1bWUnXSksXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcGFyc2VGbG9hdCAob3JkZXJbJ3JlbWFpbmluZ192b2x1bWUnXSksXG4gICAgICAgICAgICAndHJhZGVzJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAndm9sdW1lJzogYW1vdW50LnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZF90eXBlJzogdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0Jykge1xuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZS50b1N0cmluZyAoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJzICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzQnlJZFtyZXNwb25zZVsnbWFya2V0J11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlckRlbGV0ZSAoeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5wYXJzZU9yZGVyKHJlc3VsdCk7XG4gICAgICAgIGlmIChvcmRlclsnc3RhdHVzJ10gPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyAnICsgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdzdW0nOiBhbW91bnQsXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXN1bHQsXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgZW5jb2RlUGFyYW1zIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKCdvcmRlcnMnIGluIHBhcmFtcykge1xuICAgICAgICAgICAgbGV0IG9yZGVycyA9IHBhcmFtc1snb3JkZXJzJ107XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5rZXlzb3J0ICh0aGlzLm9taXQgKHBhcmFtcywgJ29yZGVycycpKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvcmRlciA9IG9yZGVyc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChvcmRlcik7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBrZXlzW2tdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBvcmRlcltrZXldO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSArPSAnJm9yZGVycyU1QiU1RCU1QicgKyBrZXkgKyAnJTVEPScgKyB2YWx1ZS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudXJsZW5jb2RlICh0aGlzLmtleXNvcnQgKHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSAnL2FwaScgKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGlmICgnZXh0ZW5zaW9uJyBpbiB0aGlzLnVybHMpXG4gICAgICAgICAgICByZXF1ZXN0ICs9IHRoaXMudXJsc1snZXh0ZW5zaW9uJ107XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyByZXF1ZXN0O1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZW5jb2RlUGFyYW1zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdhY2Nlc3Nfa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3RvbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gbWV0aG9kICsgJ3wnICsgcmVxdWVzdCArICd8JyArIHF1ZXJ5O1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGxldCBzdWZmaXggPSBxdWVyeSArICcmc2lnbmF0dXJlPScgKyBzaWduYXR1cmU7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdHRVQnKSB7XG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHN1ZmZpeDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHN1ZmZpeDtcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgb2tjb2ludXNkID0gcmVxdWlyZSAoJy4vb2tjb2ludXNkLmpzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGFsbGNvaW4gZXh0ZW5kcyBva2NvaW51c2Qge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2FsbGNvaW4nLFxuICAgICAgICAgICAgJ25hbWUnOiAnQWxsY29pbicsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0NBJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnZXh0ZW5zaW9uJzogJycsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMxNTYxODA5LWMzMTZiMzdjLWIwNjEtMTFlNy04ZDVhLWI1NDdiNGQ3MzBlYi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICd3ZWInOiAnaHR0cHM6Ly9hbGxjb2luLmNvbScsXG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkuYWxsY29pbi5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYWxsY29pbi5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9hbGxjb2luLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2FsbGNvaW4uY29tL0Fib3V0L0FQSVJlZmVyZW5jZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAnd2ViJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldG92ZXJ2aWV3cy8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAna2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYXRjaF90cmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnNfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVwYXltZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVfaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcmluZm8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIC8vIHRvZG8gcmV3cml0ZSBmb3IgaHR0cHM6Ly93d3cuYWxsY29pbi5jb20vSG9tZS9NYXJrZXRPdmVyVmlld0RldGFpbC9cbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBbICdCVEMnLCAnRVRIJywgJ1VTRCcsICdRVFVNJywgJ0NORVQnLCAnQ0suVVNEJyBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2ViR2V0TWFya2V0b3ZlcnZpZXdzICh7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZnVsbCcsXG4gICAgICAgICAgICAgICAgJ3NlY29uZGFyeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydNYXJrZXRzJ107XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG1hcmtldHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1trXTtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnUHJpbWFyeSddO1xuICAgICAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnU2Vjb25kYXJ5J107XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gYmFzZS50b0xvd2VyQ2FzZSAoKSArICdfJyArIHF1b3RlLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3Nwb3QnLFxuICAgICAgICAgICAgICAgICAgICAnc3BvdCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdmdXR1cmUnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXRPcmRlclN0YXR1cyAoc3RhdHVzKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gJ2NhbmNlbGVkJztcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuICdvcGVuJztcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuICdvcGVuJzsgLy8gcGFydGlhbGx5IGZpbGxlZFxuICAgICAgICBpZiAoc3RhdHVzID09IDIpXG4gICAgICAgICAgICByZXR1cm4gJ2Nsb3NlZCc7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gMTApXG4gICAgICAgICAgICByZXR1cm4gJ2NhbmNlbGVkJztcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBhbnhwcm8gZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYW54cHJvJyxcbiAgICAgICAgICAgICduYW1lJzogJ0FOWFBybycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnSlAnLCAnU0cnLCAnSEsnLCAnTlonIF0sXG4gICAgICAgICAgICAndmVyc2lvbic6ICcyJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRyYWRlcyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjU5ODMtZmQ4NTk1ZGEtNWVjOS0xMWU3LTgyZTMtYWRiM2FiOGMyNjEyLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FueHByby5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYW54cHJvLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly9kb2NzLmFueHYyLmFwaWFyeS5pbycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FueHByby5jb20vcGFnZXMvYXBpJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvZGVwdGgvZnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L3RyYWRlL2ZldGNoJywgLy8gZGlzYWJsZWQgYnkgQU5YUHJvXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L29yZGVyL2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L29yZGVyL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L29yZGVyL3F1b3RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvb3JkZXIvcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb25leS97Y3VycmVuY3l9L2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vbmV5L3tjdXJyZW5jeX0vc2VuZF9zaW1wbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vbmV5L2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vbmV5L3RyYWRlL2xpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vbmV5L3dhbGxldC9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnQlRDVVNEJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcsICdtdWx0aXBsaWVyJzogMTAwMDAwIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9IS0QnOiB7ICdpZCc6ICdCVENIS0QnLCAnc3ltYm9sJzogJ0JUQy9IS0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSEtEJywgJ211bHRpcGxpZXInOiAxMDAwMDAgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0JUQ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInLCAnbXVsdGlwbGllcic6IDEwMDAwMCB9LFxuICAgICAgICAgICAgICAgICdCVEMvQ0FEJzogeyAnaWQnOiAnQlRDQ0FEJywgJ3N5bWJvbCc6ICdCVEMvQ0FEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NBRCcsICdtdWx0aXBsaWVyJzogMTAwMDAwIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9BVUQnOiB7ICdpZCc6ICdCVENBVUQnLCAnc3ltYm9sJzogJ0JUQy9BVUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQVVEJywgJ211bHRpcGxpZXInOiAxMDAwMDAgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1NHRCc6IHsgJ2lkJzogJ0JUQ1NHRCcsICdzeW1ib2wnOiAnQlRDL1NHRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdTR0QnLCAnbXVsdGlwbGllcic6IDEwMDAwMCB9LFxuICAgICAgICAgICAgICAgICdCVEMvSlBZJzogeyAnaWQnOiAnQlRDSlBZJywgJ3N5bWJvbCc6ICdCVEMvSlBZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0pQWScsICdtdWx0aXBsaWVyJzogMTAwMDAwIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9HQlAnOiB7ICdpZCc6ICdCVENHQlAnLCAnc3ltYm9sJzogJ0JUQy9HQlAnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnR0JQJywgJ211bHRpcGxpZXInOiAxMDAwMDAgfSxcbiAgICAgICAgICAgICAgICAnQlRDL05aRCc6IHsgJ2lkJzogJ0JUQ05aRCcsICdzeW1ib2wnOiAnQlRDL05aRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdOWkQnLCAnbXVsdGlwbGllcic6IDEwMDAwMCB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycsICdtdWx0aXBsaWVyJzogMTAwMDAwIH0sXG4gICAgICAgICAgICAgICAgJ1NUUi9CVEMnOiB7ICdpZCc6ICdTVFJCVEMnLCAnc3ltYm9sJzogJ1NUUi9CVEMnLCAnYmFzZSc6ICdTVFInLCAncXVvdGUnOiAnQlRDJywgJ211bHRpcGxpZXInOiAxMDAwMDAwMDAgfSxcbiAgICAgICAgICAgICAgICAnWFJQL0JUQyc6IHsgJ2lkJzogJ1hSUEJUQycsICdzeW1ib2wnOiAnWFJQL0JUQycsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdCVEMnLCAnbXVsdGlwbGllcic6IDEwMDAwMDAwMCB9LFxuICAgICAgICAgICAgICAgICdET0dFL0JUQyc6IHsgJ2lkJzogJ0RPR0VCVEMnLCAnc3ltYm9sJzogJ0RPR0UvQlRDJywgJ2Jhc2UnOiAnRE9HRScsICdxdW90ZSc6ICdCVEMnLCAnbXVsdGlwbGllcic6IDEwMDAwMDAwMCB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjMgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuNiAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TW9uZXlJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VbJ1dhbGxldHMnXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlWydXYWxsZXRzJ10pIHtcbiAgICAgICAgICAgICAgICBsZXQgd2FsbGV0ID0gYmFsYW5jZVsnV2FsbGV0cyddW2N1cnJlbmN5XTtcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0ICh3YWxsZXRbJ0F2YWlsYWJsZV9CYWxhbmNlJ11bJ3ZhbHVlJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBwYXJzZUZsb2F0ICh3YWxsZXRbJ0JhbGFuY2UnXVsndmFsdWUnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5UGFpck1vbmV5RGVwdGhGdWxsICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5X3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCB0ID0gcGFyc2VJbnQgKG9yZGVyYm9va1snZGF0YVVwZGF0ZVRpbWUnXSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodCAvIDEwMDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXAsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDdXJyZW5jeVBhaXJNb25leVRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9wYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgdCA9IHBhcnNlSW50ICh0aWNrZXJbJ2RhdGFVcGRhdGVUaW1lJ10pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHQgLyAxMDAwKTtcbiAgICAgICAgbGV0IGJpZCA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXJbJ2J1eSddLCAndmFsdWUnKTtcbiAgICAgICAgbGV0IGFzayA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSwgJ3ZhbHVlJyk7O1xuICAgICAgICBsZXQgdndhcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddWyd2YWx1ZSddKTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbCddWyd2YWx1ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXVsndmFsdWUnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXVsndmFsdWUnXSksXG4gICAgICAgICAgICAnYmlkJzogYmlkLFxuICAgICAgICAgICAgJ2Fzayc6IGFzayxcbiAgICAgICAgICAgICd2d2FwJzogdndhcCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXVsndmFsdWUnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXZnJ11bJ3ZhbHVlJ10pLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBiYXNlVm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogYmFzZVZvbHVtZSAqIHZ3YXAsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBzd2l0Y2hlZCBvZmYgdGhlIHRyYWRlcyBlbmRwb2ludCwgc2VlIHRoZWlyIGRvY3MgYXQgaHR0cDovL2RvY3MuYW54djIuYXBpYXJ5LmlvL3JlZmVyZW5jZS9tYXJrZXQtZGF0YS9jdXJyZW5jeXBhaXJtb25leXRyYWRlZmV0Y2gtZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljR2V0Q3VycmVuY3lQYWlyTW9uZXlUcmFkZUZldGNoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5X3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9wYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2Ftb3VudF9pbnQnOiBwYXJzZUludCAoYW1vdW50ICogMTAwMDAwMDAwKSwgLy8gMTBeOFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKSB7XG4gICAgICAgICAgICBvcmRlclsncHJpY2VfaW50J10gPSBwYXJzZUludCAocHJpY2UgKiBtYXJrZXRbJ211bHRpcGxpZXInXSk7IC8vIDEwXjUgb3IgMTBeOFxuICAgICAgICB9XG4gICAgICAgIG9yZGVyWyd0eXBlJ10gPSAoc2lkZSA9PSAnYnV5JykgPyAnYmlkJyA6ICdhc2snO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEN1cnJlbmN5UGFpck1vbmV5T3JkZXJBZGQgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHJlc3VsdFsnZGF0YSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEN1cnJlbmN5UGFpck1vbmV5T3JkZXJDYW5jZWwgKHsgJ29pZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGdldEFtb3VudE11bHRpcGxpZXIgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQlRDJykge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnTFRDJykge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnU1RSJykge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnWFJQJykge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDAwMDAwMDtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnRE9HRScpIHtcbiAgICAgICAgICAgIHJldHVybiAxMDAwMDAwMDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDEwMDtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSB0aGlzLmdldEFtb3VudE11bHRpcGxpZXIgKGN1cnJlbmN5KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE1vbmV5Q3VycmVuY3lTZW5kU2ltcGxlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50X2ludCc6IHBhcnNlSW50IChhbW91bnQgKiBtdWx0aXBsaWVyKSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2RhdGEnXVsndHJhbnNhY3Rpb25JZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyByZXF1ZXN0O1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5iYXNlNjRUb0JpbmFyeSAodGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSByZXF1ZXN0ICsgXCJcXDBcIiArIGJvZHk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHNlY3JldCwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdSZXN0LUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdSZXN0LVNpZ24nOiB0aGlzLmRlY29kZSAoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdyZXN1bHQnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydyZXN1bHQnXSA9PSAnc3VjY2VzcycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBpc05vZGUgICAgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgLCBmdW5jdGlvbnMgPSByZXF1aXJlICgnLi9mdW5jdGlvbnMnKVxuICAgICwgdGhyb3R0bGUgID0gcmVxdWlyZSAoJy4vdGhyb3R0bGUnKVxuICAgICwgZmV0Y2ggICAgID0gcmVxdWlyZSAoJ2ZldGNoLXBvbnlmaWxsJykoKS5mZXRjaFxuICAgICwgTWFya2V0ICAgID0gcmVxdWlyZSAoJy4vTWFya2V0JylcblxuY29uc3QgeyBkZWVwRXh0ZW5kXG4gICAgICAsIGV4dGVuZFxuICAgICAgLCBzbGVlcFxuICAgICAgLCB0aW1lb3V0XG4gICAgICAsIGluZGV4QnlcbiAgICAgICwgc29ydEJ5XG4gICAgICAsIGFnZ3JlZ2F0ZVxuICAgICAgLCB1dWlkXG4gICAgICAsIHByZWNpc2lvbkZyb21TdHJpbmcgfSA9IGZ1bmN0aW9uc1xuXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3JcbiAgICAgICwgTm90U3VwcG9ydGVkXG4gICAgICAsIEF1dGhlbnRpY2F0aW9uRXJyb3JcbiAgICAgICwgRERvU1Byb3RlY3Rpb25cbiAgICAgICwgUmVxdWVzdFRpbWVvdXRcbiAgICAgICwgRXhjaGFuZ2VOb3RBdmFpbGFibGUgfSA9IHJlcXVpcmUgKCcuL2Vycm9ycycpXG5cbi8vIHN0dWIgdW50aWwgd2UgZ2V0IGEgYmV0dGVyIHNvbHV0aW9uIGZvciBXZWJwYWNrIGFuZCBSZWFjdFxuLy8gY29uc3Qgam91cm5hbCA9IGlzTm9kZSAmJiByZXF1aXJlICgnLi9qb3VybmFsJylcbmNvbnN0IGpvdXJuYWwgPSB1bmRlZmluZWRcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFeGNoYW5nZSB7XG5cbiAgICBnZXRNYXJrZXQgKHN5bWJvbCkge1xuXG4gICAgICAgIGlmICghdGhpcy5tYXJrZXRDbGFzc2VzKVxuICAgICAgICAgICAgdGhpcy5tYXJrZXRDbGFzc2VzID0ge31cblxuICAgICAgICBsZXQgbWFya2V0Q2xhc3MgPSB0aGlzLm1hcmtldENsYXNzZXNbc3ltYm9sXVxuXG4gICAgICAgIGlmIChtYXJrZXRDbGFzcylcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXRDbGFzc1xuXG4gICAgICAgIG1hcmtldENsYXNzID0gbmV3IE1hcmtldCAodGhpcywgc3ltYm9sKVxuICAgICAgICB0aGlzLm1hcmtldENsYXNzZXNbc3ltYm9sXSA9IG1hcmtldENsYXNzIC8vIG9ubHkgb25lIE1hcmtldCBpbnN0YW5jZSBwZXIgbWFya2V0XG4gICAgICAgIHJldHVybiBtYXJrZXRDbGFzc1xuICAgIH1cblxuICAgIGRlc2NyaWJlICgpIHsgcmV0dXJuIHt9IH1cblxuICAgIGNvbnN0cnVjdG9yICh1c2VyQ29uZmlnID0ge30pIHtcblxuICAgICAgICBPYmplY3QuYXNzaWduICh0aGlzLCBmdW5jdGlvbnMsIHsgZW5jb2RlOiBzdHJpbmcgPT4gc3RyaW5nLCBkZWNvZGU6IHN0cmluZyA9PiBzdHJpbmcgfSlcblxuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5ub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbi5tYXRjaCAoL1xcZCtcXC5cXGQrLlxcZCsvKSBbMF1cblxuICAgICAgICAvLyB0aGlzLmluaXRSZXN0UmF0ZUxpbWl0ZXIgKClcblxuICAgICAgICAvLyBpZiAoaXNOb2RlKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnVzZXJBZ2VudCA9IHtcbiAgICAgICAgLy8gICAgICAgICAnVXNlci1BZ2VudCc6ICdjY3h0LycgKyBFeGNoYW5nZS5jY3h0VmVyc2lvbiArXG4gICAgICAgIC8vICAgICAgICAgICAgICcgKCtodHRwczovL2dpdGh1Yi5jb20vY2N4dC9jY3h0KScgK1xuICAgICAgICAvLyAgICAgICAgICAgICAnIE5vZGUuanMvJyArIHRoaXMubm9kZVZlcnNpb24gKyAnIChKYXZhU2NyaXB0KSdcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHRoaXMudXNlckFnZW50cyA9IHtcbiAgICAgICAgICAgICdjaHJvbWUnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzYyLjAuMzIwMi45NCBTYWZhcmkvNTM3LjM2JyxcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9XG5cbiAgICAgICAgLy8gcHJlcGVuZGVkIHRvIFVSTCwgbGlrZSBodHRwczovL3Byb3h5LmNvbS9odHRwczovL2V4Y2hhbmdlLmNvbS9hcGkuLi5cbiAgICAgICAgdGhpcy5wcm94eSA9ICcnXG5cbiAgICAgICAgdGhpcy5pc284NjAxICAgICAgICAgID0gdGltZXN0YW1wID0+IG5ldyBEYXRlICh0aW1lc3RhbXApLnRvSVNPU3RyaW5nICgpXG4gICAgICAgIHRoaXMucGFyc2U4NjAxICAgICAgICA9IHggPT4gRGF0ZS5wYXJzZSAoKCh4LmluZGV4T2YgKCcrJykgPj0gMCkgfHwgKHguc2xpY2UgKC0xKSA9PSAnWicpKSA/IHggOiAoeCArICdaJykpXG4gICAgICAgIHRoaXMubWlsbGlzZWNvbmRzICAgICA9IERhdGUubm93XG4gICAgICAgIHRoaXMubWljcm9zZWNvbmRzICAgICA9ICgpID0+IE1hdGguZmxvb3IgKHRoaXMubWlsbGlzZWNvbmRzICgpICogMTAwMClcbiAgICAgICAgdGhpcy5zZWNvbmRzICAgICAgICAgID0gKCkgPT4gTWF0aC5mbG9vciAodGhpcy5taWxsaXNlY29uZHMgKCkgLyAxMDAwKVxuICAgICAgICB0aGlzLmlkICAgICAgICAgICAgICAgPSB1bmRlZmluZWRcblxuICAgICAgICAvLyByYXRlIGxpbWl0ZXIgc2V0dGluZ3NcbiAgICAgICAgdGhpcy5lbmFibGVSYXRlTGltaXQgID0gZmFsc2VcbiAgICAgICAgdGhpcy5yYXRlTGltaXQgICAgICAgID0gMjAwMCAgLy8gbWlsbGlzZWNvbmRzID0gc2Vjb25kcyAqIDEwMDBcblxuICAgICAgICB0aGlzLnBhcnNlSnNvblJlc3BvbnNlICAgICAgICAgICAgID0gdHJ1ZSAgLy8gd2hldGhlciBhIHJlcGx5IGlzIHJlcXVpcmVkIHRvIGJlIGluIEpTT04gb3Igbm90XG4gICAgICAgIHRoaXMuc3Vic3RpdHV0ZUNvbW1vbkN1cnJlbmN5Q29kZXMgPSB0cnVlICAvLyByZXNlcnZlZFxuICAgICAgICB0aGlzLnBhcnNlQmFsYW5jZUZyb21PcGVuT3JkZXJzICAgID0gZmFsc2UgLy8gc29tZSBleGNoYW5nZXMgcmV0dXJuIGJhbGFuY2UgdXBkYXRlcyBmcm9tIG9yZGVyIEFQSSBlbmRwb2ludHNcblxuICAgICAgICB0aGlzLnRpbWVvdXQgICAgICAgICAgPSAxMDAwMCAvLyBtaWxsaXNlY29uZHNcbiAgICAgICAgdGhpcy52ZXJib3NlICAgICAgICAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5kZWJ1ZyAgICAgICAgICAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5qb3VybmFsICAgICAgICAgID0gJ2RlYnVnLmpzb24nXG4gICAgICAgIHRoaXMudXNlckFnZW50ICAgICAgICA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLnR3b2ZhICAgICAgICAgICAgPSBmYWxzZSAvLyB0d28tZmFjdG9yIGF1dGhlbnRpY2F0aW9uICgyRkEpXG4gICAgICAgIHRoaXMudGltZWZyYW1lcyAgICAgICA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLmhhc1B1YmxpY0FQSSAgICAgICAgID0gdHJ1ZVxuICAgICAgICB0aGlzLmhhc1ByaXZhdGVBUEkgICAgICAgID0gdHJ1ZVxuICAgICAgICB0aGlzLmhhc0NPUlMgICAgICAgICAgICAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNEZXBvc2l0ICAgICAgICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hCYWxhbmNlICAgICAgPSB0cnVlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hDbG9zZWRPcmRlcnMgPSBmYWxzZVxuICAgICAgICB0aGlzLmhhc0ZldGNoQ3VycmVuY2llcyAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNGZXRjaE15VHJhZGVzICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hPSExDViAgICAgICAgPSBmYWxzZVxuICAgICAgICB0aGlzLmhhc0ZldGNoT3Blbk9yZGVycyAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNGZXRjaE9yZGVyICAgICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hPcmRlckJvb2sgICAgPSB0cnVlXG4gICAgICAgIHRoaXMuaGFzRmV0Y2hPcmRlcnMgICAgICAgPSBmYWxzZVxuICAgICAgICB0aGlzLmhhc0ZldGNoVGlja2VyICAgICAgID0gdHJ1ZVxuICAgICAgICB0aGlzLmhhc0ZldGNoVGlja2VycyAgICAgID0gZmFsc2VcbiAgICAgICAgdGhpcy5oYXNGZXRjaFRyYWRlcyAgICAgICA9IHRydWVcbiAgICAgICAgdGhpcy5oYXNXaXRoZHJhdyAgICAgICAgICA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzQ3JlYXRlT3JkZXIgICAgICAgPSB0aGlzLmhhc1ByaXZhdGVBUElcbiAgICAgICAgdGhpcy5oYXNDYW5jZWxPcmRlciAgICAgICA9IHRoaXMuaGFzUHJpdmF0ZUFQSVxuXG4gICAgICAgIHRoaXMucmVxdWlyZWRDcmVkZW50aWFscyA9IHtcbiAgICAgICAgICAgICdhcGlLZXknOiAgIHRydWUsXG4gICAgICAgICAgICAnc2VjcmV0JzogICB0cnVlLFxuICAgICAgICAgICAgJ3VpZCc6ICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnbG9naW4nOiAgICBmYWxzZSxcbiAgICAgICAgICAgICdwYXNzd29yZCc6IGZhbHNlLFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iYWxhbmNlICAgID0ge31cbiAgICAgICAgdGhpcy5vcmRlcmJvb2tzID0ge31cbiAgICAgICAgdGhpcy50aWNrZXJzICAgID0ge31cbiAgICAgICAgdGhpcy5mZWVzICAgICAgID0ge31cbiAgICAgICAgdGhpcy5vcmRlcnMgICAgID0ge31cbiAgICAgICAgdGhpcy50cmFkZXMgICAgID0ge31cbiAgICAgICAgdGhpcy5jdXJyZW5jaWVzID0ge31cblxuICAgICAgICB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSA9IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLmxhc3RfanNvbl9yZXNwb25zZSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vIFRPRE86IGdlbmVyYXRlXG4gICAgICAgIHRoaXMubWFya2V0X2lkICAgICAgICAgICAgICAgICAgID0gdGhpcy5tYXJrZXRJZFxuICAgICAgICB0aGlzLm1hcmtldF9pZHMgICAgICAgICAgICAgICAgICA9IHRoaXMubWFya2V0SWRzXG4gICAgICAgIHRoaXMuaW1wbG9kZV9wYXJhbXMgICAgICAgICAgICAgID0gdGhpcy5pbXBsb2RlUGFyYW1zXG4gICAgICAgIHRoaXMuZXh0cmFjdF9wYXJhbXMgICAgICAgICAgICAgID0gdGhpcy5leHRyYWN0UGFyYW1zXG4gICAgICAgIHRoaXMuZmV0Y2hfYmFsYW5jZSAgICAgICAgICAgICAgID0gdGhpcy5mZXRjaEJhbGFuY2VcbiAgICAgICAgdGhpcy5mZXRjaF9mcmVlX2JhbGFuY2UgICAgICAgICAgPSB0aGlzLmZldGNoRnJlZUJhbGFuY2VcbiAgICAgICAgdGhpcy5mZXRjaF91c2VkX2JhbGFuY2UgICAgICAgICAgPSB0aGlzLmZldGNoVXNlZEJhbGFuY2VcbiAgICAgICAgdGhpcy5mZXRjaF90b3RhbF9iYWxhbmNlICAgICAgICAgPSB0aGlzLmZldGNoVG90YWxCYWxhbmNlXG4gICAgICAgIHRoaXMuZmV0Y2hfbDJfb3JkZXJfYm9vayAgICAgICAgID0gdGhpcy5mZXRjaEwyT3JkZXJCb29rXG4gICAgICAgIHRoaXMuZmV0Y2hfb3JkZXJfYm9vayAgICAgICAgICAgID0gdGhpcy5mZXRjaE9yZGVyQm9va1xuICAgICAgICB0aGlzLmZldGNoX3RpY2tlcnMgICAgICAgICAgICAgICA9IHRoaXMuZmV0Y2hUaWNrZXJzXG4gICAgICAgIHRoaXMuZmV0Y2hfdGlja2VyICAgICAgICAgICAgICAgID0gdGhpcy5mZXRjaFRpY2tlclxuICAgICAgICB0aGlzLmZldGNoX3RyYWRlcyAgICAgICAgICAgICAgICA9IHRoaXMuZmV0Y2hUcmFkZXNcbiAgICAgICAgdGhpcy5mZXRjaF9vcmRlciAgICAgICAgICAgICAgICAgPSB0aGlzLmZldGNoT3JkZXJcbiAgICAgICAgdGhpcy5mZXRjaF9vcmRlcnMgICAgICAgICAgICAgICAgPSB0aGlzLmZldGNoT3JkZXJzXG4gICAgICAgIHRoaXMuZmV0Y2hfb3Blbl9vcmRlcnMgICAgICAgICAgID0gdGhpcy5mZXRjaE9wZW5PcmRlcnNcbiAgICAgICAgdGhpcy5mZXRjaF9jbG9zZWRfb3JkZXJzICAgICAgICAgPSB0aGlzLmZldGNoQ2xvc2VkT3JkZXJzXG4gICAgICAgIHRoaXMuZmV0Y2hfb3JkZXJfc3RhdHVzICAgICAgICAgID0gdGhpcy5mZXRjaE9yZGVyU3RhdHVzXG4gICAgICAgIHRoaXMuZmV0Y2hfbWFya2V0cyAgICAgICAgICAgICAgID0gdGhpcy5mZXRjaE1hcmtldHNcbiAgICAgICAgdGhpcy5sb2FkX21hcmtldHMgICAgICAgICAgICAgICAgPSB0aGlzLmxvYWRNYXJrZXRzXG4gICAgICAgIHRoaXMuc2V0X21hcmtldHMgICAgICAgICAgICAgICAgID0gdGhpcy5zZXRNYXJrZXRzXG4gICAgICAgIHRoaXMucGFyc2VfYmFsYW5jZSAgICAgICAgICAgICAgID0gdGhpcy5wYXJzZUJhbGFuY2VcbiAgICAgICAgdGhpcy5wYXJzZV9iaWRfYXNrICAgICAgICAgICAgICAgPSB0aGlzLnBhcnNlQmlkQXNrXG4gICAgICAgIHRoaXMucGFyc2VfYmlkc19hc2tzICAgICAgICAgICAgID0gdGhpcy5wYXJzZUJpZHNBc2tzXG4gICAgICAgIHRoaXMucGFyc2Vfb3JkZXJfYm9vayAgICAgICAgICAgID0gdGhpcy5wYXJzZU9yZGVyQm9va1xuICAgICAgICB0aGlzLnBhcnNlX3RyYWRlcyAgICAgICAgICAgICAgICA9IHRoaXMucGFyc2VUcmFkZXNcbiAgICAgICAgdGhpcy5wYXJzZV9vcmRlcnMgICAgICAgICAgICAgICAgPSB0aGlzLnBhcnNlT3JkZXJzXG4gICAgICAgIHRoaXMucGFyc2Vfb2hsY3YgICAgICAgICAgICAgICAgID0gdGhpcy5wYXJzZU9ITENWXG4gICAgICAgIHRoaXMucGFyc2Vfb2hsY3ZzICAgICAgICAgICAgICAgID0gdGhpcy5wYXJzZU9ITENWc1xuICAgICAgICB0aGlzLmVkaXRfbGltaXRfYnV5X29yZGVyICAgICAgICA9IHRoaXMuZWRpdExpbWl0QnV5T3JkZXJcbiAgICAgICAgdGhpcy5lZGl0X2xpbWl0X3NlbGxfb3JkZXIgICAgICAgPSB0aGlzLmVkaXRMaW1pdFNlbGxPcmRlclxuICAgICAgICB0aGlzLmVkaXRfbGltaXRfb3JkZXIgICAgICAgICAgICA9IHRoaXMuZWRpdExpbWl0T3JkZXJcbiAgICAgICAgdGhpcy5lZGl0X29yZGVyICAgICAgICAgICAgICAgICAgPSB0aGlzLmVkaXRPcmRlclxuICAgICAgICB0aGlzLmNyZWF0ZV9saW1pdF9idXlfb3JkZXIgICAgICA9IHRoaXMuY3JlYXRlTGltaXRCdXlPcmRlclxuICAgICAgICB0aGlzLmNyZWF0ZV9saW1pdF9zZWxsX29yZGVyICAgICA9IHRoaXMuY3JlYXRlTGltaXRTZWxsT3JkZXJcbiAgICAgICAgdGhpcy5jcmVhdGVfbWFya2V0X2J1eV9vcmRlciAgICAgPSB0aGlzLmNyZWF0ZU1hcmtldEJ1eU9yZGVyXG4gICAgICAgIHRoaXMuY3JlYXRlX21hcmtldF9zZWxsX29yZGVyICAgID0gdGhpcy5jcmVhdGVNYXJrZXRTZWxsT3JkZXJcbiAgICAgICAgdGhpcy5jcmVhdGVfb3JkZXIgICAgICAgICAgICAgICAgPSB0aGlzLmNyZWF0ZU9yZGVyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlX2ZlZSAgICAgICAgICAgICAgID0gdGhpcy5jYWxjdWxhdGVGZWVcbiAgICAgICAgdGhpcy5jb21tb25fY3VycmVuY3lfY29kZSAgICAgICAgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZVxuICAgICAgICB0aGlzLnByaWNlX3RvX3ByZWNpc2lvbiAgICAgICAgICA9IHRoaXMucHJpY2VUb1ByZWNpc2lvblxuICAgICAgICB0aGlzLmFtb3VudF90b19wcmVjaXNpb24gICAgICAgICA9IHRoaXMuYW1vdW50VG9QcmVjaXNpb25cbiAgICAgICAgdGhpcy5mZWVfdG9fcHJlY2lzaW9uICAgICAgICAgICAgPSB0aGlzLmZlZVRvUHJlY2lzaW9uXG4gICAgICAgIHRoaXMuY29zdF90b19wcmVjaXNpb24gICAgICAgICAgID0gdGhpcy5jb3N0VG9QcmVjaXNpb25cbiAgICAgICAgdGhpcy5wcmVjaXNpb25Gcm9tU3RyaW5nICAgICAgICAgPSBwcmVjaXNpb25Gcm9tU3RyaW5nXG4gICAgICAgIHRoaXMucHJlY2lzaW9uX2Zyb21fc3RyaW5nICAgICAgID0gcHJlY2lzaW9uRnJvbVN0cmluZ1xuICAgICAgICB0aGlzLnRydW5jYXRlICAgICAgICAgICAgICAgICAgICA9IGZ1bmN0aW9ucy50cnVuY2F0ZVxuICAgICAgICB0aGlzLnV1aWQgICAgICAgICAgICAgICAgICAgICAgICA9IHV1aWRcblxuICAgICAgICAvLyBBUEkgbWV0aG9kcyBtZXRhaW5mb1xuICAgICAgICB0aGlzLmhhcyA9IHtcbiAgICAgICAgICAgICdjYW5jZWxPcmRlcic6IHRoaXMuaGFzUHJpdmF0ZUFQSSxcbiAgICAgICAgICAgICdjcmVhdGVEZXBvc2l0QWRkcmVzcyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2NyZWF0ZU9yZGVyJzogdGhpcy5oYXNQcml2YXRlQVBJLFxuICAgICAgICAgICAgJ2RlcG9zaXQnOiBmYWxzZSxcbiAgICAgICAgICAgICdmZXRjaEJhbGFuY2UnOiB0aGlzLmhhc1ByaXZhdGVBUEksXG4gICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICdmZXRjaEN1cnJlbmNpZXMnOiBmYWxzZSxcbiAgICAgICAgICAgICdmZXRjaERlcG9zaXRBZGRyZXNzJzogZmFsc2UsXG4gICAgICAgICAgICAnZmV0Y2hNYXJrZXRzJzogdHJ1ZSxcbiAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogZmFsc2UsXG4gICAgICAgICAgICAnZmV0Y2hPSExDVic6IGZhbHNlLFxuICAgICAgICAgICAgJ2ZldGNoT3Blbk9yZGVycyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2ZldGNoT3JkZXInOiBmYWxzZSxcbiAgICAgICAgICAgICdmZXRjaE9yZGVyQm9vayc6IHRydWUsXG4gICAgICAgICAgICAnZmV0Y2hPcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICdmZXRjaFRpY2tlcic6IHRydWUsXG4gICAgICAgICAgICAnZmV0Y2hUaWNrZXJzJzogZmFsc2UsXG4gICAgICAgICAgICAnZmV0Y2hUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgJ3dpdGhkcmF3JzogZmFsc2UsXG4gICAgICAgIH1cblxuICAgICAgICAvLyBtZXJnZSBjb25maWdzXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGRlZXBFeHRlbmQgKHRoaXMuZGVzY3JpYmUgKCksIHVzZXJDb25maWcpXG5cbiAgICAgICAgLy8gbWVyZ2UgdG8gdGhpc1xuICAgICAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzIChjb25maWcpKVxuICAgICAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWVwRXh0ZW5kICh0aGlzW3Byb3BlcnR5XSwgdmFsdWUpXG5cbiAgICAgICAgaWYgKHRoaXMuYXBpKVxuICAgICAgICAgICAgdGhpcy5kZWZpbmVSZXN0QXBpICh0aGlzLmFwaSwgJ3JlcXVlc3QnKVxuXG4gICAgICAgIHRoaXMuaW5pdFJlc3RSYXRlTGltaXRlciAoKVxuXG4gICAgICAgIGlmICh0aGlzLm1hcmtldHMpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtldHMgKHRoaXMubWFya2V0cylcblxuICAgICAgICBpZiAodGhpcy5kZWJ1ZyAmJiBqb3VybmFsKSB7XG4gICAgICAgICAgICBqb3VybmFsICgoKSA9PiB0aGlzLmpvdXJuYWwsIHRoaXMsIE9iamVjdC5rZXlzICh0aGlzLmhhcykpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZhdWx0cyAoKSB7XG4gICAgICAgIHJldHVybiB7IC8qIG92ZXJyaWRlIG1lICovIH1cbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMgKClcbiAgICB9XG5cbiAgICBlbmNvZGVVUklDb21wb25lbnQgKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCAoLi4uYXJncylcbiAgICB9XG5cbiAgICBjaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCkge1xuICAgICAgICBPYmplY3Qua2V5cyAodGhpcy5yZXF1aXJlZENyZWRlbnRpYWxzKS5tYXAgKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXF1aXJlZENyZWRlbnRpYWxzW2tleV0gJiYgIXRoaXNba2V5XSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgYCcgKyBrZXkgKyAnYCcpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgaW5pdFJlc3RSYXRlTGltaXRlciAoKSB7XG5cbiAgICAgICAgdGhpcy50b2tlbkJ1Y2tldCA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICByZWZpbGxSYXRlOiAgMSAvIHRoaXMucmF0ZUxpbWl0LFxuICAgICAgICAgICAgZGVsYXk6ICAgICAgIDEsXG4gICAgICAgICAgICBjYXBhY2l0eTogICAgMSxcbiAgICAgICAgICAgIGRlZmF1bHRDb3N0OiAxLFxuICAgICAgICAgICAgbWF4Q2FwYWNpdHk6IDEwMDAsXG4gICAgICAgIH0sIHRoaXMudG9rZW5CdWNrZXQpXG5cbiAgICAgICAgdGhpcy50aHJvdHRsZSA9IHRocm90dGxlICh0aGlzLnRva2VuQnVja2V0KVxuXG4gICAgICAgIHRoaXMuZXhlY3V0ZVJlc3RSZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCwgbWV0aG9kID0gJ0dFVCcsIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgbGV0IHByb21pc2UgPVxuICAgICAgICAgICAgICAgIGZldGNoICh1cmwsIHsgJ21ldGhvZCc6IG1ldGhvZCwgJ2hlYWRlcnMnOiBoZWFkZXJzLCAnYm9keSc6IGJvZHksICdhZ2VudCc6IHRoaXMudHVubmVsQWdlbnQgfHwgbnVsbCwgdGltZW91dDogdGhpcy50aW1lb3V0fSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoIChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlTm90QXZhaWxhYmxlIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBlLnR5cGUsIGUubWVzc2FnZSBdLmpvaW4gKCcgJykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlIC8vIHJldGhyb3cgYWxsIHVua25vd24gZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuIChyZXNwb25zZSA9PiB0aGlzLmhhbmRsZVJlc3RFcnJvcnMgKHJlc3BvbnNlLCB1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSkpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuIChyZXNwb25zZSA9PiB0aGlzLmhhbmRsZVJlc3RSZXNwb25zZSAocmVzcG9uc2UsIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSlcblxuICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXQgKHRoaXMudGltZW91dCwgcHJvbWlzZSkuY2F0Y2ggKGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVxdWVzdFRpbWVvdXQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXF1ZXN0VGltZW91dCAodGhpcy5pZCArICcgJyArIG1ldGhvZCArICcgJyArIHVybCArICcgJyArIGUubWVzc2FnZSArICcgKCcgKyB0aGlzLnRpbWVvdXQgKyAnIG1zKScpXG4gICAgICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZmluZVJlc3RBcGkgKGFwaSwgbWV0aG9kTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIE9iamVjdC5rZXlzIChhcGkpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGh0dHBNZXRob2Qgb2YgT2JqZWN0LmtleXMgKGFwaVt0eXBlXSkpIHtcblxuICAgICAgICAgICAgICAgIGxldCB1cmxzID0gYXBpW3R5cGVdW2h0dHBNZXRob2RdXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSB1cmxzW2ldLnRyaW0gKClcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0UGF0aCA9IHVybC5zcGxpdCAoL1teYS16QS1aMC05XS8pXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwcGVyY2FzZU1ldGhvZCAgPSBodHRwTWV0aG9kLnRvVXBwZXJDYXNlICgpXG4gICAgICAgICAgICAgICAgICAgIGxldCBsb3dlcmNhc2VNZXRob2QgID0gaHR0cE1ldGhvZC50b0xvd2VyQ2FzZSAoKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY2FtZWxjYXNlTWV0aG9kICA9IHRoaXMuY2FwaXRhbGl6ZSAobG93ZXJjYXNlTWV0aG9kKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY2FtZWxjYXNlU3VmZml4ICA9IHNwbGl0UGF0aC5tYXAgKHRoaXMuY2FwaXRhbGl6ZSkuam9pbiAoJycpXG4gICAgICAgICAgICAgICAgICAgIGxldCB1bmRlcnNjb3JlU3VmZml4ID0gc3BsaXRQYXRoLm1hcCAoeCA9PiB4LnRyaW0gKCkudG9Mb3dlckNhc2UgKCkpLmZpbHRlciAoeCA9PiB4Lmxlbmd0aCA+IDApLmpvaW4gKCdfJylcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FtZWxjYXNlU3VmZml4LmluZGV4T2YgKGNhbWVsY2FzZU1ldGhvZCkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW1lbGNhc2VTdWZmaXggPSBjYW1lbGNhc2VTdWZmaXguc2xpY2UgKGNhbWVsY2FzZU1ldGhvZC5sZW5ndGgpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuZGVyc2NvcmVTdWZmaXguaW5kZXhPZiAobG93ZXJjYXNlTWV0aG9kKSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVyc2NvcmVTdWZmaXggPSB1bmRlcnNjb3JlU3VmZml4LnNsaWNlIChsb3dlcmNhc2VNZXRob2QubGVuZ3RoKVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjYW1lbGNhc2UgID0gdHlwZSArIGNhbWVsY2FzZU1ldGhvZCArIHRoaXMuY2FwaXRhbGl6ZSAoY2FtZWxjYXNlU3VmZml4KVxuICAgICAgICAgICAgICAgICAgICBsZXQgdW5kZXJzY29yZSA9IHR5cGUgKyAnXycgKyBsb3dlcmNhc2VNZXRob2QgKyAnXycgKyB1bmRlcnNjb3JlU3VmZml4XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdzdWZmaXhlcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdjYW1lbGNhc2UnIGluIG9wdGlvbnNbJ3N1ZmZpeGVzJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FtZWxjYXNlICs9IG9wdGlvbnNbJ3N1ZmZpeGVzJ11bJ2NhbWVsY2FzZSddXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ3VuZGVyc2NvcmUnIGluIG9wdGlvbnMuc3VmZml4ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJzY29yZSArPSBvcHRpb25zWydzdWZmaXhlcyddWyd1bmRlcnNjb3JlJ11cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgndW5kZXJzY29yZV9zdWZmaXgnIGluIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlcnNjb3JlICs9IG9wdGlvbnMudW5kZXJzY29yZVN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdjYW1lbGNhc2Vfc3VmZml4JyBpbiBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FtZWxjYXNlICs9IG9wdGlvbnMuY2FtZWxjYXNlU3VmZml4O1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0aWFsID0gYXN5bmMgcGFyYW1zID0+IHRoaXNbbWV0aG9kTmFtZV0gKHVybCwgdHlwZSwgdXBwZXJjYXNlTWV0aG9kLCBwYXJhbXMgfHwge30pXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpc1tjYW1lbGNhc2VdICA9IHBhcnRpYWxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1t1bmRlcnNjb3JlXSA9IHBhcnRpYWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmZXRjaCAodXJsLCBtZXRob2QgPSAnR0VUJywgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIGlmIChpc05vZGUgJiYgdGhpcy51c2VyQWdlbnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy51c2VyQWdlbnQgPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IGV4dGVuZCAoeyAnVXNlci1BZ2VudCc6IHRoaXMudXNlckFnZW50IH0sIGhlYWRlcnMpXG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZW9mIHRoaXMudXNlckFnZW50ID09ICdvYmplY3QnKSAmJiAoJ1VzZXItQWdlbnQnIGluIHRoaXMudXNlckFnZW50KSlcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gZXh0ZW5kICh0aGlzLnVzZXJBZ2VudCwgaGVhZGVycylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm94eSA9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgIHVybCA9IHRoaXMucHJveHkgKHVybClcbiAgICAgICAgICAgIGhlYWRlcnMgPSBleHRlbmQgKHsgJ09yaWdpbic6ICcqJyB9LCBoZWFkZXJzKVxuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMucHJveHkgPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJveHkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBleHRlbmQgKHsgJ09yaWdpbic6ICcqJyB9LCBoZWFkZXJzKVxuXG4gICAgICAgICAgICB1cmwgPSB0aGlzLnByb3h5ICsgdXJsXG4gICAgICAgIH1cblxuICAgICAgICBoZWFkZXJzID0gZXh0ZW5kICh0aGlzLmhlYWRlcnMsIGhlYWRlcnMpXG5cbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nICh0aGlzLmlkLCBtZXRob2QsIHVybCwgXCJcXG5SZXF1ZXN0OlxcblwiLCBoZWFkZXJzLCBib2R5KVxuXG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVSZXN0UmVxdWVzdCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpXG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2gyIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUmF0ZUxpbWl0KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy50aHJvdHRsZSAoKVxuXG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5zaWduIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCAocmVxdWVzdC51cmwsIHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmhlYWRlcnMsIHJlcXVlc3QuYm9keSlcbiAgICB9XG5cbiAgICByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSlcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKHN0YXR1c0NvZGUsIHN0YXR1c1RleHQsIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIC8vIG92ZXJyaWRlIG1lXG4gICAgfVxuXG4gICAgZGVmYXVsdEVycm9ySGFuZGxlciAoY29kZSwgcmVhc29uLCB1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSkge1xuICAgICAgICBpZiAodGhpcy52ZXJib3NlKVxuICAgICAgICAgICAgY29uc29sZS5sb2cgKHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBjb2RlLCByZWFzb24sIGJvZHkgPyAoXCJcXG5SZXNwb25zZTpcXG5cIiArIGJvZHkpIDogJycpXG4gICAgICAgIGlmICgoY29kZSA+PSAyMDApICYmIChjb2RlIDw9IDMwMCkpXG4gICAgICAgICAgICByZXR1cm4gYm9keVxuICAgICAgICBsZXQgZXJyb3IgPSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UgPSBib2R5XG4gICAgICAgIGxldCBkZXRhaWxzID0gYm9keVxuICAgICAgICBsZXQgbWF0Y2ggPSBib2R5Lm1hdGNoICgnXFw8dGl0bGVcXD4oW148XSspJylcbiAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgZGV0YWlscyA9IG1hdGNoWzFdLnRyaW0gKCk7XG4gICAgICAgIGlmIChbIDQyOSBdLmluY2x1ZGVzIChjb2RlKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBERG9TUHJvdGVjdGlvblxuICAgICAgICB9IGVsc2UgaWYgKFsgNDA0LCA0MDksIDQyMiwgNTAwLCA1MDEsIDUwMiwgNTIwLCA1MjEsIDUyMiwgNTI1IF0uaW5jbHVkZXMgKGNvZGUpKSB7XG4gICAgICAgICAgICBlcnJvciA9IEV4Y2hhbmdlTm90QXZhaWxhYmxlXG4gICAgICAgIH0gZWxzZSBpZiAoWyA0MDAsIDQwMywgNDA1LCA1MDMsIDUzMCBdLmluY2x1ZGVzIChjb2RlKSkge1xuICAgICAgICAgICAgbGV0IGRkb3NQcm90ZWN0aW9uID0gYm9keS5tYXRjaCAoL2Nsb3VkZmxhcmV8aW5jYXBzdWxhL2kpXG4gICAgICAgICAgICBpZiAoZGRvc1Byb3RlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IEREb1NQcm90ZWN0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gRXhjaGFuZ2VOb3RBdmFpbGFibGVcbiAgICAgICAgICAgICAgICBkZXRhaWxzICs9ICcgKHBvc3NpYmxlIHJlYXNvbnM6ICcgKyBbXG4gICAgICAgICAgICAgICAgICAgICdpbnZhbGlkIEFQSSBrZXlzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JhZCBvciBvbGQgbm9uY2UnLFxuICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UgaXMgZG93biBvciBvZmZsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgJ29uIG1haW50ZW5hbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgJ0REb1MgcHJvdGVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdyYXRlLWxpbWl0aW5nJyxcbiAgICAgICAgICAgICAgICBdLmpvaW4gKCcsICcpICsgJyknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoWyA0MDgsIDUwNCBdLmluY2x1ZGVzIChjb2RlKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBSZXF1ZXN0VGltZW91dFxuICAgICAgICB9IGVsc2UgaWYgKFsgNDAxLCA1MTEgXS5pbmNsdWRlcyAoY29kZSkpIHtcbiAgICAgICAgICAgIGVycm9yID0gQXV0aGVudGljYXRpb25FcnJvclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSBFeGNoYW5nZUVycm9yXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBjb2RlLCByZWFzb24sIGRldGFpbHMgXS5qb2luICgnICcpKVxuICAgIH1cblxuICAgIGhhbmRsZVJlc3RFcnJvcnMgKHJlc3BvbnNlLCB1cmwsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0ICgpLnRoZW4gKHRleHQgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBhcmdzID0gWyByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQsIHVybCwgbWV0aG9kLCBoZWFkZXJzLCB0ZXh0IF1cblxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcnMgKC4uLmFyZ3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXJyb3JIYW5kbGVyICguLi5hcmdzKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGhhbmRsZVJlc3RSZXNwb25zZSAocmVzcG9uc2UsIHVybCwgbWV0aG9kID0gJ0dFVCcsIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSA9IHJlc3BvbnNlXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUpzb25SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdF9qc29uX3Jlc3BvbnNlID1cbiAgICAgICAgICAgICAgICAgICAgKCh0eXBlb2YgcmVzcG9uc2UgPT0gJ3N0cmluZycpICYmIChyZXNwb25zZS5sZW5ndGggPiAxKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZSAocmVzcG9uc2UpIDogcmVzcG9uc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0X2pzb25fcmVzcG9uc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICBsZXQgbWFpbnRlbmFuY2UgPSByZXNwb25zZS5tYXRjaCAoL29mZmxpbmV8YnVzeXxyZXRyeXx3YWl0fHVuYXZhaWxhYmxlfG1haW50YWlufG1haW50ZW5hbmNlfG1haW50ZW5hbmNpbmcvaSlcbiAgICAgICAgICAgIGxldCBkZG9zUHJvdGVjdGlvbiA9IHJlc3BvbnNlLm1hdGNoICgvY2xvdWRmbGFyZXxpbmNhcHN1bGF8b3ZlcmxvYWQvaSlcblxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuXG4gICAgICAgICAgICAgICAgbGV0IGVycm9yID0gRXhjaGFuZ2VOb3RBdmFpbGFibGVcbiAgICAgICAgICAgICAgICBsZXQgZGV0YWlscyA9ICdub3QgYWNjZXNzaWJsZSBmcm9tIHRoaXMgbG9jYXRpb24gYXQgdGhlIG1vbWVudCdcbiAgICAgICAgICAgICAgICBpZiAobWFpbnRlbmFuY2UpXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnb2ZmbGluZSwgb24gbWFpbnRlbmFuY2Ugb3IgdW5yZWFjaGFibGUgZnJvbSB0aGlzIGxvY2F0aW9uIGF0IHRoZSBtb21lbnQnXG4gICAgICAgICAgICAgICAgaWYgKGRkb3NQcm90ZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEREb1NQcm90ZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBkZXRhaWxzIF0uam9pbiAoJyAnKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyAodGhpcy5pZCwgbWV0aG9kLCB1cmwsICdlcnJvcicsIGUsIFwicmVzcG9uc2UgYm9keTpcXG4nXCIgKyByZXNwb25zZSArIFwiJ1wiKVxuXG4gICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRNYXJrZXRzIChtYXJrZXRzLCBjdXJyZW5jaWVzID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzIChtYXJrZXRzKS5tYXAgKG1hcmtldCA9PiBkZWVwRXh0ZW5kICh7XG4gICAgICAgICAgICAnbGltaXRzJzogdGhpcy5saW1pdHMsXG4gICAgICAgICAgICAncHJlY2lzaW9uJzogdGhpcy5wcmVjaXNpb24sXG4gICAgICAgIH0sIHRoaXMuZmVlc1sndHJhZGluZyddLCBtYXJrZXQpKVxuICAgICAgICB0aGlzLm1hcmtldHMgPSBkZWVwRXh0ZW5kICh0aGlzLm1hcmtldHMsIGluZGV4QnkgKHZhbHVlcywgJ3N5bWJvbCcpKVxuICAgICAgICB0aGlzLm1hcmtldHNCeUlkID0gaW5kZXhCeSAobWFya2V0cywgJ2lkJylcbiAgICAgICAgdGhpcy5tYXJrZXRzX2J5X2lkID0gdGhpcy5tYXJrZXRzQnlJZFxuICAgICAgICB0aGlzLnN5bWJvbHMgPSBPYmplY3Qua2V5cyAodGhpcy5tYXJrZXRzKS5zb3J0ICgpXG4gICAgICAgIHRoaXMuaWRzID0gT2JqZWN0LmtleXMgKHRoaXMubWFya2V0c19ieV9pZCkuc29ydCAoKVxuICAgICAgICBpZiAoY3VycmVuY2llcykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW5jaWVzID0gZGVlcEV4dGVuZCAoY3VycmVuY2llcywgdGhpcy5jdXJyZW5jaWVzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmFzZUN1cnJlbmNpZXMgPVxuICAgICAgICAgICAgICAgIHZhbHVlcy5maWx0ZXIgKG1hcmtldCA9PiAnYmFzZScgaW4gbWFya2V0KVxuICAgICAgICAgICAgICAgICAgICAubWFwIChtYXJrZXQgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtYXJrZXQuYmFzZUlkIHx8IG1hcmtldC5iYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogbWFya2V0LmJhc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgY29uc3QgcXVvdGVDdXJyZW5jaWVzID1cbiAgICAgICAgICAgICAgICB2YWx1ZXMuZmlsdGVyIChtYXJrZXQgPT4gJ3F1b3RlJyBpbiBtYXJrZXQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAgKG1hcmtldCA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1hcmtldC5xdW90ZUlkIHx8IG1hcmtldC5xdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IG1hcmtldC5xdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICBjb25zdCBjdXJyZW5jaWVzID0gc29ydEJ5IChiYXNlQ3VycmVuY2llcy5jb25jYXQgKHF1b3RlQ3VycmVuY2llcyksICdjb2RlJylcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY2llcyA9IGRlZXBFeHRlbmQgKGluZGV4QnkgKGN1cnJlbmNpZXMsICdjb2RlJyksIHRoaXMuY3VycmVuY2llcylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXRzXG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZE1hcmtldHMgKHJlbG9hZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghcmVsb2FkICYmIHRoaXMubWFya2V0cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmtldHNCeUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWFya2V0cyAodGhpcy5tYXJrZXRzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFya2V0c1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtldHMgPSBhd2FpdCB0aGlzLmZldGNoTWFya2V0cyAoKVxuICAgICAgICBsZXQgY3VycmVuY2llcyA9IHVuZGVmaW5lZFxuICAgICAgICBpZiAodGhpcy5oYXMuZmV0Y2hDdXJyZW5jaWVzKSB7XG4gICAgICAgICAgICBjdXJyZW5jaWVzID0gYXdhaXQgdGhpcy5mZXRjaEN1cnJlbmNpZXMgKClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXRNYXJrZXRzIChtYXJrZXRzLCBjdXJyZW5jaWVzKVxuICAgIH1cblxuICAgIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hUaWNrZXJzIG5vdCBzdXBwb3J0ZWQgeWV0JylcbiAgICB9XG5cbiAgICBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9yZGVyIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gICAgfVxuXG4gICAgZmV0Y2hPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9yZGVycyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoT3Blbk9yZGVycyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hDbG9zZWRPcmRlcnMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hNeVRyYWRlcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIGZldGNoQ3VycmVuY2llcyAoKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoQ3VycmVuY2llcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSAoKHJlc29sdmUsIHJlamVjdCkgPT4gcmVzb2x2ZSAodGhpcy5tYXJrZXRzKSlcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyU3RhdHVzIChpZCwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBvcmRlciA9IGF3YWl0IHRoaXMuZmV0Y2hPcmRlciAoaWQpXG4gICAgICAgIHJldHVybiBvcmRlclsnc3RhdHVzJ11cbiAgICB9XG5cbiAgICBhY2NvdW50ICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdmcmVlJzogMC4wLFxuICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJzdGl0dXRlQ29tbW9uQ3VycmVuY3lDb2RlcylcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW5jeVxuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1hCVCcpXG4gICAgICAgICAgICByZXR1cm4gJ0JUQydcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ0MnKVxuICAgICAgICAgICAgcmV0dXJuICdCQ0gnXG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRFJLJylcbiAgICAgICAgICAgIHJldHVybiAnREFTSCdcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5XG4gICAgfVxuXG4gICAgY3VycmVuY3kgKGNvZGUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY3VycmVuY2llcyA9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY3VycmVuY2llcyBub3QgbG9hZGVkJylcblxuICAgICAgICBpZiAoKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykgJiYgKGNvZGUgaW4gdGhpcy5jdXJyZW5jaWVzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbmNpZXNbY29kZV1cblxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZG9lcyBub3QgaGF2ZSBjdXJyZW5jeSBjb2RlICcgKyBjb2RlKVxuICAgIH1cblxuXG4gICAgbWFya2V0IChzeW1ib2wpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFya2V0cyA9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgbWFya2V0cyBub3QgbG9hZGVkJylcblxuICAgICAgICBpZiAoKHR5cGVvZiBzeW1ib2wgPT09ICdzdHJpbmcnKSAmJiAoc3ltYm9sIGluIHRoaXMubWFya2V0cykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXRzW3N5bWJvbF1cblxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZG9lcyBub3QgaGF2ZSBtYXJrZXQgc3ltYm9sICcgKyBzeW1ib2wpXG4gICAgfVxuXG4gICAgbWFya2V0SWQgKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrZXQgKHN5bWJvbCkuaWQgfHwgc3ltYm9sXG4gICAgfVxuXG4gICAgbWFya2V0SWRzIChzeW1ib2xzKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xzLm1hcCAoc3ltYm9sID0+IHRoaXMubWFya2V0SWQoc3ltYm9sKSk7XG4gICAgfVxuXG4gICAgc3ltYm9sIChzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2V0IChzeW1ib2wpLnN5bWJvbCB8fCBzeW1ib2xcbiAgICB9XG5cbiAgICBleHRyYWN0UGFyYW1zIChzdHJpbmcpIHtcbiAgICAgICAgbGV0IHJlID0gL3soW2EtekEtWjAtOV9dKz8pfS9nXG4gICAgICAgIGxldCBtYXRjaGVzID0gW11cbiAgICAgICAgbGV0IG1hdGNoXG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHJlLmV4ZWMgKHN0cmluZykpXG4gICAgICAgICAgICBtYXRjaGVzLnB1c2ggKG1hdGNoWzFdKVxuICAgICAgICByZXR1cm4gbWF0Y2hlc1xuICAgIH1cblxuICAgIGltcGxvZGVQYXJhbXMgKHN0cmluZywgcGFyYW1zKSB7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5IGluIHBhcmFtcylcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlICgneycgKyBwcm9wZXJ0eSArICd9JywgcGFyYW1zW3Byb3BlcnR5XSlcbiAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgIH1cblxuICAgIHVybCAocGF0aCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBwYXJzZUJpZEFzayAoYmlkYXNrLCBwcmljZUtleSA9IDAsIGFtb3VudEtleSA9IDEpIHtcbiAgICAgICAgbGV0IHByaWNlID0gcGFyc2VGbG9hdCAoYmlkYXNrW3ByaWNlS2V5XSlcbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKGJpZGFza1thbW91bnRLZXldKVxuICAgICAgICByZXR1cm4gWyBwcmljZSwgYW1vdW50IF1cbiAgICB9XG5cbiAgICBwYXJzZUJpZHNBc2tzIChiaWRhc2tzLCBwcmljZUtleSA9IDAsIGFtb3VudEtleSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMgKGJpZGFza3MgfHwgW10pLm1hcCAoYmlkYXNrID0+IHRoaXMucGFyc2VCaWRBc2sgKGJpZGFzaywgcHJpY2VLZXksIGFtb3VudEtleSkpXG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hMMk9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5mZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMpXG4gICAgICAgIHJldHVybiBleHRlbmQgKG9yZGVyYm9vaywge1xuICAgICAgICAgICAgJ2JpZHMnOiBzb3J0QnkgKGFnZ3JlZ2F0ZSAob3JkZXJib29rLmJpZHMpLCAwLCB0cnVlKSxcbiAgICAgICAgICAgICdhc2tzJzogc29ydEJ5IChhZ2dyZWdhdGUgKG9yZGVyYm9vay5hc2tzKSwgMCksXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wID0gdW5kZWZpbmVkLCBiaWRzS2V5ID0gJ2JpZHMnLCBhc2tzS2V5ID0gJ2Fza3MnLCBwcmljZUtleSA9IDAsIGFtb3VudEtleSA9IDEpIHtcbiAgICAgICAgdGltZXN0YW1wID0gdGltZXN0YW1wIHx8IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2JpZHMnOiAoYmlkc0tleSBpbiBvcmRlcmJvb2spID8gdGhpcy5wYXJzZUJpZHNBc2tzIChvcmRlcmJvb2tbYmlkc0tleV0sIHByaWNlS2V5LCBhbW91bnRLZXkpIDogW10sXG4gICAgICAgICAgICAnYXNrcyc6IChhc2tzS2V5IGluIG9yZGVyYm9vaykgPyB0aGlzLnBhcnNlQmlkc0Fza3MgKG9yZGVyYm9va1thc2tzS2V5XSwgcHJpY2VLZXksIGFtb3VudEtleSkgOiBbXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVuY3lVc2VkT25PcGVuT3JkZXJzIChjdXJyZW5jeSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyAodGhpcy5vcmRlcnMpLmZpbHRlciAob3JkZXIgPT4gKG9yZGVyWydzdGF0dXMnXSA9PSAnb3BlbicpKS5yZWR1Y2UgKCh0b3RhbCwgb3JkZXIpID0+IHtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBvcmRlclsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gb3JkZXJbJ3JlbWFpbmluZyddXG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gbWFya2V0WydiYXNlJ10gJiYgb3JkZXJbJ3NpZGUnXSA9PSAnc2VsbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG90YWwgKyBhbW91bnRcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgPT0gbWFya2V0WydxdW90ZSddICYmIG9yZGVyWydzaWRlJ10gPT0gJ2J1eScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG90YWwgKyAob3JkZXJbJ2Nvc3QnXSB8fCAob3JkZXJbJ3ByaWNlJ10gKiBhbW91bnQpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG90YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMClcbiAgICB9XG5cbiAgICBwYXJzZUJhbGFuY2UgKGJhbGFuY2UpIHtcblxuICAgICAgICBjb25zdCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMub21pdCAoYmFsYW5jZSwgJ2luZm8nKSk7XG5cbiAgICAgICAgY3VycmVuY2llcy5mb3JFYWNoIChjdXJyZW5jeSA9PiB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmFsYW5jZVtjdXJyZW5jeV0udXNlZCA9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VCYWxhbmNlRnJvbU9wZW5PcmRlcnMgJiYgKCdvcGVuX29yZGVycycgaW4gYmFsYW5jZVsnaW5mbyddKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNoYW5nZU9yZGVyc0NvdW50ID0gYmFsYW5jZVsnaW5mbyddWydvcGVuX29yZGVycyddO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRPcmRlcnNDb3VudCA9IE9iamVjdC52YWx1ZXMgKHRoaXMub3JkZXJzKS5maWx0ZXIgKG9yZGVyID0+IChvcmRlclsnc3RhdHVzJ10gPT0gJ29wZW4nKSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT3JkZXJzQ291bnQgPT0gZXhjaGFuZ2VPcmRlcnNDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVtjdXJyZW5jeV0udXNlZCA9IHRoaXMuZ2V0Q3VycmVuY3lVc2VkT25PcGVuT3JkZXJzIChjdXJyZW5jeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbY3VycmVuY3ldLnRvdGFsID0gYmFsYW5jZVtjdXJyZW5jeV0udXNlZCArIGJhbGFuY2VbY3VycmVuY3ldLmZyZWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbY3VycmVuY3ldLnVzZWQgPSB0aGlzLmdldEN1cnJlbmN5VXNlZE9uT3Blbk9yZGVycyAoY3VycmVuY3kpXG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbY3VycmVuY3ldLnRvdGFsID0gYmFsYW5jZVtjdXJyZW5jeV0udXNlZCArIGJhbGFuY2VbY3VycmVuY3ldLmZyZWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFsgJ2ZyZWUnLCAndXNlZCcsICd0b3RhbCcgXS5mb3JFYWNoIChhY2NvdW50ID0+IHtcbiAgICAgICAgICAgICAgICBiYWxhbmNlW2FjY291bnRdID0gYmFsYW5jZVthY2NvdW50XSB8fCB7fVxuICAgICAgICAgICAgICAgIGJhbGFuY2VbYWNjb3VudF1bY3VycmVuY3ldID0gYmFsYW5jZVtjdXJyZW5jeV1bYWNjb3VudF1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBiYWxhbmNlO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoUGFydGlhbEJhbGFuY2UgKHBhcnQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgdGhpcy5mZXRjaEJhbGFuY2UgKHBhcmFtcylcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VbcGFydF1cbiAgICB9XG5cbiAgICBmZXRjaEZyZWVCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFBhcnRpYWxCYWxhbmNlICgnZnJlZScsIHBhcmFtcylcbiAgICB9XG5cbiAgICBmZXRjaFVzZWRCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFBhcnRpYWxCYWxhbmNlICgndXNlZCcsIHBhcmFtcylcbiAgICB9XG5cbiAgICBmZXRjaFRvdGFsQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hQYXJ0aWFsQmFsYW5jZSAoJ3RvdGFsJywgcGFyYW1zKVxuICAgIH1cblxuICAgIGZpbHRlckJ5U2luY2VMaW1pdCAoYXJyYXksIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICBhcnJheSA9IGFycmF5LmZpbHRlciAoZW50cnkgPT4gZW50cnkudGltZXN0YW1wID4gc2luY2UpXG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIGFycmF5ID0gYXJyYXkuc2xpY2UgKDAsIGxpbWl0KVxuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlcyAodHJhZGVzLCBtYXJrZXQgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LnZhbHVlcyAodHJhZGVzKS5tYXAgKHRyYWRlID0+IHRoaXMucGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkpXG4gICAgICAgIHJlc3VsdCA9IHNvcnRCeSAocmVzdWx0LCAndGltZXN0YW1wJywgdHJ1ZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQnlTaW5jZUxpbWl0IChyZXN1bHQsIHNpbmNlLCBsaW1pdClcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVycyAob3JkZXJzLCBtYXJrZXQgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LnZhbHVlcyAob3JkZXJzKS5tYXAgKG9yZGVyID0+IHRoaXMucGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCkpXG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5U2luY2VMaW1pdCAocmVzdWx0LCBzaW5jZSwgbGltaXQpXG4gICAgfVxuXG4gICAgZmlsdGVyT3JkZXJzQnlTeW1ib2wgKG9yZGVycywgc3ltYm9sID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBncm91cGVkID0gdGhpcy5ncm91cEJ5IChvcmRlcnMsICdzeW1ib2wnKVxuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sIGluIGdyb3VwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwZWRbc3ltYm9sXVxuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yZGVyc1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb2hsY3ZcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWcyAob2hsY3ZzLCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBvaGxjdnMgPSBPYmplY3QudmFsdWVzIChvaGxjdnMpXG4gICAgICAgIGxldCByZXN1bHQgPSBbXVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9obGN2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbWl0ICYmIChyZXN1bHQubGVuZ3RoID49IGxpbWl0KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvaGxjdiA9IHRoaXMucGFyc2VPSExDViAob2hsY3ZzW2ldLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KVxuICAgICAgICAgICAgaWYgKHNpbmNlICYmIChvaGxjdlswXSA8IHNpbmNlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9obGN2KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBlZGl0TGltaXRCdXlPcmRlciAoaWQsIHN5bWJvbCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0TGltaXRPcmRlciAoaWQsIHN5bWJvbCwgJ2J1eScsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgZWRpdExpbWl0U2VsbE9yZGVyIChpZCwgc3ltYm9sLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRMaW1pdE9yZGVyIChpZCwgc3ltYm9sLCAnc2VsbCcsIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgZWRpdExpbWl0T3JkZXIgKGlkLCBzeW1ib2wsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdE9yZGVyIChpZCwgc3ltYm9sLCAnbGltaXQnLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIGFzeW5jIGVkaXRPcmRlciAoaWQsIHN5bWJvbCwgLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlUmF0ZUxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGVkaXRPcmRlcigpIHJlcXVpcmVzIGVuYWJsZVJhdGVMaW1pdCA9IHRydWUnKVxuICAgICAgICBhd2FpdCB0aGlzLmNhbmNlbE9yZGVyIChpZCwgc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgKHN5bWJvbCwgLi4uYXJncylcbiAgICB9XG5cbiAgICBjcmVhdGVMaW1pdEJ1eU9yZGVyIChzeW1ib2wsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgIChzeW1ib2wsICdsaW1pdCcsICdidXknLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIGNyZWF0ZUxpbWl0U2VsbE9yZGVyIChzeW1ib2wsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgKHN5bWJvbCwgJ2xpbWl0JywgJ3NlbGwnLCAuLi5hcmdzKVxuICAgIH1cblxuICAgIGNyZWF0ZU1hcmtldEJ1eU9yZGVyIChzeW1ib2wsIGFtb3VudCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgKHN5bWJvbCwgJ21hcmtldCcsICdidXknLCBhbW91bnQsIHVuZGVmaW5lZCwgcGFyYW1zKVxuICAgIH1cblxuICAgIGNyZWF0ZU1hcmtldFNlbGxPcmRlciAoc3ltYm9sLCBhbW91bnQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9yZGVyIChzeW1ib2wsICdtYXJrZXQnLCAnc2VsbCcsIGFtb3VudCwgdW5kZWZpbmVkLCBwYXJhbXMpXG4gICAgfVxuXG4gICAgY29zdFRvUHJlY2lzaW9uIChzeW1ib2wsIGNvc3QpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQgKGNvc3QpLnRvRml4ZWQgKHRoaXMubWFya2V0c1tzeW1ib2xdLnByZWNpc2lvbi5wcmljZSlcbiAgICB9XG5cbiAgICBwcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0IChwcmljZSkudG9GaXhlZCAodGhpcy5tYXJrZXRzW3N5bWJvbF0ucHJlY2lzaW9uLnByaWNlKVxuICAgIH1cblxuICAgIGFtb3VudFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cnVuY2F0ZShhbW91bnQsIHRoaXMubWFya2V0c1tzeW1ib2xdLnByZWNpc2lvbi5hbW91bnQpXG4gICAgfVxuXG4gICAgYW1vdW50VG9Mb3RzIChzeW1ib2wsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBNYXRoLmZsb29yIChhbW91bnQgLyB0aGlzLm1hcmtldHNbc3ltYm9sXS5sb3QpICogdGhpcy5tYXJrZXRzW3N5bWJvbF0ubG90KVxuICAgIH1cblxuICAgIGZlZVRvUHJlY2lzaW9uIChzeW1ib2wsIGZlZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCAoZmVlKS50b0ZpeGVkICh0aGlzLm1hcmtldHNbc3ltYm9sXS5wcmVjaXNpb24ucHJpY2UpXG4gICAgfVxuXG4gICAgY2FsY3VsYXRlRmVlIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UsIHRha2VyT3JNYWtlciA9ICd0YWtlcicsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXVxuICAgICAgICBsZXQgcmF0ZSA9IG1hcmtldFt0YWtlck9yTWFrZXJdXG4gICAgICAgIGxldCBjb3N0ID0gcGFyc2VGbG9hdCAodGhpcy5jb3N0VG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50ICogcHJpY2UpKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiB0YWtlck9yTWFrZXIsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAncmF0ZSc6IHJhdGUsXG4gICAgICAgICAgICAnY29zdCc6IHBhcnNlRmxvYXQgKHRoaXMuZmVlVG9QcmVjaXNpb24gKHN5bWJvbCwgcmF0ZSAqIGNvc3QpKSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFltZCAodGltZXN0YW1wLCBpbmZpeCA9ICcgJykge1xuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlICh0aW1lc3RhbXApXG4gICAgICAgIGxldCBZID0gZGF0ZS5nZXRVVENGdWxsWWVhciAoKVxuICAgICAgICBsZXQgbSA9IGRhdGUuZ2V0VVRDTW9udGggKCkgKyAxXG4gICAgICAgIGxldCBkID0gZGF0ZS5nZXRVVENEYXRlICgpXG4gICAgICAgIG0gPSBtIDwgMTAgPyAoJzAnICsgbSkgOiBtXG4gICAgICAgIGQgPSBkIDwgMTAgPyAoJzAnICsgZCkgOiBkXG4gICAgICAgIHJldHVybiBZICsgJy0nICsgbSArICctJyArIGRcbiAgICB9XG5cbiAgICBZbWRITVMgKHRpbWVzdGFtcCwgaW5maXggPSAnICcpIHtcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSAodGltZXN0YW1wKVxuICAgICAgICBsZXQgWSA9IGRhdGUuZ2V0VVRDRnVsbFllYXIgKClcbiAgICAgICAgbGV0IG0gPSBkYXRlLmdldFVUQ01vbnRoICgpICsgMVxuICAgICAgICBsZXQgZCA9IGRhdGUuZ2V0VVRDRGF0ZSAoKVxuICAgICAgICBsZXQgSCA9IGRhdGUuZ2V0VVRDSG91cnMgKClcbiAgICAgICAgbGV0IE0gPSBkYXRlLmdldFVUQ01pbnV0ZXMgKClcbiAgICAgICAgbGV0IFMgPSBkYXRlLmdldFVUQ1NlY29uZHMgKClcbiAgICAgICAgbSA9IG0gPCAxMCA/ICgnMCcgKyBtKSA6IG1cbiAgICAgICAgZCA9IGQgPCAxMCA/ICgnMCcgKyBkKSA6IGRcbiAgICAgICAgSCA9IEggPCAxMCA/ICgnMCcgKyBIKSA6IEhcbiAgICAgICAgTSA9IE0gPCAxMCA/ICgnMCcgKyBNKSA6IE1cbiAgICAgICAgUyA9IFMgPCAxMCA/ICgnMCcgKyBTKSA6IFNcbiAgICAgICAgcmV0dXJuIFkgKyAnLScgKyBtICsgJy0nICsgZCArIGluZml4ICsgSCArICc6JyArIE0gKyAnOicgKyBTXG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWFya2V0IHtcblxuICAgIGNvbnN0cnVjdG9yIChleGNoYW5nZSwgc3ltYm9sKSB7XG4gICAgICAgIHRoaXMuZXhjaGFuZ2UgPSBleGNoYW5nZTtcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICAgIHRoaXMubWFya2V0ID0gZXhjaGFuZ2UubWFya2V0c1tzeW1ib2xdO1xuICAgIH1cblxuICAgIGFtb3VudFRvUHJlY2lzaW9uIChhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjaGFuZ2UuYW1vdW50VG9QcmVjaXNpb24gKHRoaXMuc3ltYm9sLCBhbW91bnQpXG4gICAgfVxuXG4gICAgY3JlYXRlTGltaXRCdXlPcmRlcihhbW91bnQsIHByaWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4Y2hhbmdlLmNyZWF0ZUxpbWl0QnV5T3JkZXIgKHRoaXMuc3ltYm9sLCBhbW91bnQsIHByaWNlKVxuICAgIH1cblxuICAgIGNyZWF0ZUxpbWl0U2VsbE9yZGVyKGFtb3VudCwgcHJpY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjaGFuZ2UuY3JlYXRlTGltaXRTZWxsT3JkZXIgKHRoaXMuc3ltYm9sLCBhbW91bnQsIHByaWNlKVxuICAgIH1cbn1cbiIsImNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgLy8gYSB3b3JrYXJvdW5kIHRvIG1ha2UgYGluc3RhbmNlb2YgQmFzZUVycm9yYCB3b3JrIGluIEVTNVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQmFzZUVycm9yXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBCYXNlRXJyb3IucHJvdG90eXBlXG4gICAgICAgIHRoaXMubWVzc2FnZSAgICAgPSBtZXNzYWdlXG4gICAgfVxufVxuXG5jbGFzcyBFeGNoYW5nZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IEV4Y2hhbmdlRXJyb3JcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEV4Y2hhbmdlRXJyb3IucHJvdG90eXBlXG4gICAgICAgIHRoaXMubWVzc2FnZSAgICAgPSBtZXNzYWdlXG4gICAgfVxufVxuXG5jbGFzcyBOb3RTdXBwb3J0ZWQgZXh0ZW5kcyBFeGNoYW5nZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IE5vdFN1cHBvcnRlZFxuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gTm90U3VwcG9ydGVkLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIEV4Y2hhbmdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQXV0aGVudGljYXRpb25FcnJvclxuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gQXV0aGVudGljYXRpb25FcnJvci5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIEludmFsaWROb25jZSBleHRlbmRzIEV4Y2hhbmdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gSW52YWxpZE5vbmNlXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBJbnZhbGlkTm9uY2UucHJvdG90eXBlXG4gICAgICAgIHRoaXMubWVzc2FnZSAgICAgPSBtZXNzYWdlXG4gICAgfVxufVxuXG5jbGFzcyBJbnN1ZmZpY2llbnRGdW5kcyBleHRlbmRzIEV4Y2hhbmdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gSW5zdWZmaWNpZW50RnVuZHNcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEluc3VmZmljaWVudEZ1bmRzLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgSW52YWxpZE9yZGVyIGV4dGVuZHMgRXhjaGFuZ2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIgKG1lc3NhZ2UpXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBJbnZhbGlkT3JkZXJcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEludmFsaWRPcmRlci5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIE9yZGVyTm90Rm91bmQgZXh0ZW5kcyBJbnZhbGlkT3JkZXIge1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gT3JkZXJOb3RGb3VuZFxuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gT3JkZXJOb3RGb3VuZC5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIE9yZGVyTm90Q2FjaGVkIGV4dGVuZHMgSW52YWxpZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IE9yZGVyTm90Q2FjaGVkXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBPcmRlck5vdENhY2hlZC5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIENhbmNlbFBlbmRpbmcgZXh0ZW5kcyBJbnZhbGlkT3JkZXIge1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2FuY2VsUGVuZGluZ1xuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gQ2FuY2VsUGVuZGluZy5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIgKG1lc3NhZ2UpXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBOZXR3b3JrRXJyb3JcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IE5ldHdvcmtFcnJvci5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIEREb1NQcm90ZWN0aW9uIGV4dGVuZHMgTmV0d29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IEREb1NQcm90ZWN0aW9uXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBERG9TUHJvdGVjdGlvbi5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIFJlcXVlc3RUaW1lb3V0IGV4dGVuZHMgTmV0d29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IFJlcXVlc3RUaW1lb3V0XG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBSZXF1ZXN0VGltZW91dC5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIEV4Y2hhbmdlTm90QXZhaWxhYmxlIGV4dGVuZHMgTmV0d29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IEV4Y2hhbmdlTm90QXZhaWxhYmxlXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBFeGNoYW5nZU5vdEF2YWlsYWJsZS5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgQmFzZUVycm9yLFxuICAgIEV4Y2hhbmdlRXJyb3IsXG4gICAgTm90U3VwcG9ydGVkLFxuICAgIEF1dGhlbnRpY2F0aW9uRXJyb3IsXG4gICAgSW52YWxpZE5vbmNlLFxuICAgIEluc3VmZmljaWVudEZ1bmRzLFxuICAgIEludmFsaWRPcmRlcixcbiAgICBPcmRlck5vdEZvdW5kLFxuICAgIE9yZGVyTm90Q2FjaGVkLFxuICAgIENhbmNlbFBlbmRpbmcsXG4gICAgTmV0d29ya0Vycm9yLFxuICAgIEREb1NQcm90ZWN0aW9uLFxuICAgIFJlcXVlc3RUaW1lb3V0LFxuICAgIEV4Y2hhbmdlTm90QXZhaWxhYmxlLFxufSIsIlwidXNlIHN0cmljdFwiO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IENyeXB0b0pTID0gcmVxdWlyZSAoJ2NyeXB0by1qcycpXG4gICAgLCBxcyAgICAgICA9IHJlcXVpcmUgKCdxcycpIC8vIHF1ZXJ5c3RyaW5nXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgeyBSZXF1ZXN0VGltZW91dCB9ID0gcmVxdWlyZSAoJy4vZXJyb3JzJylcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdXRpbGl0eSBoZWxwZXJzXG5cbmNvbnN0IHNldFRpbWVvdXRfb3JpZ2luYWwgPSBzZXRUaW1lb3V0XG5cbi8vIHNldFRpbWVvdXQgY2FuIGZpcmUgZWFybGllciB0aGFuIHNwZWNpZmllZCwgc28gd2UgbmVlZCB0byBlbnN1cmUgaXQgZG9lcyBub3QgaGFwcGVuLi4uXG5cbmNvbnN0IHNldFRpbWVvdXRfc2FmZSA9IChkb25lLCBtcywgc2V0VGltZW91dCA9IHNldFRpbWVvdXRfb3JpZ2luYWwgLyogb3ZlcnJpZGVhYmxlIGZvciBtb2NraW5nIHB1cnBvc2VzICovLCB0YXJnZXRUaW1lID0gRGF0ZS5ub3cgKCkgKyBtcykgPT4ge1xuXG4gICAgbGV0IGNsZWFySW5uZXJUaW1lb3V0ID0gKCkgPT4ge31cbiAgICBsZXQgYWN0aXZlID0gdHJ1ZVxuXG4gICAgbGV0IGlkID0gc2V0VGltZW91dCAoKCkgPT4ge1xuICAgICAgICBhY3RpdmUgPSB0cnVlXG4gICAgICAgIGNvbnN0IHJlc3QgPSB0YXJnZXRUaW1lIC0gRGF0ZS5ub3cgKClcbiAgICAgICAgaWYgKHJlc3QgPiAwKSB7XG4gICAgICAgICAgICBjbGVhcklubmVyVGltZW91dCA9IHNldFRpbWVvdXRfc2FmZSAoZG9uZSwgcmVzdCwgc2V0VGltZW91dCwgdGFyZ2V0VGltZSkgLy8gdHJ5IHNsZWVwIG1vcmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgKClcbiAgICAgICAgfVxuICAgIH0sIG1zKVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyICgpIHsgXG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlIC8vIGR1bm5vIGlmIElEcyBhcmUgdW5pcXVlIG9uIHZhcmlvdXMgcGxhdGZvcm1zLCBzbyBpdCdzIGJldHRlciB0byByZWx5IG9uIHRoaXMgZmxhZyB0byBleGNsdWRlIHRoZSBwb3NzaWJsZSBjYW5jZWxsYXRpb24gb2YgdGhlIHdyb25nIHRpbWVyIChpZiBjYWxsZWQgYWZ0ZXIgY29tcGxldGlvbilcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCAoaWQpXG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJJbm5lclRpbWVvdXQgKClcbiAgICB9XG59XG5cbmNvbnN0IHNsZWVwID0gbXMgPT4gbmV3IFByb21pc2UgKHJlc29sdmUgPT4gc2V0VGltZW91dF9zYWZlIChyZXNvbHZlLCBtcykpXG5cbmNvbnN0IGRlY2ltYWwgPSBmbG9hdCA9PiBwYXJzZUZsb2F0IChmbG9hdCkudG9TdHJpbmcgKClcblxuY29uc3QgdGltZW91dCA9IGFzeW5jIChtcywgcHJvbWlzZSkgPT4ge1xuXG4gICAgbGV0IGNsZWFyID0gKCkgPT4ge31cbiAgICBjb25zdCB0aW1lb3V0ID0gbmV3IFByb21pc2UgKHJlc29sdmUgPT4gKGNsZWFyID0gc2V0VGltZW91dF9zYWZlIChyZXNvbHZlLCBtcykpKVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmFjZSAoW3Byb21pc2UsIHRpbWVvdXQudGhlbiAoKCkgPT4geyB0aHJvdyBuZXcgUmVxdWVzdFRpbWVvdXQgKCdyZXF1ZXN0IHRpbWVkIG91dCcpIH0pXSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICBjbGVhciAoKSAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vY2N4dC9jY3h0L2lzc3Vlcy83NDlcbiAgICB9XG59XG5cbmNvbnN0IGNhcGl0YWxpemUgPSBzdHJpbmcgPT4gc3RyaW5nLmxlbmd0aCA/IChzdHJpbmcuY2hhckF0ICgwKS50b1VwcGVyQ2FzZSAoKSArIHN0cmluZy5zbGljZSAoMSkpIDogc3RyaW5nXG5cbmNvbnN0IGtleXNvcnQgPSBvYmplY3QgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG4gICAgT2JqZWN0LmtleXMgKG9iamVjdCkuc29ydCAoKS5mb3JFYWNoIChrZXkgPT4gcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XSlcbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IGV4dGVuZCA9ICguLi5hcmdzKSA9PiBPYmplY3QuYXNzaWduICh7fSwgLi4uYXJncylcblxuY29uc3QgZGVlcEV4dGVuZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAvLyBpZiAoYXJncy5sZW5ndGggPCAxKVxuICAgIC8vICAgICByZXR1cm4gYXJnc1xuICAgIC8vIGVsc2UgaWYgKGFyZ3MubGVuZ3RoIDwgMilcbiAgICAvLyAgICAgcmV0dXJuIGFyZ3NbMF1cblxuICAgIGxldCByZXN1bHQgPSB1bmRlZmluZWRcblxuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcblxuICAgICAgICBpZiAoYXJnICYmICh0eXBlb2YgYXJnID09ICdvYmplY3QnKSAmJiAoYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgISgnY29uc3RydWN0b3InIGluIGFyZykpKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge31cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwRXh0ZW5kIChyZXN1bHRba2V5XSwgYXJnW2tleV0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmVzdWx0ID0gYXJnXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IG9taXQgPSAob2JqZWN0LCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZXh0ZW5kIChvYmplY3QpXG4gICAgZm9yIChjb25zdCB4IG9mIGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFt4XVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkgKHgpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgeClcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0W2tdXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5jb25zdCBncm91cEJ5ID0gKGFycmF5LCBrZXkpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fVxuICAgIE9iamVjdFxuICAgICAgICAudmFsdWVzIChhcnJheSlcbiAgICAgICAgLmZpbHRlciAoZW50cnkgPT4gZW50cnlba2V5XSAhPSAndW5kZWZpbmVkJylcbiAgICAgICAgLmZvckVhY2ggKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2VudHJ5W2tleV1dID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtlbnRyeVtrZXldXSA9IFtdXG4gICAgICAgICAgICByZXN1bHRbZW50cnlba2V5XV0ucHVzaCAoZW50cnkpXG4gICAgICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5jb25zdCBmaWx0ZXJCeSA9IChhcnJheSwga2V5LCB2YWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBsZXQgZ3JvdXBlZCA9IGdyb3VwQnkgKGFycmF5LCBrZXkpXG4gICAgICAgIGlmICh2YWx1ZSBpbiBncm91cGVkKVxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwZWRbdmFsdWVdXG4gICAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlcbn1cblxuY29uc3QgaW5kZXhCeSA9IChhcnJheSwga2V5KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge31cbiAgICBPYmplY3RcbiAgICAgICAgLnZhbHVlcyAoYXJyYXkpXG4gICAgICAgIC5maWx0ZXIgKGVudHJ5ID0+IGVudHJ5W2tleV0gIT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIC5mb3JFYWNoIChlbnRyeSA9PiB7XG4gICAgICAgICAgICByZXN1bHRbZW50cnlba2V5XV0gPSBlbnRyeVxuICAgICAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbn1cblxuY29uc3Qgc29ydEJ5ID0gKGFycmF5LCBrZXksIGRlc2NlbmRpbmcgPSBmYWxzZSkgPT4ge1xuICAgIGRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nID8gLTEgOiAxXG4gICAgcmV0dXJuIGFycmF5LnNvcnQgKChhLCBiKSA9PiAoKGFba2V5XSA8IGJba2V5XSkgPyAtZGVzY2VuZGluZyA6ICgoYVtrZXldID4gYltrZXldKSA/IGRlc2NlbmRpbmcgOiAwKSkpXG59XG5cbmNvbnN0IGZsYXR0ZW4gPSAoYXJyYXksIHJlc3VsdCA9IFtdKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkgKHZhbHVlKSkge1xuICAgICAgICAgICAgZmxhdHRlbiAodmFsdWUsIHJlc3VsdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh2YWx1ZSlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IHVuaXF1ZSA9IGFycmF5ID0+IGFycmF5LmZpbHRlciAoKHZhbHVlLCBpbmRleCwgc2VsZikgPT4gKHNlbGYuaW5kZXhPZiAodmFsdWUpID09IGluZGV4KSlcblxuY29uc3QgcGx1Y2sgPSAoYXJyYXksIGtleSkgPT4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlciAoZWxlbWVudCA9PiAodHlwZW9mIGVsZW1lbnRba2V5XSAhPSAndW5kZWZpbmVkJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAgKGVsZW1lbnQgPT4gZWxlbWVudFtrZXldKVxuXG5jb25zdCB1cmxlbmNvZGUgPSBvYmplY3QgPT4gcXMuc3RyaW5naWZ5IChvYmplY3QpXG5jb25zdCByYXdlbmNvZGUgPSBvYmplY3QgPT4gcXMuc3RyaW5naWZ5IChvYmplY3QsIHsgZW5jb2RlOiBmYWxzZSB9KVxuXG5jb25zdCBzdW0gPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGFyZ3MuZmlsdGVyIChhcmcgPT4gdHlwZW9mIGFyZyAhPSAndW5kZWZpbmVkJylcbiAgICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPiAwKSA/XG4gICAgICAgIHJlc3VsdC5yZWR1Y2UgKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCkgOiB1bmRlZmluZWRcbn1cblxuY29uc3Qgc2FmZUZsb2F0ID0gKG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQpID0+IHtcbiAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdFtrZXldID09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldXG4gICAgICAgIGVsc2UgaWYgKCh0eXBlb2Ygb2JqZWN0W2tleV0gPT0gJ3N0cmluZycpICYmIG9iamVjdFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQgKG9iamVjdFtrZXldKVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlXG59XG5cbmNvbnN0IHNhZmVTdHJpbmcgPSAob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgIHJldHVybiAob2JqZWN0ICYmIChrZXkgaW4gb2JqZWN0KSAmJiBvYmplY3Rba2V5XSkgPyBvYmplY3Rba2V5XS50b1N0cmluZyAoKSA6IGRlZmF1bHRWYWx1ZVxufVxuXG5jb25zdCBzYWZlSW50ZWdlciA9IChvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSA9PiB7XG4gICAgcmV0dXJuICgoa2V5IGluIG9iamVjdCkgJiYgb2JqZWN0W2tleV0pID8gcGFyc2VJbnQgKG9iamVjdFtrZXldKSA6IGRlZmF1bHRWYWx1ZVxufVxuXG5jb25zdCBzYWZlVmFsdWUgPSAob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgIHJldHVybiAoKGtleSBpbiBvYmplY3QpICYmIG9iamVjdFtrZXldKSA/IG9iamVjdFtrZXldIDogZGVmYXVsdFZhbHVlXG59XG5cbmNvbnN0IHV1aWQgPSBhID0+IGEgP1xuICAgIChhIF4gTWF0aC5yYW5kb20gKCkgKiAxNiA+PiBhIC8gNCkudG9TdHJpbmcgKDE2KSA6XG4gICAgKFsxZTddKy0xZTMrLTRlMystOGUzKy0xZTExKS5yZXBsYWNlICgvWzAxOF0vZywgdXVpZClcblxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2ODU2ODAvaG93LXRvLWF2b2lkLXNjaWVudGlmaWMtbm90YXRpb24tZm9yLWxhcmdlLW51bWJlcnMtaW4tamF2YXNjcmlwdCBmb3IgZGlzY3Vzc2lvblxuXG5mdW5jdGlvbiB0b0ZpeGVkICh4KSB7IC8vIGF2b2lkIHNjaWVudGlmaWMgbm90YXRpb24gZm9yIHRvbyBsYXJnZSBhbmQgdG9vIHNtYWxsIG51bWJlcnNcblxuICAgIGlmIChNYXRoLmFicyAoeCkgPCAxLjApIHtcbiAgICAgICAgY29uc3QgZSA9IHBhcnNlSW50ICh4LnRvU3RyaW5nICgpLnNwbGl0ICgnZS0nKVsxXSlcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHggKj0gTWF0aC5wb3cgKDEwLCBlLTEpXG4gICAgICAgICAgICB4ID0gJzAuJyArIChuZXcgQXJyYXkgKGUpKS5qb2luICgnMCcpICsgeC50b1N0cmluZyAoKS5zdWJzdHJpbmcgKDIpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZSA9IHBhcnNlSW50ICh4LnRvU3RyaW5nICgpLnNwbGl0ICgnKycpWzFdKVxuICAgICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgICAgICBlIC09IDIwXG4gICAgICAgICAgICB4IC89IE1hdGgucG93ICgxMCwgZSlcbiAgICAgICAgICAgIHggKz0gKG5ldyBBcnJheSAoZSsxKSkuam9pbiAoJzAnKVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4XG59XG5cbi8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTEyNzg4L3RydW5jYXRlLW5vdC1yb3VuZC1vZmYtZGVjaW1hbC1udW1iZXJzLWluLWphdmFzY3JpcHQgZm9yIGRpc2N1c3Npb25cblxuLy8gPiBTbywgYWZ0ZXIgYWxsIGl0IHR1cm5lZCBvdXQsIHJvdW5kaW5nIGJ1Z3Mgd2lsbCBhbHdheXMgaGF1bnQgeW91LCBubyBtYXR0ZXIgaG93IGhhcmQgeW91IHRyeSB0byBjb21wZW5zYXRlIHRoZW0uXG4vLyA+IEhlbmNlIHRoZSBwcm9ibGVtIHNob3VsZCBiZSBhdHRhY2tlZCBieSByZXByZXNlbnRpbmcgbnVtYmVycyBleGFjdGx5IGluIGRlY2ltYWwgbm90YXRpb24uXG5cbmNvbnN0IHRydW5jYXRlX3JlZ0V4cENhY2hlID0gW11cbiAgICAsIHRydW5jYXRlID0gKG51bSwgcHJlY2lzaW9uID0gMCkgPT4ge1xuICAgICAgICBudW0gPSB0b0ZpeGVkIChudW0pXG4gICAgICAgIGNvbnN0IHJlID0gdHJ1bmNhdGVfcmVnRXhwQ2FjaGVbcHJlY2lzaW9uXSB8fCAodHJ1bmNhdGVfcmVnRXhwQ2FjaGVbcHJlY2lzaW9uXSA9IG5ldyBSZWdFeHAoXCIoWy1dKlxcXFxkK1xcXFwuXFxcXGR7XCIgKyBwcmVjaXNpb24gKyBcIn0pKFxcXFxkKVwiKSlcbiAgICAgICAgY29uc3QgWyxyZXN1bHRdID0gbnVtLnRvU3RyaW5nICgpLm1hdGNoIChyZSkgfHwgW251bGwsIG51bV1cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQgKHJlc3VsdClcbiAgICB9XG5cbmNvbnN0IHByZWNpc2lvbkZyb21TdHJpbmcgPSAoc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc3BsaXQgPSBzdHJpbmcucmVwbGFjZSAoLzArJC9nLCAnJykuc3BsaXQgKCcuJylcbiAgICByZXR1cm4gKHNwbGl0Lmxlbmd0aCA+IDEpID8gKHNwbGl0WzFdLmxlbmd0aCkgOiAwXG59XG5cbmNvbnN0IG9yZGVyZWQgPSB4ID0+IHggLy8gYSBzdHViIHRvIGtlZXAgYXNzb2Mga2V5cyBpbiBvcmRlciwgaW4gSlMgaXQgZG9lcyBub3RoaW5nLCBpdCdzIG1vc3RseSBmb3IgUHl0aG9uXG5cbmNvbnN0IGFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIChiaWRhc2tzKSB7XG5cbiAgICBsZXQgcmVzdWx0ID0ge31cblxuICAgIGJpZGFza3MuZm9yRWFjaCAoKFsgcHJpY2UsIHZvbHVtZSBdKSA9PiB7XG4gICAgICAgIHJlc3VsdFtwcmljZV0gPSAocmVzdWx0W3ByaWNlXSB8fCAwKSArIHZvbHVtZVxuICAgIH0pXG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMgKHJlc3VsdCkubWFwIChwcmljZSA9PiBbXG4gICAgICAgIHBhcnNlRmxvYXQgKHByaWNlKSxcbiAgICAgICAgcGFyc2VGbG9hdCAocmVzdWx0W3ByaWNlXSksXG4gICAgXSlcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3RyaW5nIOKGkOKGkiBiaW5hcnkg4oaQ4oaSIGJhc2U2NCBjb252ZXJzaW9uIHJvdXRpbmVzXG5cbmNvbnN0IHN0cmluZ1RvQmluYXJ5ID0gc3RyID0+IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSAoc3RyLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykgeyBhcnJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTsgfVxuICAgIHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSAoYXJyKVxufVxuXG5jb25zdCBzdHJpbmdUb0Jhc2U2NCA9IHN0cmluZyA9PiBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlIChzdHJpbmcpLnRvU3RyaW5nIChDcnlwdG9KUy5lbmMuQmFzZTY0KVxuICAgICwgdXRmMTZUb0Jhc2U2NCAgPSBzdHJpbmcgPT4gQ3J5cHRvSlMuZW5jLlV0ZjE2IC5wYXJzZSAoc3RyaW5nKS50b1N0cmluZyAoQ3J5cHRvSlMuZW5jLkJhc2U2NClcbiAgICAsIGJhc2U2NFRvQmluYXJ5ID0gc3RyaW5nID0+IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UgKHN0cmluZylcbiAgICAsIGJhc2U2NFRvU3RyaW5nID0gc3RyaW5nID0+IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UgKHN0cmluZykudG9TdHJpbmcgKENyeXB0b0pTLmVuYy5VdGY4KVxuICAgICwgYmluYXJ5VG9TdHJpbmcgPSBzdHJpbmcgPT4gc3RyaW5nXG5cbmNvbnN0IGJpbmFyeUNvbmNhdCA9ICguLi5hcmdzKSA9PiBhcmdzLnJlZHVjZSAoKGEsIGIpID0+IGEuY29uY2F0IChiKSlcblxuLy8gdXJsLXNhZmUtYmFzZTY0IHdpdGhvdXQgZXF1YWxzIHNpZ25zLCB3aXRoICsgcmVwbGFjZWQgYnkgLSBhbmQgc2xhc2hlcyByZXBsYWNlZCBieSB1bmRlcnNjb3Jlc1xuY29uc3QgdXJsZW5jb2RlQmFzZTY0ID0gYmFzZTY0c3RyaW5nID0+IGJhc2U2NHN0cmluZy5yZXBsYWNlICgvWz1dKyQvLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSAoL1xcKy9nLCAnLScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UgKC9cXC8vZywgJ18nKVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjcnlwdG9ncmFwaHlcblxuY29uc3QgaGFzaCA9IChyZXF1ZXN0LCBoYXNoID0gJ21kNScsIGRpZ2VzdCA9ICdoZXgnKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gQ3J5cHRvSlNbaGFzaC50b1VwcGVyQ2FzZSAoKV0gKHJlcXVlc3QpXG4gICAgcmV0dXJuIChkaWdlc3QgPT0gJ2JpbmFyeScpID8gcmVzdWx0IDogcmVzdWx0LnRvU3RyaW5nIChDcnlwdG9KUy5lbmNbY2FwaXRhbGl6ZSAoZGlnZXN0KV0pXG59XG5cbmNvbnN0IGhtYWMgPSAocmVxdWVzdCwgc2VjcmV0LCBoYXNoID0gJ3NoYTI1NicsIGRpZ2VzdCA9ICdoZXgnKSA9PiB7XG4gICAgY29uc3QgZW5jb2RpbmcgPSAoZGlnZXN0ID09ICdiaW5hcnknKSA/ICdMYXRpbjEnIDogY2FwaXRhbGl6ZSAoZGlnZXN0KVxuICAgIHJldHVybiBDcnlwdG9KU1snSG1hYycgKyBoYXNoLnRvVXBwZXJDYXNlICgpXSAocmVxdWVzdCwgc2VjcmV0KS50b1N0cmluZyAoQ3J5cHRvSlMuZW5jW2NhcGl0YWxpemUgKGVuY29kaW5nKV0pXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGEgSlNPTiBXZWIgVG9rZW4gYXV0aGVudGljYXRpb24gbWV0aG9kXG5cbmNvbnN0IGp3dCA9IChyZXF1ZXN0LCBzZWNyZXQsIGFsZyA9ICdIUzI1NicsIGhhc2ggPSAnc2hhMjU2JykgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRIZWFkZXIgPSB1cmxlbmNvZGVCYXNlNjQgKHN0cmluZ1RvQmFzZTY0IChKU09OLnN0cmluZ2lmeSAoeyAnYWxnJzogYWxnLCAndHlwJzogJ0pXVCcgfSkpKVxuICAgICAgICAsIGVuY29kZWREYXRhID0gdXJsZW5jb2RlQmFzZTY0IChzdHJpbmdUb0Jhc2U2NCAoSlNPTi5zdHJpbmdpZnkgKHJlcXVlc3QpKSlcbiAgICAgICAgLCB0b2tlbiA9IFsgZW5jb2RlZEhlYWRlciwgZW5jb2RlZERhdGEgXS5qb2luICgnLicpXG4gICAgICAgICwgc2lnbmF0dXJlID0gdXJsZW5jb2RlQmFzZTY0ICh1dGYxNlRvQmFzZTY0IChobWFjICh0b2tlbiwgc2VjcmV0LCBoYXNoLCAndXRmMTYnKSkpXG4gICAgcmV0dXJuIFsgdG9rZW4sIHNpZ25hdHVyZSBdLmpvaW4gKCcuJylcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHNldFRpbWVvdXRfc2FmZSxcblxuICAgIC8vIGNvbW1vbiB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4gICAgc2xlZXAsXG4gICAgdGltZW91dCxcbiAgICBjYXBpdGFsaXplLFxuICAgIGtleXNvcnQsXG4gICAgZXh0ZW5kLFxuICAgIGRlZXBFeHRlbmQsXG4gICAgb21pdCxcbiAgICBncm91cEJ5LFxuICAgIGluZGV4QnksXG4gICAgc29ydEJ5LFxuICAgIGZpbHRlckJ5LFxuICAgIGZsYXR0ZW4sXG4gICAgdW5pcXVlLFxuICAgIHBsdWNrLFxuICAgIHVybGVuY29kZSxcbiAgICByYXdlbmNvZGUsXG4gICAgc3VtLFxuICAgIGRlY2ltYWwsXG4gICAgc2FmZUZsb2F0LFxuICAgIHNhZmVTdHJpbmcsXG4gICAgc2FmZUludGVnZXIsXG4gICAgc2FmZVZhbHVlLFxuICAgIG9yZGVyZWQsXG4gICAgYWdncmVnYXRlLFxuICAgIHRydW5jYXRlLFxuICAgIHV1aWQsXG4gICAgcHJlY2lzaW9uRnJvbVN0cmluZyxcblxuICAgIC8vIHVuZGVyc2NvcmUgYWxpYXNlc1xuXG4gICAgaW5kZXhfYnk6IGluZGV4QnksXG4gICAgc29ydF9ieTogc29ydEJ5LFxuICAgIGdyb3VwX2J5OiBncm91cEJ5LFxuICAgIGZpbHRlcl9ieTogZmlsdGVyQnksXG4gICAgc2FmZV9mbG9hdDogc2FmZUZsb2F0LFxuICAgIHNhZmVfc3RyaW5nOiBzYWZlU3RyaW5nLFxuICAgIHNhZmVfaW50ZWdlcjogc2FmZUludGVnZXIsXG4gICAgc2FmZV92YWx1ZTogc2FmZVZhbHVlLFxuXG4gICAgLy8gY3J5cHRvIGZ1bmN0aW9uc1xuXG4gICAgYmluYXJ5Q29uY2F0LFxuICAgIHN0cmluZ1RvQmluYXJ5LFxuICAgIGJpbmFyeVRvU3RyaW5nLFxuICAgIHN0cmluZ1RvQmFzZTY0LFxuICAgIHV0ZjE2VG9CYXNlNjQsXG4gICAgYmFzZTY0VG9CaW5hcnksXG4gICAgYmFzZTY0VG9TdHJpbmcsXG4gICAgdXJsZW5jb2RlQmFzZTY0LFxuICAgIGhhc2gsXG4gICAgaG1hYyxcbiAgICBqd3QsXG5cbiAgICAvLyBqc29uXG4gICAganNvbjogICBKU09OLnN0cmluZ2lmeSxcbiAgICB1bmpzb246IEpTT04ucGFyc2Vcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7IHNsZWVwIH0gID0gcmVxdWlyZSAoJy4vZnVuY3Rpb25zJylcblxuY29uc3QgdGhyb3R0bGUgPSBjZmcgPT4ge1xuXG4gICAgbGV0IGxhc3RUaW1lc3RhbXAgPSBEYXRlLm5vdyAoKVxuICAgICAgICAsIG51bVRva2VucyA9ICh0eXBlb2YgY2ZnLm51bVRva2VucyAhPSAndW5kZWZpbmVkJykgPyBjZmcubnVtVG9rZW5zIDogY2ZnLmNhcGFjaXR5XG4gICAgICAgICwgcXVldWUgPSBbXVxuICAgICAgICAsIHJ1bm5pbmcgPSBmYWxzZVxuICAgICAgICAsIGNvdW50ZXIgPSAwXG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbiAoY29zdCA9PiB7XG5cbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IGNmZy5tYXhDYXBhY2l0eSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciAoJ0JhY2tsb2cgaXMgb3ZlciBtYXggY2FwYWNpdHkgb2YgJyArIGNmZy5tYXhDYXBhY2l0eSlcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UgKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2ggKHsgY29zdCwgcmVzb2x2ZSwgcmVqZWN0IH0pXG5cbiAgICAgICAgICAgICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0Vub3VnaFRva2VucyA9IGNmZy5jYXBhY2l0eSA/IChudW1Ub2tlbnMgPiAwKSA6IChudW1Ub2tlbnMgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNFbm91Z2hUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeyBjb3N0LCByZXNvbHZlLCByZWplY3QgfSA9IHF1ZXVlWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvc3QgPSAoY29zdCB8fCBjZmcuZGVmYXVsdENvc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1Ub2tlbnMgPj0gTWF0aC5taW4gKGNvc3QsIGNmZy5jYXBhY2l0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRva2VucyAtPSBjb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5zaGlmdCAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vdyA9IERhdGUubm93ICgpXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxhcHNlZCA9IG5vdyAtIGxhc3RUaW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUaW1lc3RhbXAgPSBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRva2VucyA9IE1hdGgubWluIChjZmcuY2FwYWNpdHksIG51bVRva2VucyArIGVsYXBzZWQgKiBjZmcucmVmaWxsUmF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwIChjZmcuZGVsYXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgICAgICByZWplY3QgKGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICB9LCBjZmcsIHtcbiAgICAgICAgY29uZmlndXJlOiBuZXdDZmcgPT4gdGhyb3R0bGUgKE9iamVjdC5hc3NpZ24gKHt9LCBjZmcsIG5ld0NmZykpXG4gICAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdHRsZVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMsIE9yZGVyTm90Rm91bmQsIEludmFsaWRPcmRlciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYmluYW5jZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaW5hbmNlJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JpbmFuY2UnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDTicsIC8vIENoaW5hXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hNeVRyYWRlcyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgLy8gbmV3IG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhcyc6IHtcbiAgICAgICAgICAgICAgICAnZmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoTXlUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFtJzogJzFtJyxcbiAgICAgICAgICAgICAgICAnM20nOiAnM20nLFxuICAgICAgICAgICAgICAgICc1bSc6ICc1bScsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICcxNW0nLFxuICAgICAgICAgICAgICAgICczMG0nOiAnMzBtJyxcbiAgICAgICAgICAgICAgICAnMWgnOiAnMWgnLFxuICAgICAgICAgICAgICAgICcyaCc6ICcyaCcsXG4gICAgICAgICAgICAgICAgJzRoJzogJzRoJyxcbiAgICAgICAgICAgICAgICAnNmgnOiAnNmgnLFxuICAgICAgICAgICAgICAgICc4aCc6ICc4aCcsXG4gICAgICAgICAgICAgICAgJzEyaCc6ICcxMmgnLFxuICAgICAgICAgICAgICAgICcxZCc6ICcxZCcsXG4gICAgICAgICAgICAgICAgJzNkJzogJzNkJyxcbiAgICAgICAgICAgICAgICAnMXcnOiAnMXcnLFxuICAgICAgICAgICAgICAgICcxTSc6ICcxTScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yOTYwNDAyMC1kNTQ4M2NkYy04N2VlLTExZTctOTRjNy1kMWE4ZDkxNjkyOTMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAnd2ViJzogJ2h0dHBzOi8vd3d3LmJpbmFuY2UuY29tJyxcbiAgICAgICAgICAgICAgICAgICAgJ3dhcGknOiAnaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vd2FwaS92MycsXG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vYXBpL3YxJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYmluYW5jZS5jb20vYXBpL3YzJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYmluYW5jZS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuYmluYW5jZS5jb20vcmVzdGFwaXB1Yi5odG1sJyxcbiAgICAgICAgICAgICAgICAnZmVlcyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYmluYW5jZS56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8xMTUwMDA0MjkzMzInLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9zdXBwb3J0LmJpbmFuY2UuY29tL2hjL2VuLXVzL2FydGljbGVzLzExNTAwMDU4MzMxMScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICd3ZWInOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvcHVibGljL3Byb2R1Y3QnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3dhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0SGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlSW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FnZ1RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAna2xpbmVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIvMjRocicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL2FsbFByaWNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL2FsbEJvb2tUaWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbGxPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL3Rlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJEYXRhU3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyRGF0YVN0cmVhbSdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlckRhdGFTdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wMDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZnVuZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RpZXJCYXNlZCc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAncGVyY2VudGFnZSc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQk5CJzogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdORU8nOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVRVTSc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05UJzogNTAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTlQnOiAwLjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU9TJzogMi4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JDSCc6IDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHQVMnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVVNEVCc6IDUuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPQVgnOiAyLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE5UJzogMzAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQ08nOiAwLjE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lDTic6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXVEMnOiAwLjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT01HJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pSWCc6IDUuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVFJBVCc6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTkdMUyc6IDguMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCUVgnOiAyLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnS05DJzogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZVTic6IDUwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05NJzogMTAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMSU5LJzogNS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hWRyc6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDVFInOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0FMVCc6IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJT1RBJzogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01EQSc6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNVEwnOiAwLjE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NVQic6IDEwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRDJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNVEgnOiAxMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VORyc6IDIuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBU1QnOiA0LjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRHJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLjAwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVlgnOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUkVRJzogMzAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMUkMnOiA3LjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVklCJzogNy4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hTUic6IDAuMDAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUUlgnOiA1MDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQT1dSJzogMTUuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBUksnOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWU9ZTyc6IDMwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWFJQJzogMC4xNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNT0QnOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5KJzogMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NUT1JKJzogMi4wLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTkInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05FTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVRVTSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05UJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VPUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkNIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHQVMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VTRFQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09BWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE5UJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQ08nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lDTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV1RDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPTUcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pSWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1RSQVQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOR0xTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCUVgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0tOQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRlVOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTk0nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xJTksnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hWRyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ1RSJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTQUxUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJT1RBJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNREEnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01UTCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1VCJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01USCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5HJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBU1QnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JURyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnREFTSCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVZYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSRVEnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xSQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVklCJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdIU1InOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RSWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUE9XUic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVJLJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdZT1lPJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYUlAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01PRCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5KJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVE9SSic6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VJbmZvICgpO1xuICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydzeW1ib2xzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChtYXJrZXRbJ2Jhc2VBc3NldCddKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChtYXJrZXRbJ3F1b3RlQXNzZXQnXSk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IGZpbHRlcnMgPSB0aGlzLmluZGV4QnkgKG1hcmtldFsnZmlsdGVycyddLCAnZmlsdGVyVHlwZScpO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogbWFya2V0WydiYXNlQXNzZXRQcmVjaXNpb24nXSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBtYXJrZXRbJ3F1b3RlUHJlY2lzaW9uJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IChtYXJrZXRbJ3N0YXR1cyddID09ICdUUkFESU5HJyk7XG4gICAgICAgICAgICBsZXQgbG90ID0gLTEgKiBNYXRoLmxvZzEwIChwcmVjaXNpb25bJ2Ftb3VudCddKTtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IC0xICogTWF0aC5sb2cxMCAocHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGxvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCdQUklDRV9GSUxURVInIGluIGZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlsdGVyID0gZmlsdGVyc1snUFJJQ0VfRklMVEVSJ107XG4gICAgICAgICAgICAgICAgZW50cnlbJ3ByZWNpc2lvbiddWydwcmljZSddID0gdGhpcy5wcmVjaXNpb25Gcm9tU3RyaW5nIChmaWx0ZXJbJ3RpY2tTaXplJ10pO1xuICAgICAgICAgICAgICAgIGVudHJ5WydsaW1pdHMnXVsncHJpY2UnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ21pbic6IHBhcnNlRmxvYXQgKGZpbHRlclsnbWluUHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgICdtYXgnOiBwYXJzZUZsb2F0IChmaWx0ZXJbJ21heFByaWNlJ10pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ0xPVF9TSVpFJyBpbiBmaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbHRlciA9IGZpbHRlcnNbJ0xPVF9TSVpFJ107XG4gICAgICAgICAgICAgICAgZW50cnlbJ3ByZWNpc2lvbiddWydhbW91bnQnXSA9IHRoaXMucHJlY2lzaW9uRnJvbVN0cmluZyAoZmlsdGVyWydzdGVwU2l6ZSddKTtcbiAgICAgICAgICAgICAgICBlbnRyeVsnbG90J10gPSBwYXJzZUZsb2F0IChmaWx0ZXJbJ3N0ZXBTaXplJ10pO1xuICAgICAgICAgICAgICAgIGVudHJ5WydsaW1pdHMnXVsnYW1vdW50J10gPSB7XG4gICAgICAgICAgICAgICAgICAgICdtaW4nOiBwYXJzZUZsb2F0IChmaWx0ZXJbJ21pblF0eSddKSxcbiAgICAgICAgICAgICAgICAgICAgJ21heCc6IHBhcnNlRmxvYXQgKGZpbHRlclsnbWF4UXR5J10pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ01JTl9OT1RJT05BTCcgaW4gZmlsdGVycykge1xuICAgICAgICAgICAgICAgIGVudHJ5WydsaW1pdHMnXVsnY29zdCddWydtaW4nXSA9IHBhcnNlRmxvYXQgKGZpbHRlcnNbJ01JTl9OT1RJT05BTCddWydtaW5Ob3Rpb25hbCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoIChlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVGZWUgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSwgdGFrZXJPck1ha2VyID0gJ3Rha2VyJywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICBsZXQga2V5ID0gJ3F1b3RlJztcbiAgICAgICAgbGV0IHJhdGUgPSBtYXJrZXRbdGFrZXJPck1ha2VyXTtcbiAgICAgICAgbGV0IGNvc3QgPSBwYXJzZUZsb2F0ICh0aGlzLmNvc3RUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQgKiByYXRlKSk7XG4gICAgICAgIGlmIChzaWRlID09ICdzZWxsJykge1xuICAgICAgICAgICAgY29zdCAqPSBwcmljZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9ICdiYXNlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiB0YWtlck9yTWFrZXIsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRba2V5XSxcbiAgICAgICAgICAgICdyYXRlJzogcmF0ZSxcbiAgICAgICAgICAgICdjb3N0JzogcGFyc2VGbG9hdCAodGhpcy5mZWVUb1ByZWNpc2lvbiAoc3ltYm9sLCBjb3N0KSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBY2NvdW50IChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydiYWxhbmNlcyddO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgbGV0IGFzc2V0ID0gYmFsYW5jZVsnYXNzZXQnXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChhc3NldCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2ZyZWUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydsb2NrZWQnXSksXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogMC4wLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2xpbWl0JzogMTAwLCAvLyBkZWZhdWx0ID0gbWF4aW11bSA9IDEwMFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnNhZmVJbnRlZ2VyICh0aWNrZXIsICdjbG9zZVRpbWUnKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2hQcmljZScpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3dQcmljZScpLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdiaWRQcmljZScpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2tQcmljZScpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnd2VpZ2h0ZWRBdmdQcmljZScpLFxuICAgICAgICAgICAgJ29wZW4nOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnb3BlblByaWNlJyksXG4gICAgICAgICAgICAnY2xvc2UnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAncHJldkNsb3NlUHJpY2UnKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3RQcmljZScpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdwcmljZUNoYW5nZVBlcmNlbnQnKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2x1bWUnKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdxdW90ZVZvbHVtZScpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcjI0aHIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlckFsbEJvb2tUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaV07XG4gICAgICAgICAgICBsZXQgaWQgPSB0aWNrZXJbJ3N5bWJvbCddO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvaGxjdlswXSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzFdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzJdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzNdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzRdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzVdKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnaW50ZXJ2YWwnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IChsaW1pdCkgPyBsaW1pdCA6IDUwMDsgLy8gZGVmYXVsdCA9PSBtYXggPT0gNTAwXG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0VGltZSddID0gc2luY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0S2xpbmVzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wRmllbGQgPSAoJ1QnIGluIHRyYWRlKSA/ICdUJyA6ICd0aW1lJztcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlW3RpbWVzdGFtcEZpZWxkXTtcbiAgICAgICAgbGV0IHByaWNlRmllbGQgPSAoJ3AnIGluIHRyYWRlKSA/ICdwJyA6ICdwcmljZSc7XG4gICAgICAgIGxldCBwcmljZSA9IHBhcnNlRmxvYXQgKHRyYWRlW3ByaWNlRmllbGRdKTtcbiAgICAgICAgbGV0IGFtb3VudEZpZWxkID0gKCdxJyBpbiB0cmFkZSkgPyAncScgOiAncXR5JztcbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKHRyYWRlW2Ftb3VudEZpZWxkXSk7XG4gICAgICAgIGxldCBpZEZpZWxkID0gKCdhJyBpbiB0cmFkZSkgPyAnYScgOiAnaWQnO1xuICAgICAgICBsZXQgaWQgPSB0cmFkZVtpZEZpZWxkXS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBvcmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdvcmRlcklkJyBpbiB0cmFkZSlcbiAgICAgICAgICAgIG9yZGVyID0gdHJhZGVbJ29yZGVySWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgaWYgKCdtJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgc2lkZSA9IHRyYWRlWydtJ10gPyAnc2VsbCcgOiAnYnV5JzsgLy8gdGhpcyBpcyByZXZlcnNlZCBpbnRlbnRpb25hbGx5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWRlID0gKHRyYWRlWydpc0J1eWVyJ10pID8gJ2J1eScgOiAnc2VsbCc7IC8vIHRoaXMgaXMgYSB0cnVlIHNpZGVcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmVlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2NvbW1pc3Npb24nIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBwYXJzZUZsb2F0ICh0cmFkZVsnY29tbWlzc2lvbiddKSxcbiAgICAgICAgICAgICAgICAnY3VycmVuY3knOiB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAodHJhZGVbJ2NvbW1pc3Npb25Bc3NldCddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdjb3N0JzogcHJpY2UgKiBhbW91bnQsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0VGltZSddID0gc2luY2U7XG4gICAgICAgICAgICByZXF1ZXN0WydlbmRUaW1lJ10gPSBzaW5jZSArIDg2NDAwMDAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgLy8gJ2Zyb21JZCc6IDEyMywgICAgLy8gSUQgdG8gZ2V0IGFnZ3JlZ2F0ZSB0cmFkZXMgZnJvbSBJTkNMVVNJVkUuXG4gICAgICAgIC8vICdzdGFydFRpbWUnOiA0NTYsIC8vIFRpbWVzdGFtcCBpbiBtcyB0byBnZXQgYWdncmVnYXRlIHRyYWRlcyBmcm9tIElOQ0xVU0lWRS5cbiAgICAgICAgLy8gJ2VuZFRpbWUnOiA3ODksICAgLy8gVGltZXN0YW1wIGluIG1zIHRvIGdldCBhZ2dyZWdhdGUgdHJhZGVzIHVudGlsIElOQ0xVU0lWRS5cbiAgICAgICAgLy8gJ2xpbWl0JzogNTAwLCAgICAgLy8gZGVmYXVsdCA9IG1heGltdW0gPSA1MDBcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRBZ2dUcmFkZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlclN0YXR1cyAoc3RhdHVzKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gJ05FVycpXG4gICAgICAgICAgICByZXR1cm4gJ29wZW4nO1xuICAgICAgICBpZiAoc3RhdHVzID09ICdQQVJUSUFMTFlfRklMTEVEJylcbiAgICAgICAgICAgIHJldHVybiAnb3Blbic7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gJ0ZJTExFRCcpXG4gICAgICAgICAgICByZXR1cm4gJ2Nsb3NlZCc7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gJ0NBTkNFTEVEJylcbiAgICAgICAgICAgIHJldHVybiAnY2FuY2VsZWQnO1xuICAgICAgICByZXR1cm4gc3RhdHVzLnRvTG93ZXJDYXNlICgpO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHN0YXR1cyA9IHRoaXMucGFyc2VPcmRlclN0YXR1cyAob3JkZXJbJ3N0YXR1cyddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpZCA9IG9yZGVyWydzeW1ib2wnXTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyWyd0aW1lJ107XG4gICAgICAgIGxldCBwcmljZSA9IHBhcnNlRmxvYXQgKG9yZGVyWydwcmljZSddKTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKG9yZGVyWydvcmlnUXR5J10pO1xuICAgICAgICBsZXQgZmlsbGVkID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnZXhlY3V0ZWRRdHknLCAwLjApO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gTWF0aC5tYXggKGFtb3VudCAtIGZpbGxlZCwgMC4wKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnb3JkZXJJZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyWyd0eXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAnc2lkZSc6IG9yZGVyWydzaWRlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnY29zdCc6IHByaWNlICogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAncXVhbnRpdHknOiB0aGlzLmFtb3VudFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCksXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUudG9VcHBlckNhc2UgKCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgIG9yZGVyID0gdGhpcy5leHRlbmQgKG9yZGVyLCB7XG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogdGhpcy5wcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKSxcbiAgICAgICAgICAgICAgICAndGltZUluRm9yY2UnOiAnR1RDJywgLy8gJ0dUQycgPSBHb29kIFRvIENhbmNlbCAoZGVmYXVsdCksICdJT0MnID0gSW1tZWRpYXRlIE9yIENhbmNlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcklkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcmRlciByZXF1aXJlcyBhIHN5bWJvbCBwYXJhbScpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdvcmRlcklkJzogcGFyc2VJbnQgKGlkKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcmRlcnMgcmVxdWlyZXMgYSBzeW1ib2wgcGFyYW0nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWxsT3JkZXJzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3Blbk9yZGVycyByZXF1aXJlcyBhIHN5bWJvbCBwYXJhbScpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9wZW5PcmRlcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVEZWxldGVPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgICAgICdvcmRlcklkJzogcGFyc2VJbnQgKGlkKSxcbiAgICAgICAgICAgICAgICAvLyAnb3JpZ0NsaWVudE9yZGVySWQnOiBpZCxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UuaW5kZXhPZiAoJ1VOS05PV05fT1JERVInKSA+PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIGVycm9yOiAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoTXlUcmFkZXMgcmVxdWlyZXMgYSBzeW1ib2wnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TXlUcmFkZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JDQycpXG4gICAgICAgICAgICByZXR1cm4gJ0JDSCc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBjdXJyZW5jeUlkIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JDSCcpXG4gICAgICAgICAgICByZXR1cm4gJ0JDQyc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaERlcG9zaXRBZGRyZXNzIChjdXJyZW5jeSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YXBpR2V0RGVwb3NpdEFkZHJlc3MgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYXNzZXQnOiB0aGlzLmN1cnJlbmN5SWQgKGN1cnJlbmN5KSxcbiAgICAgICAgICAgICdyZWN2V2luZG93JzogMTAwMDAwMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSkge1xuICAgICAgICAgICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5zYWZlU3RyaW5nIChyZXNwb25zZSwgJ2FkZHJlc3MnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaERlcG9zaXRBZGRyZXNzIGZhaWxlZDogJyArIHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YXBpUG9zdFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Fzc2V0JzogdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAoYW1vdW50KSxcbiAgICAgICAgICAgICdyZWN2V2luZG93JzogMTAwMDAwMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIHVybCArPSAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICd3YXBpJylcbiAgICAgICAgICAgIHVybCArPSAnLmh0bWwnO1xuICAgICAgICBpZiAoKGFwaSA9PSAncHJpdmF0ZScpIHx8IChhcGkgPT0gJ3dhcGknKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAndGltZXN0YW1wJzogbm9uY2UgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocXVlcnkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5ICs9ICcmJyArICdzaWduYXR1cmU9JyArIHNpZ25hdHVyZTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtTUJYLUFQSUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgobWV0aG9kID09ICdHRVQnKSB8fCAoYXBpID09ICd3YXBpJykpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgcXVlcnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGNvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICBpZiAoYm9keS5pbmRleE9mICgnTUlOX05PVElPTkFMJykgPj0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyBvcmRlciBjb3N0ID0gYW1vdW50ICogcHJpY2Ugc2hvdWxkIGJlID4gMC4wMDEgQlRDICcgKyBib2R5KTtcbiAgICAgICAgICAgIGlmIChib2R5LmluZGV4T2YgKCdMT1RfU0laRScpID49IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcmRlciAodGhpcy5pZCArICcgb3JkZXIgYW1vdW50IHNob3VsZCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IGxvdCBzaXplLCB1c2UgdGhpcy5hbW91bnRUb0xvdHMgKHN5bWJvbCwgYW1vdW50KSAnICsgYm9keSk7XG4gICAgICAgICAgICBpZiAoYm9keS5pbmRleE9mICgnUFJJQ0VfRklMVEVSJykgPj0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyBvcmRlciBwcmljZSBleGNlZWRzIGFsbG93ZWQgcHJpY2UgcHJlY2lzaW9uIG9yIGludmFsaWQsIHVzZSB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50KSAnICsgYm9keSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydjb2RlJ10gPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydjb2RlJ10gPT0gLTIwMTApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2NvZGUnXSA9PSAtMjAxMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXQyYyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXQyYycsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXQyQycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0lMJywgLy8gSXNyYWVsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMzAwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MTE5LTM1OTMyMjBlLTVlY2UtMTFlNy04YjNhLTVhMDQxZjZiY2MzZi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuYml0MmMuY28uaWwnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0MmMuY28uaWwnLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5iaXQyYy5jby5pbC9ob21lL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vT2ZlckUvYml0MmMnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0V4Y2hhbmdlcy97cGFpcn0vVGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFeGNoYW5nZXMve3BhaXJ9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRXhjaGFuZ2VzL3twYWlyfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9CYWxhbmNlL3YyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNZXJjaGFudC9DcmVhdGVDaGVja291dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JkZXIvQWNjb3VudEhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVyL0FkZENvaW5GdW5kc1JlcXVlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVyL0FkZEZ1bmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVyL0FkZE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmRlci9BZGRPcmRlck1hcmtldFByaWNlQnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmRlci9BZGRPcmRlck1hcmtldFByaWNlU2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JkZXIvQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVyL015T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQYXltZW50L0dldE15SWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BheW1lbnQvU2VuZCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL05JUyc6IHsgJ2lkJzogJ0J0Y05pcycsICdzeW1ib2wnOiAnQlRDL05JUycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdOSVMnIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9OSVMnOiB7ICdpZCc6ICdCY2hOaXMnLCAnc3ltYm9sJzogJ0JDSC9OSVMnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnTklTJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvTklTJzogeyAnaWQnOiAnTHRjTmlzJywgJ3N5bWJvbCc6ICdMVEMvTklTJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ05JUycgfSxcbiAgICAgICAgICAgICAgICAnQlRHL05JUyc6IHsgJ2lkJzogJ0J0Z05pcycsICdzeW1ib2wnOiAnQlRHL05JUycsICdiYXNlJzogJ0JURycsICdxdW90ZSc6ICdOSVMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC41IC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEFjY291bnRCYWxhbmNlVjIgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF2YWlsYWJsZSA9ICdBVkFJTEFCTEVfJyArIGN1cnJlbmN5O1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VbYXZhaWxhYmxlXTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYmFsYW5jZVtjdXJyZW5jeV07XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZXNQYWlyT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VzUGFpclRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IGF2ZXJhZ2VQcmljZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsnYXYnXSk7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWydhJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogYXZlcmFnZVByaWNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydoJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGwnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IGF2ZXJhZ2VQcmljZSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlc1BhaXJUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RPcmRlckFkZE9yZGVyJztcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ0Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdQYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnTWFya2V0UHJpY2UnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyWydQcmljZSddID0gcHJpY2U7XG4gICAgICAgICAgICBvcmRlclsnVG90YWwnXSA9IGFtb3VudCAqIHByaWNlO1xuICAgICAgICAgICAgb3JkZXJbJ0lzQmlkJ10gPSAoc2lkZSA9PSAnYnV5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydOZXdPcmRlciddWydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9ICcuanNvbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmV4dGVuZCAoeyAnbm9uY2UnOiBub25jZSB9LCBwYXJhbXMpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ24nOiB0aGlzLmRlY29kZSAoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXRiYXkgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYml0YmF5JyxcbiAgICAgICAgICAgICduYW1lJzogJ0JpdEJheScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnUEwnLCAnRVUnIF0sIC8vIFBvbGFuZFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjEzMi05NzhhN2JkOC01ZWNlLTExZTctOTU0MC1iYzk2ZDFlOWJiYjguanBnJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYml0YmF5Lm5ldCcsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2JpdGJheS5uZXQvQVBJL1B1YmxpYycsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYml0YmF5Lm5ldC9BUEkvVHJhZGluZy90cmFkaW5nQXBpLnBocCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9iaXRiYXkubmV0L3B1YmxpYy1hcGknLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9iaXRiYXkubmV0L2FjY291bnQvdGFiLWFwaScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vQml0QmF5TmV0L0FQSScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vbWFya2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9VU0QnOiB7ICdpZCc6ICdCVENVU0QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvRVVSJzogeyAnaWQnOiAnQlRDRVVSJywgJ3N5bWJvbCc6ICdCVEMvRVVSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1BMTic6IHsgJ2lkJzogJ0JUQ1BMTicsICdzeW1ib2wnOiAnQlRDL1BMTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9VU0QnOiB7ICdpZCc6ICdMVENVU0QnLCAnc3ltYm9sJzogJ0xUQy9VU0QnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvRVVSJzogeyAnaWQnOiAnTFRDRVVSJywgJ3N5bWJvbCc6ICdMVEMvRVVSJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgICAgICAgICAnTFRDL1BMTic6IHsgJ2lkJzogJ0xUQ1BMTicsICdzeW1ib2wnOiAnTFRDL1BMTicsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICdMVENCVEMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdFVEgvVVNEJzogeyAnaWQnOiAnRVRIVVNEJywgJ3N5bWJvbCc6ICdFVEgvVVNEJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0VVUic6IHsgJ2lkJzogJ0VUSEVVUicsICdzeW1ib2wnOiAnRVRIL0VVUicsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9QTE4nOiB7ICdpZCc6ICdFVEhQTE4nLCAnc3ltYm9sJzogJ0VUSC9QTE4nLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnUExOJyB9LFxuICAgICAgICAgICAgICAgICdFVEgvQlRDJzogeyAnaWQnOiAnRVRIQlRDJywgJ3N5bWJvbCc6ICdFVEgvQlRDJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnTFNLL1VTRCc6IHsgJ2lkJzogJ0xTS1VTRCcsICdzeW1ib2wnOiAnTFNLL1VTRCcsICdiYXNlJzogJ0xTSycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0xTSy9FVVInOiB7ICdpZCc6ICdMU0tFVVInLCAnc3ltYm9sJzogJ0xTSy9FVVInLCAnYmFzZSc6ICdMU0snLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAgICAgICAgICdMU0svUExOJzogeyAnaWQnOiAnTFNLUExOJywgJ3N5bWJvbCc6ICdMU0svUExOJywgJ2Jhc2UnOiAnTFNLJywgJ3F1b3RlJzogJ1BMTicgfSxcbiAgICAgICAgICAgICAgICAnTFNLL0JUQyc6IHsgJ2lkJzogJ0xTS0JUQycsICdzeW1ib2wnOiAnTFNLL0JUQycsICdiYXNlJzogJ0xTSycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMyAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDQzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RJbmZvICgpO1xuICAgICAgICBpZiAoJ2JhbGFuY2VzJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSByZXNwb25zZVsnYmFsYW5jZXMnXTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2F2YWlsYWJsZSddKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2xvY2tlZCddKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBlbXB0eSBiYWxhbmNlIHJlc3BvbnNlICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0SWRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0SWRUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2x1bWUnKTtcbiAgICAgICAgbGV0IHZ3YXAgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndndhcCcpO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbWF4JyksXG4gICAgICAgICAgICAnbG93JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ21pbicpLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdiaWQnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXNrJyksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2F2ZXJhZ2UnKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0SWRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncGF5bWVudF9jdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBpc0ZpYXQgKGN1cnJlbmN5KSB7XG4gICAgICAgIGxldCBmaWF0Q3VycmVuY2llcyA9IHtcbiAgICAgICAgICAgICdVU0QnOiB0cnVlLFxuICAgICAgICAgICAgJ0VVUic6IHRydWUsXG4gICAgICAgICAgICAnUExOJzogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN1cnJlbmN5IGluIGZpYXRDdXJyZW5jaWVzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuaXNGaWF0IChjdXJyZW5jeSkpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdwcml2YXRlUG9zdFdpdGhkcmF3JztcbiAgICAgICAgICAgIC8vIHJlcXVlc3RbJ2FjY291bnQnXSA9IHBhcmFtc1snYWNjb3VudCddOyAvLyB0aGV5IGRlbWFuZCBhbiBhY2NvdW50IG51bWJlclxuICAgICAgICAgICAgLy8gcmVxdWVzdFsnZXhwcmVzcyddID0gcGFyYW1zWydleHByZXNzJ107IC8vIHdoYXRldmVyIGl0IG1lYW5zLCB0aGV5IGRvbid0IGV4cGxhaW5cbiAgICAgICAgICAgIC8vIHJlcXVlc3RbJ2JpYyddID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAncHJpdmF0ZVBvc3RUcmFuc2Zlcic7XG4gICAgICAgICAgICByZXF1ZXN0WydhZGRyZXNzJ10gPSBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcykgKyAnLmpzb24nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ21vbWVudCc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdBUEktS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FQSS1IYXNoJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXRjb2luY29pZCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXRjb2luY29pZCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRjb2luLmNvLmlkJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSUQnLCAvLyBJbmRvbmVzaWFcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MTM4LTA0M2M3Nzg2LTVlY2YtMTFlNy04ODJiLTgwOWMxNGYzOGI1My5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly92aXAuYml0Y29pbi5jby5pZC9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3ZpcC5iaXRjb2luLmNvLmlkL3RhcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5iaXRjb2luLmNvLmlkJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly92aXAuYml0Y29pbi5jby5pZC9kb3dubG9hZHMvQklUQ09JTkNPSUQtQVBJLURPQ1VNRU5UQVRJT04ucGRmJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vdmlwLmJpdGNvaW4uY28uaWQvdHJhZGVfYXBpJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7cGFpcn0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7cGFpcn0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7cGFpcn0vZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbk9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9JRFInOiB7ICdpZCc6ICdidGNfaWRyJywgJ3N5bWJvbCc6ICdCVEMvSURSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0lEUicsICdiYXNlSWQnOiAnYnRjJywgJ3F1b3RlSWQnOiAnaWRyJyB9LFxuICAgICAgICAgICAgICAgICdCQ0gvSURSJzogeyAnaWQnOiAnYmNoX2lkcicsICdzeW1ib2wnOiAnQkNIL0lEUicsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ2JjaCcsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0lEUic6IHsgJ2lkJzogJ2V0aF9pZHInLCAnc3ltYm9sJzogJ0VUSC9JRFInLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnSURSJywgJ2Jhc2VJZCc6ICdldGgnLCAncXVvdGVJZCc6ICdpZHInIH0sXG4gICAgICAgICAgICAgICAgJ0VUQy9JRFInOiB7ICdpZCc6ICdldGNfaWRyJywgJ3N5bWJvbCc6ICdFVEMvSURSJywgJ2Jhc2UnOiAnRVRDJywgJ3F1b3RlJzogJ0lEUicsICdiYXNlSWQnOiAnZXRjJywgJ3F1b3RlSWQnOiAnaWRyJyB9LFxuICAgICAgICAgICAgICAgICdYUlAvSURSJzogeyAnaWQnOiAneHJwX2lkcicsICdzeW1ib2wnOiAnWFJQL0lEUicsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ3hycCcsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgICAgICAgICAnWFpDL0lEUic6IHsgJ2lkJzogJ3h6Y19pZHInLCAnc3ltYm9sJzogJ1haQy9JRFInLCAnYmFzZSc6ICdYWkMnLCAncXVvdGUnOiAnSURSJywgJ2Jhc2VJZCc6ICd4emMnLCAncXVvdGVJZCc6ICdpZHInIH0sXG4gICAgICAgICAgICAgICAgJ1hMTS9JRFInOiB7J2lkJzogJ3N0cl9pZHInLCAnc3ltYm9sJzogJ1hMTS9JRFInLCAnYmFzZSc6ICdYTE0nLCAncXVvdGUnOiAnSURSJywgJ2Jhc2VJZCc6ICdzdHInLCAncXVvdGVJZCc6ICdpZHInfSxcbiAgICAgICAgICAgICAgICAnQlRTL0JUQyc6IHsgJ2lkJzogJ2J0c19idGMnLCAnc3ltYm9sJzogJ0JUUy9CVEMnLCAnYmFzZSc6ICdCVFMnLCAncXVvdGUnOiAnQlRDJywgJ2Jhc2VJZCc6ICdidHMnLCAncXVvdGVJZCc6ICdidGMnIH0sXG4gICAgICAgICAgICAgICAgJ0RBU0gvQlRDJzogeyAnaWQnOiAnZHJrX2J0YycsICdzeW1ib2wnOiAnREFTSC9CVEMnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0JUQycsICdiYXNlSWQnOiAnZHJrJywgJ3F1b3RlSWQnOiAnYnRjJyB9LFxuICAgICAgICAgICAgICAgICdET0dFL0JUQyc6IHsgJ2lkJzogJ2RvZ2VfYnRjJywgJ3N5bWJvbCc6ICdET0dFL0JUQycsICdiYXNlJzogJ0RPR0UnLCAncXVvdGUnOiAnQlRDJywgJ2Jhc2VJZCc6ICdkb2dlJywgJ3F1b3RlSWQnOiAnYnRjJyB9LFxuICAgICAgICAgICAgICAgICdFVEgvQlRDJzogeyAnaWQnOiAnZXRoX2J0YycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ2V0aCcsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ2x0Y19idGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJywgJ2Jhc2VJZCc6ICdsdGMnLCAncXVvdGVJZCc6ICdidGMnIH0sXG4gICAgICAgICAgICAgICAgJ05YVC9CVEMnOiB7ICdpZCc6ICdueHRfYnRjJywgJ3N5bWJvbCc6ICdOWFQvQlRDJywgJ2Jhc2UnOiAnTlhUJywgJ3F1b3RlJzogJ0JUQycsICdiYXNlSWQnOiAnbnh0JywgJ3F1b3RlSWQnOiAnYnRjJyB9LFxuICAgICAgICAgICAgICAgICdYTE0vQlRDJzogeyAnaWQnOiAnc3RyX2J0YycsICdzeW1ib2wnOiAnWExNL0JUQycsICdiYXNlJzogJ1hMTScsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ3N0cicsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgICAgICAgICAnWEVNL0JUQyc6IHsgJ2lkJzogJ25lbV9idGMnLCAnc3ltYm9sJzogJ1hFTS9CVEMnLCAnYmFzZSc6ICdYRU0nLCAncXVvdGUnOiAnQlRDJywgJ2Jhc2VJZCc6ICduZW0nLCAncXVvdGVJZCc6ICdidGMnIH0sXG4gICAgICAgICAgICAgICAgJ1hSUC9CVEMnOiB7ICdpZCc6ICd4cnBfYnRjJywgJ3N5bWJvbCc6ICdYUlAvQlRDJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0JUQycsICdiYXNlSWQnOiAneHJwJywgJ3F1b3RlSWQnOiAnYnRjJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSByZXNwb25zZVsncmV0dXJuJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlWydiYWxhbmNlJ10sIGxvd2VyY2FzZSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlWydiYWxhbmNlX2hvbGQnXSwgbG93ZXJjYXNlLCAwLjApO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0UGFpckRlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5JywgJ3NlbGwnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UGFpclRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWyd0aWNrZXInXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VydmVyX3RpbWUnXSkgKiAxMDAwO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9ICd2b2xfJyArIG1hcmtldFsnYmFzZUlkJ10udG9Mb3dlckNhc2UgKCk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9ICd2b2xfJyArIG1hcmtldFsncXVvdGVJZCddLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyW2Jhc2VWb2x1bWVdKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlcltxdW90ZVZvbHVtZV0pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFBhaXJUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2VJZCddO1xuICAgICAgICBvcmRlcltiYXNlXSA9IGFtb3VudDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydyZXR1cm4nXVsnb3JkZXJfaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiB0aGlzLm5vbmNlICgpLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgcmVzcG9uc2VbJ2Vycm9yJ10pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMsIE5vdFN1cHBvcnRlZCwgSW52YWxpZE9yZGVyLCBPcmRlck5vdEZvdW5kIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXRmaW5leCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXRmaW5leCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRmaW5leCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9sZCBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0RlcG9zaXQnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMW0nLFxuICAgICAgICAgICAgICAgICc1bSc6ICc1bScsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICcxNW0nLFxuICAgICAgICAgICAgICAgICczMG0nOiAnMzBtJyxcbiAgICAgICAgICAgICAgICAnMWgnOiAnMWgnLFxuICAgICAgICAgICAgICAgICczaCc6ICczaCcsXG4gICAgICAgICAgICAgICAgJzZoJzogJzZoJyxcbiAgICAgICAgICAgICAgICAnMTJoJzogJzEyaCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJzFEJyxcbiAgICAgICAgICAgICAgICAnMXcnOiAnN0QnLFxuICAgICAgICAgICAgICAgICcydyc6ICcxNEQnLFxuICAgICAgICAgICAgICAgICcxTSc6ICcxTScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjI0NC1lMzI4YTUwYy01ZWQyLTExZTctOTQ3Yi0wNDE0MTY1NzliYjMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJpdGZpbmV4LmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5iaXRmaW5leC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JpdGZpbmV4LnJlYWRtZS5pby92MS9kb2NzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9iaXRmaW5leGNvbS9iaXRmaW5leC1hcGktbm9kZScsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICd2Mic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5kbGVzL3RyYWRlOnt0aW1lZnJhbWV9OntzeW1ib2x9L3tzZWN0aW9ufScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuZGxlcy90cmFkZTp7dGltZWZyYW1lfTp7c3ltYm9sfS9sYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5kbGVzL3RyYWRlOnt0aW1lZnJhbWV9OntzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29rL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICdjYW5kbGVzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZW5kYm9vay97Y3VycmVuY3l9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZW5kcy97Y3VycmVuY3l9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwdWJ0aWNrZXIve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXRzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2xzX2RldGFpbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RvZGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRfZmVlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudF9pbmZvcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jhc2tldF9tYW5hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyZWRpdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kaW5nL2Nsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5L21vdmVtZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAna2V5X2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmdpbl9pbmZvcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215dHJhZGVzX2Z1bmRpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29mZmVyL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2ZmZXIvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvZmZlci9zdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29mZmVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2ZmZXJzL2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsL2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsL211bHRpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9jYW5jZWwvcmVwbGFjZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9uZXcvbXVsdGknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL3N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24vY2xhaW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3VtbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGFrZW5fZnVuZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RvdGFsX3Rha2VuX2Z1bmRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndW51c2VkX3Rha2VuX2Z1bmRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RpZXJCYXNlZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4xIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0aWVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0YWtlcic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMCwgMC4yIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNTAwMDAwLCAwLjIgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxMDAwMDAwLCAwLjIgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsyNTAwMDAwLCAwLjIgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs1MDAwMDAwLCAwLjIgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs3NTAwMDAwLCAwLjIgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxMDAwMDAwMCwgMC4xOCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzE1MDAwMDAwLCAwLjE2IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMjAwMDAwMDAsIDAuMTQgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsyNTAwMDAwMCwgMC4xMiAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzMwMDAwMDAwLCAwLjEgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYWtlcic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMCwgMC4xIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNTAwMDAwLCAwLjA4IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTAwMDAwMCwgMC4wNiAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzI1MDAwMDAsIDAuMDQgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs1MDAwMDAwLCAwLjAyIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNzUwMDAwMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEwMDAwMDAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTUwMDAwMDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsyMDAwMDAwMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzI1MDAwMDAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMzAwMDAwMDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsIC8vIHRydWUgZm9yIHRpZXItYmFzZWQvcHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiBmYWxzZSwgLy8gZml4ZWQgY29tbWlzc2lvblxuICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLjAwMDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSU9UQSc6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JDSCc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFRDJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VPUyc6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYTVInOiAwLjA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NBTic6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQVNIJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEMnOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hQUic6IDAuMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWVlXJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05FTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWkVDJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JURyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT01HJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBVEEnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1FBU0gnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUUCc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVRVTSc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRURPJzogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FWVCc6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVU0RUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJT1RBJzogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUSCc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkNIJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU9TJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hNUic6IDAuMDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0FOJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUQyc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWFBSJzogMC4wMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdZWVcnOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTkVPJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdaRUMnOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRHJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPTUcnOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnREFUQSc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUUFTSCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRQJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdRVFVNJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFRE8nOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVZUJzogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VTRFQnOiA1LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIC8vIGlzc3VlICM0IEJpdGZpbmV4IG5hbWVzIERhc2ggYXMgRFNILCBpbnN0ZWFkIG9mIERBU0hcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdEU0gnKVxuICAgICAgICAgICAgcmV0dXJuICdEQVNIJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdRVE0nKVxuICAgICAgICAgICAgcmV0dXJuICdRVFVNJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ0MnKVxuICAgICAgICAgICAgcmV0dXJuICdDU1RfQkNDJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ1UnKVxuICAgICAgICAgICAgcmV0dXJuICdDU1RfQkNVJztcbiAgICAgICAgLy8gaXNzdWUgIzc5NlxuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0lPVCcpXG4gICAgICAgICAgICByZXR1cm4gJ0lPVEEnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFN5bWJvbHNEZXRhaWxzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3BhaXInXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBiYXNlSWQgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGVJZCA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2VJZCk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGVJZCk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBtYXJrZXRbJ3ByaWNlX3ByZWNpc2lvbiddLFxuICAgICAgICAgICAgICAgICdhbW91bnQnOiBtYXJrZXRbJ3ByaWNlX3ByZWNpc2lvbiddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnYmFzZUlkJzogYmFzZUlkLFxuICAgICAgICAgICAgICAgICdxdW90ZUlkJzogcXVvdGVJZCxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogcGFyc2VGbG9hdCAobWFya2V0WydtaW5pbXVtX29yZGVyX3NpemUnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogcGFyc2VGbG9hdCAobWFya2V0WydtYXhpbXVtX29yZGVyX3NpemUnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZVR5cGUgPSB0aGlzLnNhZmVTdHJpbmcgKHBhcmFtcywgJ3R5cGUnLCAnZXhjaGFuZ2UnKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsYW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbaV07XG4gICAgICAgICAgICBpZiAoYmFsYW5jZVsndHlwZSddID09IGJhbGFuY2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gY3VycmVuY3kudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgdXBwZXJjYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHVwcGVyY2FzZSk7XG4gICAgICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlWydhbW91bnQnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJvb2tTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaV07XG4gICAgICAgICAgICBpZiAoJ3BhaXInIGluIHRpY2tlcikge1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHRpY2tlclsncGFpciddO1xuICAgICAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hUaWNrZXJzKCkgZmFpbGVkIHRvIHJlY29nbml6ZSBzeW1ib2wgJyArIGlkICsgJyAnICsgdGhpcy5qc29uICh0aWNrZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaFRpY2tlcnMoKSByZXNwb25zZSBub3QgcmVjb2duaXplZCAnICsgdGhpcy5qc29uICh0aWNrZXJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFB1YnRpY2tlclN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VGbG9hdCAodGlja2VyWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICB9IGVsc2UgaWYgKCdwYWlyJyBpbiB0aWNrZXIpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IHRpY2tlclsncGFpciddO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHVucmVjb2duaXplZCB0aWNrZXIgc3ltYm9sICcgKyBpZCArICcgJyArIHRoaXMuanNvbiAodGlja2VyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RfcHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbWlkJ10pLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChwYXJzZUZsb2F0ICh0cmFkZVsndGltZXN0YW1wJ10pKSAqIDEwMDA7XG4gICAgICAgIGxldCBzaWRlID0gdHJhZGVbJ3R5cGUnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgbGV0IG9yZGVySWQgPSB0aGlzLnNhZmVTdHJpbmcgKHRyYWRlLCAnb3JkZXJfaWQnKTtcbiAgICAgICAgbGV0IHByaWNlID0gcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pO1xuICAgICAgICBsZXQgYW1vdW50ID0gcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKTtcbiAgICAgICAgbGV0IGNvc3QgPSBwcmljZSAqIGFtb3VudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVySWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHsgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSB9O1xuICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0X3RyYWRlcyddID0gbGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmNlKSB7XG4gICAgICAgICAgICByZXF1ZXN0Wyd0aW1lc3RhbXAnXSA9IHBhcnNlSW50IChzaW5jZSAvIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RNeXRyYWRlcyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKCh0eXBlID09ICdsaW1pdCcpIHx8ICh0eXBlID09ICdtYXJrZXQnKSlcbiAgICAgICAgICAgIG9yZGVyVHlwZSA9ICdleGNoYW5nZSAnICsgdHlwZTtcbiAgICAgICAgLy8gYW1vdW50ID0gdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyVHlwZSxcbiAgICAgICAgICAgICdvY29vcmRlcic6IGZhbHNlLFxuICAgICAgICAgICAgJ2J1eV9wcmljZV9vY28nOiAwLFxuICAgICAgICAgICAgJ3NlbGxfcHJpY2Vfb2NvJzogMCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHByaWNlID0gdGhpcy5wcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKTtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2UudG9TdHJpbmcgKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlck5ldyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcihyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ2FuY2VsICh7ICdvcmRlcl9pZCc6IHBhcnNlSW50IChpZCkgfSk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9IG9yZGVyWydzaWRlJ107XG4gICAgICAgIGxldCBvcGVuID0gb3JkZXJbJ2lzX2xpdmUnXTtcbiAgICAgICAgbGV0IGNhbmNlbGVkID0gb3JkZXJbJ2lzX2NhbmNlbGxlZCddO1xuICAgICAgICBsZXQgc3RhdHVzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgc3RhdHVzID0gJ29wZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2FuY2VsZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gJ2Nsb3NlZCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGxldCBleGNoYW5nZSA9IG9yZGVyWydzeW1ib2wnXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGlmIChleGNoYW5nZSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbZXhjaGFuZ2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgb3JkZXJUeXBlID0gb3JkZXJbJ3R5cGUnXTtcbiAgICAgICAgbGV0IGV4Y2hhbmdlID0gb3JkZXJUeXBlLmluZGV4T2YgKCdleGNoYW5nZSAnKSA+PSAwO1xuICAgICAgICBpZiAoZXhjaGFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBbIHByZWZpeCwgb3JkZXJUeXBlIF0gPSBvcmRlclsndHlwZSddLnNwbGl0ICgnICcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAocGFyc2VGbG9hdCAob3JkZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDApO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyVHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKG9yZGVyWydwcmljZSddKSxcbiAgICAgICAgICAgICdhdmVyYWdlJzogcGFyc2VGbG9hdCAob3JkZXJbJ2F2Z19leGVjdXRpb25fcHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAob3JkZXJbJ29yaWdpbmFsX2Ftb3VudCddKSxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiBwYXJzZUZsb2F0IChvcmRlclsncmVtYWluaW5nX2Ftb3VudCddKSxcbiAgICAgICAgICAgICdmaWxsZWQnOiBwYXJzZUZsb2F0IChvcmRlclsnZXhlY3V0ZWRfYW1vdW50J10pLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdmZWUnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAocGFyYW1zKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlLCB1bmRlZmluZWQsIHNpbmNlLCBsaW1pdCk7XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBvcmRlcnMgPSB0aGlzLmZpbHRlckJ5IChvcmRlcnMsICdzeW1ib2wnLCBzeW1ib2wpO1xuICAgICAgICByZXR1cm4gb3JkZXJzO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJzSGlzdCAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJzID0gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UsIHVuZGVmaW5lZCwgc2luY2UsIGxpbWl0KTtcbiAgICAgICAgaWYgKHN5bWJvbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5IChvcmRlcnMsICdzeW1ib2wnLCBzeW1ib2wpO1xuICAgICAgICByZXR1cm4gb3JkZXJzO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlclN0YXR1cyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IHBhcnNlSW50IChpZCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyIChyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvaGxjdlswXSxcbiAgICAgICAgICAgIG9obGN2WzFdLFxuICAgICAgICAgICAgb2hsY3ZbM10sXG4gICAgICAgICAgICBvaGxjdls0XSxcbiAgICAgICAgICAgIG9obGN2WzJdLFxuICAgICAgICAgICAgb2hsY3ZbNV0sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHYyaWQgPSAndCcgKyBtYXJrZXRbJ2lkJ107XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHYyaWQsXG4gICAgICAgICAgICAndGltZWZyYW1lJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgaWYgKHNpbmNlKVxuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnQnXSA9IHNpbmNlO1xuICAgICAgICByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMudjJHZXRDYW5kbGVzVHJhZGVUaW1lZnJhbWVTeW1ib2xIaXN0IChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW5jeU5hbWUgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQlRDJykge1xuICAgICAgICAgICAgcmV0dXJuICdiaXRjb2luJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnTFRDJykge1xuICAgICAgICAgICAgcmV0dXJuICdsaXRlY29pbic7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgPT0gJ0VUSCcpIHtcbiAgICAgICAgICAgIHJldHVybiAnZXRoZXJldW0nO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdFVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2V0aGVyZXVtYyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgPT0gJ09NTkknKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hc3RlcmNvaW4nOyAvLyA/Pz9cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnWkVDJykge1xuICAgICAgICAgICAgcmV0dXJuICd6Y2FzaCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgPT0gJ1hNUicpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9uZXJvJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnVVNEJykge1xuICAgICAgICAgICAgcmV0dXJuICd3aXJlJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnREFTSCcpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGFzaCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgPT0gJ1hSUCcpIHtcbiAgICAgICAgICAgIHJldHVybiAncmlwcGxlJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnRU9TJykge1xuICAgICAgICAgICAgcmV0dXJuICdlb3MnO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdCQ0gnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JjYXNoJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnVVNEVCcpIHtcbiAgICAgICAgICAgIHJldHVybiAndGV0aGVydXNvJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyAnICsgY3VycmVuY3kgKyAnIG5vdCBzdXBwb3J0ZWQgZm9yIHdpdGhkcmF3YWwnKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncmVuZXcnOiAxLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiByZXNwb25zZVsnYWRkcmVzcyddLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlWydpbmZvJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5nZXRDdXJyZW5jeU5hbWUgKGN1cnJlbmN5KTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnbWV0aG9kJzogbmFtZSxcbiAgICAgICAgICAgICd3YWxsZXRfbmFtZSc6ICdleGNoYW5nZScsXG4gICAgICAgICAgICAncmVuZXcnOiAwLCAvLyBhIHZhbHVlIG9mIDEgd2lsbCBnZW5lcmF0ZSBhIG5ldyBhZGRyZXNzXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3REZXBvc2l0TmV3ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogcmVzcG9uc2VbJ2FkZHJlc3MnXSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb2snLFxuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmdldEN1cnJlbmN5TmFtZSAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICd3aXRoZHJhd190eXBlJzogbmFtZSxcbiAgICAgICAgICAgICd3YWxsZXRzZWxlY3RlZCc6ICdleGNoYW5nZScsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHJlc3BvbnNlc1swXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnd2l0aGRyYXdhbF9pZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3YyJykge1xuICAgICAgICAgICAgcmVxdWVzdCA9ICcvJyArIGFwaSArIHJlcXVlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gJy8nICsgdGhpcy52ZXJzaW9uICsgcmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgcmVxdWVzdDtcbiAgICAgICAgaWYgKChhcGkgPT0gJ3B1YmxpYycpIHx8IChwYXRoLmluZGV4T2YgKCcvaGlzdCcpID49IDApKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB1cmwgKz0gc3VmZml4O1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgKz0gc3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAgICAgJ3JlcXVlc3QnOiByZXF1ZXN0LFxuICAgICAgICAgICAgfSwgcXVlcnkpO1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5lbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gdGhpcy5zdHJpbmdUb0Jhc2U2NCAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjIChwYXlsb2FkLCBzZWNyZXQsICdzaGEzODQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtQkZYLUFQSUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdYLUJGWC1QQVlMT0FEJzogdGhpcy5kZWNvZGUgKHBheWxvYWQpLFxuICAgICAgICAgICAgICAgICdYLUJGWC1TSUdOQVRVUkUnOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3JzIChjb2RlLCByZWFzb24sIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIGlmIChjb2RlID09IDQwMCkge1xuICAgICAgICAgICAgaWYgKGJvZHlbMF0gPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBKU09OLnBhcnNlIChib2R5KTtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHJlc3BvbnNlWydtZXNzYWdlJ107XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5kZXhPZiAoJ0tleSBwcmljZSBzaG91bGQgYmUgYSBkZWNpbWFsIG51bWJlcicpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcmRlciAodGhpcy5pZCArICcgJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5pbmRleE9mICgnSW52YWxpZCBvcmRlcjogbm90IGVub3VnaCBleGNoYW5nZSBiYWxhbmNlJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50RnVuZHMgKHRoaXMuaWQgKyAnICcgKyBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuaW5kZXhPZiAoJ0ludmFsaWQgb3JkZXInKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3JkZXIgKHRoaXMuaWQgKyAnICcgKyBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuaW5kZXhPZiAoJ09yZGVyIGNvdWxkIG5vdCBiZSBjYW5jZWxsZWQuJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgYm9keSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgYml0ZmluZXggPSByZXF1aXJlICgnLi9iaXRmaW5leC5qcycpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIE5vdFN1cHBvcnRlZCwgSW5zdWZmaWNpZW50RnVuZHMgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYml0ZmluZXgyIGV4dGVuZHMgYml0ZmluZXgge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdGZpbmV4MicsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRmaW5leCB2MicsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG9sZCBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNEZXBvc2l0JzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hDbG9zZWRPcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ2ZldGNoQ2xvc2VkT3JkZXJzJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdCc6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcxbScsXG4gICAgICAgICAgICAgICAgJzVtJzogJzVtJyxcbiAgICAgICAgICAgICAgICAnMTVtJzogJzE1bScsXG4gICAgICAgICAgICAgICAgJzMwbSc6ICczMG0nLFxuICAgICAgICAgICAgICAgICcxaCc6ICcxaCcsXG4gICAgICAgICAgICAgICAgJzNoJzogJzNoJyxcbiAgICAgICAgICAgICAgICAnNmgnOiAnNmgnLFxuICAgICAgICAgICAgICAgICcxMmgnOiAnMTJoJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMUQnLFxuICAgICAgICAgICAgICAgICcxdyc6ICc3RCcsXG4gICAgICAgICAgICAgICAgJzJ3JzogJzE0RCcsXG4gICAgICAgICAgICAgICAgJzFNJzogJzFNJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYyNDQtZTMyOGE1MGMtNWVkMi0xMWU3LTk0N2ItMDQxNDE2NTc5YmIzLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5iaXRmaW5leC5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0ZmluZXguY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9iaXRmaW5leC5yZWFkbWUuaW8vdjIvZG9jcycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vYml0ZmluZXhjb20vYml0ZmluZXgtYXBpLW5vZGUnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2ZlZXMnOiAnaHR0cHM6Ly93d3cuYml0ZmluZXguY29tL2ZlZXMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGF0Zm9ybS9zdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlci97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL3tzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0ve3ByZWNpc2lvbn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0vUDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0vUDEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0vUDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0vUDMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0vUjAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbHNfZGV0YWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHMxL3trZXl9OntzaXplfTp7c3ltYm9sfS97c2lkZX0ve3NlY3Rpb259JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGF0czEve2tleX06e3NpemV9OntzeW1ib2x9L2xvbmcvbGFzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHMxL3trZXl9OntzaXplfTp7c3ltYm9sfS9sb25nL2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXRzMS97a2V5fTp7c2l6ZX06e3N5bWJvbH0vc2hvcnQvbGFzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHMxL3trZXl9OntzaXplfTp7c3ltYm9sfS9zaG9ydC9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5kbGVzL3RyYWRlOnt0aW1lZnJhbWV9OntzeW1ib2x9L3tzZWN0aW9ufScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuZGxlcy90cmFkZTp7dGltZWZyYW1lfTp7c3ltYm9sfS9sYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5kbGVzL3RyYWRlOnt0aW1lZnJhbWV9OntzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYWxjL3RyYWRlL2F2ZycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL3dhbGxldHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9vcmRlcnMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9vcmRlcnMve3N5bWJvbH0vbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3Ivb3JkZXJzL3tzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9vcmRlci97c3ltYm9sfTp7aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL3RyYWRlcy97c3ltYm9sfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvcG9zaXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvZnVuZGluZy9vZmZlcnMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgvci9mdW5kaW5nL29mZmVycy97c3ltYm9sfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvZnVuZGluZy9sb2Fucy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL2Z1bmRpbmcvbG9hbnMve3N5bWJvbH0vaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL2Z1bmRpbmcvY3JlZGl0cy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL2Z1bmRpbmcvY3JlZGl0cy97c3ltYm9sfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvZnVuZGluZy90cmFkZXMve3N5bWJvbH0vaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL2luZm8vbWFyZ2luL3trZXl9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvaW5mby9mdW5kaW5nL3trZXl9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdXRoL3IvbW92ZW1lbnRzL3tjdXJyZW5jeX0vaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL3N0YXRzL3BlcmY6e3RpbWVmcmFtZX0vaGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9yL2FsZXJ0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC93L2FsZXJ0L3NldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC93L2FsZXJ0L3t0eXBlfTp7c3ltYm9sfTp7cHJpY2V9L2RlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXV0aC9jYWxjL29yZGVyL2F2YWlsJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdBVlQvQlRDJzogeyAnaWQnOiAndEFWVEJUQycsICdzeW1ib2wnOiAnQVZUL0JUQycsICdiYXNlJzogJ0FWVCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0FWVC9FVEgnOiB7ICdpZCc6ICd0QVZURVRIJywgJ3N5bWJvbCc6ICdBVlQvRVRIJywgJ2Jhc2UnOiAnQVZUJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnQVZUL1VTRCc6IHsgJ2lkJzogJ3RBVlRVU0QnLCAnc3ltYm9sJzogJ0FWVC9VU0QnLCAnYmFzZSc6ICdBVlQnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdDU1RfQkNDL0JUQyc6IHsgJ2lkJzogJ3RCQ0NCVEMnLCAnc3ltYm9sJzogJ0NTVF9CQ0MvQlRDJywgJ2Jhc2UnOiAnQ1NUX0JDQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0NTVF9CQ0MvVVNEJzogeyAnaWQnOiAndEJDQ1VTRCcsICdzeW1ib2wnOiAnQ1NUX0JDQy9VU0QnLCAnYmFzZSc6ICdDU1RfQkNDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQkNIL0JUQyc6IHsgJ2lkJzogJ3RCQ0hCVEMnLCAnc3ltYm9sJzogJ0JDSC9CVEMnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdCQ0gvRVRIJzogeyAnaWQnOiAndEJDSEVUSCcsICdzeW1ib2wnOiAnQkNIL0VUSCcsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdFVEgnIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9VU0QnOiB7ICdpZCc6ICd0QkNIVVNEJywgJ3N5bWJvbCc6ICdCQ0gvVVNEJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQ1NUX0JDVS9CVEMnOiB7ICdpZCc6ICd0QkNVQlRDJywgJ3N5bWJvbCc6ICdDU1RfQkNVL0JUQycsICdiYXNlJzogJ0NTVF9CQ1UnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdDU1RfQkNVL1VTRCc6IHsgJ2lkJzogJ3RCQ1VVU0QnLCAnc3ltYm9sJzogJ0NTVF9CQ1UvVVNEJywgJ2Jhc2UnOiAnQ1NUX0JDVScsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUMS9CVEMnOiB7ICdpZCc6ICd0QlQxQlRDJywgJ3N5bWJvbCc6ICdCVDEvQlRDJywgJ2Jhc2UnOiAnQlQxJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnQlQxL1VTRCc6IHsgJ2lkJzogJ3RCVDFVU0QnLCAnc3ltYm9sJzogJ0JUMS9VU0QnLCAnYmFzZSc6ICdCVDEnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdCVDIvQlRDJzogeyAnaWQnOiAndEJUMkJUQycsICdzeW1ib2wnOiAnQlQyL0JUQycsICdiYXNlJzogJ0JUMicsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0JUMi9VU0QnOiB7ICdpZCc6ICd0QlQyVVNEJywgJ3N5bWJvbCc6ICdCVDIvVVNEJywgJ2Jhc2UnOiAnQlQyJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ3RCVENVU0QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvRVVSJzogeyAnaWQnOiAndEJUQ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICAgICAgJ0JURy9CVEMnOiB7ICdpZCc6ICd0QlRHQlRDJywgJ3N5bWJvbCc6ICdCVEcvQlRDJywgJ2Jhc2UnOiAnQlRHJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnQlRHL1VTRCc6IHsgJ2lkJzogJ3RCVEdVU0QnLCAnc3ltYm9sJzogJ0JURy9VU0QnLCAnYmFzZSc6ICdCVEcnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdEQVNIL0JUQyc6IHsgJ2lkJzogJ3REU0hCVEMnLCAnc3ltYm9sJzogJ0RBU0gvQlRDJywgJ2Jhc2UnOiAnREFTSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0RBU0gvVVNEJzogeyAnaWQnOiAndERTSFVTRCcsICdzeW1ib2wnOiAnREFTSC9VU0QnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnREFUL0JUQyc6IHsgJ2lkJzogJ3REQVRCVEMnLCAnc3ltYm9sJzogJ0RBVC9CVEMnLCAnYmFzZSc6ICdEQVQnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdEQVQvRVRIJzogeyAnaWQnOiAndERBVEVUSCcsICdzeW1ib2wnOiAnREFUL0VUSCcsICdiYXNlJzogJ0RBVCcsICdxdW90ZSc6ICdFVEgnIH0sXG4gICAgICAgICAgICAgICAgJ0RBVC9VU0QnOiB7ICdpZCc6ICd0REFUVVNEJywgJ3N5bWJvbCc6ICdEQVQvVVNEJywgJ2Jhc2UnOiAnREFUJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnRURPL0JUQyc6IHsgJ2lkJzogJ3RFRE9CVEMnLCAnc3ltYm9sJzogJ0VETy9CVEMnLCAnYmFzZSc6ICdFRE8nLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdFRE8vRVRIJzogeyAnaWQnOiAndEVET0VUSCcsICdzeW1ib2wnOiAnRURPL0VUSCcsICdiYXNlJzogJ0VETycsICdxdW90ZSc6ICdFVEgnIH0sXG4gICAgICAgICAgICAgICAgJ0VETy9VU0QnOiB7ICdpZCc6ICd0RURPVVNEJywgJ3N5bWJvbCc6ICdFRE8vVVNEJywgJ2Jhc2UnOiAnRURPJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnRU9TL0JUQyc6IHsgJ2lkJzogJ3RFT1NCVEMnLCAnc3ltYm9sJzogJ0VPUy9CVEMnLCAnYmFzZSc6ICdFT1MnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdFT1MvRVRIJzogeyAnaWQnOiAndEVPU0VUSCcsICdzeW1ib2wnOiAnRU9TL0VUSCcsICdiYXNlJzogJ0VPUycsICdxdW90ZSc6ICdFVEgnIH0sXG4gICAgICAgICAgICAgICAgJ0VPUy9VU0QnOiB7ICdpZCc6ICd0RU9TVVNEJywgJ3N5bWJvbCc6ICdFT1MvVVNEJywgJ2Jhc2UnOiAnRU9TJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnRVRDL0JUQyc6IHsgJ2lkJzogJ3RFVENCVEMnLCAnc3ltYm9sJzogJ0VUQy9CVEMnLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdFVEMvVVNEJzogeyAnaWQnOiAndEVUQ1VTRCcsICdzeW1ib2wnOiAnRVRDL1VTRCcsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9CVEMnOiB7ICdpZCc6ICd0RVRIQlRDJywgJ3N5bWJvbCc6ICdFVEgvQlRDJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnRVRIL1VTRCc6IHsgJ2lkJzogJ3RFVEhVU0QnLCAnc3ltYm9sJzogJ0VUSC9VU0QnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdFVFAvQlRDJzogeyAnaWQnOiAndEVUUEJUQycsICdzeW1ib2wnOiAnRVRQL0JUQycsICdiYXNlJzogJ0VUUCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0VUUC9FVEgnOiB7ICdpZCc6ICd0RVRQRVRIJywgJ3N5bWJvbCc6ICdFVFAvRVRIJywgJ2Jhc2UnOiAnRVRQJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnRVRQL1VTRCc6IHsgJ2lkJzogJ3RFVFBVU0QnLCAnc3ltYm9sJzogJ0VUUC9VU0QnLCAnYmFzZSc6ICdFVFAnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdJT1RBL0JUQyc6IHsgJ2lkJzogJ3RJT1RCVEMnLCAnc3ltYm9sJzogJ0lPVEEvQlRDJywgJ2Jhc2UnOiAnSU9UQScsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0lPVEEvRVRIJzogeyAnaWQnOiAndElPVEVUSCcsICdzeW1ib2wnOiAnSU9UQS9FVEgnLCAnYmFzZSc6ICdJT1RBJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgICAgICAgICAnSU9UQS9VU0QnOiB7ICdpZCc6ICd0SU9UVVNEJywgJ3N5bWJvbCc6ICdJT1RBL1VTRCcsICdiYXNlJzogJ0lPVEEnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAndExUQ0JUQycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9VU0QnOiB7ICdpZCc6ICd0TFRDVVNEJywgJ3N5bWJvbCc6ICdMVEMvVVNEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnTkVPL0JUQyc6IHsgJ2lkJzogJ3RORU9CVEMnLCAnc3ltYm9sJzogJ05FTy9CVEMnLCAnYmFzZSc6ICdORU8nLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdORU8vRVRIJzogeyAnaWQnOiAndE5FT0VUSCcsICdzeW1ib2wnOiAnTkVPL0VUSCcsICdiYXNlJzogJ05FTycsICdxdW90ZSc6ICdFVEgnIH0sXG4gICAgICAgICAgICAgICAgJ05FTy9VU0QnOiB7ICdpZCc6ICd0TkVPVVNEJywgJ3N5bWJvbCc6ICdORU8vVVNEJywgJ2Jhc2UnOiAnTkVPJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnT01HL0JUQyc6IHsgJ2lkJzogJ3RPTUdCVEMnLCAnc3ltYm9sJzogJ09NRy9CVEMnLCAnYmFzZSc6ICdPTUcnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdPTUcvRVRIJzogeyAnaWQnOiAndE9NR0VUSCcsICdzeW1ib2wnOiAnT01HL0VUSCcsICdiYXNlJzogJ09NRycsICdxdW90ZSc6ICdFVEgnIH0sXG4gICAgICAgICAgICAgICAgJ09NRy9VU0QnOiB7ICdpZCc6ICd0T01HVVNEJywgJ3N5bWJvbCc6ICdPTUcvVVNEJywgJ2Jhc2UnOiAnT01HJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnUVRVTS9CVEMnOiB7ICdpZCc6ICd0UVRNQlRDJywgJ3N5bWJvbCc6ICdRVFVNL0JUQycsICdiYXNlJzogJ1FUVU0nLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdRVFVNL0VUSCc6IHsgJ2lkJzogJ3RRVE1FVEgnLCAnc3ltYm9sJzogJ1FUVU0vRVRIJywgJ2Jhc2UnOiAnUVRVTScsICdxdW90ZSc6ICdFVEgnIH0sXG4gICAgICAgICAgICAgICAgJ1FUVU0vVVNEJzogeyAnaWQnOiAndFFUTVVTRCcsICdzeW1ib2wnOiAnUVRVTS9VU0QnLCAnYmFzZSc6ICdRVFVNJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnUlJUL0JUQyc6IHsgJ2lkJzogJ3RSUlRCVEMnLCAnc3ltYm9sJzogJ1JSVC9CVEMnLCAnYmFzZSc6ICdSUlQnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdSUlQvVVNEJzogeyAnaWQnOiAndFJSVFVTRCcsICdzeW1ib2wnOiAnUlJUL1VTRCcsICdiYXNlJzogJ1JSVCcsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ1NBTi9CVEMnOiB7ICdpZCc6ICd0U0FOQlRDJywgJ3N5bWJvbCc6ICdTQU4vQlRDJywgJ2Jhc2UnOiAnU0FOJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnU0FOL0VUSCc6IHsgJ2lkJzogJ3RTQU5FVEgnLCAnc3ltYm9sJzogJ1NBTi9FVEgnLCAnYmFzZSc6ICdTQU4nLCAncXVvdGUnOiAnRVRIJyB9LFxuICAgICAgICAgICAgICAgICdTQU4vVVNEJzogeyAnaWQnOiAndFNBTlVTRCcsICdzeW1ib2wnOiAnU0FOL1VTRCcsICdiYXNlJzogJ1NBTicsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICAgICAgJ1hNUi9CVEMnOiB7ICdpZCc6ICd0WE1SQlRDJywgJ3N5bWJvbCc6ICdYTVIvQlRDJywgJ2Jhc2UnOiAnWE1SJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnWE1SL1VTRCc6IHsgJ2lkJzogJ3RYTVJVU0QnLCAnc3ltYm9sJzogJ1hNUi9VU0QnLCAnYmFzZSc6ICdYTVInLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdYUlAvQlRDJzogeyAnaWQnOiAndFhSUEJUQycsICdzeW1ib2wnOiAnWFJQL0JUQycsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ1hSUC9VU0QnOiB7ICdpZCc6ICd0WFJQVVNEJywgJ3N5bWJvbCc6ICdYUlAvVVNEJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnWkVDL0JUQyc6IHsgJ2lkJzogJ3RaRUNCVEMnLCAnc3ltYm9sJzogJ1pFQy9CVEMnLCAnYmFzZSc6ICdaRUMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdaRUMvVVNEJzogeyAnaWQnOiAndFpFQ1VTRCcsICdzeW1ib2wnOiAnWkVDL1VTRCcsICdiYXNlJzogJ1pFQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLjAwMDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkNIJzogMC4wMDA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUSCc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU9TJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xUQyc6IDAuMDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09NRyc6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJT1QnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTkVPJzogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUQyc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWFJQJzogMC4wMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVFAnOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pFQyc6IDAuMDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JURyc6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQVNIJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYTVInOiAwLjA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1FUTSc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRURPJzogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBVCc6IDEuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBVlQnOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0FOJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VTRFQnOiA1LjAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgLy8gaXNzdWUgIzQgQml0ZmluZXggbmFtZXMgRGFzaCBhcyBEU0gsIGluc3RlYWQgb2YgREFTSFxuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RTSCcpXG4gICAgICAgICAgICByZXR1cm4gJ0RBU0gnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1FUTScpXG4gICAgICAgICAgICByZXR1cm4gJ1FUVU0nO1xuICAgICAgICAvLyBpc3N1ZSAjNzk2XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnSU9UJylcbiAgICAgICAgICAgIHJldHVybiAnSU9UQSc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RBdXRoUldhbGxldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlVHlwZSA9IHRoaXMuc2FmZVN0cmluZyAocGFyYW1zLCAndHlwZScsICdleGNoYW5nZScpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgcmVzcG9uc2UubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbYl07XG4gICAgICAgICAgICBsZXQgWyBhY2NvdW50VHlwZSwgY3VycmVuY3ksIHRvdGFsLCBpbnRlcmVzdCwgYXZhaWxhYmxlIF0gPSBiYWxhbmNlO1xuICAgICAgICAgICAgaWYgKGFjY291bnRUeXBlID09IGJhbGFuY2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5WzBdID09ICd0JylcbiAgICAgICAgICAgICAgICAgICAgY3VycmVuY3kgPSBjdXJyZW5jeS5zbGljZSAoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIHVwcGVyY2FzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGF2YWlsYWJsZTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdG90YWw7XG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnRbJ2ZyZWUnXSlcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJvb2tTeW1ib2xQcmVjaXNpb24gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdwcmVjaXNpb24nOiAnUjAnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiBbXSxcbiAgICAgICAgICAgICdhc2tzJzogW10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyYm9vay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gb3JkZXJib29rW2ldO1xuICAgICAgICAgICAgbGV0IHByaWNlID0gb3JkZXJbMV07XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gb3JkZXJbMl07XG4gICAgICAgICAgICBsZXQgc2lkZSA9IChhbW91bnQgPiAwKSA/ICdiaWRzJyA6ICdhc2tzJztcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGguYWJzIChhbW91bnQpO1xuICAgICAgICAgICAgcmVzdWx0W3NpZGVdLnB1c2ggKFsgcHJpY2UsIGFtb3VudCBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRpY2tlci5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGlja2VyW2xlbmd0aCAtIDJdLFxuICAgICAgICAgICAgJ2xvdyc6IHRpY2tlcltsZW5ndGggLSAxXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbbGVuZ3RoIC0gMTBdLFxuICAgICAgICAgICAgJ2Fzayc6IHRpY2tlcltsZW5ndGggLSA4XSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRpY2tlcltsZW5ndGggLSA0XSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB0aWNrZXJbbGVuZ3RoIC0gNl0sXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHRpY2tlcltsZW5ndGggLSA1XSxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aWNrZXJbbGVuZ3RoIC0gM10sXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbHMnOiB0aGlzLmlkcy5qb2luICgnLCcpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWzBdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCBbIGlkLCB0aW1lc3RhbXAsIGFtb3VudCwgcHJpY2UgXSA9IHRyYWRlO1xuICAgICAgICBsZXQgc2lkZSA9IChhbW91bnQgPCAwKSA/ICdzZWxsJyA6ICdidXknO1xuICAgICAgICBpZiAoYW1vdW50IDwgMCkge1xuICAgICAgICAgICAgYW1vdW50ID0gLWFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNpbmNlKSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydCddID0gc2luY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNTeW1ib2xIaXN0ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lZnJhbWUnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydCddID0gc2luY2U7XG4gICAgICAgIHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDYW5kbGVzVHJhZGVUaW1lZnJhbWVTeW1ib2xIaXN0IChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBjcmVhdGVPcmRlciBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfVxuXG4gICAgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9yZGVyIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgd2l0aGRyYXcgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyByZXF1ZXN0O1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gJy9hcGknICsgJy8nICsgcmVxdWVzdCArIG5vbmNlICsgYm9keTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTM4NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnYmZ4LW5vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ2JmeC1hcGlrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnYmZ4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICgnbWVzc2FnZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXS5pbmRleE9mICgnbm90IGVub3VnaCBleGNoYW5nZSBiYWxhbmNlJykgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlID09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcmV0dXJuZWQgZW1wdHkgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdGZseWVyIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdGZseWVyJyxcbiAgICAgICAgICAgICduYW1lJzogJ2JpdEZseWVyJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSlAnLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODA1MTY0Mi01NjE1NDE4Mi02NjBlLTExZTctOWIwZC02MDQyZDFlNmVkZDguanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJpdGZseWVyLmpwJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYml0Zmx5ZXIuanAnLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9iaXRmbHllci5qcC9BUEknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRtYXJrZXRzJywgICAgLy8gb3IgJ21hcmtldHMnXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0Ym9hcmQnLCAgICAgIC8vIG9yICdib2FyZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXR0aWNrZXInLCAgICAgLy8gb3IgJ3RpY2tlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRleGVjdXRpb25zJywgLy8gb3IgJ2V4ZWN1dGlvbnMnXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0aGVhbHRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRjaGF0cycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRwZXJtaXNzaW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0YmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0Y29sbGF0ZXJhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0Y29sbGF0ZXJhbGFjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRhZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGNvaW5pbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGNvaW5vdXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRiYW5rYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGRlcG9zaXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXR3aXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0Y2hpbGRvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldHBhcmVudG9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0cGFyZW50b3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGV4ZWN1dGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldHBvc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0dHJhZGluZ2NvbW1pc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZW5kY29pbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbmRjaGlsZG9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxjaGlsZG9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZW5kcGFyZW50b3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbHBhcmVudG9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxhbGxjaGlsZG9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4yNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yNSAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsncHJvZHVjdF9jb2RlJ107XG4gICAgICAgICAgICBsZXQgY3VycmVuY2llcyA9IGlkLnNwbGl0ICgnXycpO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQ7XG4gICAgICAgICAgICBsZXQgbnVtQ3VycmVuY2llcyA9IGN1cnJlbmNpZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG51bUN1cnJlbmNpZXMgPT0gMSkge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBzeW1ib2wuc2xpY2UgKDAsIDMpO1xuICAgICAgICAgICAgICAgIHF1b3RlID0gc3ltYm9sLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQ3VycmVuY2llcyA9PSAyKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGN1cnJlbmNpZXNbMF07XG4gICAgICAgICAgICAgICAgcXVvdGUgPSBjdXJyZW5jaWVzWzFdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGN1cnJlbmNpZXNbMV07XG4gICAgICAgICAgICAgICAgcXVvdGUgPSBjdXJyZW5jaWVzWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRCYWxhbmNlICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCByZXNwb25zZS5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSByZXNwb25zZVtiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGFjY291bnRbJ2N1cnJlbmN5X2NvZGUnXTtcbiAgICAgICAgICAgIGJhbGFuY2VzW2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBiYWxhbmNlc1tjdXJyZW5jeV1bJ2Ftb3VudCddO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VzW2N1cnJlbmN5XVsnYXZhaWxhYmxlJ107XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRCb2FyZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwcm9kdWN0X2NvZGUnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ3NpemUnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncHJvZHVjdF9jb2RlJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodGlja2VyWyd0aW1lc3RhbXAnXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Jlc3RfYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmVzdF9hc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2x0cCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV9ieV9wcm9kdWN0J10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG9yZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3NpZGUnIGluIHRyYWRlKVxuICAgICAgICAgICAgaWYgKHRyYWRlWydzaWRlJ10pIHtcbiAgICAgICAgICAgICAgICBzaWRlID0gdHJhZGVbJ3NpZGUnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBzaWRlICsgJ19jaGlsZF9vcmRlcl9hY2NlcHRhbmNlX2lkJztcbiAgICAgICAgICAgICAgICBpZiAoaWQgaW4gdHJhZGUpXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID0gdHJhZGVbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydleGVjX2RhdGUnXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiBvcmRlcixcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ3NpemUnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGVjdXRpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3Byb2R1Y3RfY29kZSc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwcm9kdWN0X2NvZGUnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2NoaWxkX29yZGVyX3R5cGUnOiB0eXBlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnc2l6ZSc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RTZW5kY2hpbGRvcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydjaGlsZF9vcmRlcl9hY2NlcHRhbmNlX2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsY2hpbGRvcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYXJlbnRfb3JkZXJfaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9jb2RlJzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgLy8gJ2JhbmtfYWNjb3VudF9pZCc6IDEyMzQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydtZXNzYWdlX2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9ICcvJyArIHRoaXMudmVyc2lvbiArICcvJztcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpXG4gICAgICAgICAgICByZXF1ZXN0ICs9ICdtZS8nO1xuICAgICAgICByZXF1ZXN0ICs9IHBhdGg7XG4gICAgICAgIGlmIChtZXRob2QgPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVxdWVzdCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHJlcXVlc3Q7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBbIG5vbmNlLCBtZXRob2QsIHJlcXVlc3QsIGJvZHkgXS5qb2luICgnJyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBQ0NFU1MtS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FDQ0VTUy1USU1FU1RBTVAnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQUNDRVNTLVNJR04nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBOb3RTdXBwb3J0ZWQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdGh1bWIgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYml0aHVtYicsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRodW1iJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnS1InLCAvLyBTb3V0aCBLb3JlYVxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDU5NzE3Ny1lYTgwMDE3Mi05ZDVlLTExZTctODA0Yy1iOWQ0ZmE5YjU2YjAuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmJpdGh1bWIuY29tL3B1YmxpYycsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmJpdGh1bWIuY29tJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0aHVtYi5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuYml0aHVtYi5jb20vdTEvVVMxMjcnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rL3tjdXJyZW5jeX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyYm9vay9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlY2VudF90cmFuc2FjdGlvbnMve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVjZW50X3RyYW5zYWN0aW9ucy9hbGwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZm8vYWNjb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mby9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvL3dhbGxldF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvL3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mby9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZm8vdXNlcl90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlL3BsYWNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvL29yZGVyX2RldGFpbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS9idGNfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUva3J3X2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlL2tyd193aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS9tYXJrZXRfYnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS9tYXJrZXRfc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4xNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4xNSAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlckFsbCAoKTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAobWFya2V0c1snZGF0YSddKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBpZiAoaWQgIT0gJ2RhdGUnKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ2RhdGEnXVtpZF07XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBpZDtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGUgPSAnS1JXJztcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5leHRlbmQgKHRoaXMuZmVlc1sndHJhZGluZyddLCB7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAgICAgJ2xvdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYW1vdW50JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEluZm9CYWxhbmNlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogJ0FMTCcsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlcywgJ3RvdGFsXycgKyBsb3dlcmNhc2UpO1xuICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2VzLCAnaW5fdXNlXycgKyBsb3dlcmNhc2UpO1xuICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2VzLCAnYXZhaWxhYmxlXycgKyBsb3dlcmNhc2UpO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2tDdXJyZW5jeSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb3VudCc6IDUwLCAvLyBtYXggPSA1MFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ3F1YW50aXR5Jyk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodGlja2VyWydkYXRlJ10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbWF4X3ByaWNlJyksXG4gICAgICAgICAgICAnbG93JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ21pbl9wcmljZScpLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdidXlfcHJpY2UnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnc2VsbF9wcmljZScpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdvcGVuaW5nX3ByaWNlJyksXG4gICAgICAgICAgICAnY2xvc2UnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnY2xvc2luZ19wcmljZScpLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdF90cmFkZScpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXZlcmFnZV9wcmljZScpLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sdW1lXzFkYXknKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJBbGwgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHJlc3BvbnNlWydkYXRhJ11bJ2RhdGUnXTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSB0aGlzLm9taXQgKHJlc3BvbnNlWydkYXRhJ10sICdkYXRlJyk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQ7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHRpY2tlclsnZGF0ZSddID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyQ3VycmVuY3kgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyIChyZXNwb25zZVsnZGF0YSddLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgLy8gYSB3b3JrYXJvdW5kIGZvciB0aGVpciBidWcgaW4gZGF0ZSBmb3JtYXQsIGhvdXJzIGFyZSBub3QgMC1wYWRkZWRcbiAgICAgICAgbGV0IFsgdHJhbnNhY3Rpb25fZGF0ZSwgdHJhbnNhY3Rpb25fdGltZSBdID0gdHJhZGVbJ3RyYW5zYWN0aW9uX2RhdGUnXS5zcGxpdCAoJyAnKTtcbiAgICAgICAgbGV0IHRyYW5zYWN0aW9uX3RpbWVfc2hvcnQgPSB0cmFuc2FjdGlvbl90aW1lLmxlbmd0aCA8IDg7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbl90aW1lX3Nob3J0KVxuICAgICAgICAgICAgdHJhbnNhY3Rpb25fdGltZSA9ICcwJyArIHRyYW5zYWN0aW9uX3RpbWU7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhbnNhY3Rpb25fZGF0ZSArICcgJyArIHRyYW5zYWN0aW9uX3RpbWUpO1xuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsndHlwZSddID09ICdhc2snKSA/ICdzZWxsJyA6ICdidXknO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWyd1bml0c190cmFkZWQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UmVjZW50VHJhbnNhY3Rpb25zQ3VycmVuY3kgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICdjb3VudCc6IDEwMCwgLy8gbWF4ID0gMTAwXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ2RhdGEnXSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIHByaXZhdGUgQVBJIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgLy8gICAgIGxldCBwcmVmaXggPSAnJztcbiAgICAgICAgLy8gICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAvLyAgICAgICAgIHByZWZpeCA9ICdtYXJrZXRfJztcbiAgICAgICAgLy8gICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgLy8gICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIC8vICAgICAgICAgJ3F1YW50aXR5JzogYW1vdW50LFxuICAgICAgICAvLyAgICAgICAgICdwcmljZSc6IHByaWNlIHx8IDAsXG4gICAgICAgIC8vICAgICAgICAgJ3R5cGUnOiBwcmVmaXggKyBzaWRlLFxuICAgICAgICAvLyAgICAgfTtcbiAgICAgICAgLy8gICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlckNyZWF0ZSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgLy8gICAgIHJldHVybiB7XG4gICAgICAgIC8vICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgLy8gICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJfaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgLy8gICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBzaWRlID0gKCdzaWRlJyBpbiBwYXJhbXMpO1xuICAgICAgICBpZiAoIXNpZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgcmVxdWlyZXMgYSBzaWRlIHBhcmFtZXRlciAoc2VsbCBvciBidXkpJyk7XG4gICAgICAgIHNpZGUgPSAoc2lkZSA9PSAnYnV5JykgPyAncHVyY2hhc2UnIDogJ3NhbGVzJztcbiAgICAgICAgbGV0IGN1cnJlbmN5ID0gKCdjdXJyZW5jeScgaW4gcGFyYW1zKTtcbiAgICAgICAgaWYgKCFjdXJyZW5jeSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlciByZXF1aXJlcyBhIGN1cnJlbmN5IHBhcmFtZXRlcicpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlQ2FuY2VsICh7XG4gICAgICAgICAgICAnb3JkZXJfaWQnOiBpZCxcbiAgICAgICAgICAgICd0eXBlJzogcGFyYW1zWydzaWRlJ10sXG4gICAgICAgICAgICAnY3VycmVuY3knOiBwYXJhbXNbJ2N1cnJlbmN5J10sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGVuZHBvaW50ID0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgZW5kcG9pbnQ7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2VuZHBvaW50JzogZW5kcG9pbnQsXG4gICAgICAgICAgICB9LCBxdWVyeSkpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gZW5kcG9pbnQgKyBcIlxcMFwiICsgYm9keSArIFwiXFwwXCIgKyBub25jZTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXBpLUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdBcGktU2lnbic6IHRoaXMuZGVjb2RlICh0aGlzLnN0cmluZ1RvQmFzZTY0ICh0aGlzLmVuY29kZSAoc2lnbmF0dXJlKSkpLFxuICAgICAgICAgICAgICAgICdBcGktTm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdGF0dXMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddID09ICcwMDAwJylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgTm90U3VwcG9ydGVkIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXRsaXNoIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdGxpc2gnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQml0bGlzaCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnR0InLCAnRVUnLCAnUlUnIF0sXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2Mjc1LWRjZmM2YzMwLTVlZDMtMTFlNy04MzlkLTAwYTg0NjM4NWQwYi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9iaXRsaXNoLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9iaXRsaXNoLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2JpdGxpc2guY29tL2FwaScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4zIC8gMTAwLCAvLyBhbm9ueW1vdXMgMC4zJSwgdmVyaWZpZWQgMC4yJVxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAuMDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xUQyc6IDAuMDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RPR0UnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYTVInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pFQyc6IDAuMDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLjAwMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVVSJzogNTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZXBvc2l0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdET0dFJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hNUic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWkVDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQVNIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVVInOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luc3RydW1lbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvaGxjdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFpcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlc19kZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzX2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0cnVtZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2hsY3YnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhaXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXNfZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlc19oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50c19vcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfdHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF90cmFkZXNfYnlfaWRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfYWxsX3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3JlYXRlX2Jjb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcmVhdGVfdGVtcGxhdGVfd2FsbGV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcmVhdGVfdHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RfYWNjb3VudHNfb3BlcmF0aW9uc19mcm9tX3RzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0X2FjdGl2ZV90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RfYmNvZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0X215X21hdGNoZXNfZnJvbV90cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdF9teV90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RfbXlfdHJhZHNfZnJvbV90cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdF9wYXltZW50X21ldGhvZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RfcGF5bWVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZGVlbV9jb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXNpZ24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NpZ25pbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2lnbm91dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVfZGV0YWlscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVfb3B0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2J5X2lkJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoIXRoaXMuc3Vic3RpdHV0ZUNvbW1vbkN1cnJlbmN5Q29kZXMpXG4gICAgICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnWEJUJylcbiAgICAgICAgICAgIHJldHVybiAnQlRDJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCQ0MnKVxuICAgICAgICAgICAgcmV0dXJuICdCQ0gnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RSSycpXG4gICAgICAgICAgICByZXR1cm4gJ0RBU0gnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RTSCcpXG4gICAgICAgICAgICBjdXJyZW5jeSA9ICdEQVNIJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdYREcnKVxuICAgICAgICAgICAgY3VycmVuY3kgPSAnRE9HRSc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0UGFpcnMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAobWFya2V0cyk7XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwga2V5cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNba2V5c1twXV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdtYXgnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbWluJyksXG4gICAgICAgICAgICAnYmlkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Fzayc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnZmlyc3QnKSxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdwcmMnKSxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnc3VtJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1ttYXJrZXRbJ2lkJ11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICAvLyBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBub3cgPSB0aGlzLnNlY29uZHMgKCk7XG4gICAgICAgIGxldCBzdGFydCA9IG5vdyAtIDg2NDAwICogMzA7IC8vIGxhc3QgMzAgZGF5c1xuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBbIHN0YXJ0LnRvU3RyaW5nICgpLCB1bmRlZmluZWQgXTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHVibGljUG9zdE9obGN2ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3RpbWVfcmFuZ2UnOiBpbnRlcnZhbCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzRGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcl9pZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHBhcnNlSW50IChvcmRlcmJvb2tbJ2xhc3QnXSkgLyAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnYmlkJywgJ2FzaycsICdwcmljZScsICd2b2x1bWUnKTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWydkaXInXSA9PSAnYmlkJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2NyZWF0ZWQnXSAvIDEwMDApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzSGlzdG9yeSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyX2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydsaXN0J10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHJlc3BvbnNlKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSByZXNwb25zZVtjdXJyZW5jeV07XG4gICAgICAgICAgICBjdXJyZW5jeSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgLy8gaXNzdWUgIzQgYml0bGlzaCBuYW1lcyBEYXNoIGFzIERTSCwgaW5zdGVhZCBvZiBEQVNIXG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0RTSCcpXG4gICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnREFTSCc7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1hERycpXG4gICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnRE9HRSc7XG4gICAgICAgICAgICBiYWxhbmNlW2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2Z1bmRzJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydob2xkZWQnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgc2lnbkluICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RTaWduaW4gKHtcbiAgICAgICAgICAgICdsb2dpbic6IHRoaXMubG9naW4sXG4gICAgICAgICAgICAncGFzc3dkJzogdGhpcy5wYXNzd29yZCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXJfaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2Rpcic6IChzaWRlID09ICdidXknKSA/ICdiaWQnIDogJ2FzaycsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDcmVhdGVUcmFkZSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbFRyYWRlICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBpZiAoY3VycmVuY3kgIT0gJ0JUQycpIHtcbiAgICAgICAgICAgIC8vIHRoZXkgZGlkIG5vdCBkb2N1bWVudCBvdGhlciB0eXBlcy4uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgY3VycmVudGx5IHN1cHBvcnRzIEJUQyB3aXRoZHJhd2FscyBvbmx5LCB1bnRpbCB0aGV5IGRvY3VtZW50IG90aGVyIGN1cnJlbmNpZXMuLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0IChhbW91bnQpLFxuICAgICAgICAgICAgJ2FjY291bnQnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3BheW1lbnRfbWV0aG9kJzogJ2JpdGNvaW4nLCAvLyB0aGV5IGRpZCBub3QgZG9jdW1lbnQgb3RoZXIgdHlwZXMuLi5cbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ21lc3NhZ2VfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh0aGlzLmV4dGVuZCAoeyAndG9rZW4nOiB0aGlzLmFwaUtleSB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdG1hcmtldCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXRtYXJrZXQnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQml0TWFya2V0JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdQTCcsICdFVScgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnOTBtJzogJzkwbScsXG4gICAgICAgICAgICAgICAgJzZoJzogJzZoJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMWQnLFxuICAgICAgICAgICAgICAgICcxdyc6ICc3ZCcsXG4gICAgICAgICAgICAgICAgJzFNJzogJzFtJyxcbiAgICAgICAgICAgICAgICAnM00nOiAnM20nLFxuICAgICAgICAgICAgICAgICc2TSc6ICc2bScsXG4gICAgICAgICAgICAgICAgJzF5JzogJzF5JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY3MjU2LWE4NTU1MjAwLTVlZjktMTFlNy05NmZkLTQ2OWE2NWUyYjBiZC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly93d3cuYml0bWFya2V0Lm5ldCcsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vd3d3LmJpdG1hcmtldC5wbC9hcGkyLycsIC8vIGxhc3Qgc2xhc2ggaXMgY3JpdGljYWxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5iaXRtYXJrZXQucGwnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cuYml0bWFya2V0Lm5ldCcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cuYml0bWFya2V0Lm5ldC9kb2NzLnBocD9maWxlPWFwaV9wdWJsaWMuaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5iaXRtYXJrZXQubmV0L2RvY3MucGhwP2ZpbGU9YXBpX3ByaXZhdGUuaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vYml0bWFya2V0LW5ldC9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2pzb24ve21hcmtldH0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdqc29uL3ttYXJrZXR9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnanNvbi97bWFya2V0fS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2pzb24vY3RyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vOTBtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vNmgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyYXBocy97bWFya2V0fS8xZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ3JhcGhzL3ttYXJrZXR9LzdkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vMW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dyYXBocy97bWFya2V0fS8zbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ3JhcGhzL3ttYXJrZXR9LzZtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vMXknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZ2Rlc2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRpbmdkZXNrU3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkaW5nZGVza0NvbmZpcm0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyeXB0b3RyYWRpbmdkZXNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcnlwdG90cmFkaW5nZGVza1N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3J5cHRvdHJhZGluZ2Rlc2tDb25maXJtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdGaWF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd1BMTlBQJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd0ZpYXRGYXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5MaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5PcGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5DbG9zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luQ2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5Nb2RpZnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmdpbkJhbGFuY2VBZGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmdpbkJhbGFuY2VSZW1vdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N3YXBMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzd2FwT3BlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3dhcENsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvUExOJzogeyAnaWQnOiAnQlRDUExOJywgJ3N5bWJvbCc6ICdCVEMvUExOJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1BMTicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0JUQ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9QTE4nOiB7ICdpZCc6ICdMVENQTE4nLCAnc3ltYm9sJzogJ0xUQy9QTE4nLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnUExOJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnTGl0ZU1pbmVYL0JUQyc6IHsgJ2lkJzogJ0xpdGVNaW5lWEJUQycsICdzeW1ib2wnOiAnTGl0ZU1pbmVYL0JUQycsICdiYXNlJzogJ0xpdGVNaW5lWCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAncGVyY2VudGFnZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuNDUgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMTUgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0aWVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0YWtlcic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMCwgMC40NSAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzk5Ljk5LCAwLjQ0IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMjk5Ljk5LCAwLjQzIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNDk5Ljk5LCAwLjQyIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbOTk5Ljk5LCAwLjQxIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTk5OS45OSwgMC40MCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzI5OTkuOTksIDAuMzkgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs0OTk5Ljk5LCAwLjM4IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbOTk5OS45OSwgMC4zNyAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzE5OTk5Ljk5LCAwLjM2IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMjk5OTkuOTksIDAuMzUgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs0OTk5OS45OSwgMC4zNCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzk5OTk5Ljk5LCAwLjMzIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTk5OTk5Ljk5LCAwLjMyIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMjk5OTk5Ljk5LCAwLjMxIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNDk5OTk5Ljk5LCAwLjAgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYWtlcic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMCwgMC4xNSAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzk5Ljk5LCAwLjE0IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMjk5Ljk5LCAwLjEzIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNDk5Ljk5LCAwLjEyIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbOTk5Ljk5LCAwLjExIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTk5OS45OSwgMC4xMCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzI5OTkuOTksIDAuOSAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzQ5OTkuOTksIDAuOCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzk5OTkuOTksIDAuNyAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzE5OTk5Ljk5LCAwLjYgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsyOTk5OS45OSwgMC41IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNDk5OTkuOTksIDAuNCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzk5OTk5Ljk5LCAwLjMgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxOTk5OTkuOTksIDAuMiAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzI5OTk5OS45OSwgMC4xIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNDk5OTk5Ljk5LCAwLjAgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLjAwMDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFRDJzogMC4wMDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkNIJzogMC4wMDA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JURyc6IDAuMDAwOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdET0dFJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVVInOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BMTic6IDIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZXBvc2l0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQ0gnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JURyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE9HRSc6IDI1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VVUic6IDIsIC8vIFNFUEEuIFRyYW5zZmVyIElOVCAoU0hBKTogNSBFVVJcbiAgICAgICAgICAgICAgICAgICAgICAgICdQTE4nOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RJbmZvICgpO1xuICAgICAgICBsZXQgZGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCBiYWxhbmNlID0gZGF0YVsnYmFsYW5jZXMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBkYXRhIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2VbJ2F2YWlsYWJsZSddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VbJ2F2YWlsYWJsZSddW2N1cnJlbmN5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlWydibG9ja2VkJ10pXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYmFsYW5jZVsnYmxvY2tlZCddW2N1cnJlbmN5XTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEpzb25NYXJrZXRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdiaWRzJzogb3JkZXJib29rWydiaWRzJ10sXG4gICAgICAgICAgICAnYXNrcyc6IG9yZGVyYm9va1snYXNrcyddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRKc29uTWFya2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAnYmlkJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEpzb25NYXJrZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzkwbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbJ3RpbWUnXSAqIDEwMDAsXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnb3BlbiddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydoaWdoJ10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ2xvdyddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydjbG9zZSddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2Wyd2b2wnXSksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnOTBtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3B1YmxpY0dldEdyYXBoc01hcmtldCcgKyB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncmF0ZSc6IHByaWNlLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmICgnaWQnIGluIHJlc3BvbnNlWydvcmRlciddKVxuICAgICAgICAgICAgcmVzdWx0WydpZCddID0gcmVzcG9uc2VbJ2lkJ107XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGlzRmlhdCAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdFVVInKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnUExOJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmlzRmlhdCAoY3VycmVuY3kpKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAncHJpdmF0ZVBvc3RXaXRoZHJhd0ZpYXQnO1xuICAgICAgICAgICAgaWYgKCdhY2NvdW50JyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0WydhY2NvdW50J10gPSBwYXJhbXNbJ2FjY291bnQnXTsgLy8gYmFuayBhY2NvdW50IGNvZGUgZm9yIHdpdGhkcmF3YWxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIGFjY291bnQgcGFyYW1ldGVyIHRvIHdpdGhkcmF3IGZpYXQgY3VycmVuY3knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnYWNjb3VudDInIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RbJ2FjY291bnQyJ10gPSBwYXJhbXNbJ2FjY291bnQyJ107IC8vIGJhbmsgU1dJRlQgY29kZSAoRVVSIG9ubHkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRVVSJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIGFjY291bnQyIHBhcmFtZXRlciB0byB3aXRoZHJhdyBFVVInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnd2l0aGRyYXdhbF9ub3RlJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Wyd3aXRoZHJhd2FsX25vdGUnXSA9IHBhcmFtc1snd2l0aGRyYXdhbF9ub3RlJ107IC8vIGEgMTAtY2hhcmFjdGVyIHVzZXItc3BlY2lmaWVkIHdpdGhkcmF3YWwgbm90ZSAoUExOIG9ubHkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeSA9PSAnUExOJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIHdpdGhkcmF3YWxfbm90ZSBwYXJhbWV0ZXIgdG8gd2l0aGRyYXcgUExOJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAncHJpdmF0ZVBvc3RXaXRoZHJhdyc7XG4gICAgICAgICAgICByZXF1ZXN0WydhZGRyZXNzJ10gPSBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCArICcuanNvbicsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICd0b25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgfSwgcGFyYW1zKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQVBJLUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdBUEktSGFzaCc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYml0bWV4IGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdG1leCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRNRVgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdTQycsIC8vIFNleWNoZWxsZXNcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICd1c2VyQWdlbnQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFtJzogJzFtJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnNW0nLFxuICAgICAgICAgICAgICAgICcxaCc6ICcxaCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJzFkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAndGVzdCc6ICdodHRwczovL3Rlc3RuZXQuYml0bWV4LmNvbScsXG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjMxOS1mNjUzYzZlNi01ZWQ0LTExZTctOTMzZC1mMGJjMzY5OWFlOGYuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdG1leC5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0bWV4LmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LmJpdG1leC5jb20vYXBwL2FwaU92ZXJ2aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9CaXRNRVgvYXBpLWNvbm5lY3RvcnMvdHJlZS9tYXN0ZXIvb2ZmaWNpYWwtaHR0cCcsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5ub3VuY2VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbm5vdW5jZW1lbnQvdXJnZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0cnVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0cnVtZW50L2FjdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9hY3RpdmVBbmRJbmRpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0cnVtZW50L2FjdGl2ZUludGVydmFscycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9jb21wb3NpdGVJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9pbmRpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN1cmFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlYWRlcmJvYXJkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXF1aWRhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJCb29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlckJvb2svTDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZS9idWNrZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2NoZW1hJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzY2hlbWEvd2Vic29ja2V0SGVscCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2V0dGxlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXRzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS9idWNrZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcGlLZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NoYXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NoYXQvY2hhbm5lbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NoYXQvY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGVjdXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4ZWN1dGlvbi90cmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25vdGlmaWNhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2FmZmlsaWF0ZVN0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9jaGVja1JlZmVycmFsQ29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9jb21taXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2RlcG9zaXRBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL21hcmdpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9taW5XaXRoZHJhd2FsRmVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci93YWxsZXRIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldFN1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcGlLZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FwaUtleS9kaXNhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcGlLZXkvZW5hYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjaGF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvYnVsaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsQWxsQWZ0ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2Nsb3NlUG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2lzb2xhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2xldmVyYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9yaXNrTGltaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL3RyYW5zZmVyTWFyZ2luJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2NhbmNlbFdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvY29uZmlybUVtYWlsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2NvbmZpcm1FbmFibGVURkEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvY29uZmlybVdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZGlzYWJsZVRGQScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9sb2dvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvbG9nb3V0QWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3ByZWZlcmVuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3JlcXVlc3RFbmFibGVURkEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcmVxdWVzdFdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9idWxrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcGlLZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9hbGwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0SW5zdHJ1bWVudEFjdGl2ZUFuZEluZGljZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSAobWFya2V0WydzdGF0ZSddICE9ICdVbmxpc3RlZCcpO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0Wyd1bmRlcmx5aW5nJ107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGZ1dHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZWRpY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBiYXNlcXVvdGUgPSBiYXNlICsgcXVvdGU7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN3YXAgPSAoaWQgPT0gYmFzZXF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZDtcbiAgICAgICAgICAgIGlmIChzd2FwKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdzd2FwJztcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkLmluZGV4T2YgKCdCXycpID49IDApIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3ByZWRpY3Rpb24nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdXR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnZnV0dXJlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtYWtlciA9IG1hcmtldFsnbWFrZXJGZWUnXTtcbiAgICAgICAgICAgIGxldCB0YWtlciA9IG1hcmtldFsndGFrZXJGZWUnXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAndGFrZXInOiB0YWtlcixcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBtYWtlcixcbiAgICAgICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAgICAgJ3Nwb3QnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnc3dhcCc6IHN3YXAsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZSc6IGZ1dHVyZSxcbiAgICAgICAgICAgICAgICAncHJlZGljdGlvbic6IHByZWRpY3Rpb24sXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0VXNlck1hcmdpbiAoeyAnY3VycmVuY3knOiAnYWxsJyB9KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IHJlc3BvbnNlLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnYXZhaWxhYmxlTWFyZ2luJ10sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZVsnYW1vdW50J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCVEMnKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYWNjb3VudFsnZnJlZSddICogMC4wMDAwMDAwMTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYWNjb3VudFsndG90YWwnXSAqIDAuMDAwMDAwMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9va0wyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnYmlkcyc6IFtdLFxuICAgICAgICAgICAgJ2Fza3MnOiBbXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgb3JkZXJib29rLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBsZXQgb3JkZXIgPSBvcmRlcmJvb2tbb107XG4gICAgICAgICAgICBsZXQgc2lkZSA9IChvcmRlclsnc2lkZSddID09ICdTZWxsJykgPyAnYXNrcycgOiAnYmlkcyc7XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gb3JkZXJbJ3NpemUnXTtcbiAgICAgICAgICAgIGxldCBwcmljZSA9IG9yZGVyWydwcmljZSddO1xuICAgICAgICAgICAgcmVzdWx0W3NpZGVdLnB1c2ggKFsgcHJpY2UsIGFtb3VudCBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGlmICghbWFya2V0WydhY3RpdmUnXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJzogc3ltYm9sICcgKyBzeW1ib2wgKyAnIGlzIGRlbGlzdGVkJyk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnYmluU2l6ZSc6ICcxZCcsXG4gICAgICAgICAgICAncGFydGlhbCc6IHRydWUsXG4gICAgICAgICAgICAnY291bnQnOiAxLFxuICAgICAgICAgICAgJ3JldmVyc2UnOiB0cnVlLFxuICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVvdGVzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRRdW90ZUJ1Y2tldGVkIChyZXF1ZXN0KTtcbiAgICAgICAgbGV0IHF1b3Rlc0xlbmd0aCA9IHF1b3Rlcy5sZW5ndGg7XG4gICAgICAgIGxldCBxdW90ZSA9IHF1b3Rlc1txdW90ZXNMZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlQnVja2V0ZWQgKHJlcXVlc3QpO1xuICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1swXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0IChxdW90ZVsnYmlkUHJpY2UnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAocXVvdGVbJ2Fza1ByaWNlJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSksXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnY2xvc2UnXSksXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hvbWVOb3Rpb25hbCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnZm9yZWlnbk5vdGlvbmFsJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob2hsY3ZbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIG9obGN2WydvcGVuJ10sXG4gICAgICAgICAgICBvaGxjdlsnaGlnaCddLFxuICAgICAgICAgICAgb2hsY3ZbJ2xvdyddLFxuICAgICAgICAgICAgb2hsY3ZbJ2Nsb3NlJ10sXG4gICAgICAgICAgICBvaGxjdlsndm9sdW1lJ10sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIC8vIHNlbmQgSlNPTiBrZXkvdmFsdWUgcGFpcnMsIHN1Y2ggYXMge1wia2V5XCI6IFwidmFsdWVcIn1cbiAgICAgICAgLy8gZmlsdGVyIGJ5IGluZGl2aWR1YWwgZmllbGRzIGFuZCBkbyBhZHZhbmNlZCBxdWVyaWVzIG9uIHRpbWVzdGFtcHNcbiAgICAgICAgLy8gbGV0IGZpbHRlciA9IHsgJ2tleSc6ICd2YWx1ZScgfTtcbiAgICAgICAgLy8gc2VuZCBhIGJhcmUgc2VyaWVzIChlLmcuIFhCVSkgdG8gbmVhcmVzdCBleHBpcmluZyBjb250cmFjdCBpbiB0aGF0IHNlcmllc1xuICAgICAgICAvLyB5b3UgY2FuIGFsc28gc2VuZCBhIHRpbWVmcmFtZSwgZS5nLiBYQlU6bW9udGhseVxuICAgICAgICAvLyB0aW1lZnJhbWVzOiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCBxdWFydGVybHksIGFuZCBiaXF1YXJ0ZXJseVxuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdiaW5TaXplJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgICAgICAncGFydGlhbCc6IHRydWUsICAgICAvLyB0cnVlID09IGluY2x1ZGUgeWV0LWluY29tcGxldGUgY3VycmVudCBiaW5zXG4gICAgICAgICAgICAvLyAnZmlsdGVyJzogZmlsdGVyLCAvLyBmaWx0ZXIgYnkgaW5kaXZpZHVhbCBmaWVsZHMgYW5kIGRvIGFkdmFuY2VkIHF1ZXJpZXNcbiAgICAgICAgICAgIC8vICdjb2x1bW5zJzogW10sICAgIC8vIHdpbGwgcmV0dXJuIGFsbCBjb2x1bW5zIGlmIG9taXR0ZWRcbiAgICAgICAgICAgIC8vICdzdGFydCc6IDAsICAgICAgIC8vIHN0YXJ0aW5nIHBvaW50IGZvciByZXN1bHRzICh3dGY/KVxuICAgICAgICAgICAgLy8gJ3JldmVyc2UnOiBmYWxzZSwgLy8gdHJ1ZSA9PSBuZXdlc3QgZmlyc3RcbiAgICAgICAgICAgIC8vICdlbmRUaW1lJzogJycsICAgIC8vIGVuZGluZyBkYXRlIGZpbHRlciBmb3IgcmVzdWx0c1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpIHtcbiAgICAgICAgICAgIGxldCB5bWRobXMgPSB0aGlzLlltZEhNUyAoc2luY2UpO1xuICAgICAgICAgICAgbGV0IHltZGhtID0geW1kaG1zLnNsaWNlICgwLCAxNik7XG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydFRpbWUnXSA9IHltZGhtOyAvLyBzdGFydGluZyBkYXRlIGZpbHRlciBmb3IgcmVzdWx0c1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvdW50J10gPSBsaW1pdDsgLy8gZGVmYXVsdCAxMDBcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZUJ1Y2tldGVkICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KSB7XG4gICAgICAgICAgICBpZiAoJ3N5bWJvbCcgaW4gdHJhZGUpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydzeW1ib2wnXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndHJkTWF0Y2hJRCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydzaWRlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnc2l6ZSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3NpZGUnOiB0aGlzLmNhcGl0YWxpemUgKHNpZGUpLFxuICAgICAgICAgICAgJ29yZGVyUXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ29yZFR5cGUnOiB0aGlzLmNhcGl0YWxpemUgKHR5cGUpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcklEJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVEZWxldGVPcmRlciAoeyAnb3JkZXJJRCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGlzRmlhdCAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdFVVInKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnUExOJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmIChjdXJyZW5jeSAhPSAnQlRDJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBzdXBvcHJ0cyBCVEMgd2l0aGRyYXdhbHMgb25seSwgb3RoZXIgY3VycmVuY2llcyBjb21pbmcgc29vbi4uLicpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6ICdYQnQnLCAvLyB0ZW1wb3JhcmlseVxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgIC8vICdvdHBUb2tlbic6ICcxMjM0NTYnLCAvLyByZXF1aXJlcyBpZiB0d28tZmFjdG9yIGF1dGggKE9UUCkgaXMgZW5hYmxlZFxuICAgICAgICAgICAgLy8gJ2ZlZSc6IDAuMDAxLCAvLyBiaXRjb2luIG5ldHdvcmsgZmVlXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RVc2VyUmVxdWVzdFdpdGhkcmF3YWwgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsndHJhbnNhY3RJRCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGhhbmRsZUVycm9ycyAoY29kZSwgcmVhc29uLCB1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSkge1xuICAgICAgICBpZiAoY29kZSA+PSA0MDApIHtcbiAgICAgICAgICAgIGlmIChib2R5WzBdID09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gSlNPTi5wYXJzZSAoYm9keSk7XG4gICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZVsnZXJyb3InXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcXVlcnkgPSAnL2FwaScgKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgcXVlcnkgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgcXVlcnk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG1ldGhvZCArIHF1ZXJ5ICsgbm9uY2U7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0aCArPSBib2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnYXBpLW5vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ2FwaS1rZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnYXBpLXNpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBiaXRzbyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdiaXRzbycsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRzbycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ01YJywgLy8gTWV4aWNvXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMjAwMCwgLy8gMzAgcmVxdWVzdHMgcGVyIG1pbnV0ZVxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjMnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjMzNS03MTVjZTdhYS01ZWQ1LTExZTctODhhOC0xNzNhMjdiYjMwZmUuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJpdHNvLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdHNvLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2JpdHNvLmNvbS9hcGlfaW5mbycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2F2YWlsYWJsZV9ib29rcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudF9zdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZlZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRpbmdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kaW5ncy97ZmlkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZGluZ19kZXN0aW5hdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAna3ljX2RvY3VtZW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVkZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWRnZXIvdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWRnZXIvZmVlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVkZ2VyL2Z1bmRpbmdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWRnZXIvd2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ214X2JhbmtfY29kZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5fb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl90cmFkZXMve29pZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy97b2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJfdHJhZGVzL3t0aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2Fscy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL3t3aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYml0Y29pbl93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZWJpdF9jYXJkX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V0aGVyX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGhvbmVfbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwaG9uZV92ZXJpZmljYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Bob25lX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NwZWlfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3tvaWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEF2YWlsYWJsZUJvb2tzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2V0c1sncGF5bG9hZCddLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sncGF5bG9hZCddW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0Wydib29rJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQudG9VcHBlckNhc2UgKCkucmVwbGFjZSAoJ18nLCAnLycpO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIGxldCBsaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21pbic6IHBhcnNlRmxvYXQgKG1hcmtldFsnbWluaW11bV9hbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgICdtYXgnOiBwYXJzZUZsb2F0IChtYXJrZXRbJ21heGltdW1fYW1vdW50J10pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWluJzogcGFyc2VGbG9hdCAobWFya2V0WydtaW5pbXVtX3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAnbWF4JzogcGFyc2VGbG9hdCAobWFya2V0WydtYXhpbXVtX3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtaW4nOiBwYXJzZUZsb2F0IChtYXJrZXRbJ21pbmltdW1fdmFsdWUnXSksXG4gICAgICAgICAgICAgICAgICAgICdtYXgnOiBwYXJzZUZsb2F0IChtYXJrZXRbJ21heGltdW1fdmFsdWUnXSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiB0aGlzLnByZWNpc2lvbkZyb21TdHJpbmcgKG1hcmtldFsnbWluaW11bV9hbW91bnQnXSksXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogdGhpcy5wcmVjaXNpb25Gcm9tU3RyaW5nIChtYXJrZXRbJ21pbmltdW1fcHJpY2UnXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGxvdCA9IGxpbWl0c1snYW1vdW50J11bJ21pbiddO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnbG90JzogbG90LFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiBsaW1pdHMsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRCYWxhbmNlICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncGF5bG9hZCddWydiYWxhbmNlcyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydhdmFpbGFibGUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydsb2NrZWQnXSksXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsndG90YWwnXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydwYXlsb2FkJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob3JkZXJib29rWyd1cGRhdGVkX2F0J10pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXAsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYm9vayc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3BheWxvYWQnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0aWNrZXJbJ2NyZWF0ZWRfYXQnXSk7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnY3JlYXRlZF9hdCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGlmICgnYm9vaycgaW4gdHJhZGUpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydib29rJ11dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydtYWtlcl9zaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYm9vayc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsncGF5bG9hZCddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ21ham9yJzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgcHJpY2UpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJzICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydwYXlsb2FkJ11bJ29pZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlRGVsZXRlT3JkZXJzICh7ICdvaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBxdWVyeSA9ICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyBxdWVyeTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IFsgbm9uY2UsIG1ldGhvZCwgcXVlcnkgXS5qb2luICgnJyk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocGFyYW1zKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ICs9IGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocmVxdWVzdCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLmFwaUtleSArICc6JyArIG5vbmNlICsgJzonICsgc2lnbmF0dXJlO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IFwiQml0c28gXCIgKyBhdXRoLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdHN0YW1wIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdHN0YW1wJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JpdHN0YW1wJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnR0InLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc4NjM3Ny04YzhhYjU3ZS01ZmU5LTExZTctOGVhNC0yYjA1YjZiY2NlZWMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0c3RhbXAubmV0JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd1aWQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcl9ob3VyL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlci97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZy1wYWlycy1pbmZvLycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2Uve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl90cmFuc2FjdGlvbnMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyX3RyYW5zYWN0aW9ucy97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycy9hbGwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX3N0YXR1cy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlci8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eS97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXkvbWFya2V0L3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGwve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbC9tYXJrZXQve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbHRjX3dpdGhkcmF3YWwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsdGNfYWRkcmVzcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V0aF93aXRoZHJhd2FsLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXRoX2FkZHJlc3MvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zlci10by1tYWluLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmZXItZnJvbS1tYWluLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAneHJwX3dpdGhkcmF3YWwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd4cnBfYWRkcmVzcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwvb3Blbi8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwvc3RhdHVzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbC9jYW5jZWwvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXF1aWRhdGlvbl9hZGRyZXNzL25ldy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpcXVpZGF0aW9uX2FkZHJlc3MvaW5mby8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3YxJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaXRjb2luX2RlcG9zaXRfYWRkcmVzcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VuY29uZmlybWVkX2J0Yy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW5fd2l0aGRyYXdhbC8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAncGVyY2VudGFnZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMjUgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMjUgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0aWVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0YWtlcic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMCwgMC4yNSAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzIwMDAwLCAwLjI0IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTAwMDAwLCAwLjIyIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNDAwMDAwLCAwLjIwIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNjAwMDAwLCAwLjE1IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTAwMDAwMCwgMC4xNCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzIwMDAwMDAsIDAuMTMgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs0MDAwMDAwLCAwLjEyIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMjAwMDAwMDAsIDAuMTEgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsyMDAwMDAwMSwgMC4xMCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswLCAwLjI1IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMjAwMDAsIDAuMjQgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxMDAwMDAsIDAuMjIgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs0MDAwMDAsIDAuMjAgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs2MDAwMDAsIDAuMTUgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxMDAwMDAwLCAwLjE0IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMjAwMDAwMCwgMC4xMyAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzQwMDAwMDAsIDAuMTIgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsyMDAwMDAwMCwgMC4xMSAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzIwMDAwMDAxLCAwLjEwIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZnVuZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RpZXJCYXNlZCc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAncGVyY2VudGFnZSc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUSCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWFJQJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVU0QnOiAyNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVVInOiAwLjkwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYUlAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VTRCc6IDI1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VVUic6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkaW5nUGFpcnNJbmZvICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaV07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0Wyd1cmxfc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBtYXJrZXRbJ2Jhc2VfZGVjaW1hbHMnXSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBtYXJrZXRbJ2NvdW50ZXJfZGVjaW1hbHMnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgWyBjb3N0LCBjdXJyZW5jeSBdID0gbWFya2V0WydtaW5pbXVtX29yZGVyJ10uc3BsaXQgKCcgJyk7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gKG1hcmtldFsndHJhZGluZyddID09ICdFbmFibGVkJyk7XG4gICAgICAgICAgICBsZXQgbG90ID0gTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydhbW91bnQnXSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsncHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBwYXJzZUZsb2F0IChjb3N0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJib29rWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgbGV0IHZ3YXAgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSk7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IGJhc2VWb2x1bWUgKiB2d2FwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdndhcCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2RhdGUnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICB9IGVsc2UgaWYgKCdkYXRldGltZScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIC8vIHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnZGF0ZXRpbWUnXSk7XG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGV0aW1lJ10pICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsndHlwZSddID09IDApID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgICAgIGxldCBvcmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdvcmRlcl9pZCcgaW4gdHJhZGUpXG4gICAgICAgICAgICBvcmRlciA9IHRyYWRlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpO1xuICAgICAgICBpZiAoJ2N1cnJlbmN5X3BhaXInIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBpZiAodHJhZGVbJ2N1cnJlbmN5X3BhaXInXSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeV9wYWlyJ11dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ29yZGVyJzogb3JkZXIsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYW5zYWN0aW9uc1BhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lJzogJ21pbnV0ZScsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBsb3dlcmNhc2UgKyAnX2JhbGFuY2UnO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSBsb3dlcmNhc2UgKyAnX2F2YWlsYWJsZSc7XG4gICAgICAgICAgICBsZXQgdXNlZCA9IGxvd2VyY2FzZSArICdfcmVzZXJ2ZWQnO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoZnJlZSBpbiBiYWxhbmNlKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbZnJlZV0pO1xuICAgICAgICAgICAgaWYgKHVzZWQgaW4gYmFsYW5jZSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlW3VzZWRdKTtcbiAgICAgICAgICAgIGlmICh0b3RhbCBpbiBiYWxhbmNlKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlW3RvdGFsXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIG1ldGhvZCArPSAnTWFya2V0JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbWV0aG9kICs9ICdQYWlyJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXJTdGF0dXMgKG9yZGVyKSB7XG4gICAgICAgIGlmICgob3JkZXJbJ3N0YXR1cyddID09ICdRdWV1ZScpIHx8IChvcmRlclsnc3RhdHVzJ10gPT0gJ09wZW4nKSlcbiAgICAgICAgICAgIHJldHVybiAnb3Blbic7XG4gICAgICAgIGlmIChvcmRlclsnc3RhdHVzJ10gPT0gJ0ZpbmlzaGVkJylcbiAgICAgICAgICAgIHJldHVybiAnY2xvc2VkJztcbiAgICAgICAgcmV0dXJuIG9yZGVyWydzdGF0dXMnXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyU3RhdHVzIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlclN0YXR1cyAoeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlclN0YXR1cyAocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTXlUcmFkZXMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBwYWlyID0gbWFya2V0ID8gbWFya2V0WydpZCddIDogJ2FsbCc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHsgJ3BhaXInOiBwYWlyIH0sIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcGVuT3JkZXJzUGFpciAocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJTdGF0dXMgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJztcbiAgICAgICAgaWYgKGFwaSAhPSAndjEnKVxuICAgICAgICAgICAgdXJsICs9IHRoaXMudmVyc2lvbiArICcvJztcbiAgICAgICAgdXJsICs9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlICsgdGhpcy51aWQgKyB0aGlzLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmVuY29kZSAodGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3RhdHVzJ10gPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIE5vdFN1cHBvcnRlZCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYml0c3RhbXAxIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2JpdHN0YW1wMScsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXRzdGFtcCB2MScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0dCJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc4NjM3Ny04YzhhYjU3ZS01ZmU5LTExZTctOGVhNC0yYjA1YjZiY2NlZWMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0c3RhbXAubmV0JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd1aWQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcl9ob3VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V1cl91c2QnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJfdHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9hbGxfb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW5fZGVwb3NpdF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1bmNvbmZpcm1lZF9idGMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JpcHBsZV93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyaXBwbGVfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbF9yZXF1ZXN0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYml0Y29pbl93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnYnRjdXNkJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAyNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdidGNldXInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJywgJ21ha2VyJzogMC4wMDI1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnRVVSL1VTRCc6IHsgJ2lkJzogJ2V1cnVzZCcsICdzeW1ib2wnOiAnRVVSL1VTRCcsICdiYXNlJzogJ0VVUicsICdxdW90ZSc6ICdVU0QnLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgICdYUlAvVVNEJzogeyAnaWQnOiAneHJwdXNkJywgJ3N5bWJvbCc6ICdYUlAvVVNEJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAyNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ1hSUC9FVVInOiB7ICdpZCc6ICd4cnBldXInLCAnc3ltYm9sJzogJ1hSUC9FVVInLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnRVVSJywgJ21ha2VyJzogMC4wMDI1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnWFJQL0JUQyc6IHsgJ2lkJzogJ3hycGJ0YycsICdzeW1ib2wnOiAnWFJQL0JUQycsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgICdMVEMvVVNEJzogeyAnaWQnOiAnbHRjdXNkJywgJ3N5bWJvbCc6ICdMVEMvVVNEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAyNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9FVVInOiB7ICdpZCc6ICdsdGNldXInLCAnc3ltYm9sJzogJ0xUQy9FVVInLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnRVVSJywgJ21ha2VyJzogMC4wMDI1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ2x0Y2J0YycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgICdFVEgvVVNEJzogeyAnaWQnOiAnZXRodXNkJywgJ3N5bWJvbCc6ICdFVEgvVVNEJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1VTRCcsICdtYWtlcic6IDAuMDAyNSwgJ3Rha2VyJzogMC4wMDI1IH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9FVVInOiB7ICdpZCc6ICdldGhldXInLCAnc3ltYm9sJzogJ0VUSC9FVVInLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnRVVSJywgJ21ha2VyJzogMC4wMDI1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aGJ0YycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPSAnQlRDL1VTRCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMudmVyc2lvbiArIFwiIGZldGNoT3JkZXJCb29rIGRvZXNuJ3Qgc3VwcG9ydCBcIiArIHN5bWJvbCArICcsIHVzZSBpdCBmb3IgQlRDL1VTRCBvbmx5Jyk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPSAnQlRDL1VTRCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMudmVyc2lvbiArIFwiIGZldGNoVGlja2VyIGRvZXNuJ3Qgc3VwcG9ydCBcIiArIHN5bWJvbCArICcsIHVzZSBpdCBmb3IgQlRDL1VTRCBvbmx5Jyk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0aWNrZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdkYXRlJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgfSBlbHNlIGlmICgnZGF0ZXRpbWUnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICAvLyB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2RhdGV0aW1lJ10pO1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRldGltZSddKSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAwKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgb3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnb3JkZXJfaWQnIGluIHRyYWRlKVxuICAgICAgICAgICAgb3JkZXIgPSB0cmFkZVsnb3JkZXJfaWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgaWYgKCdjdXJyZW5jeV9wYWlyJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgaWYgKHRyYWRlWydjdXJyZW5jeV9wYWlyJ10gaW4gdGhpcy5tYXJrZXRzX2J5X2lkKVxuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFt0cmFkZVsnY3VycmVuY3lfcGFpciddXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmIChzeW1ib2wgIT0gJ0JUQy9VU0QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLnZlcnNpb24gKyBcIiBmZXRjaFRyYWRlcyBkb2Vzbid0IHN1cHBvcnQgXCIgKyBzeW1ib2wgKyAnLCB1c2UgaXQgZm9yIEJUQy9VU0Qgb25seScpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhbnNhY3Rpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3RpbWUnOiAnbWludXRlJyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IGxvd2VyY2FzZSArICdfYmFsYW5jZSc7XG4gICAgICAgICAgICBsZXQgZnJlZSA9IGxvd2VyY2FzZSArICdfYXZhaWxhYmxlJztcbiAgICAgICAgICAgIGxldCB1c2VkID0gbG93ZXJjYXNlICsgJ19yZXNlcnZlZCc7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlLCBmcmVlLCAwLjApO1xuICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2UsIHVzZWQsIDAuMCk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2UsIHRvdGFsLCAwLjApO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlICE9ICdsaW1pdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMudmVyc2lvbiArICcgYWNjZXB0cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBpZiAoc3ltYm9sICE9ICdCVEMvVVNEJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyB2MSBzdXBwb3J0cyBCVEMvVVNEIG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlclN0YXR1cyAob3JkZXIpIHtcbiAgICAgICAgaWYgKChvcmRlclsnc3RhdHVzJ10gPT0gJ1F1ZXVlJykgfHwgKG9yZGVyWydzdGF0dXMnXSA9PSAnT3BlbicpKVxuICAgICAgICAgICAgcmV0dXJuICdvcGVuJztcbiAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnRmluaXNoZWQnKVxuICAgICAgICAgICAgcmV0dXJuICdjbG9zZWQnO1xuICAgICAgICByZXR1cm4gb3JkZXJbJ3N0YXR1cyddO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJTdGF0dXMgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyU3RhdHVzICh7ICdpZCc6IGlkIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyU3RhdHVzIChyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHBhaXIgPSBtYXJrZXQgPyBtYXJrZXRbJ2lkJ10gOiAnYWxsJztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAoeyAnaWQnOiBwYWlyIH0sIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcGVuT3JkZXJzSWQgKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9yZGVyIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gbm9uY2UgKyB0aGlzLnVpZCArIHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuZW5jb2RlICh0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSkpO1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJzogc2lnbmF0dXJlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdGF0dXMnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydzdGF0dXMnXSA9PSAnZXJyb3InKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEludmFsaWRPcmRlciwgSW5zdWZmaWNpZW50RnVuZHMsIE9yZGVyTm90Rm91bmQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJpdHRyZXggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYml0dHJleCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdCaXR0cmV4JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEuMScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAvLyBvYnNvbGV0ZSBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE15VHJhZGVzJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hDdXJyZW5jaWVzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAvLyBuZXcgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiAnZW11bGF0ZWQnLFxuICAgICAgICAgICAgICAgICdmZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ2ZldGNoQ3VycmVuY2llcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnb25lTWluJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnZml2ZU1pbicsXG4gICAgICAgICAgICAgICAgJzMwbSc6ICd0aGlydHlNaW4nLFxuICAgICAgICAgICAgICAgICcxaCc6ICdob3VyJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnZGF5JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MzUyLWNmMGIzYzI2LTVlZDUtMTFlNy04MmI3LWYzODI2YjdhOTdkOC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9iaXR0cmV4LmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAnYWNjb3VudCc6ICdodHRwczovL2JpdHRyZXguY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdtYXJrZXQnOiAnaHR0cHM6Ly9iaXR0cmV4LmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAndjInOiAnaHR0cHM6Ly9iaXR0cmV4LmNvbS9hcGkvdjIuMC9wdWInLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdHRyZXguY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9iaXR0cmV4LmNvbS9Ib21lL0FwaScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5ucG1qcy5vcmcvcGFja2FnZS9ub2RlLmJpdHRyZXguYXBpJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICdmZWVzJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9iaXR0cmV4LmNvbS9GZWVzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vc3VwcG9ydC5iaXR0cmV4LmNvbS9oYy9lbi11cy9hcnRpY2xlcy8xMTUwMDAxOTk2NTEtV2hhdC1mZWVzLWRvZXMtQml0dHJleC1jaGFyZ2UtJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3YyJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmNpZXMvR2V0QlRDUHJpY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9HZXRUaWNrcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L0dldExhdGVzdFRpY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01hcmtldHMvR2V0TWFya2V0U3VtbWFyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvR2V0TGF0ZXN0VGljaycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmNpZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldGhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldHN1bW1hcmllcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0c3VtbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2FjY291bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRhZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0aGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbGhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXJrZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5bGltaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eW1hcmtldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVub3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxsbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxtYXJrZXQnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAwMjUsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMDAyNSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RPR0UnOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZUQyc6IDAuMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFBDJzogMC4wMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdGVEMnOiAwLjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUkREJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdOWFQnOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLjAwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdQT1QnOiAwLjAwMixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RPR0UnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFBDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdGVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JERCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTlhUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQVNIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQT1QnOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb3N0VG9QcmVjaXNpb24gKHN5bWJvbCwgY29zdCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cnVuY2F0ZSAocGFyc2VGbG9hdCAoY29zdCksIHRoaXMubWFya2V0c1tzeW1ib2xdWydwcmVjaXNpb24nXVsncHJpY2UnXSk7XG4gICAgfVxuXG4gICAgZmVlVG9QcmVjaXNpb24gKHN5bWJvbCwgZmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRydW5jYXRlIChwYXJzZUZsb2F0IChmZWUpLCB0aGlzLm1hcmtldHNbc3ltYm9sXVsncHJlY2lzaW9uJ11bJ3ByaWNlJ10pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMudjJHZXRNYXJrZXRzR2V0TWFya2V0U3VtbWFyaWVzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2VbJ3Jlc3VsdCddLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gcmVzcG9uc2VbJ3Jlc3VsdCddW2ldWydNYXJrZXQnXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnTWFya2V0TmFtZSddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ01hcmtldEN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ0Jhc2VDdXJyZW5jeSddO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiA4LFxuICAgICAgICAgICAgICAgICdwcmljZSc6IDgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG1hcmtldFsnSXNBY3RpdmUnXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdsb3QnOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbWFya2V0WydNaW5UcmFkZVNpemUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNjb3VudEdldEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGluZGV4ZWQgPSB0aGlzLmluZGV4QnkgKGJhbGFuY2VzLCAnQ3VycmVuY3knKTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAoaW5kZXhlZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChpZCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gaW5kZXhlZFtpZF07XG4gICAgICAgICAgICBsZXQgZnJlZSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ0F2YWlsYWJsZSddKTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ0JhbGFuY2UnXSk7XG4gICAgICAgICAgICBsZXQgdXNlZCA9IHRvdGFsIC0gZnJlZTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGZyZWU7XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSB1c2VkO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6ICdib3RoJyxcbiAgICAgICAgICAgICdkZXB0aCc6IDUwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5JywgJ3NlbGwnLCAnUmF0ZScsICdRdWFudGl0eScpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnVGltZVN0YW1wJ10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnSGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdMb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnQmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ0FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ0xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnVm9sdW1lJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnQmFzZVZvbHVtZScpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDdXJyZW5jaWVzIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmNpZXMgKHBhcmFtcyk7XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IGN1cnJlbmN5WydDdXJyZW5jeSddO1xuICAgICAgICAgICAgLy8gdG9kbzogd2lsbCBuZWVkIHRvIHJldGhpbmsgdGhlIGZlZXNcbiAgICAgICAgICAgIC8vIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aXBsZSB3aXRoZHJhd2FsL2RlcG9zaXQgbWV0aG9kcyBhbmRcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudGlhdGVkIGZlZXMgZm9yIGVhY2ggcGFydGljdWxhciBtZXRob2RcbiAgICAgICAgICAgIGxldCBjb2RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGlkKTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IDgsIC8vIGRlZmF1bHQgcHJlY2lzaW9uLCB0b2RvOiBmaXggXCJtYWdpYyBjb25zdGFudHNcIlxuICAgICAgICAgICAgICAgICdwcmljZSc6IDgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2NvZGVdID0ge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdjb2RlJzogY29kZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICduYW1lJzogY3VycmVuY3lbJ0N1cnJlbmN5TG9uZyddLFxuICAgICAgICAgICAgICAgICdhY3RpdmUnOiBjdXJyZW5jeVsnSXNBY3RpdmUnXSxcbiAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICAgICAnZmVlJzogY3VycmVuY3lbJ1R4RmVlJ10sIC8vIHRvZG86IHJlZGVzaWduXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGN1cnJlbmN5WydUeEZlZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0c3VtbWFyaWVzIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpY2tlcnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW3RdO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWydNYXJrZXROYW1lJ107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IFsgcXVvdGUsIGJhc2UgXSA9IGlkLnNwbGl0ICgnLScpO1xuICAgICAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHN1bW1hcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydyZXN1bHQnXVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ1RpbWVTdGFtcCddKTtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFkZVsnT3JkZXJUeXBlJ10gPT0gJ0JVWScpIHtcbiAgICAgICAgICAgIHNpZGUgPSAnYnV5JztcbiAgICAgICAgfSBlbHNlIGlmICh0cmFkZVsnT3JkZXJUeXBlJ10gPT0gJ1NFTEwnKSB7XG4gICAgICAgICAgICBzaWRlID0gJ3NlbGwnO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdJZCcgaW4gdHJhZGUpXG4gICAgICAgICAgICBpZCA9IHRyYWRlWydJZCddLnRvU3RyaW5nICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ1ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydRdWFudGl0eSddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRoaXN0b3J5ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGlmICgncmVzdWx0JyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZVsncmVzdWx0J10gIT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydyZXN1bHQnXSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaFRyYWRlcygpIHJldHVybmVkIHVuZGVmaW5lZCByZXNwb25zZScpO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxZCcsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9obGN2WydUJ10pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgb2hsY3ZbJ08nXSxcbiAgICAgICAgICAgIG9obGN2WydIJ10sXG4gICAgICAgICAgICBvaGxjdlsnTCddLFxuICAgICAgICAgICAgb2hsY3ZbJ0MnXSxcbiAgICAgICAgICAgIG9obGN2WydWJ10sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAndGlja0ludGVydmFsJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgICAgICAnbWFya2V0TmFtZSc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy52MkdldE1hcmtldEdldFRpY2tzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZVsncmVzdWx0J10sIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsnbWFya2V0J10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYXJrZXRHZXRPcGVub3JkZXJzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcnMgPSB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZVsncmVzdWx0J10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyT3JkZXJzQnlTeW1ib2wgKG9yZGVycywgc3ltYm9sKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAnbWFya2V0R2V0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSkgKyB0eXBlO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3JhdGUnXSA9IHRoaXMucHJpY2VUb1ByZWNpc2lvbiAoc3ltYm9sLCBwcmljZSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J11bJ3V1aWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1hcmtldEdldENhbmNlbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAndXVpZCc6IGlkLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5zYWZlU3RyaW5nICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSwgJ21lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSA9PSAnT1JERVJfTk9UX09QRU4nKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIGVycm9yOiAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09ICdVVUlEX0lOVkFMSUQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIoKSBlcnJvcjogJyArIHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnT3JkZXJUeXBlJyBpbiBvcmRlcilcbiAgICAgICAgICAgIHNpZGUgPSAob3JkZXJbJ09yZGVyVHlwZSddID09ICdMSU1JVF9CVVknKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBpZiAoJ1R5cGUnIGluIG9yZGVyKVxuICAgICAgICAgICAgc2lkZSA9IChvcmRlclsnVHlwZSddID09ICdMSU1JVF9CVVknKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgc3RhdHVzID0gJ29wZW4nO1xuICAgICAgICBpZiAob3JkZXJbJ0Nsb3NlZCddKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2xvc2VkJztcbiAgICAgICAgfSBlbHNlIGlmIChvcmRlclsnQ2FuY2VsSW5pdGlhdGVkJ10pIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGlmICgnRXhjaGFuZ2UnIGluIG9yZGVyKVxuICAgICAgICAgICAgICAgIGlmIChvcmRlclsnRXhjaGFuZ2UnXSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpXG4gICAgICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtvcmRlclsnRXhjaGFuZ2UnXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnT3BlbmVkJyBpbiBvcmRlcilcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlclsnT3BlbmVkJ10pO1xuICAgICAgICBpZiAoJ1RpbWVTdGFtcCcgaW4gb3JkZXIpXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob3JkZXJbJ1RpbWVTdGFtcCddKTtcbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvbW1pc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnQ29tbWlzc2lvbicgaW4gb3JkZXIpIHtcbiAgICAgICAgICAgIGNvbW1pc3Npb24gPSAnQ29tbWlzc2lvbic7XG4gICAgICAgIH0gZWxzZSBpZiAoJ0NvbW1pc3Npb25QYWlkJyBpbiBvcmRlcikge1xuICAgICAgICAgICAgY29tbWlzc2lvbiA9ICdDb21taXNzaW9uUGFpZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1pc3Npb24pIHtcbiAgICAgICAgICAgIGZlZSA9IHtcbiAgICAgICAgICAgICAgICAnY29zdCc6IHBhcnNlRmxvYXQgKG9yZGVyW2NvbW1pc3Npb25dKSxcbiAgICAgICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmljZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ0xpbWl0Jyk7XG4gICAgICAgIGxldCBjb3N0ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnUHJpY2UnKTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ1F1YW50aXR5Jyk7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdRdWFudGl0eVJlbWFpbmluZycsIDAuMCk7XG4gICAgICAgIGxldCBmaWxsZWQgPSBhbW91bnQgLSByZW1haW5pbmc7XG4gICAgICAgIGlmICghY29zdCkge1xuICAgICAgICAgICAgaWYgKHByaWNlICYmIGFtb3VudClcbiAgICAgICAgICAgICAgICBjb3N0ID0gcHJpY2UgKiBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmljZSkge1xuICAgICAgICAgICAgaWYgKGNvc3QgJiYgZmlsbGVkKVxuICAgICAgICAgICAgICAgIHByaWNlID0gY29zdCAvIGZpbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXZlcmFnZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ1ByaWNlUGVyVW5pdCcpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydPcmRlclV1aWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IGF2ZXJhZ2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNjb3VudEdldE9yZGVyICh0aGlzLmV4dGVuZCAoeyAndXVpZCc6IGlkIH0sIHBhcmFtcykpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0X2pzb25fcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMuc2FmZVN0cmluZyAodGhpcy5sYXN0X2pzb25fcmVzcG9uc2UsICdtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgPT0gJ1VVSURfSU5WQUxJRCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyBmZXRjaE9yZGVyKCkgZXJyb3I6ICcgKyB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIgKHJlc3BvbnNlWydyZXN1bHQnXSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ21hcmtldCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNjb3VudEdldE9yZGVyaGlzdG9yeSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJzID0gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3Jlc3VsdCddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlck9yZGVyc0J5U3ltYm9sIChvcmRlcnMsIHN5bWJvbCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJzID0gYXdhaXQgdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeSAob3JkZXJzLCAnc3RhdHVzJywgJ2Nsb3NlZCcpO1xuICAgIH1cblxuICAgIGN1cnJlbmN5SWQgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQkNIJylcbiAgICAgICAgICAgIHJldHVybiAnQkNDJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFjY291bnRHZXREZXBvc2l0YWRkcmVzcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5SWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2VbJ3Jlc3VsdCddLCAnQWRkcmVzcycpO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2UsICdtZXNzYWdlJyk7XG4gICAgICAgIGxldCBzdGF0dXMgPSAnb2snO1xuICAgICAgICBpZiAoIWFkZHJlc3MgfHwgbWVzc2FnZSA9PSAnQUREUkVTU19HRU5FUkFUSU5HJylcbiAgICAgICAgICAgIHN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNjb3VudEdldFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3lJZCxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdyZXN1bHQnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoJ3V1aWQnIGluIHJlc3BvbnNlWydyZXN1bHQnXSlcbiAgICAgICAgICAgICAgICBpZCA9IHJlc3BvbnNlWydyZXN1bHQnXVsndXVpZCddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgJy8nO1xuICAgICAgICBpZiAoYXBpICE9ICd2MicpXG4gICAgICAgICAgICB1cmwgKz0gdGhpcy52ZXJzaW9uICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gYXBpICsgJy8nICsgbWV0aG9kLnRvTG93ZXJDYXNlICgpICsgcGF0aDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGFwaSA9PSAndjInKSB7XG4gICAgICAgICAgICB1cmwgKz0gcGF0aDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgdXJsICs9IGFwaSArICcvJztcbiAgICAgICAgICAgIGlmICgoKGFwaSA9PSAnYWNjb3VudCcpICYmIChwYXRoICE9ICd3aXRoZHJhdycpKSB8fCAocGF0aCA9PSAnb3Blbm9yZGVycycpKVxuICAgICAgICAgICAgICAgIHVybCArPSBtZXRob2QudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICB1cmwgKz0gcGF0aCArICc/JyArIHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdhcGlrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHVybCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdhcGlzaWduJzogc2lnbmF0dXJlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGNvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICBpZiAoYm9keVswXSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IEpTT04ucGFyc2UgKGJvZHkpO1xuICAgICAgICAgICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydtZXNzYWdlJ10gPT0gJ01JTl9UUkFERV9SRVFVSVJFTUVOVF9OT1RfTUVUJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcmRlciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSA9PSAnQVBJS0VZX0lOVkFMSUQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSA9PSAnQUREUkVTU19HRU5FUkFUSU5HJylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSA9PSBcIklOU1VGRklDSUVOVF9GVU5EU1wiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYmwzcCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdibDNwJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JMM1AnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ05MJywgJ0VVJyBdLCAvLyBOZXRoZXJsYW5kcywgRVVcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMScsXG4gICAgICAgICAgICAnY29tbWVudCc6ICdBbiBleGNoYW5nZSBtYXJrZXQgYnkgQml0b25pY05MJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4NTAxNzUyLTYwYzIxYjgyLTZmZWItMTFlNy04MThiLTA1NWVlNmQwZTc1NC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuYmwzcC5ldScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYmwzcC5ldScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JpdG9uaWMubmwnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9CaXRvbmljTkwvYmwzcC1hcGkvdHJlZS9tYXN0ZXIvZG9jcycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2JsM3AuZXUvYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYml0b25pYy5ubC9lbi9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAne21hcmtldH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7bWFya2V0fS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L21vbmV5L2RlcHRoL2Z1bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L21vbmV5L29yZGVyL2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXIvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7bWFya2V0fS9tb25leS9vcmRlci9yZXN1bHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L21vbmV5L29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXJzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ttYXJrZXR9L21vbmV5L3RyYWRlcy9mZXRjaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR0VOTUtUL21vbmV5L2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS9kZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS9uZXdfZGVwb3NpdF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHRU5NS1QvbW9uZXkvd2FsbGV0L2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS93aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0JUQ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInLCAnbWFrZXInOiAwLjAwMjUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgIC8vICdMVEMvRVVSJzogeyAnaWQnOiAnTFRDRVVSJywgJ3N5bWJvbCc6ICdMVEMvRVVSJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdFTk1LVE1vbmV5SW5mbyAoKTtcbiAgICAgICAgbGV0IGRhdGEgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IGRhdGFbJ3dhbGxldHMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBkYXRhIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2F2YWlsYWJsZScgaW4gYmFsYW5jZVtjdXJyZW5jeV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2F2YWlsYWJsZSddWyd2YWx1ZSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICgnYmFsYW5jZScgaW4gYmFsYW5jZVtjdXJyZW5jeV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydiYWxhbmNlJ11bJ3ZhbHVlJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY2NvdW50Wyd0b3RhbCddKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnRbJ2ZyZWUnXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBwYXJzZUJpZEFzayAoYmlkYXNrLCBwcmljZUtleSA9IDAsIGFtb3VudEtleSA9IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGJpZGFza1sncHJpY2VfaW50J10gLyAxMDAwMDAuMCxcbiAgICAgICAgICAgIGJpZGFza1snYW1vdW50X2ludCddIC8gMTAwMDAwMDAwLjAsXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldE9yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ11bJzI0aCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFkZV9pZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsnZGF0ZSddLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0cmFkZVsnZGF0ZSddKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZV9pbnQnXSAvIDEwMDAwMC4wLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnRfaW50J10gLyAxMDAwMDAwMDAuMCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydkYXRhJ11bJ3RyYWRlcyddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2Ftb3VudF9pbnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmVlX2N1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ3R5cGUnOiAoc2lkZSA9PSAnYnV5JykgPyAnYmlkJyA6ICdhc2snLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlX2ludCddID0gcHJpY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RNYXJrZXRNb25leU9yZGVyQWRkICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE1hcmtldE1vbmV5T3JkZXJDYW5jZWwgKHsgJ29yZGVyX2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyByZXF1ZXN0O1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBzZWNyZXQgPSB0aGlzLmJhc2U2NFRvQmluYXJ5ICh0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHJlcXVlc3QgKyBcIlxcMFwiICsgYm9keTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgc2VjcmV0LCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ1Jlc3QtS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1Jlc3QtU2lnbic6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGJpdHRyZXggPSByZXF1aXJlICgnLi9iaXR0cmV4LmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYmxldXRyYWRlIGV4dGVuZHMgYml0dHJleCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYmxldXRyYWRlJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JsZXV0cmFkZScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0JSJywgLy8gQnJhemlsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzAzMDMwMDAtYjYwMmRiZTYtOTc2ZC0xMWU3LTk1NmQtMzZjNTA0OWMwMWU3LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2JsZXV0cmFkZS5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQnOiAnaHR0cHM6Ly9ibGV1dHJhZGUuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdtYXJrZXQnOiAnaHR0cHM6Ly9ibGV1dHJhZGUuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYmxldXRyYWRlLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2JsZXV0cmFkZS5jb20vaGVscC9BUEknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWydyZXN1bHQnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3Jlc3VsdCddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydNYXJrZXROYW1lJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnTWFya2V0Q3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnQmFzZUN1cnJlbmN5J107XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IDgsXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogOCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gbWFya2V0WydJc0FjdGl2ZSddO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdhY3RpdmUnOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgJ2xvdCc6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ01pblRyYWRlU2l6ZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3R5cGUnOiAnQUxMJyxcbiAgICAgICAgICAgICdkZXB0aCc6IDUwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5JywgJ3NlbGwnLCAnUmF0ZScsICdRdWFudGl0eScpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ0Y2JveCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdidGNib3gnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQnRjQm94JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSlAnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzEyNzU4MDMtNGRmNzU1YTgtYWFhMS0xMWU3LTlhYmItMTFlYzJmYWQ5ZjJkLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5idGNib3guY28uanAvYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmJ0Y2JveC5jby5qcC8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuYnRjYm94LmNvLmpwL2hlbHAvYXNtJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbGx0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlX2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVfY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZV9saXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZV92aWV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXQnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9KUFknOiB7ICdpZCc6ICdCVEMvSlBZJywgJ3N5bWJvbCc6ICdCVEMvSlBZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgaWYgKGxvd2VyY2FzZSA9PSAnZGFzaCcpXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlID0gJ2Ryayc7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGxldCBmcmVlID0gbG93ZXJjYXNlICsgJ19iYWxhbmNlJztcbiAgICAgICAgICAgIGxldCB1c2VkID0gbG93ZXJjYXNlICsgJ19sb2NrJztcbiAgICAgICAgICAgIGlmIChmcmVlIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2ZyZWVdKTtcbiAgICAgICAgICAgIGlmICh1c2VkIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW3VzZWRdKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgbGV0IG51bVN5bWJvbHMgPSB0aGlzLnN5bWJvbHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU3ltYm9scyA+IDEpXG4gICAgICAgICAgICByZXF1ZXN0Wydjb2luJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgICAgICByZXN1bHRbJ2Fza3MnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2Fza3MnXSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eScpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdzZWxsJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2wnKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2x1bWUnKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEFsbHRpY2tlciAocGFyYW1zKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBsZXQgbnVtU3ltYm9scyA9IHRoaXMuc3ltYm9scy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TeW1ib2xzID4gMSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvaW4nXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgbGV0IG51bVN5bWJvbHMgPSB0aGlzLnN5bWJvbHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU3ltYm9scyA+IDEpXG4gICAgICAgICAgICByZXF1ZXN0Wydjb2luJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBudW1TeW1ib2xzID0gdGhpcy5zeW1ib2xzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVN5bWJvbHMgPiAxKVxuICAgICAgICAgICAgcmVxdWVzdFsnY29pbiddID0gbWFya2V0WydpZCddO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGVBZGQgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZUNhbmNlbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5oYXNoICh0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5WydzaWduYXR1cmUnXSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAoc2VjcmV0KSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydyZXN1bHQnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ0Y2NoaW5hIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2J0Y2NoaW5hJyxcbiAgICAgICAgICAgICduYW1lJzogJ0JUQ0NoaW5hJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MzY4LTQ2NWIzMjg2LTVlZDYtMTFlNy05YTExLTBmNjQ2N2UxZDgyYi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwbHVzJzogJ2h0dHBzOi8vcGx1cy1hcGkuYnRjY2hpbmEuY29tL21hcmtldCcsXG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9kYXRhLmJ0Y2NoaW5hLmNvbS9kYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYnRjY2hpbmEuY29tL2FwaV90cmFkZV92MS5waHAnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5idGNjaGluYS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuYnRjY2hpbmEuY29tL2FwaWRvY3MnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncGx1cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaXN0b3J5ZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQnV5SWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCdXlPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQnV5T3JkZXIyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCdXlTdG9wT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbEljZWJlcmdPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbFN0b3BPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0QWNjb3VudEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEFyY2hpdmVkT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEFyY2hpdmVkT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXREZXBvc2l0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0SWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRJY2ViZXJnT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRNYXJrZXREZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0RGVwdGgyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRTdG9wT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFN0b3BPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFRyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0V2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0V2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlcXVlc3RXaXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWxsSWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWxsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlbGxPcmRlcjInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlbGxTdG9wT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9DTlknOiB7ICdpZCc6ICdidGNjbnknLCAnc3ltYm9sJzogJ0JUQy9DTlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwdWJsaWMnLCAncGx1cyc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9DTlknOiB7ICdpZCc6ICdsdGNjbnknLCAnc3ltYm9sJzogJ0xUQy9DTlknLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwdWJsaWMnLCAncGx1cyc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICdsdGNidGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJywgJ2FwaSc6ICdwdWJsaWMnLCAncGx1cyc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9DTlknOiB7ICdpZCc6ICdiY2NjbnknLCAnc3ltYm9sJzogJ0JDSC9DTlknLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwbHVzJywgJ3BsdXMnOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9DTlknOiB7ICdpZCc6ICdldGhjbnknLCAnc3ltYm9sJzogJ0VUSC9DTlknLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwbHVzJywgJ3BsdXMnOiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh7XG4gICAgICAgICAgICAnbWFya2V0JzogJ2FsbCcsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBrZXkgPSBrZXlzW3BdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNba2V5XTtcbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCAoJ18nKTtcbiAgICAgICAgICAgIGxldCBpZCA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBiYXNlID0gYmFzZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIHF1b3RlID0gcXVvdGUudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChsb3dlcmNhc2UgaW4gYmFsYW5jZXNbJ2JhbGFuY2UnXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbJ2JhbGFuY2UnXVtsb3dlcmNhc2VdWydhbW91bnQnXSk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2VzWydmcm96ZW4nXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlc1snZnJvemVuJ11bbG93ZXJjYXNlXVsnYW1vdW50J10pO1xuICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ3VzZWQnXTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBjcmVhdGVNYXJrZXRSZXF1ZXN0IChtYXJrZXQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgbGV0IGZpZWxkID0gKG1hcmtldFsncGx1cyddKSA/ICdzeW1ib2wnIDogJ21hcmtldCc7XG4gICAgICAgIHJlcXVlc3RbZmllbGRdID0gbWFya2V0WydpZCddO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSBtYXJrZXRbJ2FwaSddICsgJ0dldE9yZGVyYm9vayc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVNYXJrZXRSZXF1ZXN0IChtYXJrZXQpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlcmJvb2tbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKSxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogcGFyc2VGbG9hdCAodGlja2VyWydwcmV2X2Nsb3NlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlclBsdXMgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ1RpbWVzdGFtcCddO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydMb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydCaWRQcmljZSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0Fza1ByaWNlJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnT3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnUHJldkNscyddKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydMYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnVm9sdW1lMjRIJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gbWFya2V0WydhcGknXSArICdHZXRUaWNrZXInO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuY3JlYXRlTWFya2V0UmVxdWVzdCAobWFya2V0KTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbJ3RpY2tlciddO1xuICAgICAgICBpZiAobWFya2V0WydwbHVzJ10pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlclBsdXMgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZVBsdXMgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsndGltZXN0YW1wJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ3NpemUnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlc1BsdXMgKHRyYWRlcywgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLnBhcnNlVHJhZGVQbHVzICh0cmFkZXNbaV0sIG1hcmtldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSBtYXJrZXRbJ2FwaSddICsgJ0dldFRyYWRlJztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmNyZWF0ZU1hcmtldFJlcXVlc3QgKG1hcmtldCk7XG4gICAgICAgIGlmIChtYXJrZXRbJ3BsdXMnXSkge1xuICAgICAgICAgICAgbGV0IG5vdyA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnRfdGltZSddID0gbm93IC0gODY0MDAgKiAxMDAwO1xuICAgICAgICAgICAgcmVxdWVzdFsnZW5kX3RpbWUnXSA9IG5vdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAncyc7IC8vIHRyYWRlcyB2cyB0cmFkZVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBpZiAobWFya2V0WydwbHVzJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzUGx1cyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgJ09yZGVyMic7XG4gICAgICAgIGxldCBvcmRlciA9IHt9O1xuICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBvcmRlclsncGFyYW1zJ10gPSBbIHVuZGVmaW5lZCwgYW1vdW50LCBpZCBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ3BhcmFtcyddID0gWyBwcmljZSwgYW1vdW50LCBpZCBdO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHBhcmFtc1snbWFya2V0J107IC8vIFRPRE8gZml4bWVcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYXJhbXMnOiBbIGlkLCBtYXJrZXQgXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWNyb3NlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IHAgPSBbXTtcbiAgICAgICAgICAgIGlmICgncGFyYW1zJyBpbiBwYXJhbXMpXG4gICAgICAgICAgICAgICAgcCA9IHBhcmFtc1sncGFyYW1zJ107XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ2lkJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcCA9IHAuam9pbiAoJywnKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHJlcXVlc3QpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gKFxuICAgICAgICAgICAgICAgICd0b25jZT0nICsgbm9uY2UgK1xuICAgICAgICAgICAgICAgICcmYWNjZXNza2V5PScgKyB0aGlzLmFwaUtleSArXG4gICAgICAgICAgICAgICAgJyZyZXF1ZXN0bWV0aG9kPScgKyBtZXRob2QudG9Mb3dlckNhc2UgKCkgK1xuICAgICAgICAgICAgICAgICcmaWQ9JyArIG5vbmNlICtcbiAgICAgICAgICAgICAgICAnJm1ldGhvZD0nICsgcGF0aCArXG4gICAgICAgICAgICAgICAgJyZwYXJhbXM9JyArIHBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocXVlcnkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMScpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLmVuY29kZSAodGhpcy5hcGlLZXkgKyAnOicgKyBzaWduYXR1cmUpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgdGhpcy5zdHJpbmdUb0Jhc2U2NCAoYXV0aCksXG4gICAgICAgICAgICAgICAgJ0pzb24tUnBjLVRvbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGJ0Y3R1cmsgPSByZXF1aXJlICgnLi9idGN0dXJrLmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgYnRjZXhjaGFuZ2UgZXh0ZW5kcyBidGN0dXJrIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdidGNleGNoYW5nZScsXG4gICAgICAgICAgICAnbmFtZSc6ICdCVENFeGNoYW5nZScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1BIJywgLy8gUGhpbGlwcGluZXNcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTMwNTItNGM5MjkxMWEtNjRhYS0xMWU3LTk2ZDgtZWM2YWMzNDM1NzU3LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5idGNleGNoYW5nZS5waC9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYnRjZXhjaGFuZ2UucGgnLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL0JUQ1RyYWRlci9icm9rZXItYXBpLWRvY3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvUEhQJzogeyAnaWQnOiAnQlRDL1BIUCcsICdzeW1ib2wnOiAnQlRDL1BIUCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdQSFAnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBidGNtYXJrZXRzIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2J0Y21hcmtldHMnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQlRDIE1hcmtldHMnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdBVScsIC8vIEF1c3RyYWxpYVxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsIC8vIG1hcmtldCBkYXRhIGNhY2hlZCBmb3IgMSBzZWNvbmQgKHRyYWRlcyBjYWNoZWQgZm9yIDIgc2Vjb25kcylcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI5MTQyOTExLTBlMWFjZmMyLTdkNWMtMTFlNy05OGM0LTA3ZDk1MzJiMjlkNy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuYnRjbWFya2V0cy5uZXQnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9idGNtYXJrZXRzLm5ldC8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL0JUQ01hcmtldHMvQVBJJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L3tpZH0vdGljaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L3tpZH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQve2lkfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L3tpZH0vdHJhZGluZ2ZlZScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmR0cmFuc2Zlci93aXRoZHJhd0NyeXB0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHRyYW5zZmVyL3dpdGhkcmF3RUZUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9jcmVhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvb3BlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvdHJhZGUvaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY3JlYXRlQmF0Y2gnLCAvLyB0aGV5IHByb21pc2UgaXQncyBjb21pbmcgc29vbi4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2RldGFpbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0FVRCc6IHsgJ2lkJzogJ0JUQy9BVUQnLCAnc3ltYm9sJzogJ0JUQy9BVUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQVVEJywgJ21ha2VyJzogMC4wMDg1LCAndGFrZXInOiAwLjAwODUgfSxcbiAgICAgICAgICAgICAgICAnTFRDL0FVRCc6IHsgJ2lkJzogJ0xUQy9BVUQnLCAnc3ltYm9sJzogJ0xUQy9BVUQnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQVVEJywgJ21ha2VyJzogMC4wMDg1LCAndGFrZXInOiAwLjAwODUgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0FVRCc6IHsgJ2lkJzogJ0VUSC9BVUQnLCAnc3ltYm9sJzogJ0VUSC9BVUQnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQVVEJywgJ21ha2VyJzogMC4wMDg1LCAndGFrZXInOiAwLjAwODUgfSxcbiAgICAgICAgICAgICAgICAnRVRDL0FVRCc6IHsgJ2lkJzogJ0VUQy9BVUQnLCAnc3ltYm9sJzogJ0VUQy9BVUQnLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQVVEJywgJ21ha2VyJzogMC4wMDg1LCAndGFrZXInOiAwLjAwODUgfSxcbiAgICAgICAgICAgICAgICAnWFJQL0FVRCc6IHsgJ2lkJzogJ1hSUC9BVUQnLCAnc3ltYm9sJzogJ1hSUC9BVUQnLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnQVVEJywgJ21ha2VyJzogMC4wMDg1LCAndGFrZXInOiAwLjAwODUgfSxcbiAgICAgICAgICAgICAgICAnQkNIL0FVRCc6IHsgJ2lkJzogJ0JDSC9BVUQnLCAnc3ltYm9sJzogJ0JDSC9BVUQnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQVVEJywgJ21ha2VyJzogMC4wMDg1LCAndGFrZXInOiAwLjAwODUgfSxcbiAgICAgICAgICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ0xUQy9CVEMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDIyLCAndGFrZXInOiAwLjAwMjIgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ0VUSC9CVEMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDIyLCAndGFrZXInOiAwLjAwMjIgfSxcbiAgICAgICAgICAgICAgICAnRVRDL0JUQyc6IHsgJ2lkJzogJ0VUQy9CVEMnLCAnc3ltYm9sJzogJ0VUQy9CVEMnLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDIyLCAndGFrZXInOiAwLjAwMjIgfSxcbiAgICAgICAgICAgICAgICAnWFJQL0JUQyc6IHsgJ2lkJzogJ1hSUC9CVEMnLCAnc3ltYm9sJzogJ1hSUC9CVEMnLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDIyLCAndGFrZXInOiAwLjAwMjIgfSxcbiAgICAgICAgICAgICAgICAnQkNIL0JUQyc6IHsgJ2lkJzogJ0JDSC9CVEMnLCAnc3ltYm9sJzogJ0JDSC9CVEMnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDIyLCAndGFrZXInOiAwLjAwMjIgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWNjb3VudEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgbXVsdGlwbGllciA9IDEwMDAwMDAwMDtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSAvIG11bHRpcGxpZXIpO1xuICAgICAgICAgICAgbGV0IHVzZWQgPSBwYXJzZUZsb2F0IChiYWxhbmNlWydwZW5kaW5nRnVuZHMnXSAvIG11bHRpcGxpZXIpO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSB0b3RhbCAtIHVzZWQ7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZyZWUsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB1c2VkLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldElkT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyYm9va1sndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiZXN0QmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmVzdEFzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdFByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lMjRoJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRJZFRpY2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0SWRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAvLyAnc2luY2UnOiA1OTg2ODM0NTIzMSxcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAxMDAwMDAwMDA7IC8vIGZvciBwcmljZSBhbmQgdm9sdW1lXG4gICAgICAgIC8vIGRvZXMgQlRDIE1hcmtldHMgc3VwcG9ydCBtYXJrZXQgb3JkZXJzIGF0IGFsbD9cbiAgICAgICAgbGV0IG9yZGVyU2lkZSA9IChzaWRlID09ICdidXknKSA/ICdCaWQnIDogJ0Fzayc7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMub3JkZXJlZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ2luc3RydW1lbnQnOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlICogbXVsdGlwbGllcixcbiAgICAgICAgICAgICd2b2x1bWUnOiBhbW91bnQgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgICAgJ29yZGVyU2lkZSc6IG9yZGVyU2lkZSxcbiAgICAgICAgICAgICdvcmRlcnR5cGUnOiB0aGlzLmNhcGl0YWxpemUgKHR5cGUpLFxuICAgICAgICAgICAgJ2NsaWVudFJlcXVlc3RJZCc6IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJDcmVhdGUgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXJzIChpZHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlckNhbmNlbCAoeyAnb3JkZXJfaWRzJzogaWRzIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jYW5jZWxPcmRlcnMgKFsgaWQgXSk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJpID0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHVyaTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdXJpICsgXCJcXG5cIiArIG5vbmNlICsgXCJcXG5cIjtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnYXBpa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IG5vbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgYXV0aCArPSBib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuYmFzZTY0VG9CaW5hcnkgKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgc2VjcmV0LCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVyc1snc2lnbmF0dXJlJ10gPSB0aGlzLmRlY29kZSAoc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydzdWNjZXNzJ10pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBidGN0cmFkZXVhIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2J0Y3RyYWRldWEnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQlRDIFRyYWRlIFVBJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVUEnLCAvLyBVa3JhaW5lLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDMwMDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTQxNDgzLTc5ZmM3MzUwLTYyZDktMTFlNy05ZjYxLWFjNDdmMjhmY2Q5Ni5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9idGMtdHJhZGUuY29tLnVhL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2J0Yy10cmFkZS5jb20udWEnLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xb2NZQTB5TXlfUlhkNTYxc2ZHM3FFUFo4MGt5bGwzNkhVeHZDUmU1R2JoRS9lZGl0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVhbHMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy9zZWxsL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMvYnV5L3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdqYXBhbl9zdGF0L2hpZ2gve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Fzay97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmlkL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXkve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215X29yZGVycy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvc3RhdHVzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbW92ZS9vcmRlci97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxsL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVUFIJzogeyAnaWQnOiAnYnRjX3VhaCcsICdzeW1ib2wnOiAnQlRDL1VBSCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVQUgnLCAncHJlY2lzaW9uJzogeyAncHJpY2UnOiAxIH0sICdsaW1pdHMnOiB7ICdhbW91bnQnOiB7ICdtaW4nOiAwLjAwMDAwMDAwMDEgfX19LFxuICAgICAgICAgICAgICAgICdFVEgvVUFIJzogeyAnaWQnOiAnZXRoX3VhaCcsICdzeW1ib2wnOiAnRVRIL1VBSCcsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdVQUgnIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9VQUgnOiB7ICdpZCc6ICdsdGNfdWFoJywgJ3N5bWJvbCc6ICdMVEMvVUFIJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgICAgICAgICAnRE9HRS9VQUgnOiB7ICdpZCc6ICdkb2dlX3VhaCcsICdzeW1ib2wnOiAnRE9HRS9VQUgnLCAnYmFzZSc6ICdET0dFJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgICAgICAgICAnREFTSC9VQUgnOiB7ICdpZCc6ICdkYXNoX3VhaCcsICdzeW1ib2wnOiAnREFTSC9VQUgnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgICAgICAgICAnU0lCL1VBSCc6IHsgJ2lkJzogJ3NpYl91YWgnLCAnc3ltYm9sJzogJ1NJQi9VQUgnLCAnYmFzZSc6ICdTSUInLCAncXVvdGUnOiAnVUFIJyB9LFxuICAgICAgICAgICAgICAgICdLUkIvVUFIJzogeyAnaWQnOiAna3JiX3VhaCcsICdzeW1ib2wnOiAnS1JCL1VBSCcsICdiYXNlJzogJ0tSQicsICdxdW90ZSc6ICdVQUgnIH0sXG4gICAgICAgICAgICAgICAgJ05WQy9VQUgnOiB7ICdpZCc6ICdudmNfdWFoJywgJ3N5bWJvbCc6ICdOVkMvVUFIJywgJ2Jhc2UnOiAnTlZDJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ2x0Y19idGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgICdOVkMvQlRDJzogeyAnaWQnOiAnbnZjX2J0YycsICdzeW1ib2wnOiAnTlZDL0JUQycsICdiYXNlJzogJ05WQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgJ0lUSS9VQUgnOiB7ICdpZCc6ICdpdGlfdWFoJywgJ3N5bWJvbCc6ICdJVEkvVUFIJywgJ2Jhc2UnOiAnSVRJJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgICAgICAgICAnRE9HRS9CVEMnOiB7ICdpZCc6ICdkb2dlX2J0YycsICdzeW1ib2wnOiAnRE9HRS9CVEMnLCAnYmFzZSc6ICdET0dFJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAnREFTSC9CVEMnOiB7ICdpZCc6ICdkYXNoX2J0YycsICdzeW1ib2wnOiAnREFTSC9CVEMnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4xIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjEgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNpZ25JbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0QXV0aCAoKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGlmICgnYWNjb3VudHMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsZXQgYWNjb3VudHMgPSByZXNwb25zZVsnYWNjb3VudHMnXTtcbiAgICAgICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYWNjb3VudHMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYWNjb3VudCA9IGFjY291bnRzW2JdO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGFjY291bnRbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBwYXJzZUZsb2F0IChhY2NvdW50WydiYWxhbmNlJ10pO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgYmlkcyA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzQnV5U3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBhc2tzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNTZWxsU3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSB7XG4gICAgICAgICAgICAnYmlkcyc6IFtdLFxuICAgICAgICAgICAgJ2Fza3MnOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGJpZHMpIHtcbiAgICAgICAgICAgIGlmICgnbGlzdCcgaW4gYmlkcylcbiAgICAgICAgICAgICAgICBvcmRlcmJvb2tbJ2JpZHMnXSA9IGJpZHNbJ2xpc3QnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNrcykge1xuICAgICAgICAgICAgaWYgKCdsaXN0JyBpbiBhc2tzKVxuICAgICAgICAgICAgICAgIG9yZGVyYm9va1snYXNrcyddID0gYXNrc1snbGlzdCddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdjdXJyZW5jeV90cmFkZScpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0SmFwYW5TdGF0SGlnaFN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMuZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCk7XG4gICAgICAgIGxldCBiaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBudW1CaWRzID0gb3JkZXJib29rWydiaWRzJ10ubGVuZ3RoO1xuICAgICAgICBpZiAobnVtQmlkcyA+IDApXG4gICAgICAgICAgICBiaWQgPSBvcmRlcmJvb2tbJ2JpZHMnXVswXVswXTtcbiAgICAgICAgbGV0IGFzayA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG51bUFza3MgPSBvcmRlcmJvb2tbJ2Fza3MnXS5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Bc2tzID4gMClcbiAgICAgICAgICAgIGFzayA9IG9yZGVyYm9va1snYXNrcyddWzBdWzBdO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RyYWRlcyddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiBiaWQsXG4gICAgICAgICAgICAnYXNrJzogYXNrLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgdGlja2VyTGVuZ3RoID0gdGlja2VyLmxlbmd0aDtcbiAgICAgICAgaWYgKHRpY2tlckxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4ICh0aWNrZXJMZW5ndGggLSA0OCwgMCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gc3RhcnQ7IHQgPCB0aWNrZXIubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FuZGxlID0gdGlja2VyW3RdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0WydvcGVuJ10gPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsnb3BlbiddID0gY2FuZGxlWzFdO1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHJlc3VsdFsnaGlnaCddID09ICd1bmRlZmluZWQnKSB8fCAocmVzdWx0WydoaWdoJ10gPCBjYW5kbGVbMl0pKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ2hpZ2gnXSA9IGNhbmRsZVsyXTtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiByZXN1bHRbJ2xvdyddID09ICd1bmRlZmluZWQnKSB8fCAocmVzdWx0Wydsb3cnXSA+IGNhbmRsZVszXSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsnbG93J10gPSBjYW5kbGVbM107XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbJ2Jhc2VWb2x1bWUnXSA9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WydiYXNlVm9sdW1lJ10gPSAtY2FuZGxlWzVdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0WydiYXNlVm9sdW1lJ10gLT0gY2FuZGxlWzVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aWNrZXJMZW5ndGggLSAxO1xuICAgICAgICAgICAgcmVzdWx0WydjbG9zZSddID0gdGlja2VyW2xhc3RdWzRdO1xuICAgICAgICAgICAgcmVzdWx0WydiYXNlVm9sdW1lJ10gPSAtMSAqIHJlc3VsdFsnYmFzZVZvbHVtZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29udmVydEN5cmlsbGljTW9udGhOYW1lVG9TdHJpbmcgKGN5cmlsbGljKSB7XG4gICAgICAgIGxldCBtb250aHMgPSBbXG4gICAgICAgICAgICAn0Y/QvdCy0LDRgNGPJyxcbiAgICAgICAgICAgICfRhNC10LLRgNCw0LvRjycsXG4gICAgICAgICAgICAn0LzQsNGA0YLQsCcsXG4gICAgICAgICAgICAn0LDQv9GA0LXQu9GPJyxcbiAgICAgICAgICAgICfQvNCw0Y8nLFxuICAgICAgICAgICAgJ9C40Y7QvdGPJyxcbiAgICAgICAgICAgICfQuNGO0LvRjycsXG4gICAgICAgICAgICAn0LDQstCz0YPRgdGC0LAnLFxuICAgICAgICAgICAgJ9GB0LXQvdGC0Y/QsdGA0Y8nLFxuICAgICAgICAgICAgJ9C+0LrRgtGP0LHRgNGPJyxcbiAgICAgICAgICAgICfQvdC+0Y/QsdGA0Y8nLFxuICAgICAgICAgICAgJ9C00LXQutCw0LHRgNGPJyxcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IG1vbnRoID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vbnRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGN5cmlsbGljID09IG1vbnRoc1tpXSkge1xuICAgICAgICAgICAgICAgIG1vbnRoID0gaSArIDE7XG4gICAgICAgICAgICAgICAgbW9udGggPSBtb250aC50b1N0cmluZyAoKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDkpXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gJzAnICsgbW9udGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbnRoO1xuICAgIH1cblxuICAgIHBhcnNlQ3lyaWxsaWNEYXRldGltZSAoY3lyaWxsaWMpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gY3lyaWxsaWMuc3BsaXQgKCcgJyk7XG4gICAgICAgIGxldCBkYXkgPSBwYXJ0c1swXTtcbiAgICAgICAgbGV0IG1vbnRoID0gdGhpcy5jb252ZXJ0Q3lyaWxsaWNNb250aE5hbWVUb1N0cmluZyAocGFydHNbMV0pO1xuICAgICAgICBpZiAoIW1vbnRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHBhcnNlVHJhZGUoKSB1bmRlZmluZWQgbW9udGggbmFtZTogJyArIGN5cmlsbGljKTtcbiAgICAgICAgbGV0IHllYXIgPSBwYXJ0c1syXTtcbiAgICAgICAgbGV0IGhtcyA9IHBhcnRzWzRdO1xuICAgICAgICBsZXQgaG1zTGVuZ3RoID0gaG1zLmxlbmd0aDtcbiAgICAgICAgaWYgKGhtc0xlbmd0aCA9PSA3KSB7XG4gICAgICAgICAgICBobXMgPSAnMCcgKyBobXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHltZCA9IFsgeWVhciwgbW9udGgsIGRheSBdLmpvaW4gKCctJyk7XG4gICAgICAgIGxldCB5bWRobXMgPSB5bWQgKyAnVCcgKyBobXM7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAoeW1kaG1zKTtcbiAgICAgICAgdGltZXN0YW1wID0gdGltZXN0YW1wIC0gMTA4MDAwMDA7IC8vIHNlcnZlciByZXBvcnRzIGxvY2FsIEdNVCszIHRpbWUsIGFkanVzdCB0byBVVENcbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcDtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlQ3lyaWxsaWNEYXRldGltZSAodHJhZGVbJ3B1Yl9kYXRlJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1udF90cmFkZSddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZWFsc1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdHJhZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVtpXVsnaWQnXSAlIDIpIHtcbiAgICAgICAgICAgICAgICB0cmFkZXMucHVzaCAocmVzcG9uc2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSkgKyAnSWQnO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY291bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnY3VycmVuY3kxJzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RSZW1vdmVPcmRlcklkICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLCAvLyB1bnRpbCB0aGV5IGZpeCB0aGVpciB0aW1lc3RhbXBcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb3BlbicsXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2FtbnRfdHJhZGUnXSxcbiAgICAgICAgICAgICdmaWxsZWQnOiAwLFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IHRyYWRlWydhbW50X3RyYWRlJ10sXG4gICAgICAgICAgICAndHJhZGVzJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaE9wZW5PcmRlcnMgcmVxdWlyZXMgYSBzeW1ib2wgcGFyYW0nKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TXlPcmRlcnNTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHJlc3BvbnNlWyd5b3VyX29wZW5fb3JkZXJzJ107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChvcmRlcnMsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ291dF9vcmRlcl9pZCc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gYm9keSArIHRoaXMuc2VjcmV0O1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAncHVibGljLWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdhcGktc2lnbic6IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKGF1dGgpLCAnc2hhMjU2JyksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ0Y3R1cmsgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYnRjdHVyaycsXG4gICAgICAgICAgICAnbmFtZSc6ICdCVENUdXJrJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVFInLCAvLyBUdXJrZXlcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMWQnOiAnMWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTI3MDktMThlMTU2NDYtNjRhMy0xMWU3LTlmYTItYjA5NTBlYzc3MTJmLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5idGN0dXJrLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYnRjdHVyay5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL0JUQ1RyYWRlci9icm9rZXItYXBpLWRvY3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvaGxjZGF0YScsIC8vID9sYXN0PUNPVU5UXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsICAgLy8gP2xhc3Q9Q09VTlQgKG1heCA1MClcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJUcmFuc2FjdGlvbnMnLCAvLyA/b2Zmc2V0PTAmbGltaXQ9MjUmc29ydD1hc2NcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1RSWSc6IHsgJ2lkJzogJ0JUQ1RSWScsICdzeW1ib2wnOiAnQlRDL1RSWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdUUlknLCAnbWFrZXInOiAwLjAwMiAqIDEuMTgsICd0YWtlcic6IDAuMDAzNSAqIDEuMTggfSxcbiAgICAgICAgICAgICAgICAnRVRIL1RSWSc6IHsgJ2lkJzogJ0VUSFRSWScsICdzeW1ib2wnOiAnRVRIL1RSWScsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdUUlknLCAnbWFrZXInOiAwLjAwMiAqIDEuMTgsICd0YWtlcic6IDAuMDAzNSAqIDEuMTggfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ0VUSEJUQycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMiAqIDEuMTgsICd0YWtlcic6IDAuMDAzNSAqIDEuMTggfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBsZXQgYmFzZSA9IHtcbiAgICAgICAgICAgICdmcmVlJzogcmVzcG9uc2VbJ2JpdGNvaW5fYXZhaWxhYmxlJ10sXG4gICAgICAgICAgICAndXNlZCc6IHJlc3BvbnNlWydiaXRjb2luX3Jlc2VydmVkJ10sXG4gICAgICAgICAgICAndG90YWwnOiByZXNwb25zZVsnYml0Y29pbl9iYWxhbmNlJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBxdW90ZSA9IHtcbiAgICAgICAgICAgICdmcmVlJzogcmVzcG9uc2VbJ21vbmV5X2F2YWlsYWJsZSddLFxuICAgICAgICAgICAgJ3VzZWQnOiByZXNwb25zZVsnbW9uZXlfcmVzZXJ2ZWQnXSxcbiAgICAgICAgICAgICd0b3RhbCc6IHJlc3BvbnNlWydtb25leV9iYWxhbmNlJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzeW1ib2wgPSB0aGlzLnN5bWJvbHNbMF07XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXTtcbiAgICAgICAgcmVzdWx0W21hcmtldFsnYmFzZSddXSA9IGJhc2U7XG4gICAgICAgIHJlc3VsdFttYXJrZXRbJ3F1b3RlJ11dID0gcXVvdGU7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyU3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ3RpbWVzdGFtcCddICogMTAwMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXZlcmFnZSddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB0aWNrZXJbJ3BhaXInXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc3ltYm9sIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtzeW1ib2xdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5mZXRjaFRpY2tlcnMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wgaW4gdGlja2VycylcbiAgICAgICAgICAgIHJlc3VsdCA9IHRpY2tlcnNbc3ltYm9sXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAvLyBsZXQgbWF4Q291bnQgPSA1MDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpclN5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxZCcsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9obGN2WydUaW1lJ10pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgb2hsY3ZbJ09wZW4nXSxcbiAgICAgICAgICAgIG9obGN2WydIaWdoJ10sXG4gICAgICAgICAgICBvaGxjdlsnTG93J10sXG4gICAgICAgICAgICBvaGxjdlsnQ2xvc2UnXSxcbiAgICAgICAgICAgIG9obGN2WydWb2x1bWUnXSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxZCcsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsYXN0J10gPSBsaW1pdDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPaGxjZGF0YSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ1R5cGUnOiAoc2lkZSA9PSAnYnV5JykgPyAnQnV5QnRjJyA6ICdTZWxCdGMnLFxuICAgICAgICAgICAgJ0lzTWFya2V0T3JkZXInOiAodHlwZSA9PSAnbWFya2V0JykgPyAxIDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIGlmIChzaWRlID09ICdidXknKVxuICAgICAgICAgICAgICAgIG9yZGVyWydUb3RhbCddID0gYW1vdW50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9yZGVyWydBbW91bnQnXSA9IGFtb3VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyWydQcmljZSddID0gcHJpY2U7XG4gICAgICAgICAgICBvcmRlclsnQW1vdW50J10gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh7ICdpZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQgPT0gJ2J0Y3RyYWRlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgaXMgYW4gYWJzdHJhY3QgYmFzZSBBUEkgZm9yIEJUQ0V4Y2hhbmdlLCBCVENUdXJrJyk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5iYXNlNjRUb0JpbmFyeSAodGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLmFwaUtleSArIG5vbmNlO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnWC1QQ0snOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnWC1TdGFtcCc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdYLVNpZ25hdHVyZSc6IHRoaXMuc3RyaW5nVG9CYXNlNjQodGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHNlY3JldCwgJ3NoYTI1NicsICdiaW5hcnknKSksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ0Y3ggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnYnRjeCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdCVENYJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdJUycsICdVUycsICdFVScgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLCAvLyBzdXBwb3J0IGluIGVuZ2xpc2ggaXMgdmVyeSBwb29yLCB1bmFibGUgdG8gdGVsbCByYXRlIGxpbWl0c1xuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYzODUtOWZkY2M5OGMtNWVkNi0xMWU3LThmMTQtNjZkNWU1Y2Q0N2U2LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2J0Yy14LmlzL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2J0Yy14LmlzJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYnRjLXguaXMvY3VzdG9tL2FwaS1kb2N1bWVudC5odG1sJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgve2lkfS97bGltaXR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUve2lkfS97bGltaXR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWRlZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0Yy91c2QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvRVVSJzogeyAnaWQnOiAnYnRjL2V1cicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlc1tjdXJyZW5jeV0sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZXNbY3VycmVuY3ldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGhJZExpbWl0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdsaW1pdCc6IDEwMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VySWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAnYXNrJykgPyAnc2VsbCcgOiAnYnV5JztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlSWRMaW1pdCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdsaW1pdCc6IDEwMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAndHlwZSc6IHNpZGUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyJ11bJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsICh7ICdvcmRlcic6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLyc7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICB1cmwgKz0gYXBpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdNZXRob2QnOiBwYXRoLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgICAgICdOb25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBidGVyIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2J0ZXInLFxuICAgICAgICAgICAgJ25hbWUnOiAnQnRlcicsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnVkcnLCAnQ04nIF0sIC8vIEJyaXRpc2ggVmlyZ2luIElzbGFuZHMsIENoaW5hXG4gICAgICAgICAgICAndmVyc2lvbic6ICcyJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTgwNDc5LWNmYTMxODhjLTYzODctMTFlNy04MTkxLTkzZmM0MTg0YmE1Yy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9kYXRhLmJ0ZXIuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmJ0ZXIuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYnRlci5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9idGVyLmNvbS9hcGkyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFpcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldGluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldGxpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlci97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlckJvb2sve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVIaXN0b3J5L3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlSGlzdG9yeS97aWR9L3t0aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdEFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ25ld0FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRzV2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbEFsbE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0T3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldGluZm8gKCk7XG4gICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ3BhaXJzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpXTtcbiAgICAgICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldCk7XG4gICAgICAgICAgICBsZXQgaWQgPSBrZXlzWzBdO1xuICAgICAgICAgICAgbGV0IGRldGFpbHMgPSBtYXJrZXRbaWRdO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IGlkLnNwbGl0ICgnXycpO1xuICAgICAgICAgICAgYmFzZSA9IGJhc2UudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBxdW90ZSA9IHF1b3RlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBkZXRhaWxzWydkZWNpbWFsX3BsYWNlcyddLFxuICAgICAgICAgICAgICAgICdwcmljZSc6IGRldGFpbHNbJ2RlY2ltYWxfcGxhY2VzJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFtb3VudExpbWl0cyA9IHtcbiAgICAgICAgICAgICAgICAnbWluJzogZGV0YWlsc1snbWluX2Ftb3VudCddLFxuICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHByaWNlTGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgbGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnRMaW1pdHMsXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2VMaW1pdHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBkZXRhaWxzWydmZWUnXSAvIDEwMCxcbiAgICAgICAgICAgICAgICAndGFrZXInOiBkZXRhaWxzWydmZWUnXSAvIDEwMCxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiBsaW1pdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmICgnYXZhaWxhYmxlJyBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2VbJ2F2YWlsYWJsZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddW2N1cnJlbmN5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdsb2NrZWQnIGluIGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZVsnbG9ja2VkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnbG9ja2VkJ11bY3VycmVuY3ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjb2RlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9va0lkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgICAgICByZXN1bHRbJ2Fza3MnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2Fza3MnXSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoMjRociddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdzI0aHInXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoZXN0QmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93ZXN0QXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsncGVyY2VudENoYW5nZSddKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsncXVvdGVWb2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Jhc2VWb2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgWyBiYXNlSWQsIHF1b3RlSWQgXSA9IGlkLnNwbGl0ICgnXycpO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBiYXNlSWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBxdW90ZUlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHN5bWJvbCBpbiB0aGlzLm1hcmtldHMpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5tYXJrZXRzX2J5X2lkKVxuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VySWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFkZUlEJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncmF0ZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRoaXMuc2FmZUZsb2F0ICh0cmFkZSwgJ2Ftb3VudCcpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlSGlzdG9yeUlkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydkYXRhJ10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyTnVtYmVyJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ29yZGVyTnVtYmVyJzogaWQgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcywgLy8gQWRkcmVzcyBtdXN0IGV4aXN0IGluIHlvdSBBZGRyZXNzQm9vayBpbiBzZWN1cml0eSBzZXR0aW5nc1xuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcHJlZml4ID0gKGFwaSA9PSAncHJpdmF0ZScpID8gKGFwaSArICcvJykgOiAnJztcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArIHRoaXMudmVyc2lvbiArICcvMS8nICsgcHJlZml4ICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0geyAnbm9uY2UnOiBub25jZSB9O1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddICE9ICd0cnVlJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGJ4aW50aCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdieGludGgnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQlguaW4udGgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdUSCcsIC8vIFRoYWlsYW5kXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY0MTItNTY3YjFlYjQtNWVkNy0xMWU3LTk0YTgtZmY2YTM4ODRmNmM1LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2J4LmluLnRoL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2J4LmluLnRoJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYnguaW4udGgvaW5mby9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICcnLCAvLyB0aWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb25ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhaXJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZWhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpbGxlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmlsbGdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaWxscGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldG9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uLWlzc3VlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24tYmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24tc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uLW15aXNzdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wdGlvbi1teWJpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uLW15b3B0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uLWV4ZXJjaXNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24tY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcHRpb24taGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwtaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4yNSAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFBhaXJpbmcgKCk7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwga2V5cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNba2V5c1twXV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3BhaXJpbmdfaWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydzZWNvbmRhcnlfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsncHJpbWFyeV9jdXJyZW5jeSddO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIC8vIHdoeSB3b3VsZCB0aGV5IHVzZSB0aHJlZSBsZXR0ZXJzIGluc3RlYWQgb2YgZm91ciBmb3IgY3VycmVuY3kgY29kZXNcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdEQVMnKVxuICAgICAgICAgICAgcmV0dXJuICdEQVNIJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdET0cnKVxuICAgICAgICAgICAgcmV0dXJuICdET0dFJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbJ2JhbGFuY2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2UpO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydhdmFpbGFibGUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ3RvdGFsJ10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY29kZV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcmluZyc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG93JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3JkZXJib29rJ11bJ2JpZHMnXVsnaGlnaGJpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29yZGVyYm9vayddWydhc2tzJ11bJ2hpZ2hiaWQnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RfcHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydjaGFuZ2UnXSksXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV8yNGhvdXJzJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0IChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcmluZyc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBpZCA9IG1hcmtldFsnaWQnXS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsndHJhZGVfZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFkZV9pZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdvcmRlcic6IHRyYWRlWydvcmRlcl9pZCddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0cmFkZV90eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncmF0ZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXJpbmcnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXJpbmcnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcGFpcmluZyA9IHVuZGVmaW5lZDsgLy8gVE9ETyBmaXhtZVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbCAoe1xuICAgICAgICAgICAgJ29yZGVyX2lkJzogaWQsXG4gICAgICAgICAgICAncGFpcmluZyc6IHBhaXJpbmcsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLyc7XG4gICAgICAgIGlmIChwYXRoKVxuICAgICAgICAgICAgdXJsICs9IHBhdGggKyAnLyc7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMuYXBpS2V5ICsgbm9uY2UudG9TdHJpbmcgKCkgKyB0aGlzLnNlY3JldDtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhhc2ggKHRoaXMuZW5jb2RlIChhdXRoKSwgJ3NoYTI1NicpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgIC8vIHR3b2ZhOiB0aGlzLnR3b2ZhLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJylcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY2NleCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjY2V4JyxcbiAgICAgICAgICAgICduYW1lJzogJ0MtQ0VYJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdERScsICdFVScgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjQzMy0xNjg4MWY5MC01ZWQ4LTExZTctOTJmOC0zZDkyY2M3NDdhNmMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAndGlja2Vycyc6ICdodHRwczovL2MtY2V4LmNvbS90JyxcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2MtY2V4LmNvbS90L2FwaV9wdWIuaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYy1jZXguY29tL3QvYXBpLmh0bWwnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2MtY2V4LmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2MtY2V4LmNvbS8/aWQ9YXBpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICd0aWNrZXJzJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvaW5uYW1lcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne21hcmtldH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BhaXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcmljZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZvbHVtZV97Y29pbn0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlZGlzdHJpYnV0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzdW1tYXJpZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXlsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRiYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0b3Blbm9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0b3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldG9yZGVyaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdJT1QnKVxuICAgICAgICAgICAgcmV0dXJuICdJb1Rjb2luJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCTEMnKVxuICAgICAgICAgICAgcmV0dXJuICdDcnlwdG9idWxsY29pbic7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnWElEJylcbiAgICAgICAgICAgIHJldHVybiAnSW50ZXJuYXRpb25hbERpYW1vbmQnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWydyZXN1bHQnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3Jlc3VsdCddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydNYXJrZXROYW1lJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnTWFya2V0Q3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnQmFzZUN1cnJlbmN5J107XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBiYWxhbmNlWydDdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGNvZGUpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydBdmFpbGFibGUnXSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IGJhbGFuY2VbJ1BlbmRpbmcnXSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlWydCYWxhbmNlJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6ICdib3RoJyxcbiAgICAgICAgICAgICdkZXB0aCc6IDEwMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2J1eScsICdzZWxsJywgJ1JhdGUnLCAnUXVhbnRpdHknKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndXBkYXRlZCddICogMTAwMDtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdHByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2F2ZyddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eXN1cHBvcnQnKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnRpY2tlcnNHZXRQcmljZXMgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogdGlja2VycyB9O1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodXBwZXJjYXNlIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFt1cHBlcmNhc2VdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSB1cHBlcmNhc2Uuc3BsaXQgKCctJyk7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMudGlja2Vyc0dldE1hcmtldCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RpY2tlciddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnVGltZVN0YW1wJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ0lkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydPcmRlclR5cGUnXS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydQcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydRdWFudGl0eSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldGhpc3RvcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiAnYm90aCcsXG4gICAgICAgICAgICAnZGVwdGgnOiAxMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3Jlc3VsdCddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlR2V0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSkgKyB0eXBlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IGFtb3VudCxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXN1bHQnXVsndXVpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlR2V0Q2FuY2VsICh7ICd1dWlkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5rZXlzb3J0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdhJzogcGF0aCxcbiAgICAgICAgICAgICAgICAnYXBpa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHsgJ2FwaXNpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlICh1cmwpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJykgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYSc6ICdnZXQnICsgcGF0aCxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsICs9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKSArICcuanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKGFwaSA9PSAndGlja2VycycpXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGNleCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjZXgnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQ0VYLklPJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdHQicsICdFVScsICdDWScsICdSVScgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcxbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjQ0Mi04ZGRjMzNiMC01ZWQ4LTExZTctOGI5OC1mNzg2YWVmMGYzYzkuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vY2V4LmlvL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2NleC5pbycsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2NleC5pby9jZXgtYXBpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmVxdWlyZWRDcmVkZW50aWFscyc6IHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnc2VjcmV0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndWlkJzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVuY3lfbGltaXRzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGFzdF9wcmljZS97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsYXN0X3ByaWNlcy97Y3VycmVuY2llc30vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvaGxjdi9oZC97eXl5eW1tZGR9L3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfYm9vay97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2Vycy97Y3VycmVuY2llc30vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZV9oaXN0b3J5L3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb252ZXJ0L3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJpY2Vfc3RhdHMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY3RpdmVfb3JkZXJzX3N0YXR1cy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyY2hpdmVkX29yZGVycy97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVyLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVycy97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfcmVwbGFjZV9vcmRlci97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbG9zZV9wb3NpdGlvbi97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfYWRkcmVzcy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9teWZlZS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9vcmRlci8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9vcmRlcl90eC8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5fb3JkZXJzL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5fb3JkZXJzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbl9wb3NpdGlvbi97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX3Bvc2l0aW9ucy97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZV9vcmRlci97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDdXJyZW5jeUxpbWl0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHNbJ2RhdGEnXVsncGFpcnMnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ2RhdGEnXVsncGFpcnMnXVtwXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnc3ltYm9sMSddICsgJy8nICsgbWFya2V0WydzeW1ib2wyJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQ7XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB0aGlzLnByZWNpc2lvbkZyb21TdHJpbmcgKG1hcmtldFsnbWluUHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiAtMSAqIE1hdGgubG9nMTAgKG1hcmtldFsnbWluTG90U2l6ZSddKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbWFya2V0WydtaW5Mb3RTaXplJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogbWFya2V0WydtYXhMb3RTaXplJ10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBwYXJzZUZsb2F0IChtYXJrZXRbJ21pblByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHBhcnNlRmxvYXQgKG1hcmtldFsnbWF4UHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IG1hcmtldFsnbWluTG90U2l6ZVMyJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgbGV0IG9tbWl0ZWQgPSBbICd1c2VybmFtZScsICd0aW1lc3RhbXAnIF07XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHRoaXMub21pdCAocmVzcG9uc2UsIG9tbWl0ZWQpO1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAnZnJlZSc6IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlc1tjdXJyZW5jeV0sICdhdmFpbGFibGUnLCAwLjApLFxuICAgICAgICAgICAgICAgICAgICAndXNlZCc6IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlc1tjdXJyZW5jeV0sICdvcmRlcnMnLCAwLjApLFxuICAgICAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlcmJvb2tbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WzBdICogMTAwMCxcbiAgICAgICAgICAgIG9obGN2WzFdLFxuICAgICAgICAgICAgb2hsY3ZbMl0sXG4gICAgICAgICAgICBvaGxjdlszXSxcbiAgICAgICAgICAgIG9obGN2WzRdLFxuICAgICAgICAgICAgb2hsY3ZbNV0sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgaWYgKCFzaW5jZSlcbiAgICAgICAgICAgIHNpbmNlID0gdGhpcy5taWxsaXNlY29uZHMgKCkgLSA4NjQwMDAwMDsgLy8geWVzdGVyZGF5XG4gICAgICAgIGxldCB5bWQgPSB0aGlzLlltZCAoc2luY2UpO1xuICAgICAgICB5bWQgPSB5bWQuc3BsaXQgKCctJyk7XG4gICAgICAgIHltZCA9IHltZC5qb2luICgnJyk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAneXl5eW1tZGQnOiB5bWQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T2hsY3ZIZFl5eXltbWRkUGFpciAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQga2V5ID0gJ2RhdGEnICsgdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV07XG4gICAgICAgIGxldCBvaGxjdnMgPSBKU09OLnBhcnNlIChyZXNwb25zZVtrZXldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKG9obGN2cywgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBpc284NjAxID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3RpbWVzdGFtcCcgaW4gdGlja2VyKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBwYXJzZUludCAodGlja2VyWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICAgICAgaXNvODYwMSA9IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdm9sdW1lID0gdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbHVtZScpO1xuICAgICAgICBsZXQgaGlnaCA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdoaWdoJyk7XG4gICAgICAgIGxldCBsb3cgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93Jyk7XG4gICAgICAgIGxldCBiaWQgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYmlkJyk7XG4gICAgICAgIGxldCBhc2sgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXNrJyk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IGlzbzg2MDEsXG4gICAgICAgICAgICAnaGlnaCc6IGhpZ2gsXG4gICAgICAgICAgICAnbG93JzogbG93LFxuICAgICAgICAgICAgJ2JpZCc6IGJpZCxcbiAgICAgICAgICAgICdhc2snOiBhc2ssXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBsYXN0LFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzQ3VycmVuY2llcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jaWVzJzogY3VycmVuY2llcy5qb2luICgnLycpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGlja2Vycy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbdF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gdGlja2VyWydwYWlyJ10ucmVwbGFjZSAoJzonLCAnLycpO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlSGlzdG9yeVBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmb3IgbWFya2V0IGJ1eSBDRVguaW8gcmVxdWlyZXMgdGhlIGFtb3VudCBvZiBxdW90ZSBjdXJyZW5jeSB0byBzcGVuZFxuICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3JkZXIgKCdGb3IgbWFya2V0IGJ1eSBvcmRlcnMgJyArIHRoaXMuaWQgKyBcIiByZXF1aXJlcyB0aGUgYW1vdW50IG9mIHF1b3RlIGN1cnJlbmN5IHRvIHNwZW5kLCB0byBjYWxjdWxhdGUgcHJvcGVyIGNvc3RzIGNhbGwgY3JlYXRlT3JkZXIgKHN5bWJvbCwgJ21hcmtldCcsICdidXknLCBhbW91bnQsIHByaWNlKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JkZXJbJ2Ftb3VudCddID0gYW1vdW50ICogcHJpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcmRlclsnb3JkZXJfdHlwZSddID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UGxhY2VPcmRlclBhaXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLnRvU3RyaW5nICgpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJbJ3RpbWUnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KSB7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gb3JkZXJbJ3N5bWJvbDEnXSArICcvJyArIG9yZGVyWydzeW1ib2wyJ107XG4gICAgICAgICAgICBpZiAoc3ltYm9sIGluIHRoaXMubWFya2V0cylcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHVzID0gb3JkZXJbJ3N0YXR1cyddO1xuICAgICAgICBpZiAoc3RhdHVzID09ICdjZCcpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09ICdjJykge1xuICAgICAgICAgICAgc3RhdHVzID0gJ2NhbmNlbGVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ2QnKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2xvc2VkJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJpY2UgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdwcmljZScpO1xuICAgICAgICBsZXQgYW1vdW50ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnYW1vdW50Jyk7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdwZW5kaW5nJyk7XG4gICAgICAgIGlmICghcmVtYWluaW5nKVxuICAgICAgICAgICAgcmVtYWluaW5nID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAncmVtYWlucycpO1xuICAgICAgICBsZXQgZmlsbGVkID0gYW1vdW50IC0gcmVtYWluaW5nO1xuICAgICAgICBsZXQgZmVlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29zdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGNvc3QgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICd0YTonICsgbWFya2V0WydxdW90ZSddKTtcbiAgICAgICAgICAgIGxldCBiYXNlRmVlID0gJ2ZhOicgKyBtYXJrZXRbJ2Jhc2UnXTtcbiAgICAgICAgICAgIGxldCBxdW90ZUZlZSA9ICdmYTonICsgbWFya2V0WydxdW90ZSddO1xuICAgICAgICAgICAgbGV0IGZlZVJhdGUgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICd0cmFkaW5nRmVlTWFrZXInKTtcbiAgICAgICAgICAgIGlmICghZmVlUmF0ZSlcbiAgICAgICAgICAgICAgICBmZWVSYXRlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAndHJhZGluZ0ZlZVRha2VyJywgZmVlUmF0ZSk7XG4gICAgICAgICAgICBpZiAoZmVlUmF0ZSlcbiAgICAgICAgICAgICAgICBmZWVSYXRlIC89IDEwMC4wOyAvLyBjb252ZXJ0IHRvIG1hdGhlbWF0aWNhbGx5LWNvcnJlY3QgcGVyY2VudGFnZSBjb2VmZmljaWVudHM6IDEuMCA9IDEwMCVcbiAgICAgICAgICAgIGlmIChiYXNlRmVlIGluIG9yZGVyKSB7XG4gICAgICAgICAgICAgICAgZmVlID0ge1xuICAgICAgICAgICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3JhdGUnOiBmZWVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgYmFzZUZlZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocXVvdGVGZWUgaW4gb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3JhdGUnOiBmZWVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgcXVvdGVGZWUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb3N0KVxuICAgICAgICAgICAgY29zdCA9IHByaWNlICogZmlsbGVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ2lkJ10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ3RyYWRlcyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmZWUnOiBmZWUsXG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RPcGVuT3JkZXJzJztcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydwYWlyJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgICAgICBtZXRob2QgKz0gJ1BhaXInO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9yZGVyc1tpXSA9IHRoaXMuZXh0ZW5kIChvcmRlcnNbaV0sIHsgJ3N0YXR1cyc6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAob3JkZXJzLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlICsgdGhpcy51aWQgKyB0aGlzLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBxdWVyeSkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXR1cm5lZCAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlID09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSBlbHNlIGlmICgnZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICgnb2snIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnb2snXSA9PSAnb2snKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfSBlbHNlIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgemIgPSByZXF1aXJlICgnLi96Yi5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGNoYnRjIGV4dGVuZHMgemIge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2NoYnRjJyxcbiAgICAgICAgICAgICduYW1lJzogJ0NIQlRDJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODU1NTY1OS1mMDA0MGRjMi03MTA5LTExZTctOWQ5OS02ODhhNDM4YmY5ZjQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHA6Ly9hcGkuY2hidGMuY29tL2RhdGEnLCAvLyBubyBodHRwcyBmb3IgcHVibGljIEFQSVxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3RyYWRlLmNoYnRjLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3RyYWRlLmNoYnRjLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuY2hidGMuY29tL2kvZGV2ZWxvcGVyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldE1hcmtldEZpZWxkTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiAnY3VycmVuY3knO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnQlRDL0NOWSc6IHsgJ2lkJzogJ2J0Y19jbnknLCAnc3ltYm9sJzogJ0JUQy9DTlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgICAgICAgICAgJ0xUQy9DTlknOiB7ICdpZCc6ICdsdGNfY255JywgJ3N5bWJvbCc6ICdMVEMvQ05ZJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgICAgICdFVEgvQ05ZJzogeyAnaWQnOiAnZXRoX2NueScsICdzeW1ib2wnOiAnRVRIL0NOWScsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICAgICAnRVRDL0NOWSc6IHsgJ2lkJzogJ2V0Y19jbnknLCAnc3ltYm9sJzogJ0VUQy9DTlknLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgICAgICAgICAgJ0JUUy9DTlknOiB7ICdpZCc6ICdidHNfY255JywgJ3N5bWJvbCc6ICdCVFMvQ05ZJywgJ2Jhc2UnOiAnQlRTJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgICAgIC8vICdFT1MvQ05ZJzogeyAnaWQnOiAnZW9zX2NueScsICdzeW1ib2wnOiAnRU9TL0NOWScsICdiYXNlJzogJ0VPUycsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICAgICAnQkNIL0NOWSc6IHsgJ2lkJzogJ2JjY19jbnknLCAnc3ltYm9sJzogJ0JDSC9DTlknLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgICAgICAgICAgJ0hTUi9DTlknOiB7ICdpZCc6ICdoc3JfY255JywgJ3N5bWJvbCc6ICdIU1IvQ05ZJywgJ2Jhc2UnOiAnSFNSJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgICAgICdRVFVNL0NOWSc6IHsgJ2lkJzogJ3F0dW1fY255JywgJ3N5bWJvbCc6ICdRVFVNL0NOWScsICdiYXNlJzogJ1FUVU0nLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZm94Yml0ID0gcmVxdWlyZSAoJy4vZm94Yml0LmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY2hpbGViaXQgZXh0ZW5kcyBmb3hiaXQge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2NoaWxlYml0JyxcbiAgICAgICAgICAgICduYW1lJzogJ0NoaWxlQml0JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ0wnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTE0MTQtMTI5OGYwZDgtNjQ3Zi0xMWU3LTljNDAtZDU2NDA5MjY2MzM2LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9jaGlsZWJpdC5uZXQnLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9ibGlua3RyYWRlLmNvbS9kb2NzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIE5vdFN1cHBvcnRlZCB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY29pbmNoZWNrIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2NvaW5jaGVjaycsXG4gICAgICAgICAgICAnbmFtZSc6ICdjb2luY2hlY2snLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0pQJywgJ0lEJyBdLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjQ2NC0zYjVjM2M3NC01ZWQ5LTExZTctODQwZS0zMWIzMjk2OGUxZGEuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vY29pbmNoZWNrLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9jb2luY2hlY2suY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vY29pbmNoZWNrLmNvbS9kb2N1bWVudHMvZXhjaGFuZ2UvYXBpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvb3JkZXJzL3JhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX2Jvb2tzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyYXRlL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRzL2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRzL2xldmVyYWdlX2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbmtfYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRfbW9uZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycy9vcGVucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvb3JkZXJzL3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvb3JkZXJzL3RyYW5zYWN0aW9uc19wYWdpbmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9sZXZlcmFnZS9wb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlbmRpbmcvYm9ycm93cy9tYXRjaGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZW5kX21vbmV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd3MnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYW5rX2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0X21vbmV5L3tpZH0vZmFzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS90cmFuc2ZlcnMvdG9fbGV2ZXJhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3RyYW5zZmVycy9mcm9tX2xldmVyYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZW5kaW5nL2JvcnJvd3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlbmRpbmcvYm9ycm93cy97aWR9L3JlcGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZW5kX21vbmV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd3MnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbmtfYWNjb3VudHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvSlBZJzogeyAnaWQnOiAnYnRjX2pweScsICdzeW1ib2wnOiAnQlRDL0pQWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdKUFknIH0sIC8vIHRoZSBvbmx5IHJlYWwgcGFpclxuICAgICAgICAgICAgICAgIC8vICdFVEgvSlBZJzogeyAnaWQnOiAnZXRoX2pweScsICdzeW1ib2wnOiAnRVRIL0pQWScsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0VUQy9KUFknOiB7ICdpZCc6ICdldGNfanB5JywgJ3N5bWJvbCc6ICdFVEMvSlBZJywgJ2Jhc2UnOiAnRVRDJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAvLyAnREFPL0pQWSc6IHsgJ2lkJzogJ2Rhb19qcHknLCAnc3ltYm9sJzogJ0RBTy9KUFknLCAnYmFzZSc6ICdEQU8nLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgICAgIC8vICdMU0svSlBZJzogeyAnaWQnOiAnbHNrX2pweScsICdzeW1ib2wnOiAnTFNLL0pQWScsICdiYXNlJzogJ0xTSycsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0ZDVC9KUFknOiB7ICdpZCc6ICdmY3RfanB5JywgJ3N5bWJvbCc6ICdGQ1QvSlBZJywgJ2Jhc2UnOiAnRkNUJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAvLyAnWE1SL0pQWSc6IHsgJ2lkJzogJ3htcl9qcHknLCAnc3ltYm9sJzogJ1hNUi9KUFknLCAnYmFzZSc6ICdYTVInLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgICAgIC8vICdSRVAvSlBZJzogeyAnaWQnOiAncmVwX2pweScsICdzeW1ib2wnOiAnUkVQL0pQWScsICdiYXNlJzogJ1JFUCcsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ1hSUC9KUFknOiB7ICdpZCc6ICd4cnBfanB5JywgJ3N5bWJvbCc6ICdYUlAvSlBZJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAvLyAnWkVDL0pQWSc6IHsgJ2lkJzogJ3plY19qcHknLCAnc3ltYm9sJzogJ1pFQy9KUFknLCAnYmFzZSc6ICdaRUMnLCAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAgICAgICAgIC8vICdYRU0vSlBZJzogeyAnaWQnOiAneGVtX2pweScsICdzeW1ib2wnOiAnWEVNL0pQWScsICdiYXNlJzogJ1hFTScsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0xUQy9KUFknOiB7ICdpZCc6ICdsdGNfanB5JywgJ3N5bWJvbCc6ICdMVEMvSlBZJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAvLyAnREFTSC9KUFknOiB7ICdpZCc6ICdkYXNoX2pweScsICdzeW1ib2wnOiAnREFTSC9KUFknLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgICAgICAgICAvLyAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aF9idGMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgIC8vICdFVEMvQlRDJzogeyAnaWQnOiAnZXRjX2J0YycsICdzeW1ib2wnOiAnRVRDL0JUQycsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgLy8gJ0xTSy9CVEMnOiB7ICdpZCc6ICdsc2tfYnRjJywgJ3N5bWJvbCc6ICdMU0svQlRDJywgJ2Jhc2UnOiAnTFNLJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAvLyAnRkNUL0JUQyc6IHsgJ2lkJzogJ2ZjdF9idGMnLCAnc3ltYm9sJzogJ0ZDVC9CVEMnLCAnYmFzZSc6ICdGQ1QnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgIC8vICdYTVIvQlRDJzogeyAnaWQnOiAneG1yX2J0YycsICdzeW1ib2wnOiAnWE1SL0JUQycsICdiYXNlJzogJ1hNUicsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgLy8gJ1JFUC9CVEMnOiB7ICdpZCc6ICdyZXBfYnRjJywgJ3N5bWJvbCc6ICdSRVAvQlRDJywgJ2Jhc2UnOiAnUkVQJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAvLyAnWFJQL0JUQyc6IHsgJ2lkJzogJ3hycF9idGMnLCAnc3ltYm9sJzogJ1hSUC9CVEMnLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgIC8vICdaRUMvQlRDJzogeyAnaWQnOiAnemVjX2J0YycsICdzeW1ib2wnOiAnWkVDL0JUQycsICdiYXNlJzogJ1pFQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICAgICAgICAgLy8gJ1hFTS9CVEMnOiB7ICdpZCc6ICd4ZW1fYnRjJywgJ3N5bWJvbCc6ICdYRU0vQlRDJywgJ2Jhc2UnOiAnWEVNJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgICAgICAgICAvLyAnTFRDL0JUQyc6IHsgJ2lkJzogJ2x0Y19idGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgICAgIC8vICdEQVNIL0JUQyc6IHsgJ2lkJzogJ2Rhc2hfYnRjJywgJ3N5bWJvbCc6ICdEQVNIL0JUQycsICdiYXNlJzogJ0RBU0gnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBY2NvdW50c0JhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2xvd2VyY2FzZV0pO1xuICAgICAgICAgICAgbGV0IHJlc2VydmVkID0gbG93ZXJjYXNlICsgJ19yZXNlcnZlZCc7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWQgaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbcmVzZXJ2ZWRdKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmIChzeW1ib2wgIT0gJ0JUQy9KUFknKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hPcmRlckJvb2sgKCkgc3VwcG9ydHMgQlRDL0pQWSBvbmx5Jyk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9va3MgKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmIChzeW1ib2wgIT0gJ0JUQy9KUFknKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hUaWNrZXIgKCkgc3VwcG9ydHMgQlRDL0pQWSBvbmx5Jyk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnY3JlYXRlZF9hdCddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnb3JkZXJfdHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3JhdGUnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmIChzeW1ib2wgIT0gJ0JUQy9KUFknKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hUcmFkZXMgKCkgc3VwcG9ydHMgQlRDL0pQWSBvbmx5Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBwcmVmaXggPSAnJztcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0Jykge1xuICAgICAgICAgICAgbGV0IG9yZGVyX3R5cGUgPSB0eXBlICsgJ18nICsgc2lkZTtcbiAgICAgICAgICAgIG9yZGVyWydvcmRlcl90eXBlJ10gPSBvcmRlcl90eXBlO1xuICAgICAgICAgICAgbGV0IHByZWZpeCA9IChzaWRlID09ICdidXknKSA/IChvcmRlcl90eXBlICsgJ18nKSA6ICcnO1xuICAgICAgICAgICAgb3JkZXJbcHJlZml4ICsgJ2Ftb3VudCddID0gYW1vdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ29yZGVyX3R5cGUnXSA9IHNpZGU7XG4gICAgICAgICAgICBvcmRlclsncmF0ZSddID0gcHJpY2U7XG4gICAgICAgICAgICBvcmRlclsnYW1vdW50J10gPSBhbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEV4Y2hhbmdlT3JkZXJzICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlRGVsZXRlRXhjaGFuZ2VPcmRlcnNJZCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBxdWVyeVN0cmluZyA9ICcnO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnUE9TVCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmtleXNvcnQgKHF1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gYm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlICsgdXJsICsgcXVlcnlTdHJpbmc7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnQUNDRVNTLUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdBQ0NFU1MtTk9OQ0UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQUNDRVNTLVNJR05BVFVSRSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJylcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY29pbmZsb29yIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2NvaW5mbG9vcicsXG4gICAgICAgICAgICAnbmFtZSc6ICdjb2luZmxvb3InLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VLJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4MjQ2MDgxLTYyM2ZjMTY0LTZhMWMtMTFlNy05MTNmLWJhYzBkNTU3NmM5MC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly93ZWJhcGkuY29pbmZsb29yLmNvLnVrOjgwOTAvYmlzdCcsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5jb2luZmxvb3IuY28udWsnLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vY29pbmZsb29yL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5jb2luZmxvb3IuY28udWsvYXBpJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd1aWQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L3RpY2tlci8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vb3JkZXJfYm9vay8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vdHJhbnNhY3Rpb25zLycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9iYWxhbmNlLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS91c2VyX3RyYW5zYWN0aW9ucy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vb3Blbl9vcmRlcnMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L2NhbmNlbF9vcmRlci8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vYnV5LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9zZWxsLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9idXlfbWFya2V0LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2lkfS9zZWxsX21hcmtldC8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tpZH0vZXN0aW1hdGVfc2VsbF9tYXJrZXQvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9L2VzdGltYXRlX2J1eV9tYXJrZXQvJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvR0JQJzogeyAnaWQnOiAnWEJUL0dCUCcsICdzeW1ib2wnOiAnQlRDL0dCUCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdHQlAnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdYQlQvRVVSJywgJ3N5bWJvbCc6ICdCVEMvRVVSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ1hCVC9VU0QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvUExOJzogeyAnaWQnOiAnWEJUL1BMTicsICdzeW1ib2wnOiAnQlRDL1BMTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9HQlAnOiB7ICdpZCc6ICdCQ0gvR0JQJywgJ3N5bWJvbCc6ICdCQ0gvR0JQJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0dCUCcgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdzeW1ib2wnIGluIHBhcmFtcylcbiAgICAgICAgICAgIHN5bWJvbCA9IHBhcmFtc1snc3ltYm9sJ107XG4gICAgICAgIGlmICgnaWQnIGluIHBhcmFtcylcbiAgICAgICAgICAgIHN5bWJvbCA9IHBhcmFtc1snaWQnXTtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hCYWxhbmNlIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgICAgIC8vIHRvZG8gcGFyc2UgYmFsYW5jZVxuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdElkQmFsYW5jZSAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0SWRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHJld3JpdGUgdG8gZ2V0IHRoZSB0aW1lc3RhbXAgZnJvbSBIVFRQIGhlYWRlcnNcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IHZ3YXAgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndndhcCcpO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdndhcCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdndhcCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJZFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldElkVHJhbnNhY3Rpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyID0geyAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpIH07XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RJZCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0Jykge1xuICAgICAgICAgICAgb3JkZXJbJ3F1YW50aXR5J10gPSBhbW91bnQ7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ01hcmtldCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICAgICAgb3JkZXJbJ2Ftb3VudCddID0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0SWRDYW5jZWxPcmRlciAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGN1cmwgLWsgLXUgJ1tVc2VyIElEXS9bQVBJIGtleV06W1Bhc3NwaHJhc2VdJyBodHRwczovL3dlYmFwaS5jb2luZmxvb3IuY28udWs6ODA5MC9iaXN0L1hCVC9HQlAvYmFsYW5jZS9cbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAnbm9uY2UnOiBub25jZSB9LCBxdWVyeSkpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLnVpZCArICcvJyArIHRoaXMuYXBpS2V5ICsgJzonICsgdGhpcy5wYXNzd29yZDtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLnN0cmluZ1RvQmFzZTY0IChhdXRoKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0Jhc2ljICcgKyBzaWduYXR1cmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY29pbmdpIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2NvaW5naScsXG4gICAgICAgICAgICAnbmFtZSc6ICdDb2luZ2knLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnUEEnLCAnQkcnLCAnQ04nLCAnVVMnIF0sIC8vIFBhbmFtYSwgQnVsZ2FyaWEsIENoaW5hLCBVU1xuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODYxOTcwNy01YzkyMzJhOC03MjEyLTExZTctODZkNi05OGZlNWQxNWNjNmUuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY29pbmdpLmNvbScsXG4gICAgICAgICAgICAgICAgICAgICdjdXJyZW50JzogJ2h0dHBzOi8vYXBpLmNvaW5naS5jb20nLFxuICAgICAgICAgICAgICAgICAgICAndXNlcic6ICdodHRwczovL2FwaS5jb2luZ2kuY29tJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9jb2luZ2kuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHA6Ly9kb2NzLmNvaW5naS5hcGlhcnkuaW8vJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICd3d3cnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdjdXJyZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyLWJvb2sve3BhaXJ9L3thc2tDb3VudH0ve2JpZENvdW50fS97ZGVwdGh9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMve3BhaXJ9L3ttYXhDb3VudH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzI0aG91ci1yb2xsaW5nLWFnZ3JlZ2F0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd1c2VyJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhZGQtb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbC1vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyZWF0ZS1jcnlwdG8td2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RpZXJCYXNlZCc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAncGVyY2VudGFnZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMiAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAuMDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xUQyc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE9HRSc6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFBDJzogMC4wMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdWVEMnOiAwLjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTk1DJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQVNIJzogMC4wMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVVNEJzogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVVSJzogMTAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZXBvc2l0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdET0dFJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTk1DJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQVNIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVU0QnOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VVUic6IDEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIHRoaXMucGFyc2VKc29uUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53d3dHZXQgKCk7XG4gICAgICAgIHRoaXMucGFyc2VKc29uUmVzcG9uc2UgPSB0cnVlO1xuICAgICAgICBsZXQgcGFydHMgPSByZXNwb25zZS5zcGxpdCAoJ2RvPWN1cnJlbmN5UGFpclNlbGVjdG9yLXNlbGVjdEN1cnJlbmN5UGFpclwiIGNsYXNzPVwiYWN0aXZlXCI+Jyk7XG4gICAgICAgIGxldCBjdXJyZW5jeVBhcnRzID0gcGFydHNbMV0uc3BsaXQgKCc8ZGl2IGNsYXNzPVwiY3VycmVuY3ktcGFpci1sYWJlbFwiPicpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY3VycmVuY3lQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5UGFydCA9IGN1cnJlbmN5UGFydHNbaV07XG4gICAgICAgICAgICBsZXQgaWRQYXJ0cyA9IGN1cnJlbmN5UGFydC5zcGxpdCAoJzwvZGl2PicpO1xuICAgICAgICAgICAgbGV0IGlkID0gaWRQYXJ0c1swXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZDtcbiAgICAgICAgICAgIGlkID0gaWQucmVwbGFjZSAoJy8nLCAnLScpO1xuICAgICAgICAgICAgaWQgPSBpZC50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiA4LFxuICAgICAgICAgICAgICAgICdwcmljZSc6IDgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGxvdCA9IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IGlkLFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGxvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBNYXRoLnBvdyAoMTAsIHByZWNpc2lvblsnYW1vdW50J10pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGxvd2VyY2FzZUN1cnJlbmNpZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbG93ZXJjYXNlQ3VycmVuY2llcy5wdXNoIChjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy51c2VyUG9zdEJhbGFuY2UgKHtcbiAgICAgICAgICAgICdjdXJyZW5jaWVzJzogbG93ZXJjYXNlQ3VycmVuY2llcy5qb2luICgnLCcpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddWyduYW1lJ107XG4gICAgICAgICAgICBjdXJyZW5jeSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydhdmFpbGFibGUnXSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IGJhbGFuY2VbJ2Jsb2NrZWQnXSArIGJhbGFuY2VbJ2luT3JkZXJzJ10gKyBiYWxhbmNlWyd3aXRoZHJhd2luZyddLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLmN1cnJlbnRHZXRPcmRlckJvb2tQYWlyQXNrQ291bnRCaWRDb3VudERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnYXNrQ291bnQnOiA1MTIsIC8vIG1heGltdW0gcmV0dXJuZWQgbnVtYmVyIG9mIGFza3MgMS01MTJcbiAgICAgICAgICAgICdiaWRDb3VudCc6IDUxMiwgLy8gbWF4aW11bSByZXR1cm5lZCBudW1iZXIgb2YgYmlkcyAxLTUxMlxuICAgICAgICAgICAgJ2RlcHRoJzogMzIsIC8vIG1heGltdW0gbnVtYmVyIG9mIGRlcHRoIHJhbmdlIHN0ZXBzIDEtMzJcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdiYXNlQW1vdW50Jyk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGlja2VyWydoaWdoJ10sXG4gICAgICAgICAgICAnbG93JzogdGlja2VyWydsb3cnXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbJ2hpZ2hlc3RCaWQnXSxcbiAgICAgICAgICAgICdhc2snOiB0aWNrZXJbJ2xvd2VzdEFzayddLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRpY2tlclsnYmFzZVZvbHVtZSddLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGlja2VyWydjb3VudGVyVm9sdW1lJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRpY2tlcjtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY3VycmVudEdldDI0aG91clJvbGxpbmdBZ2dyZWdhdGlvbiAocGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHJlc3BvbnNlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbdF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRpY2tlclsnY3VycmVuY3lQYWlyJ11bJ2Jhc2UnXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHRpY2tlclsnY3VycmVuY3lQYWlyJ11bJ2NvdW50ZXInXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHN5bWJvbCBpbiB0aGlzLm1hcmtldHMpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLmZldGNoVGlja2VycyAodW5kZWZpbmVkLCBwYXJhbXMpO1xuICAgICAgICBpZiAoc3ltYm9sIGluIHRpY2tlcnMpXG4gICAgICAgICAgICByZXR1cm4gdGlja2Vyc1tzeW1ib2xdO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcmV0dXJuIGRpZCBub3QgY29udGFpbiAnICsgc3ltYm9sKTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeVBhaXInXV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdHJhZGVbJ3RpbWVzdGFtcCddLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0cmFkZVsndGltZXN0YW1wJ10pLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLCAvLyB0eXBlXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY3VycmVudEdldFRyYW5zYWN0aW9uc1BhaXJNYXhDb3VudCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ21heENvdW50JzogMTI4LFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndm9sdW1lJzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnb3JkZXJUeXBlJzogKHNpZGUgPT0gJ2J1eScpID8gMCA6IDEsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMudXNlclBvc3RBZGRPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVzZXJQb3N0Q2FuY2VsT3JkZXIgKHsgJ29yZGVySWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAnY3VycmVudCcsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBpZiAoYXBpICE9ICd3d3cnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgYXBpICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAnY3VycmVudCcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIGlmIChhcGkgPT0gJ3VzZXInKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ3Rva2VuJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBxdWVyeSk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlLnRvU3RyaW5nICgpICsgJyQnICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICByZXF1ZXN0WydzaWduYXR1cmUnXSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHJlcXVlc3QpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdjdXJyZW50JywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZSAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCdlcnJvcnMnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBjb2lubWFya2V0Y2FwIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2NvaW5tYXJrZXRjYXAnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQ29pbk1hcmtldENhcCcsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNQcml2YXRlQVBJJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzQ3JlYXRlT3JkZXInOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNDYW5jZWxPcmRlcic6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQmFsYW5jZSc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXJCb29rJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUcmFkZXMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ3VycmVuY2llcyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaEN1cnJlbmNpZXMnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjgyNDQyNDQtOWJlNjMxMmEtNjllZC0xMWU3LTk5YzEtN2MxNzk3Mjc1MjY1LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5jb2lubWFya2V0Y2FwLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2NvaW5tYXJrZXRjYXAuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vY29pbm1hcmtldGNhcC5jb20vYXBpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmVxdWlyZWRDcmVkZW50aWFscyc6IHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve2lkfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dsb2JhbC8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2N1cnJlbmN5Q29kZXMnOiBbXG4gICAgICAgICAgICAgICAgJ0FVRCcsXG4gICAgICAgICAgICAgICAgJ0JSTCcsXG4gICAgICAgICAgICAgICAgJ0NBRCcsXG4gICAgICAgICAgICAgICAgJ0NIRicsXG4gICAgICAgICAgICAgICAgJ0NOWScsXG4gICAgICAgICAgICAgICAgJ0VVUicsXG4gICAgICAgICAgICAgICAgJ0dCUCcsXG4gICAgICAgICAgICAgICAgJ0hLRCcsXG4gICAgICAgICAgICAgICAgJ0lEUicsXG4gICAgICAgICAgICAgICAgJ0lOUicsXG4gICAgICAgICAgICAgICAgJ0pQWScsXG4gICAgICAgICAgICAgICAgJ0tSVycsXG4gICAgICAgICAgICAgICAgJ01YTicsXG4gICAgICAgICAgICAgICAgJ1JVQicsXG4gICAgICAgICAgICAgICAgJ1VTRCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAoJ0ZldGNoaW5nIG9yZGVyIGJvb2tzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEFQSSBvZiAnICsgdGhpcy5pZCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoe1xuICAgICAgICAgICAgJ2xpbWl0JzogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jaWVzID0gdGhpcy5jdXJyZW5jeUNvZGVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGVJZCA9IHF1b3RlLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZUlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gYmFzZUlkICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlSWQnOiBiYXNlSWQsXG4gICAgICAgICAgICAgICAgICAgICdxdW90ZUlkJzogcXVvdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEdsb2JhbCAoY3VycmVuY3kgPSAnVVNEJykge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBpZiAoY3VycmVuY3kpXG4gICAgICAgICAgICByZXF1ZXN0Wydjb252ZXJ0J10gPSBjdXJyZW5jeTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHVibGljR2V0R2xvYmFsIChyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBpZiAoJ2xhc3RfdXBkYXRlZCcgaW4gdGlja2VyKVxuICAgICAgICAgICAgaWYgKHRpY2tlclsnbGFzdF91cGRhdGVkJ10pXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsnbGFzdF91cGRhdGVkJ10pICogMTAwMDtcbiAgICAgICAgbGV0IGNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNoYW5nZUtleSA9ICdwZXJjZW50X2NoYW5nZV8yNGgnO1xuICAgICAgICBpZiAoY2hhbmdlS2V5IGluIHRpY2tlcilcbiAgICAgICAgICAgIGNoYW5nZSA9IHBhcnNlRmxvYXQgKHRpY2tlcltjaGFuZ2VLZXldKTtcbiAgICAgICAgbGV0IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB2b2x1bWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIGxldCBwcmljZSA9ICdwcmljZV8nICsgbWFya2V0WydxdW90ZUlkJ107XG4gICAgICAgICAgICBpZiAocHJpY2UgaW4gdGlja2VyKVxuICAgICAgICAgICAgICAgIGlmICh0aWNrZXJbcHJpY2VdKVxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gcGFyc2VGbG9hdCAodGlja2VyW3ByaWNlXSk7XG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHZvbHVtZUtleSA9ICcyNGhfdm9sdW1lXycgKyBtYXJrZXRbJ3F1b3RlSWQnXTtcbiAgICAgICAgICAgIGlmICh2b2x1bWVLZXkgaW4gdGlja2VyKVxuICAgICAgICAgICAgICAgIHZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclt2b2x1bWVLZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Fzayc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IGxhc3QsXG4gICAgICAgICAgICAnY2hhbmdlJzogY2hhbmdlLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChjdXJyZW5jeSA9ICdVU0QnLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdsaW1pdCc6IDEwMDAwLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY3VycmVuY3kpXG4gICAgICAgICAgICByZXF1ZXN0Wydjb252ZXJ0J10gPSBjdXJyZW5jeTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCByZXNwb25zZS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlW3RdO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWydpZCddICsgJy8nICsgY3VycmVuY3k7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQ7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpY2tlcnNbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja2VycztcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb252ZXJ0JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydiYXNlSWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJJZCAocmVxdWVzdCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEN1cnJlbmNpZXMgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbGltaXQnOiAwXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IGN1cnJlbmN5WydzeW1ib2wnXTtcbiAgICAgICAgICAgIC8vIHRvZG86IHdpbGwgbmVlZCB0byByZXRoaW5rIHRoZSBmZWVzXG4gICAgICAgICAgICAvLyB0byBhZGQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgd2l0aGRyYXdhbC9kZXBvc2l0IG1ldGhvZHMgYW5kXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnRpYXRlZCBmZWVzIGZvciBlYWNoIHBhcnRpY3VsYXIgbWV0aG9kXG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiA4LCAvLyBkZWZhdWx0IHByZWNpc2lvbiwgdG9kbzogZml4IFwibWFnaWMgY29uc3RhbnRzXCJcbiAgICAgICAgICAgICAgICAncHJpY2UnOiA4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBjb2RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGlkKTtcbiAgICAgICAgICAgIHJlc3VsdFtjb2RlXSA9IHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnY29kZSc6IGNvZGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IGN1cnJlbmN5WyduYW1lJ10sXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCwgLy8gdG9kbzogcmVkZXNpZ25cbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsncHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY29pbm1hdGUgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnY29pbm1hdGUnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQ29pbk1hdGUnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0dCJywgJ0NaJyBdLCAvLyBVSywgQ3plY2ggUmVwdWJsaWNcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzgxMTIyOS1jMWVmYjUxMC02MDZjLTExZTctOWEzNi04NGJhMmNlNDEyZDguanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vY29pbm1hdGUuaW8vYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY29pbm1hdGUuaW8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwOi8vZG9jcy5jb2lubWF0ZS5hcGlhcnkuaW8nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jb2lubWF0ZS5pby9kZXZlbG9wZXJzJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd1aWQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlckJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYml0Y29pbldpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW5EZXBvc2l0QWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXlJbnN0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXlMaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbE9yZGVyV2l0aEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyZWF0ZVZvdWNoZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZGVlbVZvdWNoZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxJbnN0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxsTGltaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9uSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndW5jb25maXJtZWRCaXRjb2luRGVwb3NpdHMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdCVENfRVVSJywgJ3N5bWJvbCc6ICdCVEMvRVVSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0VVUicsICdwcmVjaXNpb24nOiB7ICdhbW91bnQnOiA0LCAncHJpY2UnOiAyIH19LFxuICAgICAgICAgICAgICAgICdCVEMvQ1pLJzogeyAnaWQnOiAnQlRDX0NaSycsICdzeW1ib2wnOiAnQlRDL0NaSycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDWksnLCAncHJlY2lzaW9uJzogeyAnYW1vdW50JzogNCwgJ3ByaWNlJzogMiB9fSxcbiAgICAgICAgICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ0xUQ19CVEMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDQsICdwcmljZSc6IDUgfX0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDM1LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VzW2N1cnJlbmN5XVsnYXZhaWxhYmxlJ107XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYmFsYW5jZXNbY3VycmVuY3ldWydyZXNlcnZlZCddO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBiYWxhbmNlc1tjdXJyZW5jeV1bJ2JhbGFuY2UnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2dyb3VwQnlQcmljZUxpbWl0JzogJ0ZhbHNlJyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydhbW91bnQnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeVBhaXInXV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndHJhbnNhY3Rpb25JZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsndGltZXN0YW1wJ10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhbnNhY3Rpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdtaW51dGVzSW50b0hpc3RvcnknOiAxMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsnZGF0YSddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIGlmIChzaWRlID09ICdidXknKVxuICAgICAgICAgICAgICAgIG9yZGVyWyd0b3RhbCddID0gYW1vdW50OyAvLyBhbW91bnQgaW4gZmlhdFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9yZGVyWydhbW91bnQnXSA9IGFtb3VudDsgLy8gYW1vdW50IGluIGZpYXRcbiAgICAgICAgICAgIG1ldGhvZCArPSAnSW5zdGFudCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlclsnYW1vdW50J10gPSBhbW91bnQ7IC8vIGFtb3VudCBpbiBjcnlwdG9cbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgICAgICBtZXRob2QgKz0gdGhpcy5jYXBpdGFsaXplICh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHNlbGYuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2RhdGEnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAnb3JkZXJJZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gbm9uY2UgKyB0aGlzLnVpZCArIHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnY2xpZW50SWQnOiB0aGlzLnVpZCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAncHVibGljS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY29pbnNlY3VyZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjb2luc2VjdXJlJyxcbiAgICAgICAgICAgICduYW1lJzogJ0NvaW5zZWN1cmUnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdJTicsIC8vIEluZGlhXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY0NzItOWNiZDIwMGEtNWVkOS0xMWU3LTk1NTEtMjI2N2FkN2JhYzA4LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5jb2luc2VjdXJlLmluJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY29pbnNlY3VyZS5pbicsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLmNvaW5zZWN1cmUuaW4nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2NvaW5zZWN1cmUvcGx1Z2lucycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmVxdWlyZWRDcmVkZW50aWFscyc6IHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnc2VjcmV0JzogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW4vc2VhcmNoL2NvbmZpcm1hdGlvbi97dHhpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2Fzay9sb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2Fzay9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2JpZC9oaWdoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9iaWQvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9sYXN0VHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL21heDI0SHInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL21pbjI0SHInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21mYS9hdXRoeS9jYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZmEvYXV0aHkvc21zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXRraS9zZWFyY2gve25ldGtpTmFtZX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvYmFuay9vdHAve251bWJlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIva3ljL290cC97bnVtYmVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9wcm9maWxlL3Bob25lL290cC97bnVtYmVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi9hZGRyZXNzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vZGVwb3NpdC9jb25maXJtZWQvYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL2RlcG9zaXQvY29uZmlybWVkL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vZGVwb3NpdC91bmNvbmZpcm1lZC9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vZGVwb3NpdC91bmNvbmZpcm1lZC97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL3dhbGxldHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9iYWxhbmNlL2F2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvYmFsYW5jZS9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9iYWxhbmNlL3RvdGFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9kZXBvc2l0L2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvZGVwb3NpdC91bnZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9kZXBvc2l0L3ZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC93aXRoZHJhdy9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L3dpdGhkcmF3L2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvdW52ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvdmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYXNrL2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9hc2svY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2Fzay9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JpZC9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmlkL2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iaWQvcGVuZGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vYWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi9iYWxhbmNlL2F2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vYmFsYW5jZS9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi9iYWxhbmNlL3RvdGFsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi9kZXBvc2l0L2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vZGVwb3NpdC91bnZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi9kZXBvc2l0L3ZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi93aXRoZHJhdy9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vd2l0aGRyYXcvdW52ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vd2l0aGRyYXcvdmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9zdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2NvaW4vZmVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2ZpYXQvZmVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2t5Y3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvcmVmZXJyYWwvY29pbi9wYWlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL3JlZmVycmFsL2NvaW4vc3VjY2Vzc2Z1bCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9yZWZlcnJhbC9maWF0L3BhaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvcmVmZXJyYWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL3RyYWRlL3N1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvbG9naW4vdG9rZW4ve3Rva2VufScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9zdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9zdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXQvY29pbi93aXRoZHJhdy9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldC9jb2luL3dpdGhkcmF3L2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0L2NvaW4vd2l0aGRyYXcvdW52ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0L2NvaW4vd2l0aGRyYXcvdmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2dpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9naW4vaW5pdGlhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvZ2luL3Bhc3N3b3JkL2ZvcmdvdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWZhL2F1dGh5L2luaXRpYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZmEvZ2EvaW5pdGlhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NpZ251cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9uZXRraS91cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcHJvZmlsZS9pbWFnZS91cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L2luaXRpYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi93aXRoZHJhdy9uZXdWZXJpZnljb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC93aXRoZHJhdy9pbml0aWF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvbmV3VmVyaWZ5Y29kZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9wYXNzd29yZC9jaGFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcGFzc3dvcmQvcmVzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vd2l0aGRyYXcvaW5pdGlhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldC9jb2luL3dpdGhkcmF3L25ld1ZlcmlmeWNvZGUnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3NpZ251cC92ZXJpZnkve3Rva2VufScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9reWMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L2RlcG9zaXQvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2Fzay9uZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmlkL25ldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9pbnN0YW50L2J1eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9pbnN0YW50L3NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L3ZlcmlmeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvYWNjb3VudC9uZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L3dpdGhkcmF3L3ZlcmlmeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9tZmEvYXV0aHkvaW5pdGlhdGUvZW5hYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL21mYS9nYS9pbml0aWF0ZS9lbmFibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvbmV0a2kvY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3Byb2ZpbGUvcGhvbmUvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL2FkZHJlc3MvbmV3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL25ldycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi93aXRoZHJhdy9zZW5kVG9FeGNoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi93aXRoZHJhdy92ZXJpZnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZ2NtL3tjb2RlfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9sb2dvdXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L3VudmVyaWZpZWQvY2FuY2VsL3t3aXRoZHJhd0lEfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvZGVwb3NpdC9jYW5jZWwve2RlcG9zaXRJRH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYXNrL2NhbmNlbC97b3JkZXJJRH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmlkL2NhbmNlbC97b3JkZXJJRH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L3dpdGhkcmF3L3VudmVyaWZpZWQvY2FuY2VsL3t3aXRoZHJhd0lEfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9tZmEvYXV0aHkvZGlzYWJsZS97Y29kZX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvbWZhL2dhL2Rpc2FibGUve2NvZGV9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3Byb2ZpbGUvcGhvbmUvZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3Byb2ZpbGUvaW1hZ2UvZGVsZXRlL3tuZXRraU5hbWV9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL3dpdGhkcmF3L3VudmVyaWZpZWQvY2FuY2VsL3t3aXRoZHJhd0lEfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0lOUic6IHsgJ2lkJzogJ0JUQy9JTlInLCAnc3ltYm9sJzogJ0JUQy9JTlInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSU5SJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjQgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuNCAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRVc2VyRXhjaGFuZ2VCYW5rU3VtbWFyeSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSByZXNwb25zZVsnbWVzc2FnZSddO1xuICAgICAgICBsZXQgY29pbiA9IHtcbiAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnYXZhaWxhYmxlQ29pbkJhbGFuY2UnXSxcbiAgICAgICAgICAgICd1c2VkJzogYmFsYW5jZVsncGVuZGluZ0NvaW5CYWxhbmNlJ10sXG4gICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlWyd0b3RhbENvaW5CYWxhbmNlJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBmaWF0ID0ge1xuICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydhdmFpbGFibGVGaWF0QmFsYW5jZSddLFxuICAgICAgICAgICAgJ3VzZWQnOiBiYWxhbmNlWydwZW5kaW5nRmlhdEJhbGFuY2UnXSxcbiAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VbJ3RvdGFsRmlhdEJhbGFuY2UnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogYmFsYW5jZSxcbiAgICAgICAgICAgICdCVEMnOiBjb2luLFxuICAgICAgICAgICAgJ0lOUic6IGZpYXQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYmlkcyA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VCaWRPcmRlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCBhc2tzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZUFza09yZGVycyAocGFyYW1zKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHtcbiAgICAgICAgICAgICdiaWRzJzogYmlkc1snbWVzc2FnZSddLFxuICAgICAgICAgICAgJ2Fza3MnOiBhc2tzWydtZXNzYWdlJ10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdyYXRlJywgJ3ZvbCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnbWVzc2FnZSddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ2NvaW52b2x1bWUnXSk7XG4gICAgICAgIGlmIChzeW1ib2wgPT0gJ0JUQy9JTlInKSB7XG4gICAgICAgICAgICBsZXQgc2F0b3NoaSA9IDAuMDAwMDAwMDE7XG4gICAgICAgICAgICBiYXNlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHNhdG9zaGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RQcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBiYXNlVm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydmaWF0dm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNHZXRFeGNoYW5nZVRyYWRlcyAocGFyYW1zKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAobWFya2V0LCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQdXRVc2VyRXhjaGFuZ2UnO1xuICAgICAgICBsZXQgb3JkZXIgPSB7fTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnSW5zdGFudCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpXG4gICAgICAgICAgICAgICAgb3JkZXJbJ21heEZpYXQnXSA9IGFtb3VudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcmRlclsnbWF4Vm9sJ10gPSBhbW91bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gKHNpZGUgPT0gJ2J1eScpID8gJ0JpZCcgOiAnQXNrJztcbiAgICAgICAgICAgIG1ldGhvZCArPSBkaXJlY3Rpb24gKyAnTmV3JztcbiAgICAgICAgICAgIG9yZGVyWydyYXRlJ10gPSBwcmljZTtcbiAgICAgICAgICAgIG9yZGVyWyd2b2wnXSA9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHNlbGYuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ21lc3NhZ2UnXVsnb3JkZXJJRCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgKCkgaXMgbm90IGZ1bGx5IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVEZWxldGVVc2VyRXhjaGFuZ2VBc2tDYW5jZWxPcmRlcklkJzsgLy8gVE9ETyBmaXhtZSwgaGF2ZSB0byBzcGVjaWZ5IG9yZGVyIHNpZGUgaGVyZVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpc1ttZXRob2RdICh7ICdvcmRlcklEJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnQXV0aG9yaXphdGlvbic6IHRoaXMuYXBpS2V5IH07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgY29pbnNwb3QgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnY29pbnNwb3QnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQ29pblNwb3QnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdBVScsIC8vIEF1c3RyYWxpYVxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODIwODQyOS0zY2FjZGY5YS02ODk2LTExZTctODU0ZS00Yzc5YTc3MmEzMGYuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vd3d3LmNvaW5zcG90LmNvbS5hdS9wdWJhcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3d3dy5jb2luc3BvdC5jb20uYXUvYXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuY29pbnNwb3QuY29tLmF1JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmNvaW5zcG90LmNvbS5hdS9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsYXRlc3QnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215L2NvaW4vZGVwb3NpdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXkvY29pbi9zZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZS9idXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlL3NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215L2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdteS9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215L2J1eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXkvc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXkvYnV5L2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbXkvc2VsbC9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9BVUQnOiB7ICdpZCc6ICdCVEMnLCAnc3ltYm9sJzogJ0JUQy9BVUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQVVEJyB9LFxuICAgICAgICAgICAgICAgICdMVEMvQVVEJzogeyAnaWQnOiAnTFRDJywgJ3N5bWJvbCc6ICdMVEMvQVVEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0FVRCcgfSxcbiAgICAgICAgICAgICAgICAnRE9HRS9BVUQnOiB7ICdpZCc6ICdET0dFJywgJ3N5bWJvbCc6ICdET0dFL0FVRCcsICdiYXNlJzogJ0RPR0UnLCAncXVvdGUnOiAnQVVEJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TXlCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBpZiAoJ2JhbGFuY2UnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnYmFsYW5jZSddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAoYmFsYW5jZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gY3VycmVuY3kudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZXNbY3VycmVuY3ldLFxuICAgICAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZXNbY3VycmVuY3ldLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHVwcGVyY2FzZSA9PSAnRFJLJylcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJjYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2ludHlwZSc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2J1eW9yZGVycycsICdzZWxsb3JkZXJzJywgJ3JhdGUnLCAnYW1vdW50Jyk7XG4gICAgICAgIHJlc3VsdFsnYmlkcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYmlkcyddLCAwLCB0cnVlKTtcbiAgICAgICAgcmVzdWx0Wydhc2tzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0Wydhc2tzJ10sIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TGF0ZXN0IChwYXJhbXMpO1xuICAgICAgICBsZXQgaWQgPSB0aGlzLm1hcmtldElkIChzeW1ib2wpO1xuICAgICAgICBpZCA9IGlkLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3ByaWNlcyddW2lkXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdE9yZGVyc0hpc3RvcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbnR5cGUnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBjcmVhdGVPcmRlciAobWFya2V0LCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0TXknICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjb2ludHlwZSc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyICgpIGlzIG5vdCBmdWxseSBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdE15QnV5JztcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXNbbWV0aG9kXSAoeyAnaWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdGhpcy5hcGlLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgYXBpS2V5IGZvciBhbGwgcmVxdWVzdHMnKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh0aGlzLmV4dGVuZCAoeyAnbm9uY2UnOiBub25jZSB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBJbnN1ZmZpY2llbnRGdW5kcywgT3JkZXJOb3RGb3VuZCwgT3JkZXJOb3RDYWNoZWQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGNyeXB0b3BpYSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdjcnlwdG9waWEnLFxuICAgICAgICAgICAgJ25hbWUnOiAnQ3J5cHRvcGlhJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdOWicsIC8vIE5ldyBaZWFsYW5kXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgLy8gb2Jzb2xldGUgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hNeVRyYWRlcyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hDdXJyZW5jaWVzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNEZXBvc2l0JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAvLyBuZXcgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogJ2VtdWxhdGVkJyxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcnMnOiAnZW11bGF0ZWQnLFxuICAgICAgICAgICAgICAgICdmZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaENsb3NlZE9yZGVycyc6ICdlbXVsYXRlZCcsXG4gICAgICAgICAgICAgICAgJ2ZldGNoTXlUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaEN1cnJlbmNpZXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjk0ODQzOTQtN2I0ZWE2ZTItODRjNi0xMWU3LTgzZTUtMWZjY2Y0YjJkYzgxLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5jcnlwdG9waWEuY28ubnovYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmNyeXB0b3BpYS5jby5ueicsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LmNyeXB0b3BpYS5jby5uei9Gb3J1bS9DYXRlZ29yeS80NScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5jcnlwdG9waWEuY28ubnovRm9ydW0vVGhyZWFkLzI1NScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5jcnlwdG9waWEuY28ubnovRm9ydW0vVGhyZWFkLzI1NicsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0Q3VycmVuY2llcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VHJhZGVQYWlycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRNYXJrZXRzL3tob3Vyc30nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldHMve2lkfS97aG91cnN9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRNYXJrZXQve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0L3tpZH0ve2hvdXJzfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0SGlzdG9yeS97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRNYXJrZXRIaXN0b3J5L3tpZH0ve2hvdXJzfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0T3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldE9yZGVycy97aWR9L3tjb3VudH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE1hcmtldE9yZGVyR3JvdXBzL3tpZHN9L3tjb3VudH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbFRyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRCYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXREZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0T3Blbk9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1N1Ym1pdFRpcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU3VibWl0VHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1N1Ym1pdFRyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTdWJtaXRXaXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdDQycpXG4gICAgICAgICAgICByZXR1cm4gJ0NDWCc7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRkNOJylcbiAgICAgICAgICAgIHJldHVybiAnRmFjaWxlY29pbic7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnTkVUJylcbiAgICAgICAgICAgIHJldHVybiAnTmV0Q29pbic7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQlRHJylcbiAgICAgICAgICAgIHJldHVybiAnQml0Z2VtJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGN1cnJlbmN5SWQgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQ0NYJylcbiAgICAgICAgICAgIHJldHVybiAnQ0MnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0ZhY2lsZWNvaW4nKVxuICAgICAgICAgICAgcmV0dXJuICdGQ04nO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ05ldENvaW4nKVxuICAgICAgICAgICAgcmV0dXJuICdORVQnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JpdGdlbScpXG4gICAgICAgICAgICByZXR1cm4gJ0JURyc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlUGFpcnMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsnRGF0YSddO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydJZCddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnTGFiZWwnXTtcbiAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogOCxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiA4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhbW91bnRMaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ21pbic6IG1hcmtldFsnTWluaW11bVRyYWRlJ10sXG4gICAgICAgICAgICAgICAgJ21heCc6IG1hcmtldFsnTWF4aW11bVRyYWRlJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcHJpY2VMaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ21pbic6IG1hcmtldFsnTWluaW11bVByaWNlJ10sXG4gICAgICAgICAgICAgICAgJ21heCc6IG1hcmtldFsnTWF4aW11bVByaWNlJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGxpbWl0cyA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogYW1vdW50TGltaXRzLFxuICAgICAgICAgICAgICAgICdwcmljZSc6IHByaWNlTGltaXRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSBtYXJrZXRbJ1N0YXR1cyddID09ICdPSyc7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdtYWtlcic6IG1hcmtldFsnVHJhZGVGZWUnXSAvIDEwMCxcbiAgICAgICAgICAgICAgICAndGFrZXInOiBtYXJrZXRbJ1RyYWRlRmVlJ10gLyAxMDAsXG4gICAgICAgICAgICAgICAgJ2xvdCc6IGFtb3VudExpbWl0c1snbWluJ10sXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiBsaW1pdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0T3JkZXJzSWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydEYXRhJ107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ0J1eScsICdTZWxsJywgJ1ByaWNlJywgJ1ZvbHVtZScpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydIaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnTG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnQmlkUHJpY2UnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydBc2tQcmljZSddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ09wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0Nsb3NlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0xhc3RQcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0NoYW5nZSddKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnVm9sdW1lJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydCYXNlVm9sdW1lJ10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnRGF0YSddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzIChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCB0aWNrZXJzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IHRpY2tlclsnVHJhZGVQYWlySWQnXTtcbiAgICAgICAgICAgIGxldCByZWNvZ25pemVkID0gKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCk7XG4gICAgICAgICAgICBpZiAoIXJlY29nbml6ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoVGlja2VycygpIHJldHVybmVkIHVucmVjb2duaXplZCBwYWlyIGlkICcgKyBpZCk7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnVGltZXN0YW1wJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgdGltZXN0YW1wID0gdHJhZGVbJ1RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgfSBlbHNlIGlmICgnVGltZVN0YW1wJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydUaW1lU3RhbXAnXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByaWNlID0gdGhpcy5zYWZlRmxvYXQgKHRyYWRlLCAnUHJpY2UnKTtcbiAgICAgICAgaWYgKCFwcmljZSlcbiAgICAgICAgICAgIHByaWNlID0gdGhpcy5zYWZlRmxvYXQgKHRyYWRlLCAnUmF0ZScpO1xuICAgICAgICBsZXQgY29zdCA9IHRoaXMuc2FmZUZsb2F0ICh0cmFkZSwgJ1RvdGFsJyk7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICdUcmFkZUlkJyk7XG4gICAgICAgIGlmICghbWFya2V0KSB7XG4gICAgICAgICAgICBpZiAoJ1RyYWRlUGFpcklkJyBpbiB0cmFkZSlcbiAgICAgICAgICAgICAgICBpZiAodHJhZGVbJ1RyYWRlUGFpcklkJ10gaW4gdGhpcy5tYXJrZXRzX2J5X2lkKVxuICAgICAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbdHJhZGVbJ1RyYWRlUGFpcklkJ11dO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBmZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBpZiAoJ0ZlZScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB0cmFkZVsnRmVlJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6ICdsaW1pdCcsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydUeXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdjb3N0JzogY29zdCxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnQW1vdW50J10sXG4gICAgICAgICAgICAnZmVlJzogZmVlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldEhpc3RvcnlJZEhvdXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2hvdXJzJzogMjQsIC8vIGRlZmF1bHRcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0cmFkZXMgPSByZXNwb25zZVsnRGF0YSddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAodHJhZGVzLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoTXlUcmFkZXMgcmVxdWlyZXMgYSBzeW1ib2wnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0VHJhZGVIaXN0b3J5ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgLy8gJ01hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdUcmFkZVBhaXJJZCc6IG1hcmtldFsnaWQnXSwgLy8gQ3J5cHRvcGlhIGlkZW50aWZpZXIgKG5vdCByZXF1aXJlZCBpZiAnTWFya2V0JyBzdXBwbGllZClcbiAgICAgICAgICAgIC8vICdDb3VudCc6IDEwLCAvLyBtYXggPSAxMDBcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsnRGF0YSddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDdXJyZW5jaWVzIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmNpZXMgKHBhcmFtcyk7XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgaWQgPSBjdXJyZW5jeVsnU3ltYm9sJ107XG4gICAgICAgICAgICAvLyB0b2RvOiB3aWxsIG5lZWQgdG8gcmV0aGluayB0aGUgZmVlc1xuICAgICAgICAgICAgLy8gdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIHdpdGhkcmF3YWwvZGVwb3NpdCBtZXRob2RzIGFuZFxuICAgICAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgZmVlcyBmb3IgZWFjaCBwYXJ0aWN1bGFyIG1ldGhvZFxuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogOCwgLy8gZGVmYXVsdCBwcmVjaXNpb24sIHRvZG86IGZpeCBcIm1hZ2ljIGNvbnN0YW50c1wiXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogOCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChpZCk7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gKGN1cnJlbmN5WydMaXN0aW5nU3RhdHVzJ10gPT0gJ0FjdGl2ZScpO1xuICAgICAgICAgICAgbGV0IHN0YXR1cyA9IGN1cnJlbmN5WydTdGF0dXMnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIHJlc3VsdFtjb2RlXSA9IHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnY29kZSc6IGNvZGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IGN1cnJlbmN5WydOYW1lJ10sXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgICAgICdmZWUnOiBjdXJyZW5jeVsnV2l0aGRyYXdGZWUnXSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogY3VycmVuY3lbJ01pbkJhc2VUcmFkZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGN1cnJlbmN5WydNaW5XaXRoZHJhdyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IGN1cnJlbmN5WydNYXhXaXRoZHJhdyddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBiYWxhbmNlWydTeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChjb2RlKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnQXZhaWxhYmxlJ10sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZVsnVG90YWwnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0IChwcmljZSk7XG4gICAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQgKGFtb3VudCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ1RyYWRlUGFpcklkJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ1R5cGUnOiB0aGlzLmNhcGl0YWxpemUgKHNpZGUpLFxuICAgICAgICAgICAgJ1JhdGUnOiB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgcHJpY2UpLFxuICAgICAgICAgICAgJ0Ftb3VudCc6IHRoaXMuYW1vdW50VG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50KSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFN1Ym1pdFRyYWRlICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY3JlYXRlT3JkZXIgcmV0dXJuZWQgdW5rbm93biBlcnJvcjogJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgbGV0IGlkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZmlsbGVkID0gMC4wO1xuICAgICAgICBpZiAoJ0RhdGEnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoJ09yZGVySWQnIGluIHJlc3BvbnNlWydEYXRhJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ0RhdGEnXVsnT3JkZXJJZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkID0gcmVzcG9uc2VbJ0RhdGEnXVsnT3JkZXJJZCddLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnRmlsbGVkT3JkZXJzJyBpbiByZXNwb25zZVsnRGF0YSddKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGxlZE9yZGVycyA9IHJlc3BvbnNlWydEYXRhJ11bJ0ZpbGxlZE9yZGVycyddO1xuICAgICAgICAgICAgICAgIGxldCBmaWxsZWRPcmRlcnNMZW5ndGggPSBmaWxsZWRPcmRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmaWxsZWRPcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb3BlbicsXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnY29zdCc6IHByaWNlICogYW1vdW50LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmlsbGVkJzogZmlsbGVkLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vICd0cmFkZXMnOiB0aGlzLnBhcnNlVHJhZGVzIChvcmRlclsndHJhZGVzJ10sIG1hcmtldCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpZClcbiAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IG9yZGVyO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmQgKHsgJ2luZm8nOiByZXNwb25zZSB9LCBvcmRlcik7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdUeXBlJzogJ1RyYWRlJyxcbiAgICAgICAgICAgICAgICAnT3JkZXJJZCc6IGlkLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5vcmRlcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdWydzdGF0dXMnXSA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5zYWZlU3RyaW5nICh0aGlzLmxhc3RfanNvbl9yZXNwb25zZSwgJ0Vycm9yJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5kZXhPZiAoJ2RvZXMgbm90IGV4aXN0JykgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIGVycm9yOiAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgfSBlbHNlIGlmICgnTWFya2V0JyBpbiBvcmRlcikge1xuICAgICAgICAgICAgbGV0IGlkID0gb3JkZXJbJ01hcmtldCddO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydUaW1lU3RhbXAnXSk7XG4gICAgICAgIGxldCBhbW91bnQgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdBbW91bnQnKTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ1JlbWFpbmluZycpO1xuICAgICAgICBsZXQgZmlsbGVkID0gYW1vdW50IC0gcmVtYWluaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ09yZGVySWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdGhpcy5vbWl0IChvcmRlciwgJ3N0YXR1cycpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiBvcmRlclsnc3RhdHVzJ10sXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBvcmRlclsnVHlwZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3ByaWNlJzogdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnUmF0ZScpLFxuICAgICAgICAgICAgJ2Nvc3QnOiB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdUb3RhbCcpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vICd0cmFkZXMnOiB0aGlzLnBhcnNlVHJhZGVzIChvcmRlclsndHJhZGVzJ10sIG1hcmtldCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaE9yZGVycyByZXF1aXJlcyBhIHN5bWJvbCBwYXJhbScpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRPcGVuT3JkZXJzICh7XG4gICAgICAgICAgICAvLyAnTWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ1RyYWRlUGFpcklkJzogbWFya2V0WydpZCddLCAvLyBDcnlwdG9waWEgaWRlbnRpZmllciAobm90IHJlcXVpcmVkIGlmICdNYXJrZXQnIHN1cHBsaWVkKVxuICAgICAgICAgICAgLy8gJ0NvdW50JzogMTAwLCAvLyBkZWZhdWx0ID0gMTAwXG4gICAgICAgIH0sIHBhcmFtcyk7XG4gICAgICAgIGxldCBvcmRlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZVsnRGF0YSddLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvcmRlcnMucHVzaCAodGhpcy5leHRlbmQgKHJlc3BvbnNlWydEYXRhJ11baV0sIHsgJ3N0YXR1cyc6ICdvcGVuJyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZW5PcmRlcnMgPSB0aGlzLnBhcnNlT3JkZXJzIChvcmRlcnMsIG1hcmtldCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3Blbk9yZGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhpcy5vcmRlcnNbb3Blbk9yZGVyc1tqXVsnaWQnXV0gPSBvcGVuT3JkZXJzW2pdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVuT3JkZXJzSW5kZXhlZEJ5SWQgPSB0aGlzLmluZGV4QnkgKG9wZW5PcmRlcnMsICdpZCcpO1xuICAgICAgICBsZXQgY2FjaGVkT3JkZXJJZHMgPSBPYmplY3Qua2V5cyAodGhpcy5vcmRlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2FjaGVkT3JkZXJJZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGNhY2hlZE9yZGVySWRzW2tdO1xuICAgICAgICAgICAgaWYgKGlkIGluIG9wZW5PcmRlcnNJbmRleGVkQnlJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IHRoaXMuZXh0ZW5kICh0aGlzLm9yZGVyc1tpZF0sIG9wZW5PcmRlcnNJbmRleGVkQnlJZFtpZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLm9yZGVyc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gdGhpcy5leHRlbmQgKG9yZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ2Nsb3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29zdCc6IG9yZGVyWydhbW91bnQnXSAqIG9yZGVyWydwcmljZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxlZCc6IG9yZGVyWydhbW91bnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZW1haW5pbmcnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcmRlciA9IHRoaXMub3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGlmIChvcmRlclsnc3ltYm9sJ10gPT0gc3ltYm9sKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoIChvcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQnlTaW5jZUxpbWl0IChyZXN1bHQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWQgPSBpZC50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IGF3YWl0IHRoaXMuZmV0Y2hPcmRlcnMgKHN5bWJvbCwgcGFyYW1zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcmRlcnNbaV1bJ2lkJ10gPT0gaWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RDYWNoZWQgKHRoaXMuaWQgKyAnIG9yZGVyICcgKyBpZCArICcgbm90IGZvdW5kIGluIGNhY2hlZCAub3JkZXJzLCBmZXRjaE9yZGVyIHJlcXVpcmVzIC5vcmRlcnMgKGRlKXNlcmlhbGl6YXRpb24gaW1wbGVtZW50ZWQgZm9yIHRoaXMgbWV0aG9kIHRvIHdvcmsgcHJvcGVybHknKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJzID0gYXdhaXQgdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3JkZXJzW2ldWydzdGF0dXMnXSA9PSAnb3BlbicpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9yZGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaENsb3NlZE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcmRlcnNbaV1bJ3N0YXR1cyddID09ICdjbG9zZWQnKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoIChvcmRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXREZXBvc2l0QWRkcmVzcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDdXJyZW5jeSc6IGN1cnJlbmN5SWRcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5zYWZlU3RyaW5nIChyZXNwb25zZVsnRGF0YSddLCAnQmFzZUFkZHJlc3MnKTtcbiAgICAgICAgaWYgKCFhZGRyZXNzKVxuICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2VbJ0RhdGEnXSwgJ0FkZHJlc3MnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0U3VibWl0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnQ3VycmVuY3knOiBjdXJyZW5jeUlkLFxuICAgICAgICAgICAgJ0Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdBZGRyZXNzJzogYWRkcmVzcywgLy8gQWRkcmVzcyBtdXN0IGV4aXN0IGluIHlvdSBBZGRyZXNzQm9vayBpbiBzZWN1cml0eSBzZXR0aW5nc1xuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnRGF0YSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLmhhc2ggKHRoaXMuZW5jb2RlIChib2R5KSwgJ21kNScsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGxldCBzZWNyZXQgPSB0aGlzLmJhc2U2NFRvQmluYXJ5ICh0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgdXJpID0gdGhpcy5lbmNvZGVVUklDb21wb25lbnQgKHVybCk7XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gdXJpLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IHBheWxvYWQgPSB0aGlzLmFwaUtleSArIG1ldGhvZCArIGxvd2VyY2FzZSArIG5vbmNlICsgdGhpcy5iaW5hcnlUb1N0cmluZyAoaGFzaCk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocGF5bG9hZCksIHNlY3JldCwgJ3NoYTI1NicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gJ2FteCAnICsgdGhpcy5hcGlLZXkgKyAnOicgKyB0aGlzLmJpbmFyeVRvU3RyaW5nIChzaWduYXR1cmUpICsgJzonICsgbm9uY2U7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBhdXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICgnU3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydTdWNjZXNzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJ0Vycm9yJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ0Vycm9yJ10gPT0gJ0luc3VmZmljaWVudCBGdW5kcy4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGxpcXVpID0gcmVxdWlyZSAoJy4vbGlxdWkuanMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBkc3ggZXh0ZW5kcyBsaXF1aSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnZHN4JyxcbiAgICAgICAgICAgICduYW1lJzogJ0RTWCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VLJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTAyNzUtMTQxMzE1OGEtNjQ1YS0xMWU3LTkzMWMtOTQ3MTdmNzUxMGUzLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2RzeC51ay9tYXBpJywgLy8gbWFya2V0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9kc3gudWsvdGFwaScsIC8vIHRyYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgJ2R3YXBpJzogJ2h0dHBzOi8vZHN4LnVrL2R3YXBpJywgLy8gZGVwb3NpdC93aXRoZHJhd1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2RzeC51aycsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLmRzeC51aycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2RzeC51ay9hcGlfZG9jcy9wdWJsaWMnLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9kc3gudWsvYXBpX2RvY3MvcHJpdmF0ZScsXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrZXQgZGF0YSAocHVibGljKVxuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFyc0Zyb21Nb21lbnQve2lkfS97cGVyaW9kfS97c3RhcnR9JywgLy8gZW1wdHkgcmVwbHkgOlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsYXN0QmFycy97aWR9L3twZXJpb2R9L3thbW91bnR9JywgLy8gcGVyaW9kIGlzIChtLCBoIG9yIGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAncGVyaW9kQmFycy97aWR9L3twZXJpb2R9L3tzdGFydH0ve2VuZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlci97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gdHJhZGluZyAocHJpdmF0ZSlcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhbnNIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09yZGVySGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWN0aXZlT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gZGVwb3NpdCAvIHdpdGhkcmF3IChwcml2YXRlKVxuICAgICAgICAgICAgICAgICdkd2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0Q3J5cHRvRGVwb3NpdEFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyeXB0b1dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWF0V2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldFRyYW5zYWN0aW9uU3RhdHVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRCYXNlUXVvdGVGcm9tTWFya2V0SWQgKGlkKSB7XG4gICAgICAgIGxldCB1cHBlcmNhc2UgPSBpZC50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgbGV0IGJhc2UgPSB1cHBlcmNhc2Uuc2xpY2UgKDAsIDMpO1xuICAgICAgICBsZXQgcXVvdGUgPSB1cHBlcmNhc2Uuc2xpY2UgKDMsIDYpO1xuICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgIHJldHVybiBbIGJhc2UsIHF1b3RlIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ3JldHVybiddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBmdW5kcyA9IGJhbGFuY2VzWydmdW5kcyddO1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChmdW5kcyk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIHVwcGVyY2FzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBmdW5kc1tjdXJyZW5jeV0sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZXNbJ3RvdGFsJ11bY3VycmVuY3ldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd1cGRhdGVkJ10gKiAxMDAwO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnaGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5JyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3NlbGwnKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0JyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IDEgLyB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXZnJyksXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2wnKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2xfY3VyJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBnZXRPcmRlcklkS2V5ICgpIHtcbiAgICAgICAgcmV0dXJuICdvcmRlcklkJztcbiAgICB9XG5cbiAgICBzaWduQm9keVdpdGhTZWNyZXQgKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlICh0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicsICdiYXNlNjQnKSk7XG4gICAgfVxuXG4gICAgZ2V0VmVyc2lvblN0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiAnJzsgLy8gdGhleSBkb24ndCBwcmVwZW5kIHZlcnNpb24gbnVtYmVyIHRvIHB1YmxpYyBVUkxzIGFzIG90aGVyIEJUQy1lIGNsb25lcyBkb1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGV4bW8gZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnZXhtbycsXG4gICAgICAgICAgICAnbmFtZSc6ICdFWE1PJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdFUycsICdSVScgXSwgLy8gU3BhaW4sIFJ1c3NpYVxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsIC8vIG9uY2UgZXZlcnkgMzUwIG1zIOKJiCAxODAgcmVxdWVzdHMgcGVyIG1pbnV0ZSDiiYggMyByZXF1ZXN0cyBwZXIgc2Vjb25kXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjQ5MS0xYjBlYTk1Ni01ZWRhLTExZTctOTIyNS00MGQ2N2I0ODFiOGQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmV4bW8uY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vZXhtby5tZScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZXhtby5tZS9lbi9hcGlfZG9jJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9leG1vLWRldi9leG1vX2FwaV9saWIvdHJlZS9tYXN0ZXIvbm9kZWpzJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFpcl9zZXR0aW5ncycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJfb3Blbl9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXJfdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyX2NhbmNlbGxlZF9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyX3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVxdWlyZWRfYW1vdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2NyeXB0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd19nZXRfdHhpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjb2RlX2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjb2RlX2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldF9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMiAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFBhaXJTZXR0aW5ncyAoKTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAobWFya2V0cyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBrZXlzW3BdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkLnJlcGxhY2UgKCdfJywgJy8nKTtcbiAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbWFya2V0WydtaW5fcXVhbnRpdHknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBtYXJrZXRbJ21heF9xdWFudGl0eSddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbWFya2V0WydtaW5fcHJpY2UnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBtYXJrZXRbJ21heF9wcmljZSddLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBtYXJrZXRbJ21pbl9hbW91bnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBtYXJrZXRbJ21heF9hbW91bnQnXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiA4LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiA4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFVzZXJJbmZvICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIHJlc3BvbnNlWydiYWxhbmNlcyddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKHJlc3BvbnNlWydiYWxhbmNlcyddW2N1cnJlbmN5XSk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gcmVzcG9uc2VbJ3Jlc2VydmVkJ10pXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAocmVzcG9uc2VbJ3Jlc2VydmVkJ11bY3VycmVuY3ldKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVttYXJrZXRbJ2lkJ11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWQnLCAnYXNrJyk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3VwZGF0ZWQnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eV9wcmljZSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGxfcHJpY2UnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RfdHJhZGUnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXZnJ10pLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sX2N1cnInXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyIChwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAocmVzcG9uc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVtpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyIChwYXJhbXMpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyIChyZXNwb25zZVttYXJrZXRbJ2lkJ11dLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RyYWRlX2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ3F1YW50aXR5J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlW21hcmtldFsnaWQnXV0sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgcHJlZml4ID0gJ21hcmtldF8nO1xuICAgICAgICBpZiAodHlwZW9mIHByaWNlID09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcHJpY2UgPSAwO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICd0eXBlJzogcHJlZml4ICsgc2lkZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ3JlYXRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ2FuY2VsICh7ICdvcmRlcl9pZCc6IGlkIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3Q3J5cHQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXN1bHQsXG4gICAgICAgICAgICAnaWQnOiByZXN1bHRbJ3Rhc2tfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdTaWduJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdyZXN1bHQnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBmbG93YnRjIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2Zsb3didGMnLFxuICAgICAgICAgICAgJ25hbWUnOiAnZmxvd0JUQycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0JSJywgLy8gQnJhemlsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjgxNjI0NjUtY2Q4MTVkNGMtNjdjZi0xMWU3LThlNTctNDM4YmVhMDUyM2EyLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5mbG93YnRjLmNvbTo4NDAwL2FqYXgnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly90cmFkZXIuZmxvd2J0Yy5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cDovL3d3dy5mbG93YnRjLmNvbS5ici9hcGkvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncmVxdWlyZWRDcmVkZW50aWFscyc6IHtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnc2VjcmV0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndWlkJzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFRpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRUcmFkZXNCeURhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE9yZGVyQm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0UHJvZHVjdFBhaXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRQcm9kdWN0cycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ3JlYXRlQWNjb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VXNlckluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NldFVzZXJJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRBY2NvdW50SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0QWNjb3VudFRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0RGVwb3NpdEFkZHJlc3NlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NyZWF0ZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNb2RpZnlPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbEFsbE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0QWNjb3VudE9wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE9yZGVyRmVlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0UHJvZHVjdFBhaXJzICgpO1xuICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydwcm9kdWN0UGFpcnMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsncHJvZHVjdDFMYWJlbCddO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0Wydwcm9kdWN0MkxhYmVsJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydjdXJyZW5jaWVzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ25hbWUnXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnYmFsYW5jZSddLFxuICAgICAgICAgICAgICAgICd1c2VkJzogYmFsYW5jZVsnaG9sZCddLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY1Bvc3RHZXRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncHJvZHVjdFBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHgnLCAncXR5Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3Byb2R1Y3RQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZTI0aHInXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZTI0aHJQcm9kdWN0MiddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd1bml4dGltZSddICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ2luY29taW5nT3JkZXJTaWRlJ10gPT0gMCkgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydweCddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydxdHknXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lucyc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdzdGFydEluZGV4JzogLTEsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyVHlwZSA9ICh0eXBlID09ICdtYXJrZXQnKSA/IDEgOiAwO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnaW5zJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdvcmRlclR5cGUnOiBvcmRlclR5cGUsXG4gICAgICAgICAgICAncXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ3B4JzogcHJpY2UsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDcmVhdGVPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnc2VydmVyT3JkZXJJZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBpZiAoJ2lucycgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdzZXJ2ZXJPcmRlcklkJzogaWQsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgYGluc2Agc3ltYm9sIHBhcmFtZXRlciBmb3IgY2FuY2VsbGluZyBhbiBvcmRlcicpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gbm9uY2UudG9TdHJpbmcgKCkgKyB0aGlzLnVpZCArIHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdhcGlOb25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdhcGlTaWcnOiBzaWduYXR1cmUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdpc0FjY2VwdGVkJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnaXNBY2NlcHRlZCddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGZveGJpdCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdmb3hiaXQnLFxuICAgICAgICAgICAgJ25hbWUnOiAnRm94Qml0JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQlInLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk5MTQxMy0xMWI0MGQ0Mi02NDdmLTExZTctOTFlZS03OGNlZDg3NGRkMDkuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmJsaW5rdHJhZGUuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmJsaW5rdHJhZGUuY29tL3RhcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2ZveGJpdC5leGNoYW5nZScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2JsaW5rdHJhZGUuY29tL2RvY3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdjb21tZW50JzogJ0JsaW5rdHJhZGUgQVBJJyxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y3VycmVuY3l9L3RpY2tlcicsICAgIC8vID9jcnlwdG9fY3VycmVuY3k9QlRDXG4gICAgICAgICAgICAgICAgICAgICAgICAne2N1cnJlbmN5fS9vcmRlcmJvb2snLCAvLyA/Y3J5cHRvX2N1cnJlbmN5PUJUQ1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3tjdXJyZW5jeX0vdHJhZGVzJywgICAgLy8gP2NyeXB0b19jdXJyZW5jeT1CVEMmc2luY2U9PFRJTUVTVEFNUD4mbGltaXQ9PE5VTUJFUj5cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdEJywgICAvLyBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0YnLCAgIC8vIGNhbmNlbCBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1UyJywgIC8vIGJhbGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICdVNCcsICAvLyBteSBvcmRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdVNicsICAvLyB3aXRoZHJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1UxOCcsIC8vIGRlcG9zaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICdVMjQnLCAvLyBjb25maXJtIHdpdGhkcmF3YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVMjYnLCAvLyBsaXN0IHdpdGhkcmF3YWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAnVTMwJywgLy8gbGlzdCBkZXBvc2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1UzNCcsIC8vIGxlZGdlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1U3MCcsIC8vIGNhbmNlbCB3aXRoZHJhd2FsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1ZFRic6IHsgJ2lkJzogJ0JUQ1ZFRicsICdzeW1ib2wnOiAnQlRDL1ZFRicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdWRUYnLCAnYnJva2VySWQnOiAxLCAnYnJva2VyJzogJ1N1ckJpdGNvaW4nIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9WTkQnOiB7ICdpZCc6ICdCVENWTkQnLCAnc3ltYm9sJzogJ0JUQy9WTkQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVk5EJywgJ2Jyb2tlcklkJzogMywgJ2Jyb2tlcic6ICdWQlRDJyB9LFxuICAgICAgICAgICAgICAgICdCVEMvQlJMJzogeyAnaWQnOiAnQlRDQlJMJywgJ3N5bWJvbCc6ICdCVEMvQlJMJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0JSTCcsICdicm9rZXJJZCc6IDQsICdicm9rZXInOiAnRm94Qml0JyB9LFxuICAgICAgICAgICAgICAgICdCVEMvUEtSJzogeyAnaWQnOiAnQlRDUEtSJywgJ3N5bWJvbCc6ICdCVEMvUEtSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1BLUicsICdicm9rZXJJZCc6IDgsICdicm9rZXInOiAnVXJkdUJpdCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL0NMUCc6IHsgJ2lkJzogJ0JUQ0NMUCcsICdzeW1ib2wnOiAnQlRDL0NMUCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDTFAnLCAnYnJva2VySWQnOiA5LCAnYnJva2VyJzogJ0NoaWxlQml0JyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICAvLyB0b2RvIHBhcnNlIGJhbGFuY2VcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RVMiAoe1xuICAgICAgICAgICAgJ0JhbGFuY2VSZXFJRCc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0Q3VycmVuY3lPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAnY3J5cHRvX2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ2NyeXB0b19jdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgbG93ZXJjYXNlUXVvdGUgPSBtYXJrZXRbJ3F1b3RlJ10udG9Mb3dlckNhc2UgKCk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9ICd2b2xfJyArIGxvd2VyY2FzZVF1b3RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbcXVvdGVWb2x1bWVdKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ2NyeXB0b19jdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyU2lkZSA9IChzaWRlID09ICdidXknKSA/ICcxJyA6ICcyJztcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ0NsT3JkSUQnOiB0aGlzLm5vbmNlICgpLFxuICAgICAgICAgICAgJ1N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdTaWRlJzogb3JkZXJTaWRlLFxuICAgICAgICAgICAgJ09yZFR5cGUnOiAnMicsXG4gICAgICAgICAgICAnUHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdPcmRlclF0eSc6IGFtb3VudCxcbiAgICAgICAgICAgICdCcm9rZXJJRCc6IG1hcmtldFsnYnJva2VySWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEQgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBpbmRleGVkID0gdGhpcy5pbmRleEJ5IChyZXNwb25zZVsnUmVzcG9uc2VzJ10sICdNc2dUeXBlJyk7XG4gICAgICAgIGxldCBleGVjdXRpb24gPSBpbmRleGVkWyc4J107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogZXhlY3V0aW9uWydPcmRlcklEJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0RiAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDbE9yZElEJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuZXh0ZW5kICh7ICdNc2dUeXBlJzogcGF0aCB9LCBxdWVyeSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0FQSUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdOb25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdTaWduYXR1cmUnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChub25jZSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnU3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnU3RhdHVzJ10gIT0gMjAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgZnlic2UgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnZnlic2UnLFxuICAgICAgICAgICAgJ25hbWUnOiAnRllCLVNFJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnU0UnLCAvLyBTd2VkZW5cbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1MTItMzEwMTk3NzItNWVkYi0xMWU3LTgyNDEtMmU2NzVlNjc5N2YxLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5meWJzZS5zZS9hcGkvU0VLJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmZ5YnNlLnNlJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHA6Ly9kb2NzLmZ5Yi5hcGlhcnkuaW8nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcmRldGFpbGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndGVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0YWNjaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0cGVuZGluZ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0b3JkZXJoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxwZW5kaW5nb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWNlb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvU0VLJzogeyAnaWQnOiAnU0VLJywgJ3N5bWJvbCc6ICdCVEMvU0VLJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1NFSycgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0YWNjaW5mbyAoKTtcbiAgICAgICAgbGV0IGJ0YyA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2J0Y0JhbCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHRoaXMuc3ltYm9sc1swXTtcbiAgICAgICAgbGV0IHF1b3RlID0gdGhpcy5tYXJrZXRzW3N5bWJvbF1bJ3F1b3RlJ107XG4gICAgICAgIGxldCBsb3dlcmNhc2UgPSBxdW90ZS50b0xvd2VyQ2FzZSAoKSArICdCYWwnO1xuICAgICAgICBsZXQgZmlhdCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbbG93ZXJjYXNlXSk7XG4gICAgICAgIGxldCBjcnlwdG8gPSB7XG4gICAgICAgICAgICAnZnJlZSc6IGJ0YyxcbiAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgJ3RvdGFsJzogYnRjLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnQlRDJzogY3J5cHRvIH07XG4gICAgICAgIHJlc3VsdFtxdW90ZV0gPSB7XG4gICAgICAgICAgICAnZnJlZSc6IGZpYXQsXG4gICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICd0b3RhbCc6IGZpYXQsXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdFsnaW5mbyddID0gYmFsYW5jZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyYm9vayAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyZGV0YWlsZWQgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB2b2x1bWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnbGFzdCcgaW4gdGlja2VyKVxuICAgICAgICAgICAgbGFzdCA9IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKTtcbiAgICAgICAgaWYgKCd2b2wnIGluIHRpY2tlcilcbiAgICAgICAgICAgIHZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBsYXN0LFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFBsYWNlb3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAndHlwZSc6IHNpZGVbMF0udG9VcHBlckNhc2UgKClcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3BlbmRpbmdfb2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VscGVuZGluZ29yZGVyICh7ICdvcmRlck5vJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLmpzb24nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAndGltZXN0YW1wJzogbm9uY2UgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZyc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMScpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKVxuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZnlic2UgPSByZXF1aXJlICgnLi9meWJzZS5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGZ5YnNnIGV4dGVuZHMgZnlic2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2Z5YnNnJyxcbiAgICAgICAgICAgICduYW1lJzogJ0ZZQi1TRycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1NHJywgLy8gU2luZ2Fwb3JlXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjUxMy0zMzY0ZDU2YS01ZWRiLTExZTctOWU2Yi1kNTg5OGJiODljODEuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmZ5YnNnLmNvbS9hcGkvU0dEJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmZ5YnNnLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwOi8vZG9jcy5meWIuYXBpYXJ5LmlvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL1NHRCc6IHsgJ2lkJzogJ1NHRCcsICdzeW1ib2wnOiAnQlRDL1NHRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdTR0QnIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBnYXRlY29pbiBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdnYXRlY29pbicsXG4gICAgICAgICAgICAnbmFtZSc6ICdHYXRlY29pbicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSEsnLCAvLyBIb25nIEtvbmdcbiAgICAgICAgICAgICdjb21tZW50JzogJ2EgcmVndWxhdGVkL2xpY2Vuc2VkIGV4Y2hhbmdlJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICcxbScsXG4gICAgICAgICAgICAgICAgJzE1bSc6ICcxNW0nLFxuICAgICAgICAgICAgICAgICcxaCc6ICcxaCcsXG4gICAgICAgICAgICAgICAgJzZoJzogJzZoJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMjRoJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4NjQ2ODE3LTUwODQ1N2YyLTcyNmMtMTFlNy05ZWViLTM1MjhkMjQxM2E1OC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuZ2F0ZWNvaW4uY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vZ2F0ZWNvaW4uY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9nYXRlY29pbi5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9HYXRlY29pbi9SRVNUZnVsLUFQSS1JbXBsZW1lbnRhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FwaS5nYXRlY29pbi5jb20vc3dhZ2dlci11aS9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvRXhjaGFuZ2VSYXRlJywgLy8gR2V0IHRoZSBleGNoYW5nZSByYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1B1YmxpYy9MaXZlVGlja2VyJywgLy8gR2V0IGxpdmUgdGlja2VyIGZvciBhbGwgY3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvTGl2ZVRpY2tlci97Q3VycmVuY3lQYWlyfScsIC8vIEdldCBsaXZlIHRpY2tlciBieSBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICAgICAgICAgJ1B1YmxpYy9MaXZlVGlja2VycycsIC8vIEdldCBsaXZlIHRpY2tlciBmb3IgYWxsIGN1cnJlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICAnUHVibGljL01hcmtldERlcHRoL3tDdXJyZW5jeVBhaXJ9JywgLy8gR2V0cyBwcmljZXMgYW5kIG1hcmtldCBkZXB0aCBmb3IgdGhlIGN1cnJlbmN5IHBhaXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAnUHVibGljL05ldHdvcmtTdGF0aXN0aWNzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0IHRoZSBuZXR3b3JrIHN0YXR1cyBvZiBhIHNwZWNpZmljIGRpZ2l0YWwgY3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvU3RhdGlzdGljSGlzdG9yeS97RGlnaUN1cnJlbmN5fS97VHlwZW9mZGF0YX0nLCAvLyBHZXQgdGhlIGhpc3RvcmljYWwgZGF0YSBvZiBhIHNwZWNpZmljIGRpZ2l0YWwgY3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvVGlja2VySGlzdG9yeS97Q3VycmVuY3lQYWlyfS97VGltZWZyYW1lfScsIC8vIEdldCB0aWNrZXIgaGlzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgJ1B1YmxpYy9UcmFuc2FjdGlvbnMve0N1cnJlbmN5UGFpcn0nLCAvLyBHZXRzIHJlY2VudCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdQdWJsaWMvVHJhbnNhY3Rpb25zSGlzdG9yeS97Q3VycmVuY3lQYWlyfScsIC8vIEdldHMgYWxsIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9CdXNpbmVzc05hdHVyZUxpc3QnLCAvLyBHZXQgdGhlIGJ1c2luZXNzIG5hdHVyZSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9Db3VudHJpZXMnLCAvLyBHZXQgdGhlIGNvdW50cnkgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvQ3VycmVuY2llcycsIC8vIEdldCB0aGUgY3VycmVuY3kgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvQ3VycmVuY3lQYWlycycsIC8vIEdldCB0aGUgY3VycmVuY3kgcGFpciBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9DdXJyZW50U3RhdHVzTGlzdCcsIC8vIEdldCB0aGUgY3VycmVudCBzdGF0dXMgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvSWRlbnR5ZG9jdW1lbnRUeXBlcycsIC8vIEdldCB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGlkZW50aXR5IGRvY3VtZW50cyBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvSW5jb21lUmFuZ2VMaXN0JywgLy8gR2V0IHRoZSBpbmNvbWUgcmFuZ2UgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvSW5jb21lU291cmNlTGlzdCcsIC8vIEdldCB0aGUgaW5jb21lIHNvdXJjZSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9WZXJpZmljYXRpb25MZXZlbExpc3QnLCAvLyBHZXQgdGhlIHZlcmlmIGxldmVsIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAnU3RyZWFtL1B1YmxpY0NoYW5uZWwnLCAvLyBHZXQgdGhlIHB1YmxpYyBwdWJudWIgY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0V4cG9ydC9UcmFuc2FjdGlvbnMnLCAvLyBSZXF1ZXN0IGEgZXhwb3J0IG9mIGFsbCB0cmFkZXMgZnJvbSBiYXNlZCBvbiBjdXJyZW5jeXBhaXIsIHN0YXJ0IGRhdGUgYW5kIGVuZCBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAnUGluZycsIC8vIFBvc3QgYSBzdHJpbmcsIHRoZW4gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAnUHVibGljL1Vuc3Vic2NyaWJlL3tFbWFpbENvZGV9JywgLy8gTGV0cyB0aGUgdXNlciB1bnN1YnNjcmliZSBmcm9tIGVtYWlsc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZ2lzdGVyVXNlcicsIC8vIEluaXRpYWwgdHJhZGVyIHJlZ2lzdHJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvQ29ycG9yYXRlRGF0YScsIC8vIEdldCBjb3Jwb3JhdGUgYWNjb3VudCBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Eb2N1bWVudEFkZHJlc3MnLCAvLyBDaGVjayBpZiByZXNpZGVuY2UgcHJvb2YgdXBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50Q29ycG9yYXRpb24nLCAvLyBDaGVjayBpZiByZWdpc3RlcmVkIGRvY3VtZW50IHVwbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Eb2N1bWVudElEJywgLy8gQ2hlY2sgaWYgSUQgZG9jdW1lbnQgY29weSB1cGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRJbmZvcm1hdGlvbicsIC8vIEdldCBTdGVwMyBEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9FbWFpbCcsIC8vIEdldCB1c2VyIGVtYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9GZWVSYXRlJywgLy8gR2V0IGZlZSByYXRlIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9MZXZlbCcsIC8vIEdldCB2ZXJpZiBsZXZlbCBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUGVyc29uYWxJbmZvcm1hdGlvbicsIC8vIEdldCBTdGVwMSBEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9QaG9uZScsIC8vIEdldCB1c2VyIHBob25lIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUHJvZmlsZScsIC8vIEdldCB0cmFkZXIgcHJvZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUXVlc3Rpb25uYWlyZScsIC8vIEZpbGwgdGhlIHF1ZXN0aW9ubmFpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1JlZmVycmFsJywgLy8gR2V0IHJlZmVycmFsIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9SZWZlcnJhbENvZGUnLCAvLyBHZXQgdGhlIHJlZmVycmFsIGNvZGUgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9SZWZlcnJhbE5hbWVzJywgLy8gR2V0IG5hbWVzIG9mIHJlZmVycmVkIHRyYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1JlZmVycmFsUmV3YXJkJywgLy8gR2V0IHJlZmVycmFsIHJld2FyZCBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUmVmZXJyZWRDb2RlJywgLy8gR2V0IHJlZmVycmFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1Jlc2lkZW50SW5mb3JtYXRpb24nLCAvLyBHZXQgU3RlcDIgRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvU2VjdXJpdHlTZXR0aW5ncycsIC8vIEdldCB2ZXJpZiBkZXRhaWxzIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Vc2VyJywgLy8gR2V0IGFsbCB1c2VyIGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICdBUElLZXkvQVBJS2V5JywgLy8gR2V0IEFQSSBLZXkgZm9yIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aC9Db25uZWN0aW9uSGlzdG9yeScsIC8vIEdldHMgY29ubmVjdGlvbiBoaXN0b3J5IG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQmFsYW5jZS9CYWxhbmNlcycsIC8vIEdldHMgdGhlIGF2YWlsYWJsZSBiYWxhbmNlIGZvciBlYWNoIGN1cnJlbmN5IGZvciB0aGUgbG9nZ2VkIGluIGFjY291bnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAnQmFsYW5jZS9CYWxhbmNlcy97Q3VycmVuY3l9JywgLy8gR2V0cyB0aGUgYXZhaWxhYmxlIGJhbGFuY2UgZm9yIHMgY3VycmVuY3kgZm9yIHRoZSBsb2dnZWQgaW4gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdCYWxhbmNlL0RlcG9zaXRzJywgLy8gR2V0IGFsbCBhY2NvdW50IGRlcG9zaXRzLCBpbmNsdWRpbmcgd2lyZSBhbmQgZGlnaXRhbCBjdXJyZW5jeSwgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQmFsYW5jZS9XaXRoZHJhd2FscycsIC8vIEdldCBhbGwgYWNjb3VudCB3aXRoZHJhd2FscywgaW5jbHVkaW5nIHdpcmUgYW5kIGRpZ2l0YWwgY3VycmVuY3ksIG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvQWNjb3VudHMve0N1cnJlbmN5fS97TG9jYXRpb259JywgLy8gR2V0IGludGVybmFsIGJhbmsgYWNjb3VudCBmb3IgZGVwb3NpdFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVHJhbnNhY3Rpb25zJywgLy8gR2V0IGFsbCBhY2NvdW50IHRyYW5zYWN0aW9ucyBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdCYW5rL1VzZXJBY2NvdW50cycsIC8vIEdldHMgYWxsIHRoZSBiYW5rIGFjY291bnRzIHJlbGF0ZWQgdG8gdGhlIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzL3tDdXJyZW5jeX0nLCAvLyBHZXRzIGFsbCB0aGUgYmFuayBhY2NvdW50cyByZWxhdGVkIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L0RlcG9zaXRXYWxsZXRzJywgLy8gR2V0cyBhbGwgY3J5cHRvIGN1cnJlbmN5IGFkZHJlc3NlcyByZWxhdGVkIGRlcG9zaXRzIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L0RlcG9zaXRXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0cyBhbGwgY3J5cHRvIGN1cnJlbmN5IGFkZHJlc3NlcyByZWxhdGVkIGRlcG9zaXRzIHRvIHRoZSBsb2dnZWQgaW4gdXNlciBieSBjdXJyZW5jeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1RyYW5zYWN0aW9ucycsIC8vIEdldCBhbGwgZGlnaXRhbCBjdXJyZW5jeSB0cmFuc2FjdGlvbnMgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9UcmFuc2FjdGlvbnMve0RpZ2lDdXJyZW5jeX0nLCAvLyBHZXQgYWxsIGRpZ2l0YWwgY3VycmVuY3kgdHJhbnNhY3Rpb25zIG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvVXNlcldhbGxldHMnLCAvLyBHZXRzIGFsbCBleHRlcm5hbCBkaWdpdGFsIGN1cnJlbmN5IGFkZHJlc3NlcyByZWxhdGVkIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1VzZXJXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0cyBhbGwgZXh0ZXJuYWwgZGlnaXRhbCBjdXJyZW5jeSBhZGRyZXNzZXMgcmVsYXRlZCB0byB0aGUgbG9nZ2VkIGluIHVzZXIgYnkgY3VycmVuY3kuXG4gICAgICAgICAgICAgICAgICAgICAgICAnSW5mby9SZWZlcmVuY2VDdXJyZW5jeScsIC8vIEdldCB1c2VyJ3MgcmVmZXJlbmNlIGN1cnJlbmN5XG4gICAgICAgICAgICAgICAgICAgICAgICAnSW5mby9SZWZlcmVuY2VMYW5ndWFnZScsIC8vIEdldCB1c2VyJ3MgcmVmZXJlbmNlIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAnTm90aWZpY2F0aW9uL01lc3NhZ2VzJywgLy8gR2V0IGZyb20gb2xkZXN0IHVucmVhZCArIDMgcmVhZCBtZXNzYWdlIHRvIG5ld2VzdCBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlL09yZGVycycsIC8vIEdldHMgb3BlbiBvcmRlcnMgZm9yIHRoZSBsb2dnZWQgaW4gdHJhZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlL09yZGVycy97T3JkZXJJRH0nLCAvLyBHZXRzIGFuIG9yZGVyIGZvciB0aGUgbG9nZ2VkIGluIHRyYWRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9TdG9wT3JkZXJzJywgLy8gR2V0cyBhbGwgc3RvcCBvcmRlcnMgZm9yIHRoZSBsb2dnZWQgaW4gdHJhZGVyLiBNYXggMTAwMCByZWNvcmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGUvU3RvcE9yZGVyc0hpc3RvcnknLCAvLyBHZXRzIGFsbCBzdG9wIG9yZGVycyBmb3IgdGhlIGxvZ2dlZCBpbiB0cmFkZXIuIE1heCAxMDAwIHJlY29yZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9UcmFkZXMnLCAvLyBHZXRzIGFsbCB0cmFuc2FjdGlvbnMgb2YgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9Vc2VyVHJhZGVzJywgLy8gR2V0cyBhbGwgdHJhbnNhY3Rpb25zIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRBZGRyZXNzJywgLy8gVXBsb2FkIGFkZHJlc3MgcHJvb2YgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50Q29ycG9yYXRpb24nLCAvLyBVcGxvYWQgcmVnaXN0ZXJlZCBkb2N1bWVudCBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRJRCcsIC8vIFVwbG9hZCBJRCBkb2N1bWVudCBjb3B5XG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9FbWFpbC9SZXF1ZXN0VmVyaWZ5JywgLy8gUmVxdWVzdCBmb3IgdmVyaWZpY2F0aW9uIGVtYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9FbWFpbC9WZXJpZnknLCAvLyBWZXJpZmljYXRpb24gZW1haWxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0dvb2dsZUF1dGgnLCAvLyBFbmFibGUgZ29vZ2xlIGF1dGhcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0xldmVsJywgLy8gUmVxdWVzdCB2ZXJpZiBsZXZlbCBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUXVlc3Rpb25uYWlyZScsIC8vIEZpbGwgdGhlIHF1ZXN0aW9ubmFpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1JlZmVycmFsJywgLy8gUG9zdCBhIHJlZmVycmFsIGVtYWlsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVBJS2V5L0FQSUtleScsIC8vIENyZWF0ZSBhIG5ldyBBUEkga2V5IGZvciBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGgvQ2hhbmdlUGFzc3dvcmQnLCAvLyBDaGFuZ2UgcGFzc3dvcmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aC9Gb3Jnb3RQYXNzd29yZCcsIC8vIFJlcXVlc3QgcmVzZXQgcGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICdBdXRoL0ZvcmdvdFVzZXJJRCcsIC8vIFJlcXVlc3QgdXNlciBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGgvTG9naW4nLCAvLyBUcmFkZXIgc2Vzc2lvbiBsb2cgaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAnQXV0aC9Mb2dvdXQnLCAvLyBMb2dvdXQgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0F1dGgvTG9nb3V0T3RoZXJTZXNzaW9ucycsIC8vIExvZ291dCBvdGhlciBzZXNzaW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICdBdXRoL1Jlc2V0UGFzc3dvcmQnLCAvLyBSZXNldCBwYXNzd29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVHJhbnNhY3Rpb25zJywgLy8gUmVxdWVzdCBhIHRyYW5zZmVyIGZyb20gdGhlIHRyYWRlcnMgYWNjb3VudCBvZiB0aGUgbG9nZ2VkIGluIHVzZXIuIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGJhbmsgYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzJywgLy8gQWRkIGFuIGFjY291bnQgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9EZXBvc2l0V2FsbGV0cy97RGlnaUN1cnJlbmN5fScsIC8vIEFkZCBhbiBkaWdpdGFsIGN1cnJlbmN5IGFkZHJlc3NlcyB0byB0aGUgbG9nZ2VkIGluIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9UcmFuc2FjdGlvbnMvRGVwb3NpdHMve0RpZ2lDdXJyZW5jeX0nLCAvLyBHZXQgYWxsIGludGVybmFsIGRpZ2l0YWwgY3VycmVuY3kgdHJhbnNhY3Rpb25zIG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvVHJhbnNhY3Rpb25zL1dpdGhkcmF3YWxzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0IGFsbCBleHRlcm5hbCBkaWdpdGFsIGN1cnJlbmN5IHRyYW5zYWN0aW9ucyBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1VzZXJXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gQWRkIGFuIGV4dGVybmFsIGRpZ2l0YWwgY3VycmVuY3kgYWRkcmVzc2VzIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1dpdGhkcmF3YWxzL3tEaWdpQ3VycmVuY3l9JywgLy8gUmVxdWVzdCBhIHRyYW5zZmVyIGZyb20gdGhlIHRyYWRlcnMgYWNjb3VudCB0byBhbiBleHRlcm5hbCBhZGRyZXNzLiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBjcnlwdG8gY3VycmVuY2llcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICdOb3RpZmljYXRpb24vTWVzc2FnZXMnLCAvLyBNYXJrIGFsbCBhcyByZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICAnTm90aWZpY2F0aW9uL01lc3NhZ2VzL3tJRH0nLCAvLyBNYXJrIGFzIHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9PcmRlcnMnLCAvLyBQbGFjZSBhbiBvcmRlciBhdCB0aGUgZXhjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGUvU3RvcE9yZGVycycsIC8vIFBsYWNlIGEgc3RvcCBvcmRlciBhdCB0aGUgZXhjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwdXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Db3Jwb3JhdGVEYXRhJywgLy8gVXBkYXRlIHVzZXIgY29tcGFueSBkYXRhIGZvciBjb3Jwb3JhdGUgYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRJRCcsIC8vIFVwZGF0ZSBJRCBkb2N1bWVudCBtZXRhIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50SW5mb3JtYXRpb24nLCAvLyBVcGRhdGUgU3RlcDMgRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvRW1haWwnLCAvLyBVcGRhdGUgdXNlciBlbWFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUGVyc29uYWxJbmZvcm1hdGlvbicsIC8vIFVwZGF0ZSBTdGVwMSBEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9QaG9uZScsIC8vIFVwZGF0ZSB1c2VyIHBob25lIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUXVlc3Rpb25uYWlyZScsIC8vIHVwZGF0ZSB0aGUgcXVlc3Rpb25uYWlyZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvUmVmZXJyZWRDb2RlJywgLy8gVXBkYXRlIHJlZmVycmFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NvdW50L1Jlc2lkZW50SW5mb3JtYXRpb24nLCAvLyBVcGRhdGUgU3RlcDIgRGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY291bnQvU2VjdXJpdHlTZXR0aW5ncycsIC8vIFVwZGF0ZSB2ZXJpZiBkZXRhaWxzIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWNjb3VudC9Vc2VyJywgLy8gVXBkYXRlIGFsbCB1c2VyIGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICdCYW5rL1VzZXJBY2NvdW50cycsIC8vIFVwZGF0ZSB0aGUgbGFiZWwgb2YgZXhpc3RpbmcgdXNlciBiYW5rIGFjY291bm50XG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9EZXBvc2l0V2FsbGV0cy97RGlnaUN1cnJlbmN5fS97QWRkcmVzc05hbWV9JywgLy8gVXBkYXRlIHRoZSBuYW1lIG9mIGFuIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1VzZXJXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gVXBkYXRlIHRoZSBuYW1lIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICdJbmZvL1JlZmVyZW5jZUN1cnJlbmN5JywgLy8gVXNlcidzIHJlZmVyZW5jZSBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0luZm8vUmVmZXJlbmNlTGFuZ3VhZ2UnLCAvLyBVcGRhdGUgdXNlcidzIHJlZmVyZW5jZSBsYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0FQSUtleS9BUElLZXkve1B1YmxpY0tleX0nLCAvLyBSZW1vdmUgYW4gQVBJIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JhbmsvVHJhbnNhY3Rpb25zL3tSZXF1ZXN0SUR9JywgLy8gRGVsZXRlIHBlbmRpbmcgYWNjb3VudCB3aXRoZHJhdyBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdCYW5rL1VzZXJBY2NvdW50cy97Q3VycmVuY3l9L3tMYWJlbH0nLCAvLyBEZWxldGUgYW4gYWNjb3VudCBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L0RlcG9zaXRXYWxsZXRzL3tEaWdpQ3VycmVuY3l9L3tBZGRyZXNzTmFtZX0nLCAvLyBEZWxldGUgYW4gZGlnaXRhbCBjdXJyZW5jeSBhZGRyZXNzZXMgcmVsYXRlZCB0byB0aGUgbG9nZ2VkIGluIHVzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9Vc2VyV2FsbGV0cy97RGlnaUN1cnJlbmN5fS97QWRkcmVzc05hbWV9JywgLy8gRGVsZXRlIGFuIGV4dGVybmFsIGRpZ2l0YWwgY3VycmVuY3kgYWRkcmVzc2VzIHJlbGF0ZWQgdG8gdGhlIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlL09yZGVycycsIC8vIENhbmNlbHMgYWxsIGV4aXN0aW5nIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGUvT3JkZXJzL3tPcmRlcklEfScsIC8vIENhbmNlbHMgYW4gZXhpc3Rpbmcgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9TdG9wT3JkZXJzJywgLy8gQ2FuY2VscyBhbGwgZXhpc3Rpbmcgc3RvcCBvcmRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZS9TdG9wT3JkZXJzL3tJRH0nLCAvLyBDYW5jZWxzIGFuIGV4aXN0aW5nIHN0b3Agb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAwMjUsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMDAzNSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNMaXZlVGlja2VycyAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsndGlja2VycyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2N1cnJlbmN5UGFpciddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRCYWxhbmNlQmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydiYWxhbmNlcyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydhdmFpbGFibGVCYWxhbmNlJ10sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB0aGlzLnN1bSAoXG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbJ3BlbmRpbmdJbmNvbWluZyddLFxuICAgICAgICAgICAgICAgICAgICBiYWxhbmNlWydwZW5kaW5nT3V0Z29pbmcnXSxcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVsnb3Blbk9yZGVyJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VbJ2JhbGFuY2UnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNNYXJrZXREZXB0aEN1cnJlbmN5UGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAndm9sdW1lJyk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodGlja2VyWydjcmVhdGVEYXRlVGltZSddKSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgYmFzZVZvbHVtZSA9IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pO1xuICAgICAgICBsZXQgdndhcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHZ3YXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB2d2FwLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBiYXNlVm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcXVvdGVWb2x1bWUsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UHVibGljTGl2ZVRpY2tlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gcmVzcG9uc2VbJ3RpY2tlcnMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpY2tlcnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW3RdO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWydjdXJyZW5jeVBhaXInXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNMaXZlVGlja2VyQ3VycmVuY3lQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ0N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsndGlja2VyJ107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG9yZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3dheScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIHNpZGUgPSAodHJhZGVbJ3dheSddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICAgICAgbGV0IG9yZGVySWQgPSB0cmFkZVsnd2F5J10gKyAnT3JkZXJJZCc7XG4gICAgICAgICAgICBvcmRlciA9IHRyYWRlW29yZGVySWRdO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ3RyYW5zYWN0aW9uVGltZSddKSAqIDEwMDA7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeVBhaXInXV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RyYW5zYWN0aW9uSWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsncXVhbnRpdHknXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNUcmFuc2FjdGlvbnNDdXJyZW5jeVBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnQ3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWyd0cmFuc2FjdGlvbnMnXSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcGFyc2VJbnQgKG9obGN2WydjcmVhdGVEYXRlVGltZSddKSAqIDEwMDAsXG4gICAgICAgICAgICBvaGxjdlsnb3BlbiddLFxuICAgICAgICAgICAgb2hsY3ZbJ2hpZ2gnXSxcbiAgICAgICAgICAgIG9obGN2Wydsb3cnXSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9obGN2Wyd2b2x1bWUnXSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdDdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnVGltZWZyYW1lJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ0NvdW50J10gPSBsaW1pdDtcbiAgICAgICAgcmVxdWVzdCA9IHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFB1YmxpY1RpY2tlckhpc3RvcnlDdXJyZW5jeVBhaXJUaW1lZnJhbWUgKHJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2VbJ3RpY2tlcnMnXSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ0NvZGUnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ1dheSc6IChzaWRlID09ICdidXknKSA/ICdCaWQnIDogJ0FzaycsXG4gICAgICAgICAgICAnQW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ1ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgaWYgKHRoaXMudHdvZmEpIHtcbiAgICAgICAgICAgIGlmICgnVmFsaWRhdGlvbkNvZGUnIGluIHBhcmFtcylcbiAgICAgICAgICAgICAgICBvcmRlclsnVmFsaWRhdGlvbkNvZGUnXSA9IHBhcmFtc1snVmFsaWRhdGlvbkNvZGUnXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgdHdvLWZhY3RvciBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIG1pc3NpbmcgVmFsaWRhdGlvbkNvZGUgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlT3JkZXJzICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydjbE9yZGVySWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZURlbGV0ZVRyYWRlT3JkZXJzT3JkZXJJRCAoeyAnT3JkZXJJRCc6IGlkIH0pO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gKG1ldGhvZCA9PSAnR0VUJykgPyAnJyA6ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGxldCBhdXRoID0gbWV0aG9kICsgdXJsICsgY29udGVudFR5cGUgKyBub25jZS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGF1dGggPSBhdXRoLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMjU2JywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQVBJX1BVQkxJQ19LRVknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnQVBJX1JFUVVFU1RfU0lHTkFUVVJFJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICdBUElfUkVRVUVTVF9EQVRFJzogbm9uY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1ldGhvZCAhPSAnR0VUJykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAodGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdyZXNwb25zZVN0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHJlc3BvbnNlWydyZXNwb25zZVN0YXR1cyddKVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsncmVzcG9uc2VTdGF0dXMnXVsnbWVzc2FnZSddID09ICdPSycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBidGVyID0gcmVxdWlyZSAoJy4vYnRlci5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGdhdGVpbyBleHRlbmRzIGJ0ZXIge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2dhdGVpbycsXG4gICAgICAgICAgICAnbmFtZSc6ICdHYXRlLmlvJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMTc4NDAyOS0wMzEzYzcwMi1iNTA5LTExZTctOWNjYy1iYzBkYTZhMGU0MzUuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vZGF0YS5nYXRlLmlvL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vZGF0YS5nYXRlLmlvL2FwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vZ2F0ZS5pby8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9nYXRlLmlvL2FwaTInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW52YWxpZE9yZGVyLCBBdXRoZW50aWNhdGlvbkVycm9yLCBOb3RTdXBwb3J0ZWQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGdkYXggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnZ2RheCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdHREFYJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndXNlckFnZW50JzogdGhpcy51c2VyQWdlbnRzWydjaHJvbWUnXSxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNEZXBvc2l0JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hDbG9zZWRPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFtJzogNjAsXG4gICAgICAgICAgICAgICAgJzVtJzogMzAwLFxuICAgICAgICAgICAgICAgICcxNW0nOiA5MDAsXG4gICAgICAgICAgICAgICAgJzMwbSc6IDE4MDAsXG4gICAgICAgICAgICAgICAgJzFoJzogMzYwMCxcbiAgICAgICAgICAgICAgICAnMmgnOiA3MjAwLFxuICAgICAgICAgICAgICAgICc0aCc6IDE0NDAwLFxuICAgICAgICAgICAgICAgICcxMmgnOiA0MzIwMCxcbiAgICAgICAgICAgICAgICAnMWQnOiA4NjQwMCxcbiAgICAgICAgICAgICAgICAnMXcnOiA2MDQ4MDAsXG4gICAgICAgICAgICAgICAgJzFNJzogMjU5MjAwMCxcbiAgICAgICAgICAgICAgICAnMXknOiAzMTUzNjAwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAndGVzdCc6ICdodHRwczovL2FwaS1wdWJsaWMuc2FuZGJveC5nZGF4LmNvbScsXG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjUyNy1iMWJlNDFjNi01ZWRiLTExZTctOTVmNi01YjQ5NmM0NjllMmMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmdkYXguY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmdkYXguY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vZG9jcy5nZGF4LmNvbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVuY2llcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZHVjdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb2R1Y3RzL3tpZH0vYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfS9jYW5kbGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9kdWN0cy97aWR9L3N0YXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9kdWN0cy97aWR9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpbWUnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRzL3tpZH0vaG9sZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRzL3tpZH0vbGVkZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2luYmFzZS1hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmlsbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQtbWV0aG9kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcG9ydHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcnMvc2VsZi90cmFpbGluZy12b2x1bWUnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0cy9jb2luYmFzZS1hY2NvdW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0cy9wYXltZW50LW1ldGhvZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZGluZy9yZXBheScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbi9jbG9zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZmlsZXMvbWFyZ2luLXRyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXBvcnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2Fscy9jb2luYmFzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMvY3J5cHRvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2Fscy9wYXltZW50LW1ldGhvZCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RpZXJCYXNlZCc6IHRydWUsIC8vIGNvbXBsaWNhdGVkIHRpZXIgc3lzdGVtIHBlciBjb2luXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjMwIC8gMTAwLCAvLyB3b3JzdC1jYXNlIHNjZW5hcmlvOiBodHRwczovL3d3dy5nZGF4LmNvbS9mZWVzL0JUQy1VU0RcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVVInOiAwLjE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VTRCc6IDI1LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVVInOiAwLjE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VTRCc6IDEwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJvZHVjdHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydiYXNlX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IGFtb3VudExpbWl0cyA9IHtcbiAgICAgICAgICAgICAgICAnbWluJzogbWFya2V0WydiYXNlX21pbl9zaXplJ10sXG4gICAgICAgICAgICAgICAgJ21heCc6IG1hcmtldFsnYmFzZV9tYXhfc2l6ZSddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwcmljZUxpbWl0cyA9IHtcbiAgICAgICAgICAgICAgICAnbWluJzogbWFya2V0WydxdW90ZV9pbmNyZW1lbnQnXSxcbiAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBjb3N0TGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiBwcmljZUxpbWl0c1snbWluJ10sXG4gICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgbGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnRMaW1pdHMsXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2VMaW1pdHMsXG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0TGltaXRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IC1NYXRoLmxvZzEwIChwYXJzZUZsb2F0IChhbW91bnRMaW1pdHNbJ21pbiddKSksXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogLU1hdGgubG9nMTAgKHBhcnNlRmxvYXQgKHByaWNlTGltaXRzWydtaW4nXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCB0YWtlciA9IHRoaXMuZmVlc1sndHJhZGluZyddWyd0YWtlciddO1xuICAgICAgICAgICAgaWYgKChiYXNlID09ICdFVEgnKSB8fCAoYmFzZSA9PSAnTFRDJykpIHtcbiAgICAgICAgICAgICAgICB0YWtlciA9IDAuMDAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IGxpbWl0cyxcbiAgICAgICAgICAgICAgICAndGFrZXInOiB0YWtlcixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWNjb3VudHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2hvbGQnXSksXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJvZHVjdHNJZEJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2xldmVsJzogMiwgLy8gMSBiZXN0IGJpZGFzaywgMiBhZ2dyZWdhdGVkLCAzIGZ1bGxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkVGlja2VyIChyZXF1ZXN0KTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0aWNrZXJbJ3RpbWUnXSk7XG4gICAgICAgIGxldCBiaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBhc2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnYmlkJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICBiaWQgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKTtcbiAgICAgICAgaWYgKCdhc2snIGluIHRpY2tlcilcbiAgICAgICAgICAgIGFzayA9IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogYmlkLFxuICAgICAgICAgICAgJ2Fzayc6IGFzayxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdwcmljZScpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWyd0aW1lJ10pO1xuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsnc2lkZSddID09ICdidXknKSA/ICdzZWxsJyA6ICdidXknO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdmaWxsX2ZlZXMnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBwYXJzZUZsb2F0ICh0cmFkZVsnZmlsbF9mZWVzJ10pLFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFkZV9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ3NpemUnXSksXG4gICAgICAgICAgICAnZmVlJzogZmVlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFByb2R1Y3RzSWRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sIC8vIGZpeGVzIGlzc3VlICMyXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WzBdICogMTAwMCxcbiAgICAgICAgICAgIG9obGN2WzNdLFxuICAgICAgICAgICAgb2hsY3ZbMl0sXG4gICAgICAgICAgICBvaGxjdlsxXSxcbiAgICAgICAgICAgIG9obGN2WzRdLFxuICAgICAgICAgICAgb2hsY3ZbNV0sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGdyYW51bGFyaXR5ID0gdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV07XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2dyYW51bGFyaXR5JzogZ3JhbnVsYXJpdHksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaW5jZSkge1xuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnQnXSA9IHRoaXMuaXNvODYwMSAoc2luY2UpO1xuICAgICAgICAgICAgaWYgKCFsaW1pdClcbiAgICAgICAgICAgICAgICBsaW1pdCA9IDIwMDsgLy8gbWF4ID0gMjAwXG4gICAgICAgICAgICByZXF1ZXN0WydlbmQnXSA9IHRoaXMuaXNvODYwMSAobGltaXQgKiBncmFudWxhcml0eSAqIDEwMDAgKyBzaW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkQ2FuZGxlcyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGltZSAoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucHVibGljR2V0VGltZSAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2U4NjAxIChyZXNwb25zZVsnaXNvJ10pO1xuICAgIH1cblxuICAgIGdldE9yZGVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICAgICAgbGV0IHN0YXR1c2VzID0ge1xuICAgICAgICAgICAgJ3BlbmRpbmcnOiAnb3BlbicsXG4gICAgICAgICAgICAnYWN0aXZlJzogJ29wZW4nLFxuICAgICAgICAgICAgJ29wZW4nOiAnb3BlbicsXG4gICAgICAgICAgICAnZG9uZSc6ICdjbG9zZWQnLFxuICAgICAgICAgICAgJ2NhbmNlbGVkJzogJ2NhbmNlbGVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVN0cmluZyAoc3RhdHVzZXMsIHN0YXR1cywgc3RhdHVzKTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob3JkZXJbJ2NyZWF0ZWRfYXQnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KSB7XG4gICAgICAgICAgICBpZiAob3JkZXJbJ3Byb2R1Y3RfaWQnXSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW29yZGVyWydwcm9kdWN0X2lkJ11dO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0dXMgPSB0aGlzLmdldE9yZGVyU3RhdHVzIChvcmRlclsnc3RhdHVzJ10pO1xuICAgICAgICBsZXQgcHJpY2UgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdwcmljZScpO1xuICAgICAgICBsZXQgYW1vdW50ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnc2l6ZScpO1xuICAgICAgICBsZXQgZmlsbGVkID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnZmlsbGVkX3NpemUnKTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IGFtb3VudCAtIGZpbGxlZDtcbiAgICAgICAgbGV0IGNvc3QgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdleGVjdXRlZF92YWx1ZScpO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogb3JkZXJbJ3R5cGUnXSxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcmRlcnNJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3RhdHVzJzogJ2FsbCcsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsncHJvZHVjdF9pZCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3Byb2R1Y3RfaWQnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcmRlcnMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzdGF0dXMnOiAnZG9uZScsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsncHJvZHVjdF9pZCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAobWFya2V0LCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICAvLyBsZXQgb2lkID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3Byb2R1Y3RfaWQnOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3NpemUnOiBhbW91bnQsXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJzICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlRGVsZXRlT3JkZXJzSWQgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0UGF5bWVudE1ldGhvZHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRQYXltZW50TWV0aG9kcyAoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGFzeW5jIGRlcG9zaXQgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0RGVwb3NpdHMnO1xuICAgICAgICBpZiAoJ3BheW1lbnRfbWV0aG9kX2lkJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIGRlcG9zaXQgZnJvbSBhIHBheW1lbnRfbWV0aG9kLCBsaWtlIGEgYmFuayBhY2NvdW50XG4gICAgICAgICAgICBtZXRob2QgKz0gJ1BheW1lbnRNZXRob2QnO1xuICAgICAgICB9IGVsc2UgaWYgKCdjb2luYmFzZV9hY2NvdW50X2lkJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIGRlcG9zaXQgaW50byBHREFYIGFjY291bnQgZnJvbSBhIENvaW5iYXNlIGFjY291bnRcbiAgICAgICAgICAgIG1ldGhvZCArPSAnQ29pbmJhc2VBY2NvdW50JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlcG9zaXQgbWV0aG9kb3RoZXJ3aXNlIHdlIGRpZCBub3QgcmVjZWl2ZSBhIHN1cHBvcnRlZCBkZXBvc2l0IGxvY2F0aW9uXG4gICAgICAgICAgICAvLyByZWxldmFudCBkb2NzIGxpbmsgZm9yIHRoZSBHb29nbGVyc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmdkYXguY29tLyNkZXBvc2l0c1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZGVwb3NpdCgpIHJlcXVpcmVzIG9uZSBvZiBgY29pbmJhc2VfYWNjb3VudF9pZGAgb3IgYHBheW1lbnRfbWV0aG9kX2lkYCBleHRyYSBwYXJhbXMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBkZXBvc2l0KCkgZXJyb3I6ICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0V2l0aGRyYXdhbHMnO1xuICAgICAgICBpZiAoJ3BheW1lbnRfbWV0aG9kX2lkJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnUGF5bWVudE1ldGhvZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2NvaW5iYXNlX2FjY291bnRfaWQnIGluIHBhcmFtcykge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdDb2luYmFzZUFjY291bnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdDcnlwdG8nO1xuICAgICAgICAgICAgcmVxdWVzdFsnY3J5cHRvX2FkZHJlc3MnXSA9IGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgd2l0aGRyYXcoKSBlcnJvcjogJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChtZXRob2QgPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXF1ZXN0ICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyByZXF1ZXN0O1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IHBheWxvYWQgPSAnJztcbiAgICAgICAgICAgIGlmIChtZXRob2QgIT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gYm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsZXQgcGF5bG9hZCA9IChib2R5KSA/IGJvZHkgOiAnJztcbiAgICAgICAgICAgIGxldCB3aGF0ID0gbm9uY2UgKyBtZXRob2QgKyByZXF1ZXN0ICsgcGF5bG9hZDtcbiAgICAgICAgICAgIGxldCBzZWNyZXQgPSB0aGlzLmJhc2U2NFRvQmluYXJ5ICh0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAod2hhdCksIHNlY3JldCwgJ3NoYTI1NicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NCLUFDQ0VTUy1LRVknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnQ0ItQUNDRVNTLVNJR04nOiB0aGlzLmRlY29kZSAoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgICAgICAnQ0ItQUNDRVNTLVRJTUVTVEFNUCc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdDQi1BQ0NFU1MtUEFTU1BIUkFTRSc6IHRoaXMucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGNvZGUgPT0gNDAwKSB7XG4gICAgICAgICAgICBpZiAoYm9keVswXSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IEpTT04ucGFyc2UgKGJvZHkpO1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gcmVzcG9uc2VbJ21lc3NhZ2UnXTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5pbmRleE9mICgncHJpY2UgdG9vIHNtYWxsJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyAnICsgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmluZGV4T2YgKCdwcmljZSB0b28gcHJlY2lzZScpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcmRlciAodGhpcy5pZCArICcgJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZSA9PSAnSW52YWxpZCBBUEkgS2V5Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgYm9keSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGdlbWluaSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdnZW1pbmknLFxuICAgICAgICAgICAgJ25hbWUnOiAnR2VtaW5pJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsIC8vIDIwMCBmb3IgcHJpdmF0ZSBBUElcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3ODE2ODU3LWNlN2JlNjQ0LTYwOTYtMTFlNy04MmQ2LTNjMjU3MjYzMjI5Yy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuZ2VtaW5pLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2dlbWluaS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kb2NzLmdlbWluaS5jb20vcmVzdC1hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwdWJ0aWNrZXIve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXVjdGlvbi97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXVjdGlvbi97c3ltYm9sfS9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9uZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsL3Nlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbC9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL3N0YXR1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdteXRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGV2b2x1bWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0L3tjdXJyZW5jeX0vbmV3QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVhcnRiZWF0JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFN5bWJvbHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IGlkO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IG1hcmtldC50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdXBwZXJjYXNlLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHVwcGVyY2FzZS5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAndGFrZXInOiAwLjAwMjVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0Qm9va1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ2Ftb3VudCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0UHVidGlja2VyU3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3ZvbHVtZSddWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSBtYXJrZXRbJ2Jhc2UnXTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gbWFya2V0WydxdW90ZSddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXVtiYXNlVm9sdW1lXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddW3F1b3RlVm9sdW1lXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsndGltZXN0YW1wbXMnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudCddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY2xpZW50X29yZGVyX2lkJzogbm9uY2UudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICd0eXBlJzogJ2V4Y2hhbmdlIGxpbWl0JywgLy8gZ2VtaW5pIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJOZXcgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyX2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ29yZGVyX2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAncmVxdWVzdCc6IHVybCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KTtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gdGhpcy5qc29uIChyZXF1ZXN0KTtcbiAgICAgICAgICAgIHBheWxvYWQgPSB0aGlzLnN0cmluZ1RvQmFzZTY0ICh0aGlzLmVuY29kZSAocGF5bG9hZCkpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAocGF5bG9hZCwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTM4NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgICAgICdYLUdFTUlOSS1BUElLRVknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnWC1HRU1JTkktUEFZTE9BRCc6IHRoaXMuZGVjb2RlIChwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAnWC1HRU1JTkktU0lHTkFUVVJFJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgdXJsO1xuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddID09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IF8xYnRjeGUgPSByZXF1aXJlICgnLi9fMWJ0Y3hlLmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgZ2V0YnRjIGV4dGVuZHMgXzFidGN4ZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnZ2V0YnRjJyxcbiAgICAgICAgICAgICduYW1lJzogJ0dldEJUQycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnVkMnLCAnUlUnIF0sIC8vIFNhaW50IFZpbmNlbnQgYW5kIHRoZSBHcmVuYWRpbmVzLCBSdXNzaWEsIENJU1xuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMzODAxOTAyLTAzYzQzNDYyLWRkN2ItMTFlNy05OTJlLTA3N2U0Y2QwMTViOS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9nZXRidGMub3JnL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2dldGJ0Yy5vcmcnLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9nZXRidGMub3JnL2FwaS1kb2NzLnBocCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdFVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDgsICdwcmljZSc6IDggfSwgJ2xvdCc6IDAuMDAwMDAwMDEsICdsaW1pdHMnOiB7ICdhbW91bnQnOiB7ICdtaW4nOiAwLjAwMDAwMDAxLCAnbWF4JzogdW5kZWZpbmVkIH0sICdwcmljZSc6IHsgJ21pbic6IDAuMDAwMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfX19LFxuICAgICAgICAgICAgICAgICdCVEMvUlVCJzogeyAnaWQnOiAnUlVCJywgJ3N5bWJvbCc6ICdCVEMvUlVCJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1JVQicsICdwcmVjaXNpb24nOiB7ICdhbW91bnQnOiA4LCAncHJpY2UnOiA4IH0sICdsb3QnOiAwLjAwMDAwMDAxLCAnbGltaXRzJzogeyAnYW1vdW50JzogeyAnbWluJzogMC4wMDAwMDAwMSwgJ21heCc6IHVuZGVmaW5lZCB9LCAncHJpY2UnOiB7ICdtaW4nOiAwLjAwMDAwMDAxLCAnbWF4JzogdW5kZWZpbmVkIH19fSxcbiAgICAgICAgICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ1VTRCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnLCAncHJlY2lzaW9uJzogeyAnYW1vdW50JzogOCwgJ3ByaWNlJzogOCB9LCAnbG90JzogMC4wMDAwMDAwMSwgJ2xpbWl0cyc6IHsgJ2Ftb3VudCc6IHsgJ21pbic6IDAuMDAwMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfSwgJ3ByaWNlJzogeyAnbWluJzogMC4wMDAwMDAwMSwgJ21heCc6IHVuZGVmaW5lZCB9fX0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMjAgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMjAgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgaGl0YnRjIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2hpdGJ0YycsXG4gICAgICAgICAgICAnbmFtZSc6ICdIaXRCVEMnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdISycsIC8vIEhvbmcgS29uZ1xuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICcxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NTU1LThlYWVjMjBlLTVlZGMtMTFlNy05YzViLTZkYzY5ZmM0MmY1ZS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cDovL2FwaS5oaXRidGMuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vaGl0YnRjLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2dpdGh1Yi5jb20vaGl0YnRjLWNvbS9oaXRidGMtYXBpL2Jsb2IvbWFzdGVyL0FQSXYxLm1kJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAne3N5bWJvbH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7c3ltYm9sfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tzeW1ib2x9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne3N5bWJvbH0vdHJhZGVzL3JlY2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3ltYm9scycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aW1lLCdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy9hY3RpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy9yZWNlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMvYnkvb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25ld19vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYXltZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3Mve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMve3RyYW5zYWN0aW9ufScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZmVyX3RvX3RyYWRpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZmVyX3RvX21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3Mve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5b3V0JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogLTAuMDEgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMSAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLjAwMDcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRIJzogMC4wMDk1OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQ0gnOiAwLjAwMTgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVVNEVCc6IDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRHJzogMC4wMDA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xUQyc6IDAuMDAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pFQyc6IDAuMDAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYTVInOiAwLjA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJzFTVCc6IDAuODQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQURYJzogNS43LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FFJzogNi43LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FFT04nOiAwLjAxMDA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FJUic6IDU2NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBTVAnOiA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FOVCc6IDYuNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBUkRSJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdBUk4nOiAxOC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FSVCc6IDI2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FUQic6IDAuMDAwNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBVEwnOiAyNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBVE0nOiA1MDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVRTJzogODYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FWVCc6IDEuOSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQVMnOiAxMTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkNOJzogMC4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JFVCc6IDEyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCS0InOiA0NixcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTUMnOiAzMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTVQnOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQk5UJzogMi41NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCUVgnOiA0LjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRNJzogNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRYJzogMC4wNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVVMnOiAwLjAwNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDQ1QnOiAxMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ0RUJzogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NEWCc6IDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NGSSc6IDYxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NMRCc6IDAuODgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ05EJzogNTc0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NOWCc6IDAuMDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ09TUyc6IDY1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NTTk8nOiAxNixcbiAgICAgICAgICAgICAgICAgICAgICAgICdDVFInOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDVFgnOiAxNDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ1ZDJzogOC40NixcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQklYJzogMC4wMTY4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RDTic6IDEyMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQ1QnOiAwLjAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RERic6IDM0MixcbiAgICAgICAgICAgICAgICAgICAgICAgICdERU5UJzogNjI0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdER0InOiAwLjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnREdEJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdESUNFJzogMC4zMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdETFQnOiAwLjI2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ROVCc6IDAuMjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE9HRSc6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE9WJzogMzQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRFJQVSc6IDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RSVCc6IDI0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEU0gnOiAwLjAxNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQkVUJzogODQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUJUQyc6IDIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VCVENPTEQnOiA2LjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUNBVCc6IDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VERyc6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRURPJzogMi45LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VMRSc6IDAuMDAxNzIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUxNJzogMC4wMDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU1DJzogMC4wMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTUdPJzogMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5KJzogMTYzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VPUyc6IDEuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFUk8nOiAzNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEJTJzogMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRDJzogMC4wMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRQJzogMC4wMDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVZYJzogNS40LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VYTic6IDQ1NixcbiAgICAgICAgICAgICAgICAgICAgICAgICdGUkQnOiA2NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdGVUVMJzogMTIzLjAwMTA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZVTic6IDIwMi45NTk4MzA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZZTic6IDEuODQ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZZUCc6IDY2LjEzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dOTyc6IDAuMDAzNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHVVAnOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dWVCc6IDEuMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdIQUMnOiAxNDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSERHJzogNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdIR1QnOiAxMDgyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hQQyc6IDAuNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdIVk4nOiAxMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSUNOJzogMC41NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJQ08nOiAzNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJQ09TJzogMC4zNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJTkQnOiA3NixcbiAgICAgICAgICAgICAgICAgICAgICAgICdJTkRJJzogNTkxMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJVFMnOiAxNS4wMDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lYVCc6IDExLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0tCUic6IDE0MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdLSUNLJzogMTEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xBJzogNDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTEFUJzogMS40NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMSUZFJzogMTMwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFJDJzogMjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFNLJzogMC4zLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xVTic6IDAuMzQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTUFJRCc6IDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTUFOQSc6IDE0MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQ0FQJzogNS40NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNSVBTJzogNDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTU5FJzogMS4zMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNU1AnOiAxMjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTVRIJzogOTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTVlCJzogMy45LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05EQyc6IDE2NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdORUJMJzogMC4wNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdORVQnOiAzLjk2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05UTyc6IDk5OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdOWEMnOiAxMy4zOSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdOWFQnOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09BWCc6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09ETic6IDAuMDA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09NRyc6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT1BUJzogMzM1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09STUUnOiAyLjgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT1ROJzogMC41NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQQVknOiAzLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUElYJzogOTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUExCVCc6IDAuMzMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUExSJzogMTE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BMVSc6IDAuODcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUE9FJzogNzg0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BPTEwnOiAzLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFBUJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUkUnOiAzMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUkcnOiAzOSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUk8nOiA0MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUlMnOiA2MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQVE9ZJzogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1FBVSc6IDYzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1FDTic6IDAuMDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVRVTSc6IDAuMDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVZUJzogNjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUkVQJzogMC4wMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdSS0MnOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSVlQnOiAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTQU4nOiAyLjI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NCRCc6IDAuMDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0NMJzogMi42LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NJU0EnOiAxNjQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NLSU4nOiA0MDcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU01BUlQnOiAwLjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU01TJzogMC4wMzc1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOQyc6IDM2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOR0xTJzogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTk0nOiA0OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTlQnOiAyMzMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1RFRU0nOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NUUkFUJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVFUnOiAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVFgnOiAxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVUInOiAxNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVVInOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NXVCc6IDAuNTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVEFBUyc6IDAuOTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVEJUJzogMi4zNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdURkwnOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUSU1FJzogMC4wMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUSVgnOiA3LjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVEtOJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUS1InOiA4NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUTlQnOiA5MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUUlNUJzogMS42LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RSWCc6IDEzOTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVUVUJzogNDgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VHVCc6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZFTic6IDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZFUkknOiAwLjAzNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdWSUInOiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdWSUJFJzogMTQ1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZPSVNFJzogNjE4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dFQUxUSCc6IDAuMDE2OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXSU5HUyc6IDIuNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXVEMnOiAwLjc1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hBVVInOiAzLjIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hETic6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWEVNJzogMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWFVDJzogMC45LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1lPWU9XJzogMTQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pBUCc6IDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pSWCc6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pTQyc6IDE5MSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JDSCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVVNEVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRHJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pFQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWE1SJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICcxU1QnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FEWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQUUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FFT04nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FJUic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQU1QJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBTlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FSRFInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FSTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVJUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBVEInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FUTCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVRNJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBVFMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FWVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkFTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQ04nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JFVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQktCJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTUMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JNVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQk5UJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCUVgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUTSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVVMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NDVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ0RUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDRFgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NGSSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ0xEJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDTkQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NOWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ09TUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ1NOTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ1RSJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDVFgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NWQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnREJJWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRENOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQ1QnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RERic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnREVOVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnREdCJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdER0QnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RJQ0UnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RMVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE5UJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdET0dFJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdET1YnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RSUFUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RSVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRFNIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQkVUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQlRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQlRDT0xEJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQ0FUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFREcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VETyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUxFJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTE0nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VNQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU1HTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU5KJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFT1MnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VSTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRCUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVFAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VWWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVhOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdGUkQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZVRUwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZVTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRllOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdGWVAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dOTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR1VQJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHVlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hBQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSERHJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdIR1QnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hQQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSFZOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJQ04nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lDTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSUNPUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSU5EJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJTkRJJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJVFMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lYVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnS0JSJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdLSUNLJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMQSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTEFUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMSUZFJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMUkMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xTSyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFVOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQUlEJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQU5BJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQ0FQJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNSVBTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNTkUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01TUCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTVRIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNWUInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05EQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTkVCTCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTkVUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdOVE8nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05YQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTlhUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPQVgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09ETic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT01HJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPUFQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09STUUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09UTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUEFZJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQSVgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BMQlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BMUic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUExVJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQT0UnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BPTEwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BQVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFJFJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUkcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BSTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFJTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQVE9ZJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdRQVUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1FDTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVRVTSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUVZUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSRVAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JLQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUlZUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTQU4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NCRCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0NMJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTSVNBJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTS0lOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTUFSVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU01TJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTkMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOR0xTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTk0nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1RFRU0nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NUUkFUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVFUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NUWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1VCJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVVInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NXVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVEFBUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVEJUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdURkwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RJTUUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RJWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVEtOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUS1InOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ROVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVFJTVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVFJYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVRVQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VHVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVkVOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdWRVJJJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdWSUInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZJQkUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZPSVNFJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXRUFMVEgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dJTkdTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hBVVInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hETic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWEVNJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYVUMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1lPWU9XJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdaQVAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pSWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWlNDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1hCVCcpXG4gICAgICAgICAgICByZXR1cm4gJ0JUQyc7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRFJLJylcbiAgICAgICAgICAgIHJldHVybiAnREFTSCc7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQ0FUJylcbiAgICAgICAgICAgIHJldHVybiAnQml0Q2xhdmUnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFN5bWJvbHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWydzeW1ib2xzJ10ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzWydzeW1ib2xzJ11bcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2NvbW1vZGl0eSddO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0WydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGxvdCA9IHBhcnNlRmxvYXQgKG1hcmtldFsnbG90J10pO1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ3N0ZXAnXSk7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2xvdCc6IGxvdCxcbiAgICAgICAgICAgICAgICAnc3RlcCc6IHN0ZXAsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHRoaXMucHJlY2lzaW9uRnJvbVN0cmluZyAobWFya2V0Wydsb3QnXSksXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHRoaXMucHJlY2lzaW9uRnJvbVN0cmluZyAobWFya2V0WydzdGVwJ10pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogc3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gdGhpcy5zYWZlU3RyaW5nIChwYXJhbXMsICd0eXBlJywgJ3RyYWRpbmcnKTtcbiAgICAgICAgbWV0aG9kICs9ICdHZXRCYWxhbmNlJztcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsICd0eXBlJyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAocXVlcnkpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnYmFsYW5jZSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY29kZSA9IGJhbGFuY2VbJ2N1cnJlbmN5X2NvZGUnXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChjb2RlKTtcbiAgICAgICAgICAgIGxldCBmcmVlID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2UsICdjYXNoJywgMC4wKTtcbiAgICAgICAgICAgIGZyZWUgPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZSwgJ2JhbGFuY2UnLCBmcmVlKTtcbiAgICAgICAgICAgIGxldCB1c2VkID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2UsICdyZXNlcnZlZCcsIDAuMCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZyZWUsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB1c2VkLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRoaXMuc3VtIChmcmVlLCB1c2VkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0U3ltYm9sT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ107XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdoaWdoJyksXG4gICAgICAgICAgICAnbG93JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xvdycpLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdiaWQnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXNrJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ29wZW4nKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sdW1lJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sdW1lX3F1b3RlJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0U3ltYm9sVGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gdGlja2VyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aWNrZXJbJ21lc3NhZ2UnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWzBdLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRyYWRlWzNdLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0cmFkZVszXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVs0XSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWzFdKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsyXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0U3ltYm9sVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgIC8vICdmcm9tJzogMCxcbiAgICAgICAgICAgIC8vICd0aWxsJzogMTAwLFxuICAgICAgICAgICAgLy8gJ2J5JzogJ3RzJywgLy8gb3IgYnkgdHJhZGVfaWRcbiAgICAgICAgICAgIC8vICdzb3J0JzogJ2Rlc2MnLCAvLyBvciBhc2NcbiAgICAgICAgICAgIC8vICdzdGFydF9pbmRleCc6IDAsXG4gICAgICAgICAgICAvLyAnbWF4X3Jlc3VsdHMnOiAxMDAwLFxuICAgICAgICAgICAgLy8gJ2Zvcm1hdF9pdGVtJzogJ29iamVjdCcsXG4gICAgICAgICAgICAvLyAnZm9ybWF0X3ByaWNlJzogJ251bWJlcicsXG4gICAgICAgICAgICAvLyAnZm9ybWF0X2Ftb3VudCc6ICdudW1iZXInLFxuICAgICAgICAgICAgLy8gJ2Zvcm1hdF90aWQnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIC8vICdmb3JtYXRfdGltZXN0YW1wJzogJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgIC8vICdmb3JtYXRfd3JhcCc6IGZhbHNlLFxuICAgICAgICAgICAgJ3NpZGUnOiAndHJ1ZScsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAvLyBjaGVjayBpZiBhbW91bnQgY2FuIGJlIGV2ZW5seSBkaXZpZGVkIGludG8gbG90c1xuICAgICAgICAvLyB0aGV5IHdhbnQgaW50ZWdlciBxdWFudGl0eSBpbiBsb3QgdW5pdHNcbiAgICAgICAgbGV0IHF1YW50aXR5ID0gcGFyc2VGbG9hdCAoYW1vdW50KSAvIG1hcmtldFsnbG90J107XG4gICAgICAgIGxldCB3aG9sZUxvdHMgPSBNYXRoLnJvdW5kIChxdWFudGl0eSk7XG4gICAgICAgIGxldCBkaWZmZXJlbmNlID0gcXVhbnRpdHkgLSB3aG9sZUxvdHM7XG4gICAgICAgIGlmIChNYXRoLmFicyAoZGlmZmVyZW5jZSkgPiBtYXJrZXRbJ3N0ZXAnXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBvcmRlciBhbW91bnQgc2hvdWxkIGJlIGV2ZW5seSBkaXZpc2libGUgYnkgbG90IHVuaXQgc2l6ZSBvZiAnICsgbWFya2V0Wydsb3QnXS50b1N0cmluZyAoKSk7XG4gICAgICAgIGxldCBjbGllbnRPcmRlcklkID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjbGllbnRPcmRlcklkJzogY2xpZW50T3JkZXJJZC50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncXVhbnRpdHknOiB3aG9sZUxvdHMudG9TdHJpbmcgKCksIC8vIHF1YW50aXR5IGluIGludGVnZXIgbG90IHVuaXRzXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gdGhpcy5wcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyWyd0aW1lSW5Gb3JjZSddID0gJ0ZPSyc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFkaW5nUG9zdE5ld09yZGVyICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydFeGVjdXRpb25SZXBvcnQnXVsnY2xpZW50T3JkZXJJZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFkaW5nUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NsaWVudE9yZGVySWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgZ2V0T3JkZXJTdGF0dXMgKHN0YXR1cykge1xuICAgICAgICBsZXQgc3RhdHVzZXMgPSB7XG4gICAgICAgICAgICAnbmV3JzogJ29wZW4nLFxuICAgICAgICAgICAgJ3BhcnRpYWxseUZpbGxlZCc6ICdvcGVuJyxcbiAgICAgICAgICAgICdmaWxsZWQnOiAnY2xvc2VkJyxcbiAgICAgICAgICAgICdjYW5jZWxlZCc6ICdjYW5jZWxlZCcsXG4gICAgICAgICAgICAncmVqZWN0ZWQnOiAncmVqZWN0ZWQnLFxuICAgICAgICAgICAgJ2V4cGlyZWQnOiAnZXhwaXJlZCcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVTdHJpbmcgKHN0YXR1c2VzLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlclsnbGFzdFRpbWVzdGFtcCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbb3JkZXJbJ3N5bWJvbCddXTtcbiAgICAgICAgbGV0IHN0YXR1cyA9IHRoaXMuc2FmZVN0cmluZyAob3JkZXIsICdvcmRlclN0YXR1cycpO1xuICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgc3RhdHVzID0gdGhpcy5nZXRPcmRlclN0YXR1cyAoc3RhdHVzKTtcbiAgICAgICAgbGV0IGF2ZXJhZ2VQcmljZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2F2Z1ByaWNlJywgMC4wKTtcbiAgICAgICAgbGV0IHByaWNlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnb3JkZXJQcmljZScpO1xuICAgICAgICBsZXQgYW1vdW50ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnb3JkZXJRdWFudGl0eScpO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAncXVhbnRpdHlMZWF2ZXMnKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBhbW91bnQgKj0gbWFya2V0Wydsb3QnXTtcbiAgICAgICAgICAgIHJlbWFpbmluZyAqPSBtYXJrZXRbJ2xvdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbW91bnQgJiYgcmVtYWluaW5nKSB7XG4gICAgICAgICAgICBmaWxsZWQgPSBhbW91bnQgLSByZW1haW5pbmc7XG4gICAgICAgICAgICBjb3N0ID0gYXZlcmFnZVByaWNlICogZmlsbGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnY2xpZW50T3JkZXJJZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogb3JkZXJbJ3R5cGUnXSxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYWRpbmdHZXRPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjbGllbnRPcmRlcklkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyIChyZXNwb25zZVsnb3JkZXJzJ11bMF0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBzdGF0dXNlcyA9IFsgJ25ldycsICdwYXJ0aWFsbHlGaWlsZWQnIF07XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3NvcnQnOiAnZGVzYycsXG4gICAgICAgICAgICAnc3RhdHVzZXMnOiBzdGF0dXNlcy5qb2luICgnLCcpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N5bWJvbHMnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYWRpbmdHZXRPcmRlcnNBY3RpdmUgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydvcmRlcnMnXSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0YXR1c2VzID0gWyAnZmlsbGVkJywgJ2NhbmNlbGVkJywgJ3JlamVjdGVkJywgJ2V4cGlyZWQnIF07XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3NvcnQnOiAnZGVzYycsXG4gICAgICAgICAgICAnc3RhdHVzZXMnOiBzdGF0dXNlcy5qb2luICgnLCcpLFxuICAgICAgICAgICAgJ21heF9yZXN1bHRzJzogMTAwMCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydzeW1ib2xzJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFkaW5nR2V0T3JkZXJzUmVjZW50ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZVsnb3JkZXJzJ10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wYXltZW50UG9zdFBheW91dCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9jb2RlJzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsndHJhbnNhY3Rpb24nXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSAnLycgKyAnYXBpJyArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIGFwaSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcGF5bG9hZCA9IHsgJ25vbmNlJzogbm9uY2UsICdhcGlrZXknOiB0aGlzLmFwaUtleSB9O1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmV4dGVuZCAocGF5bG9hZCwgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJylcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBheWxvYWQpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB1cmw7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgYXV0aCArPSBib2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdYLVNpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJykudG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmw7XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnY29kZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICgnRXhlY3V0aW9uUmVwb3J0JyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnRXhlY3V0aW9uUmVwb3J0J11bJ29yZGVyUmVqZWN0UmVhc29uJ10gPT0gJ29yZGVyRXhjZWVkc0xpbWl0JylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgaGl0YnRjID0gcmVxdWlyZSAoJy4vaGl0YnRjJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgT3JkZXJOb3RGb3VuZCwgSW5zdWZmaWNpZW50RnVuZHMgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgaGl0YnRjMiBleHRlbmRzIGhpdGJ0YyB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnaGl0YnRjMicsXG4gICAgICAgICAgICAnbmFtZSc6ICdIaXRCVEMgdjInLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdISycsIC8vIEhvbmcgS29uZ1xuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICcyJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG9sZGVyIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hDdXJyZW5jaWVzJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoQ3VycmVuY2llcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAgICAgICAgICcxbSc6ICdNMScsXG4gICAgICAgICAgICAgICAgJzNtJzogJ00zJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnTTUnLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnTTE1JyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJ00zMCcsIC8vIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAnMWgnOiAnSDEnLFxuICAgICAgICAgICAgICAgICc0aCc6ICdINCcsXG4gICAgICAgICAgICAgICAgJzFkJzogJ0QxJyxcbiAgICAgICAgICAgICAgICAnMXcnOiAnRDcnLFxuICAgICAgICAgICAgICAgICcxTSc6ICcxTScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU1NS04ZWFlYzIwZS01ZWRjLTExZTctOWM1Yi02ZGM2OWZjNDJmNWUuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmhpdGJ0Yy5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9oaXRidGMuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYXBpLmhpdGJ0Yy5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2wnLCAvLyBBdmFpbGFibGUgQ3VycmVuY3kgU3ltYm9sc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbC97c3ltYm9sfScsIC8vIEdldCBzeW1ib2wgaW5mb1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5JywgLy8gQXZhaWxhYmxlIEN1cnJlbmNpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeS97Y3VycmVuY3l9JywgLy8gR2V0IGN1cnJlbmN5IGluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLCAvLyBUaWNrZXIgbGlzdCBmb3IgYWxsIHN5bWJvbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve3N5bWJvbH0nLCAvLyBUaWNrZXIgZm9yIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy97c3ltYm9sfScsIC8vIFRyYWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyYm9vay97c3ltYm9sfScsIC8vIE9yZGVyYm9va1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmRsZXMve3N5bWJvbH0nLCAvLyBDYW5kbGVzXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsIC8vIExpc3QgeW91ciBjdXJyZW50IG9wZW4gb3JkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIve2NsaWVudE9yZGVySWR9JywgLy8gR2V0IGEgc2luZ2xlIG9yZGVyIGJ5IGNsaWVudE9yZGVySWRcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkaW5nL2JhbGFuY2UnLCAvLyBHZXQgdHJhZGluZyBiYWxhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZy9mZWUve3N5bWJvbH0nLCAvLyBHZXQgdHJhZGluZyBmZWUgcmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpc3RvcnkvdHJhZGVzJywgLy8gR2V0IGhpc3RvcmljYWwgdHJhZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeS9vcmRlcicsIC8vIEdldCBoaXN0b3JpY2FsIG9yZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpc3Rvcnkvb3JkZXIve2lkfS90cmFkZXMnLCAvLyBHZXQgaGlzdG9yaWNhbCB0cmFkZXMgYnkgc3BlY2lmaWVkIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9iYWxhbmNlJywgLy8gR2V0IG1haW4gYWNjY291bnQgYmFsYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQvdHJhbnNhY3Rpb25zJywgLy8gR2V0IGFjY291bnQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC90cmFuc2FjdGlvbnMve2lkfScsIC8vIEdldCBhY2NvdW50IHRyYW5zYWN0aW9uIGJ5IGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vYWRkcmVzcy97Y3VycmVuY3l9JywgLy8gR2V0IGRlcG9zaXQgY3J5cHJvIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLCAvLyBDcmVhdGUgbmV3IG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vd2l0aGRyYXcnLCAvLyBXaXRoZHJhdyBjcnlwcm9cbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L2NyeXB0by9hZGRyZXNzL3tjdXJyZW5jeX0nLCAvLyBDcmVhdGUgbmV3IGRlcG9zaXQgY3J5cHJvIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L3RyYW5zZmVyJywgLy8gVHJhbnNmZXIgYW1vdW50IHRvIHRyYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci97Y2xpZW50T3JkZXJJZH0nLCAvLyBDcmVhdGUgbmV3IG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vd2l0aGRyYXcve2lkfScsIC8vIENvbW1pdCB3aXRoZHJhdyBjcnlwcm9cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsIC8vIENhbmNlbCBhbGwgb3BlbiBvcmRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci97Y2xpZW50T3JkZXJJZH0nLCAvLyBDYW5jZWwgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L2NyeXB0by93aXRoZHJhdy97aWR9JywgLy8gUm9sbGJhY2sgd2l0aGRyYXcgY3J5cHJvXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwYXRjaCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci97Y2xpZW50T3JkZXJJZH0nLCAvLyBDYW5jZWwgUmVwbGFjZSBvcmRlclxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAtMC4wMSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4xIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0JUQyc6IDAuMDAwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLjAwOTU4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JDSCc6IDAuMDAxOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVU0RUJzogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEcnOiAwLjAwMDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFRDJzogMC4wMDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWkVDJzogMC4wMDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hNUic6IDAuMDksXG4gICAgICAgICAgICAgICAgICAgICAgICAnMVNUJzogMC44NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBRFgnOiA1LjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQUUnOiA2LjcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQUVPTic6IDAuMDEwMDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQUlSJzogNTY1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FNUCc6IDksXG4gICAgICAgICAgICAgICAgICAgICAgICAnQU5UJzogNi43LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FSRFInOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FSTic6IDE4LjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVJUJzogMjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVRCJzogMC4wMDA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FUTCc6IDI3LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FUTSc6IDUwNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBVFMnOiA4NjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVZUJzogMS45LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JBUyc6IDExMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQ04nOiAwLjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkVUJzogMTI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JLQic6IDQ2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JNQyc6IDMyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JNVCc6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTlQnOiAyLjU3LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JRWCc6IDQuNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVE0nOiA0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVFgnOiAwLjA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JVUyc6IDAuMDA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NDVCc6IDExNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDRFQnOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ0RYJzogMzAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ0ZJJzogNjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ0xEJzogMC44OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDTkQnOiA1NzQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ05YJzogMC4wNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDT1NTJzogNjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ1NOTyc6IDE2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NUUic6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NUWCc6IDE0NixcbiAgICAgICAgICAgICAgICAgICAgICAgICdDVkMnOiA4LjQ2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RCSVgnOiAwLjAxNjgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRENOJzogMTIwMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RDVCc6IDAuMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRERGJzogMzQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RFTlQnOiA2MjQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RHQic6IDAuNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdER0QnOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RJQ0UnOiAwLjMyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RMVCc6IDAuMjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE5UJzogMC4yMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdET0dFJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdET1YnOiAzNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEUlBVJzogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRFJUJzogMjQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RTSCc6IDAuMDE3LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VCRVQnOiA4NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQlRDJzogMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUJUQ09MRCc6IDYuNixcbiAgICAgICAgICAgICAgICAgICAgICAgICdFQ0FUJzogMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRURHJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdFRE8nOiAyLjksXG4gICAgICAgICAgICAgICAgICAgICAgICAnRUxFJzogMC4wMDE3MixcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTE0nOiAwLjAwNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTUMnOiAwLjAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VNR08nOiAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTkonOiAxNjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU9TJzogMS41LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VSTyc6IDM0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUQlMnOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEMnOiAwLjAwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVFAnOiAwLjAwNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVlgnOiA1LjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVhOJzogNDU2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZSRCc6IDY1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZVRUwnOiAxMjMuMDAxMDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRlVOJzogMjAyLjk1OTgzMDksXG4gICAgICAgICAgICAgICAgICAgICAgICAnRllOJzogMS44NDksXG4gICAgICAgICAgICAgICAgICAgICAgICAnRllQJzogNjYuMTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR05PJzogMC4wMDM0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dVUCc6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR1ZUJzogMS4yLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hBQyc6IDE0NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdIREcnOiA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hHVCc6IDEwODIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSFBDJzogMC40LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hWTic6IDEyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJQ04nOiAwLjU1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lDTyc6IDM0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lDT1MnOiAwLjM1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lORCc6IDc2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lOREknOiA1OTEzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lUUyc6IDE1LjAwMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSVhUJzogMTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnS0JSJzogMTQzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0tJQ0snOiAxMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTEEnOiA0MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMQVQnOiAxLjQ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xJRkUnOiAxMzAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMUkMnOiAyNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMU0snOiAwLjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFVOJzogMC4zNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQUlEJzogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNQU5BJzogMTQzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01DQVAnOiA1LjQ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01JUFMnOiA0MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNTkUnOiAxLjMzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01TUCc6IDEyMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNVEgnOiA5MixcbiAgICAgICAgICAgICAgICAgICAgICAgICdNWUInOiAzLjksXG4gICAgICAgICAgICAgICAgICAgICAgICAnTkRDJzogMTY1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05FQkwnOiAwLjA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05FVCc6IDMuOTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTlRPJzogOTk4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05YQyc6IDEzLjM5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05YVCc6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT0FYJzogMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT0ROJzogMC4wMDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT01HJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdPUFQnOiAzMzUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT1JNRSc6IDIuOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPVE4nOiAwLjU3LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BBWSc6IDMuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQSVgnOiA5NixcbiAgICAgICAgICAgICAgICAgICAgICAgICdQTEJUJzogMC4zMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQTFInOiAxMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUExVJzogMC44NyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQT0UnOiA3ODQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUE9MTCc6IDMuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUFQnOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BSRSc6IDMyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BSRyc6IDM5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BSTyc6IDQxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BSUyc6IDYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BUT1knOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUUFVJzogNjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUUNOJzogMC4wMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdRVFVNJzogMC4wNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdRVlQnOiA2NCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSRVAnOiAwLjAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JLQyc6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JWVCc6IDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NBTic6IDIuMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0JEJzogMC4wMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTQ0wnOiAyLjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0lTQSc6IDE2NDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0tJTic6IDQwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTUFSVCc6IDAuNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTVMnOiAwLjAzNzUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05DJzogMzYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05HTFMnOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOTSc6IDQ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOVCc6IDIzMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVEVFTSc6IDAuMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1RSQVQnOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NUVSc6IDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NUWCc6IDExLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NVQic6IDE3LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NVUic6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1dUJzogMC41MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUQUFTJzogMC45MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUQlQnOiAyLjM3LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RGTCc6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RJTUUnOiAwLjAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RJWCc6IDcuMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUS04nOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RLUic6IDg0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ROVCc6IDkwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RSU1QnOiAxLjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVFJYJzogMTM5NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVRVQnOiA0ODAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVUdUJzogMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVkVOJzogMTQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVkVSSSc6IDAuMDM3LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZJQic6IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZJQkUnOiAxNDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVk9JU0UnOiA2MTgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV0VBTFRIJzogMC4wMTY4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dJTkdTJzogMi40LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dUQyc6IDAuNzUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWEFVUic6IDMuMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWEROJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYRU0nOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYVUMnOiAwLjksXG4gICAgICAgICAgICAgICAgICAgICAgICAnWU9ZT1cnOiAxNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWkFQJzogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWlJYJzogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWlNDJzogMTkxLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUSCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkNIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVU0RUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWkVDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYTVInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzFTVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQURYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBRSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQUVPTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQUlSJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBTVAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FOVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVJEUic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVJOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBUlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FUQic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVRMJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBVE0nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FUUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQVZUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQVMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JDTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkVUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCS0InOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JNQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQk1UJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCTlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JRWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRNJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVFgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0JVUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ0NUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDRFQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NEWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ0ZJJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDTEQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NORCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ05YJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDT1NTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDU05PJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDVFInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NUWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ1ZDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQklYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQ04nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RDVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRERGJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdERU5UJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdER0InOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RHRCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRElDRSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRExUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdETlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RPR0UnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RPVic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRFJQVSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRFJUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEU0gnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VCRVQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VCVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VCVENPTEQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VDQVQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VERyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRURPJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTEUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VMTSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU1DJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTUdPJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFTkonOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VPUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVJPJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEJTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUUCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVZYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFWE4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZSRCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRlVFTCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRlVOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdGWU4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZZUCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR05PJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHVVAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dWVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSEFDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdIREcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hHVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSFBDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdIVk4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lDTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSUNPJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJQ09TJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJTkQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lOREknOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lUUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSVhUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdLQlInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0tJQ0snOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xBJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMQVQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xJRkUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xSQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFNLJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVU4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01BSUQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01BTkEnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01DQVAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01JUFMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01ORSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTVNQJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNVEgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ01ZQic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTkRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdORUJMJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdORVQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ05UTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTlhDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdOWFQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09BWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT0ROJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPTUcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09QVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT1JNRSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT1ROJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQQVknOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BJWCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUExCVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUExSJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQTFUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BPRSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUE9MTCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFBUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUkUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BSRyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUFJPJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdQUlMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BUT1knOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1FBVSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUUNOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdRVFVNJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdRVlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JFUCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUktDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSVlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NBTic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU0JEJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTQ0wnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NJU0EnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NLSU4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NNQVJUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTTVMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05HTFMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NOTSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU05UJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVEVFTSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1RSQVQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NUVSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1RYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTVUInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1NVUic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnU1dUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUQUFTJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUQlQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RGTCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVElNRSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVElYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUS04nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RLUic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVE5UJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUUlNUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUUlgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VFVCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVUdUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdWRU4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZFUkknOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1ZJQic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVklCRSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVk9JU0UnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dFQUxUSCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV0lOR1MnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWEFVUic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWEROJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYRU0nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hVQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWU9ZT1cnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pBUCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWlJYJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdaU0MnOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQ0FUJylcbiAgICAgICAgICAgIHJldHVybiAnQml0Q2xhdmUnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgY3VycmVuY3lJZCAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCaXRDbGF2ZScpXG4gICAgICAgICAgICByZXR1cm4gJ0NBVCc7XG4gICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICB9XG5cbiAgICBmZWVUb1ByZWNpc2lvbiAoc3ltYm9sLCBmZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ1bmNhdGUgKGZlZSwgOCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFN5bWJvbCAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2VDdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0WydxdW90ZUN1cnJlbmN5J107XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBsb3QgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ3F1YW50aXR5SW5jcmVtZW50J10pO1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ3RpY2tTaXplJ10pO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAncHJpY2UnOiB0aGlzLnByZWNpc2lvbkZyb21TdHJpbmcgKG1hcmtldFsndGlja1NpemUnXSksXG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHRoaXMucHJlY2lzaW9uRnJvbVN0cmluZyAobWFya2V0WydxdWFudGl0eUluY3JlbWVudCddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgdGFrZXIgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ3Rha2VMaXF1aWRpdHlSYXRlJ10pO1xuICAgICAgICAgICAgbGV0IG1ha2VyID0gcGFyc2VGbG9hdCAobWFya2V0Wydwcm92aWRlTGlxdWlkaXR5UmF0ZSddKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnbG90JzogbG90LFxuICAgICAgICAgICAgICAgICdzdGVwJzogc3RlcCxcbiAgICAgICAgICAgICAgICAndGFrZXInOiB0YWtlcixcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBtYWtlcixcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBsb3QgKiBzdGVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDdXJyZW5jaWVzIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IGF3YWl0IHRoaXMucHVibGljR2V0Q3VycmVuY3kgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gY3VycmVuY3lbJ2lkJ107XG4gICAgICAgICAgICAvLyB0b2RvOiB3aWxsIG5lZWQgdG8gcmV0aGluayB0aGUgZmVlc1xuICAgICAgICAgICAgLy8gdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIHdpdGhkcmF3YWwvZGVwb3NpdCBtZXRob2RzIGFuZFxuICAgICAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgZmVlcyBmb3IgZWFjaCBwYXJ0aWN1bGFyIG1ldGhvZFxuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogOCwgLy8gZGVmYXVsdCBwcmVjaXNpb24sIHRvZG86IGZpeCBcIm1hZ2ljIGNvbnN0YW50c1wiXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogOCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChpZCk7XG4gICAgICAgICAgICBsZXQgcGF5aW4gPSBjdXJyZW5jeVsncGF5aW5FbmFibGVkJ107XG4gICAgICAgICAgICBsZXQgcGF5b3V0ID0gY3VycmVuY3lbJ3BheW91dEVuYWJsZWQnXTtcbiAgICAgICAgICAgIGxldCB0cmFuc2ZlciA9IGN1cnJlbmN5Wyd0cmFuc2ZlckVuYWJsZWQnXTtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSBwYXlpbiAmJiBwYXlvdXQgJiYgdHJhbnNmZXI7XG4gICAgICAgICAgICBsZXQgc3RhdHVzID0gJ29rJztcbiAgICAgICAgICAgIGlmICgnZGlzYWJsZWQnIGluIGN1cnJlbmN5KVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVsnZGlzYWJsZWQnXSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gJ2Rpc2FibGVkJztcbiAgICAgICAgICAgIGxldCB0eXBlID0gKGN1cnJlbmN5WydjcnlwdG8nXSkgPyAnY3J5cHRvJyA6ICdmaWF0JztcbiAgICAgICAgICAgIHJlc3VsdFtjb2RlXSA9IHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnY29kZSc6IGNvZGUsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgICAgICdwYXlpbic6IHBheWluLFxuICAgICAgICAgICAgICAgICdwYXlvdXQnOiBwYXlvdXQsXG4gICAgICAgICAgICAgICAgJ3RyYW5zZmVyJzogdHJhbnNmZXIsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IGN1cnJlbmN5WydmdWxsTmFtZSddLFxuICAgICAgICAgICAgICAgICdhY3RpdmUnOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLCAvLyB0b2RvOiByZWRlc2lnblxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBNYXRoLnBvdyAoMTAsIHByZWNpc2lvblsnYW1vdW50J10pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBNYXRoLnBvdyAoMTAsIHByZWNpc2lvblsncHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnNhZmVTdHJpbmcgKHBhcmFtcywgJ3R5cGUnLCAndHJhZGluZycpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVHZXQnICsgdGhpcy5jYXBpdGFsaXplICh0eXBlKSArICdCYWxhbmNlJztcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpc1ttZXRob2RdICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY29kZSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoY29kZSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ3Jlc2VydmVkJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMWQnLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvaGxjdlsndGltZXN0YW1wJ10pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ29wZW4nXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnbWF4J10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ21pbiddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydjbG9zZSddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2Wyd2b2x1bWVRdW90ZSddKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAncGVyaW9kJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDYW5kbGVzU3ltYm9sICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rU3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWQnLCAnYXNrJywgJ3ByaWNlJywgJ3NpemUnKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0aWNrZXJbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2JpZCcpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2snKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnb3BlbicpLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2Nsb3NlJyksXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0JyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbHVtZScpLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbHVtZVF1b3RlJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IHRpY2tlclsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIHRpY2tlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGlja2VyWydtZXNzYWdlJ10pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsndGltZXN0YW1wJ10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGlkID0gdHJhZGVbJ3N5bWJvbCddO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdmZWUnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBtYXJrZXQgPyBtYXJrZXRbJ3F1b3RlJ10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBwYXJzZUZsb2F0ICh0cmFkZVsnZmVlJ10pLFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JkZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdjbGllbnRPcmRlcklkJyBpbiB0cmFkZSlcbiAgICAgICAgICAgIG9yZGVySWQgPSB0cmFkZVsnY2xpZW50T3JkZXJJZCddO1xuICAgICAgICBsZXQgcHJpY2UgPSBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSk7XG4gICAgICAgIGxldCBhbW91bnQgPSBwYXJzZUZsb2F0ICh0cmFkZVsncXVhbnRpdHknXSk7XG4gICAgICAgIGxldCBjb3N0ID0gcHJpY2UgKiBhbW91bnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkZXInOiBvcmRlcklkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdjb3N0JzogY29zdCxcbiAgICAgICAgICAgICdmZWUnOiBmZWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzU3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGNsaWVudE9yZGVySWQgPSB0aGlzLnV1aWQgKCk7XG4gICAgICAgIC8vIHRoZWlyIG1heCBhY2NlcHRlZCBsZW5ndGggaXMgMzIgY2hhcmFjdGVyc1xuICAgICAgICBjbGllbnRPcmRlcklkID0gY2xpZW50T3JkZXJJZC5yZXBsYWNlICgnLScsICcnKTtcbiAgICAgICAgY2xpZW50T3JkZXJJZCA9IGNsaWVudE9yZGVySWQuc2xpY2UgKDAsIDMyKTtcbiAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCAoYW1vdW50KTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnY2xpZW50T3JkZXJJZCc6IGNsaWVudE9yZGVySWQsXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKSB7XG4gICAgICAgICAgICByZXF1ZXN0WydwcmljZSddID0gdGhpcy5wcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3RpbWVJbkZvcmNlJ10gPSAnRk9LJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXIgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5wYXJzZU9yZGVyIChyZXNwb25zZSk7XG4gICAgICAgIGxldCBpZCA9IG9yZGVyWydpZCddO1xuICAgICAgICB0aGlzLm9yZGVyc1tpZF0gPSBvcmRlcjtcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlRGVsZXRlT3JkZXJDbGllbnRPcmRlcklkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NsaWVudE9yZGVySWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgY3JlYXRlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdjcmVhdGVkQXQnIGluIG9yZGVyKVxuICAgICAgICAgICAgY3JlYXRlZCA9IHRoaXMucGFyc2U4NjAxIChvcmRlclsnY3JlYXRlZEF0J10pO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCd1cGRhdGVkQXQnIGluIG9yZGVyKVxuICAgICAgICAgICAgdXBkYXRlZCA9IHRoaXMucGFyc2U4NjAxIChvcmRlclsndXBkYXRlZEF0J10pO1xuICAgICAgICBpZiAoIW1hcmtldClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtvcmRlclsnc3ltYm9sJ11dO1xuICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ3F1YW50aXR5Jyk7XG4gICAgICAgIGxldCBmaWxsZWQgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdjdW1RdWFudGl0eScpO1xuICAgICAgICBsZXQgc3RhdHVzID0gb3JkZXJbJ3N0YXR1cyddO1xuICAgICAgICBpZiAoc3RhdHVzID09ICduZXcnKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09ICdwYXJ0aWFsbHlGaWxsZWQnKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09ICdmaWxsZWQnKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2xvc2VkJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQgPSBvcmRlclsnY2xpZW50T3JkZXJJZCddLnRvU3RyaW5nICgpO1xuICAgICAgICBsZXQgcHJpY2UgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdwcmljZScpO1xuICAgICAgICBpZiAodHlwZW9mIHByaWNlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5vcmRlcnMpXG4gICAgICAgICAgICAgICAgcHJpY2UgPSB0aGlzLm9yZGVyc1tpZF0ucHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbGxlZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IGFtb3VudCAtIGZpbGxlZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByaWNlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvc3QgPSBmaWxsZWQgKiBwcmljZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IGNyZWF0ZWQsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKGNyZWF0ZWQpLFxuICAgICAgICAgICAgJ2NyZWF0ZWQnOiBjcmVhdGVkLFxuICAgICAgICAgICAgJ3VwZGF0ZWQnOiB1cGRhdGVkLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyWyd0eXBlJ10sXG4gICAgICAgICAgICAnc2lkZSc6IG9yZGVyWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnZmlsbGVkJzogZmlsbGVkLFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IHJlbWFpbmluZyxcbiAgICAgICAgICAgICdmZWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEhpc3RvcnlPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjbGllbnRPcmRlcklkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgbnVtT3JkZXJzID0gcmVzcG9uc2UubGVuZ3RoO1xuICAgICAgICBpZiAobnVtT3JkZXJzID4gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIgKHJlc3BvbnNlWzBdKTtcbiAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKHRoaXMuaWQgKyAnIG9yZGVyICcgKyBpZCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hBY3RpdmVPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXJDbGllbnRPcmRlcklkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NsaWVudE9yZGVySWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIgKHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N5bWJvbCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVyICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydzeW1ib2wnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIGlmIChzaW5jZSkge1xuICAgICAgICAgICAgcmVxdWVzdFsnZnJvbSddID0gdGhpcy5pc284NjAxIChzaW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0SGlzdG9yeU9yZGVyICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTXlUcmFkZXMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC8vICdzeW1ib2wnOiAnQlRDL1VTRCcsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICAvLyAnc29ydCc6ICdERVNDJywgLy8gb3IgJ0FTQydcbiAgICAgICAgICAgIC8vICdieSc6ICd0aW1lc3RhbXAnLCAvLyBvciAnaWQnXHRTdHJpbmdcdHRpbWVzdGFtcCBieSBkZWZhdWx0LCBvciBpZFxuICAgICAgICAgICAgLy8gJ2Zyb20nOlx0J0RhdGV0aW1lIG9yIE51bWJlcicsIC8vIElTTyA4NjAxXG4gICAgICAgICAgICAvLyAndGlsbCc6XHQnRGF0ZXRpbWUgb3IgTnVtYmVyJyxcbiAgICAgICAgICAgIC8vICdsaW1pdCc6IDEwMCxcbiAgICAgICAgICAgIC8vICdvZmZzZXQnOiAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N5bWJvbCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ2Zyb20nXSA9IHRoaXMuaXNvODYwMSAoc2luY2UpO1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEhpc3RvcnlUcmFkZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QWNjb3VudENyeXB0b0FkZHJlc3NDdXJyZW5jeSAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3lJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBhZGRyZXNzID0gcmVzcG9uc2VbJ2FkZHJlc3MnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBY2NvdW50Q3J5cHRvQWRkcmVzc0N1cnJlbmN5ICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeUlkLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSByZXNwb25zZVsnYWRkcmVzcyddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQgKGFtb3VudCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RBY2NvdW50Q3J5cHRvV2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeUlkLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy9hcGknICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSBhcGkgKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIHVybCArPSB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdHRVQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGF5bG9hZCA9IHRoaXMuZW5jb2RlICh0aGlzLmFwaUtleSArICc6JyArIHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5zdHJpbmdUb0Jhc2U2NCAocGF5bG9hZCk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogXCJCYXNpYyBcIiArIHRoaXMuZGVjb2RlIChhdXRoKSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgdXJsO1xuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGhhbmRsZUVycm9ycyAoY29kZSwgcmVhc29uLCB1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSkge1xuICAgICAgICBpZiAoY29kZSA9PSA0MDApIHtcbiAgICAgICAgICAgIGlmIChib2R5WzBdID09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gSlNPTi5wYXJzZSAoYm9keSk7XG4gICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZVsnZXJyb3InXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSByZXNwb25zZVsnZXJyb3InXVsnbWVzc2FnZSddO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgPT0gJ09yZGVyIG5vdCBmb3VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgb3JkZXIgbm90IGZvdW5kIGluIGFjdGl2ZSBvcmRlcnMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZSA9PSAnSW5zdWZmaWNpZW50IGZ1bmRzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyBib2R5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgaHVvYmkgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnaHVvYmknLFxuICAgICAgICAgICAgJ25hbWUnOiAnSHVvYmknLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YzJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMDAxJyxcbiAgICAgICAgICAgICAgICAnNW0nOiAnMDA1JyxcbiAgICAgICAgICAgICAgICAnMTVtJzogJzAxNScsXG4gICAgICAgICAgICAgICAgJzMwbSc6ICcwMzAnLFxuICAgICAgICAgICAgICAgICcxaCc6ICcwNjAnLFxuICAgICAgICAgICAgICAgICcxZCc6ICcxMDAnLFxuICAgICAgICAgICAgICAgICcxdyc6ICcyMDAnLFxuICAgICAgICAgICAgICAgICcxTSc6ICczMDAnLFxuICAgICAgICAgICAgICAgICcxeSc6ICc0MDAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1NjktMTVhYTdiOWEtNWVkZC0xMWU3LTllN2YtNDQ3OTFmNGVlNDljLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwOi8vYXBpLmh1b2JpLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5odW9iaS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL2h1b2JpYXBpL0FQSV9Eb2NzX2VuL3dpa2knLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3N0YXRpY21hcmtldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9X2tsaW5lX3twZXJpb2R9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJfe2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGhfe2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGhfe2lkfV97bGVuZ3RofScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGV0YWlsX3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3VzZG1hcmtldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd7aWR9X2tsaW5lX3twZXJpb2R9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJfe2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGhfe2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGhfe2lkfV97bGVuZ3RofScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGV0YWlsX3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3RyYWRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfYWNjb3VudF9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2J1eV9tYXJrZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxfbWFya2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9uZXdfZGVhbF9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9vcmRlcl9pZF9ieV90cmFkZV9pZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdfY29pbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX3dpdGhkcmF3X2NvaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF93aXRoZHJhd19jb2luX3Jlc3VsdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlcGF5bWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X2xvYW5fYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfbG9hbnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9DTlknOiB7ICdpZCc6ICdidGMnLCAnc3ltYm9sJzogJ0JUQy9DTlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ05ZJywgJ3R5cGUnOiAnc3RhdGljbWFya2V0JywgJ2NvaW5UeXBlJzogMSB9LFxuICAgICAgICAgICAgICAgICdMVEMvQ05ZJzogeyAnaWQnOiAnbHRjJywgJ3N5bWJvbCc6ICdMVEMvQ05ZJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0NOWScsICd0eXBlJzogJ3N0YXRpY21hcmtldCcsICdjb2luVHlwZSc6IDIgfSxcbiAgICAgICAgICAgICAgICAvLyAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0YycsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnLCAndHlwZSc6ICd1c2RtYXJrZXQnLCAgICAnY29pblR5cGUnOiAxIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMudHJhZGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAodGhpcy5jdXJyZW5jaWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2ldO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBsZXQgYXZhaWxhYmxlID0gJ2F2YWlsYWJsZV8nICsgbG93ZXJjYXNlICsgJ19kaXNwbGF5JztcbiAgICAgICAgICAgIGxldCBmcm96ZW4gPSAnZnJvemVuXycgKyBsb3dlcmNhc2UgKyAnX2Rpc3BsYXknO1xuICAgICAgICAgICAgbGV0IGxvYW4gPSAnbG9hbl8nICsgbG93ZXJjYXNlICsgJ19kaXNwbGF5JztcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGUgaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbYXZhaWxhYmxlXSk7XG4gICAgICAgICAgICBpZiAoZnJvemVuIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2Zyb3plbl0pO1xuICAgICAgICAgICAgaWYgKGxvYW4gaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gdGhpcy5zdW0gKGFjY291bnRbJ3VzZWQnXSwgcGFyc2VGbG9hdCAoYmFsYW5jZXNbbG9hbl0pKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9IG1hcmtldFsndHlwZSddICsgJ0dldERlcHRoSWQnO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoeyAnaWQnOiBtYXJrZXRbJ2lkJ10gfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9IG1hcmtldFsndHlwZSddICsgJ0dldFRpY2tlcklkJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWyd0aWNrZXInXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChyZXNwb25zZVsndGltZSddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eScpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdzZWxsJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ29wZW4nKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsndHMnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnZGlyZWN0aW9uJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSBtYXJrZXRbJ3R5cGUnXSArICdHZXREZXRhaWxJZCc7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsndHJhZGVzJ10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbm90IGltcGxlbWVudGVkIHlldFxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbMF0sXG4gICAgICAgICAgICBvaGxjdlsxXSxcbiAgICAgICAgICAgIG9obGN2WzJdLFxuICAgICAgICAgICAgb2hsY3ZbM10sXG4gICAgICAgICAgICBvaGxjdls0XSxcbiAgICAgICAgICAgIG9obGN2WzZdLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSBtYXJrZXRbJ3R5cGUnXSArICdHZXRJZEtsaW5lUGVyaW9kJztcbiAgICAgICAgbGV0IG9obGN2cyA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdwZXJpb2QnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiBvaGxjdnM7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChvaGxjdnMsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICd0cmFkZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2NvaW5fdHlwZSc6IG1hcmtldFsnY29pblR5cGUnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydxdW90ZSddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWV0aG9kICs9IHRoaXMuY2FwaXRhbGl6ZSAodHlwZSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhZGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXTtcbiAgICAgICAgaWYgKGFwaSA9PSAndHJhZGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIHVybCArPSAnL2FwaScgKyB0aGlzLnZlcnNpb247XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmtleXNvcnQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ2FjY2Vzc19rZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnY3JlYXRlZCc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGxldCBxdWVyeVN0cmluZyA9IHRoaXMudXJsZW5jb2RlICh0aGlzLm9taXQgKHF1ZXJ5LCAnbWFya2V0JykpO1xuICAgICAgICAgICAgLy8gc2VjcmV0IGtleSBtdXN0IGJlIGFwcGVuZGVkIHRvIHRoZSBxdWVyeSBiZWZvcmUgc2lnbmluZ1xuICAgICAgICAgICAgcXVlcnlTdHJpbmcgKz0gJyZzZWNyZXRfa2V5PScgKyB0aGlzLnNlY3JldDtcbiAgICAgICAgICAgIHF1ZXJ5WydzaWduJ10gPSB0aGlzLmhhc2ggKHRoaXMuZW5jb2RlIChxdWVyeVN0cmluZykpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgYXBpICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpICsgJ19qc29uLmpzJztcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICd0cmFkZScsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3RhdHVzJ10gPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBodW9iaXBybyA9IHJlcXVpcmUgKCcuL2h1b2JpcHJvLmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgaHVvYmljbnkgZXh0ZW5kcyBodW9iaXBybyB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnaHVvYmljbnknLFxuICAgICAgICAgICAgJ25hbWUnOiAnSHVvYmkgQ05ZJyxcbiAgICAgICAgICAgICdob3N0bmFtZSc6ICdiZS5odW9iaS5jb20nLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1NjktMTVhYTdiOWEtNWVkZC0xMWU3LTllN2YtNDQ3OTFmNGVlNDljLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2JlLmh1b2JpLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5odW9iaS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL2h1b2JpYXBpL0FQSV9Eb2NzL3dpa2kvUkVTVF9hcGlfcmVmZXJlbmNlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgaHVvYmlwcm8gZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnaHVvYmlwcm8nLFxuICAgICAgICAgICAgJ25hbWUnOiAnSHVvYmkgUHJvJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnYWNjb3VudHMnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYWNjb3VudHNCeUlkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2hvc3RuYW1lJzogJ2FwaS5odW9iaS5wcm8nLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIHN0cnVjdHVyZVxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgLy8gbmV3IG1ldGFpbmZvIHN0cnVjdHVyZVxuICAgICAgICAgICAgJ2hhcyc6IHtcbiAgICAgICAgICAgICAgICAnZmV0Y2hPSENMVic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMW1pbicsXG4gICAgICAgICAgICAgICAgJzVtJzogJzVtaW4nLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnMTVtaW4nLFxuICAgICAgICAgICAgICAgICczMG0nOiAnMzBtaW4nLFxuICAgICAgICAgICAgICAgICcxaCc6ICc2MG1pbicsXG4gICAgICAgICAgICAgICAgJzFkJzogJzFkYXknLFxuICAgICAgICAgICAgICAgICcxdyc6ICcxd2VlaycsXG4gICAgICAgICAgICAgICAgJzFNJzogJzFtb24nLFxuICAgICAgICAgICAgICAgICcxeSc6ICcxeWVhcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU2OS0xNWFhN2I5YS01ZWRkLTExZTctOWU3Zi00NDc5MWY0ZWU0OWMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmh1b2JpLnBybycsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5odW9iaS5wcm8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL2h1b2JpYXBpL0FQSV9Eb2NzL3dpa2kvUkVTVF9hcGlfcmVmZXJlbmNlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdtYXJrZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGlzdG9yeS9rbGluZScsIC8vIOiOt+WPlkvnur/mlbDmja5cbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXRhaWwvbWVyZ2VkJywgLy8g6I635Y+W6IGa5ZCI6KGM5oOFKFRpY2tlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aCcsIC8vIOiOt+WPliBNYXJrZXQgRGVwdGgg5pWw5o2uXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLCAvLyDojrflj5YgVHJhZGUgRGV0YWlsIOaVsOaNrlxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpc3RvcnkvdHJhZGUnLCAvLyDmibnph4/ojrflj5bmnIDov5HnmoTkuqTmmJPorrDlvZVcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXRhaWwnLCAvLyDojrflj5YgTWFya2V0IERldGFpbCAyNOWwj+aXtuaIkOS6pOmHj+aVsOaNrlxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb21tb24vc3ltYm9scycsIC8vIOafpeivouezu+e7n+aUr+aMgeeahOaJgOacieS6pOaYk+WvuVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbW1vbi9jdXJyZW5jeXMnLCAvLyDmn6Xor6Lns7vnu5/mlK/mjIHnmoTmiYDmnInluIHnp41cbiAgICAgICAgICAgICAgICAgICAgICAgICdjb21tb24vdGltZXN0YW1wJywgLy8g5p+l6K+i57O757uf5b2T5YmN5pe26Ze0XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L2FjY291bnRzJywgLy8g5p+l6K+i5b2T5YmN55So5oi355qE5omA5pyJ6LSm5oi3KOWNs2FjY291bnQtaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9hY2NvdW50cy97aWR9L2JhbGFuY2UnLCAvLyDmn6Xor6LmjIflrprotKbmiLfnmoTkvZnpop1cbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMve2lkfScsIC8vIOafpeivouafkOS4quiuouWNleivpuaDhVxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL29yZGVycy97aWR9L21hdGNocmVzdWx0cycsIC8vIOafpeivouafkOS4quiuouWNleeahOaIkOS6pOaYjue7hlxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL29yZGVycycsIC8vIOafpeivouW9k+WJjeWnlOaJmOOAgeWOhuWPsuWnlOaJmFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL21hdGNocmVzdWx0cycsIC8vIOafpeivouW9k+WJjeaIkOS6pOOAgeWOhuWPsuaIkOS6pFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2R3L3dpdGhkcmF3LXZpcnR1YWwvYWRkcmVzc2VzJywgLy8g5p+l6K+i6Jma5ouf5biB5o+Q546w5Zyw5Z2AXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL29yZGVycy9wbGFjZScsIC8vIOWIm+W7uuW5tuaJp+ihjOS4gOS4quaWsOiuouWNlSAo5LiA5q2l5LiL5Y2V77yMIOaOqOiNkOS9v+eUqClcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMnLCAvLyDliJvlu7rkuIDkuKrmlrDnmoTorqLljZXor7fmsYIg77yI5LuF5Yib5bu66K6i5Y2V77yM5LiN5omn6KGM5LiL5Y2V77yJXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvb3JkZXJzL3tpZH0vcGxhY2UnLCAvLyDmiafooYzkuIDkuKrorqLljZUg77yI5LuF5omn6KGM5bey5Yib5bu655qE6K6i5Y2V77yJXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvb3JkZXJzL3tpZH0vc3VibWl0Y2FuY2VsJywgLy8g55Sz6K+35pKk6ZSA5LiA5Liq6K6i5Y2V6K+35rGCXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvb3JkZXJzL2JhdGNoY2FuY2VsJywgLy8g5om56YeP5pKk6ZSA6K6i5Y2VXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHcvYmFsYW5jZS90cmFuc2ZlcicsIC8vIOi1hOS6p+WIkui9rFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2R3L3dpdGhkcmF3LXZpcnR1YWwvY3JlYXRlJywgLy8g55Sz6K+35o+Q546w6Jma5ouf5biBXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHcvd2l0aGRyYXctdmlydHVhbC97aWR9L3BsYWNlJywgLy8g56Gu6K6k55Sz6K+36Jma5ouf5biB5o+Q546wXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHcvd2l0aGRyYXctdmlydHVhbC97aWR9L2NhbmNlbCcsIC8vIOeUs+ivt+WPlua2iOaPkOeOsOiZmuaLn+W4gVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldENvbW1vblN5bWJvbHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IG51bU1hcmtldHMgPSBtYXJrZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bU1hcmtldHMgPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHB1YmxpY0dldENvbW1vblN5bWJvbHMgcmV0dXJuZWQgZW1wdHkgcmVzcG9uc2U6ICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpXTtcbiAgICAgICAgICAgIGxldCBiYXNlSWQgPSBtYXJrZXRbJ2Jhc2UtY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZUlkID0gbWFya2V0WydxdW90ZS1jdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBiYXNlSWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBxdW90ZUlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGlkID0gYmFzZUlkICsgcXVvdGVJZDtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogbWFya2V0WydhbW91bnQtcHJlY2lzaW9uJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogbWFya2V0WydwcmljZS1wcmVjaXNpb24nXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgbG90ID0gTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydhbW91bnQnXSk7XG4gICAgICAgICAgICBsZXQgbWFrZXIgPSAoYmFzZSA9PSAnT01HJykgPyAwIDogMC4yIC8gMTAwO1xuICAgICAgICAgICAgbGV0IHRha2VyID0gKGJhc2UgPT0gJ09NRycpID8gMCA6IDAuMiAvIDEwMDtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2xvdCc6IGxvdCxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICd0YWtlcic6IHRha2VyLFxuICAgICAgICAgICAgICAgICdtYWtlcic6IG1ha2VyLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdsYXN0JyBpbiB0aWNrZXIpXG4gICAgICAgICAgICBsYXN0ID0gdGlja2VyWydsYXN0J107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgaWYgKCd0cycgaW4gdGlja2VyKVxuICAgICAgICAgICAgdGltZXN0YW1wID0gdGlja2VyWyd0cyddO1xuICAgICAgICBsZXQgYmlkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYXNrID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2JpZCcgaW4gdGlja2VyKSB7XG4gICAgICAgICAgICBpZiAodGlja2VyWydiaWQnXSlcbiAgICAgICAgICAgICAgICBiaWQgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyWydiaWQnXSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdhc2snIGluIHRpY2tlcikge1xuICAgICAgICAgICAgaWYgKHRpY2tlclsnYXNrJ10pXG4gICAgICAgICAgICAgICAgYXNrID0gdGhpcy5zYWZlRmxvYXQgKHRpY2tlclsnYXNrJ10sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGlja2VyWydoaWdoJ10sXG4gICAgICAgICAgICAnbG93JzogdGlja2VyWydsb3cnXSxcbiAgICAgICAgICAgICdiaWQnOiBiaWQsXG4gICAgICAgICAgICAnYXNrJzogYXNrLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHRpY2tlclsnb3BlbiddLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdGlja2VyWydjbG9zZSddLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBsYXN0LFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYW1vdW50J10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGlja2VyWyd2b2wnXSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYXJrZXRHZXREZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndHlwZSc6ICdzdGVwMCcsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAocmVzcG9uc2VbJ3RpY2snXSwgcmVzcG9uc2VbJ3RpY2snXVsndHMnXSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1hcmtldEdldERldGFpbE1lcmdlZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAocmVzcG9uc2VbJ3RpY2snXSwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsndHMnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnZGlyZWN0aW9uJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZXNEYXRhIChkYXRhLCBtYXJrZXQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRyYWRlcyA9IHRoaXMucGFyc2VUcmFkZXMgKGRhdGFbaV1bJ2RhdGEnXSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0cmFkZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAodHJhZGVzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1hcmtldEdldEhpc3RvcnlUcmFkZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnc2l6ZSc6IDIwMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlc0RhdGEgKHJlc3BvbnNlWydkYXRhJ10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WydpZCddICogMTAwMCxcbiAgICAgICAgICAgIG9obGN2WydvcGVuJ10sXG4gICAgICAgICAgICBvaGxjdlsnaGlnaCddLFxuICAgICAgICAgICAgb2hsY3ZbJ2xvdyddLFxuICAgICAgICAgICAgb2hsY3ZbJ2Nsb3NlJ10sXG4gICAgICAgICAgICBvaGxjdlsndm9sJ10sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYXJrZXRHZXRIaXN0b3J5S2xpbmUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3BlcmlvZCc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICAgICAgJ3NpemUnOiAyMDAwLCAvLyBtYXggPSAyMDAwXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2VbJ2RhdGEnXSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZEFjY291bnRzIChyZWxvYWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAocmVsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmFjY291bnRzID0gYXdhaXQgdGhpcy5mZXRjaEFjY291bnRzICgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWNjb3VudHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cyA9IGF3YWl0IHRoaXMuZmV0Y2hBY2NvdW50cyAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFjY291bnRzQnlJZCA9IHRoaXMuaW5kZXhCeSAodGhpcy5hY2NvdW50cywgJ2lkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3VudHM7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hBY2NvdW50cyAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFjY291bnRBY2NvdW50cyAoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydkYXRhJ107XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRBY2NvdW50cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWNjb3VudEFjY291bnRzSWRCYWxhbmNlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5hY2NvdW50c1swXVsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydkYXRhJ11bJ2xpc3QnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGJhbGFuY2VbJ2N1cnJlbmN5J10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAodXBwZXJjYXNlKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIHJlc3VsdClcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gcmVzdWx0W2N1cnJlbmN5XTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGJhbGFuY2VbJ3R5cGUnXSA9PSAndHJhZGUnKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSk7XG4gICAgICAgICAgICBpZiAoYmFsYW5jZVsndHlwZSddID09ICdmcm96ZW4nKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXJzKCkgcmVxdWlyZXMgYSBzeW1ib2wgcGFyYW1ldGVyJyk7XG4gICAgICAgIHRoaXMubG9hZF9tYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBzdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgndHlwZScgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSBwYXJhbXNbJ3R5cGUnXTtcbiAgICAgICAgfSBlbHNlIGlmICgnc3RhdHVzJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IHBhcmFtc1snc3RhdHVzJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcmRlcnMoKSByZXF1aXJlcyB0eXBlIHBhcmFtIG9yIHN0YXR1cyBwYXJhbSBmb3Igc3BvdCBtYXJrZXQgJyArIHN5bWJvbCArICcoMCBvciBcIm9wZW5cIiBmb3IgdW5maWxsZWQgb3IgcGFydGlhbCBmaWxsZWQgb3JkZXJzLCAxIG9yIFwiY2xvc2VkXCIgZm9yIGZpbGxlZCBvcmRlcnMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdGF0dXMgPT0gMCkgfHwgKHN0YXR1cyA9PSAnb3BlbicpKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnc3VibWl0dGVkLHBhcnRpYWwtZmlsbGVkJztcbiAgICAgICAgfSBlbHNlIGlmICgoc3RhdHVzID09IDEpIHx8IChzdGF0dXMgPT0gJ2Nsb3NlZCcpKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnZmlsbGVkLHBhcnRpYWwtY2FuY2VsZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXJzKCkgd3JvbmcgdHlwZSBwYXJhbSBvciBzdGF0dXMgcGFyYW0gZm9yIHNwb3QgbWFya2V0ICcgKyBzeW1ib2wgKyAnKDAgb3IgXCJvcGVuXCIgZm9yIHVuZmlsbGVkIG9yIHBhcnRpYWwgZmlsbGVkIG9yZGVycywgMSBvciBcImNsb3NlZFwiIGZvciBmaWxsZWQgb3JkZXJzKScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVyT3JkZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdzdGF0ZXMnOiBzdGF0dXMsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydkYXRhJ10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3BlbiA9IDA7IC8vIDAgZm9yIHVuZmlsbGVkIG9yZGVycywgMSBmb3IgZmlsbGVkIG9yZGVyc1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzdGF0dXMnOiBvcGVuLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAncGFydGlhbC1maWxsZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ29wZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PSAnZmlsbGVkJykge1xuICAgICAgICAgICAgcmV0dXJuICdjbG9zZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PSAnY2FuY2VsZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NhbmNlbGVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ3N1Ym1pdHRlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAnb3Blbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCd0eXBlJyBpbiBvcmRlcikge1xuICAgICAgICAgICAgbGV0IG9yZGVyVHlwZSA9IG9yZGVyWyd0eXBlJ10uc3BsaXQgKCctJyk7XG4gICAgICAgICAgICBzaWRlID0gb3JkZXJUeXBlWzBdO1xuICAgICAgICAgICAgdHlwZSA9IG9yZGVyVHlwZVsxXTtcbiAgICAgICAgICAgIHN0YXR1cyA9IHRoaXMucGFyc2VPcmRlclN0YXR1cyAob3JkZXJbJ3N0YXRlJ10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KSB7XG4gICAgICAgICAgICBpZiAoJ3N5bWJvbCcgaW4gb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJbJ3N5bWJvbCddIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya2V0SWQgPSBvcmRlclsnc3ltYm9sJ107XG4gICAgICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFttYXJrZXRJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJbJ2NyZWF0ZWQtYXQnXTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKG9yZGVyWydhbW91bnQnXSk7XG4gICAgICAgIGxldCBmaWxsZWQgPSBwYXJzZUZsb2F0IChvcmRlclsnZmllbGQtYW1vdW50J10pO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gYW1vdW50IC0gZmlsbGVkO1xuICAgICAgICBsZXQgcHJpY2UgPSBwYXJzZUZsb2F0IChvcmRlclsncHJpY2UnXSk7XG4gICAgICAgIGxldCBjb3N0ID0gcGFyc2VGbG9hdCAob3JkZXJbJ2ZpZWxkLWNhc2gtYW1vdW50J10pO1xuICAgICAgICBsZXQgYXZlcmFnZSA9IDA7XG4gICAgICAgIGlmIChmaWxsZWQpXG4gICAgICAgICAgICBhdmVyYWdlID0gcGFyc2VGbG9hdCAoY29zdCAvIGZpbGxlZCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ2lkJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiBhdmVyYWdlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdmZWUnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkQWNjb3VudHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2FjY291bnQtaWQnOiB0aGlzLmFjY291bnRzWzBdWydpZCddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRoaXMuYW1vdW50VG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50KSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUgKyAnLScgKyB0eXBlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgcHJpY2UpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJPcmRlcnNQbGFjZSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnZGF0YSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyT3JkZXJzSWRTdWJtaXRjYW5jZWwgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdXJsICs9IGFwaTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdXJsICs9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgdXJsICs9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5ZbWRITVMgKHRoaXMubWlsbGlzZWNvbmRzICgpLCAnVCcpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmtleXNvcnQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ1NpZ25hdHVyZU1ldGhvZCc6ICdIbWFjU0hBMjU2JyxcbiAgICAgICAgICAgICAgICAnU2lnbmF0dXJlVmVyc2lvbic6ICcyJyxcbiAgICAgICAgICAgICAgICAnQWNjZXNzS2V5SWQnOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnVGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy51cmxlbmNvZGUgKHJlcXVlc3QpO1xuICAgICAgICAgICAgbGV0IHBheWxvYWQgPSBbIG1ldGhvZCwgdGhpcy5ob3N0bmFtZSwgdXJsLCBhdXRoIF0uam9pbiAoXCJcXG5cIik7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocGF5bG9hZCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGEyNTYnLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBhdXRoICs9ICcmJyArIHRoaXMudXJsZW5jb2RlICh7ICdTaWduYXR1cmUnOiBzaWduYXR1cmUgfSk7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgYXV0aDtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmw7XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3RhdHVzJ10gPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBpbmRlcGVuZGVudHJlc2VydmUgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnaW5kZXBlbmRlbnRyZXNlcnZlJyxcbiAgICAgICAgICAgICduYW1lJzogJ0luZGVwZW5kZW50IFJlc2VydmUnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0FVJywgJ05aJyBdLCAvLyBBdXN0cmFsaWEsIE5ldyBaZWFsYW5kXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwNTIxNjYyLWNmM2Y0NzdjLTliY2ItMTFlNy04OWJjLWQxYWM4NTAxMmVkYS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkuaW5kZXBlbmRlbnRyZXNlcnZlLmNvbS9QdWJsaWMnLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5pbmRlcGVuZGVudHJlc2VydmUuY29tL1ByaXZhdGUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5pbmRlcGVuZGVudHJlc2VydmUuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmluZGVwZW5kZW50cmVzZXJ2ZS5jb20vQVBJJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VmFsaWRQcmltYXJ5Q3VycmVuY3lDb2RlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VmFsaWRTZWNvbmRhcnlDdXJyZW5jeUNvZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRWYWxpZExpbWl0T3JkZXJUeXBlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0VmFsaWRNYXJrZXRPcmRlclR5cGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRWYWxpZE9yZGVyVHlwZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFZhbGlkVHJhbnNhY3Rpb25UeXBlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0TWFya2V0U3VtbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0T3JkZXJCb29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRUcmFkZUhpc3RvcnlTdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRSZWNlbnRUcmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldEZ4UmF0ZXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1BsYWNlTGltaXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUGxhY2VNYXJrZXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldE9wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldENsb3NlZE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnR2V0Q2xvc2VkRmlsbGVkT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRPcmRlckRldGFpbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldEFjY291bnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXRUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldERpZ2l0YWxDdXJyZW5jeURlcG9zaXRBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXREaWdpdGFsQ3VycmVuY3lEZXBvc2l0QWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTeW5jaERpZ2l0YWxDdXJyZW5jeURlcG9zaXRBZGRyZXNzV2l0aEJsb2NrY2hhaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dpdGhkcmF3RGlnaXRhbEN1cnJlbmN5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSZXF1ZXN0RmlhdFdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dldFRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBiYXNlQ3VycmVuY2llcyA9IGF3YWl0IHRoaXMucHVibGljR2V0VmFsaWRQcmltYXJ5Q3VycmVuY3lDb2RlcyAoKTtcbiAgICAgICAgbGV0IHF1b3RlQ3VycmVuY2llcyA9IGF3YWl0IHRoaXMucHVibGljR2V0VmFsaWRTZWNvbmRhcnlDdXJyZW5jeUNvZGVzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZUN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiYXNlSWQgPSBiYXNlQ3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBiYXNlSWRVcHBlcmNhc2UgPSBiYXNlSWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlSWRVcHBlcmNhc2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBxdW90ZUN1cnJlbmNpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGVJZCA9IHF1b3RlQ3VycmVuY2llc1tqXTtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGVJZFVwcGVyY2FzZSA9IHF1b3RlSWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlSWRVcHBlcmNhc2UpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IGJhc2VJZCArICcvJyArIHF1b3RlSWQ7XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgICAgICBsZXQgdGFrZXIgPSAwLjUgLyAxMDA7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2VyID0gMC41IC8gMTAwO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICAgICAnYmFzZUlkJzogYmFzZUlkLFxuICAgICAgICAgICAgICAgICAgICAncXVvdGVJZCc6IHF1b3RlSWQsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IHRha2VyLFxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiBtYWtlcixcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEFjY291bnRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsYW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbaV07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3lDb2RlID0gYmFsYW5jZVsnQ3VycmVuY3lDb2RlJ107XG4gICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gY3VycmVuY3lDb2RlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHVwcGVyY2FzZSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VbJ0F2YWlsYWJsZUJhbGFuY2UnXTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBiYWxhbmNlWydUb3RhbEJhbGFuY2UnXTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwcmltYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydiYXNlSWQnXSxcbiAgICAgICAgICAgICdzZWNvbmRhcnlDdXJyZW5jeUNvZGUnOiBtYXJrZXRbJ3F1b3RlSWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAocmVzcG9uc2VbJ0NyZWF0ZWRUaW1lc3RhbXBVdGMnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChyZXNwb25zZSwgdGltZXN0YW1wLCAnQnV5T3JkZXJzJywgJ1NlbGxPcmRlcnMnLCAnUHJpY2UnLCAnVm9sdW1lJyk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodGlja2VyWydDcmVhdGVkVGltZXN0YW1wVXRjJ10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aWNrZXJbJ0RheUhpZ2hlc3RQcmljZSddLFxuICAgICAgICAgICAgJ2xvdyc6IHRpY2tlclsnRGF5TG93ZXN0UHJpY2UnXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbJ0N1cnJlbnRIaWdoZXN0QmlkUHJpY2UnXSxcbiAgICAgICAgICAgICdhc2snOiB0aWNrZXJbJ0N1cnJlbnRMb3dlc3RPZmZlclByaWNlJ10sXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aWNrZXJbJ0xhc3RQcmljZSddLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB0aWNrZXJbJ0RheUF2Z1ByaWNlJ10sXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRpY2tlclsnRGF5Vm9sdW1lWGJ0SW5TZWNvbmRhcnlDdXJycmVuY3knXSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRTdW1tYXJ5ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3ByaW1hcnlDdXJyZW5jeUNvZGUnOiBtYXJrZXRbJ2Jhc2VJZCddLFxuICAgICAgICAgICAgJ3NlY29uZGFyeUN1cnJlbmN5Q29kZSc6IG1hcmtldFsncXVvdGVJZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnVHJhZGVUaW1lc3RhbXBVdGMnXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydTZWNvbmRhcnlDdXJyZW5jeVRyYWRlUHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnUHJpbWFyeUN1cnJlbmN5QW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UmVjZW50VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3ByaW1hcnlDdXJyZW5jeUNvZGUnOiBtYXJrZXRbJ2Jhc2VJZCddLFxuICAgICAgICAgICAgJ3NlY29uZGFyeUN1cnJlbmN5Q29kZSc6IG1hcmtldFsncXVvdGVJZCddLFxuICAgICAgICAgICAgJ251bWJlck9mUmVjZW50VHJhZGVzVG9SZXRyaWV2ZSc6IDUwLCAvLyBtYXggPSA1MFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydUcmFkZXMnXSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGNhcGl0YWxpemVkT3JkZXJUeXBlID0gdGhpcy5jYXBpdGFsaXplICh0eXBlKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdQbGFjZScgKyBjYXBpdGFsaXplZE9yZGVyVHlwZSArICdPcmRlcic7XG4gICAgICAgIGxldCBvcmRlclR5cGUgPSBjYXBpdGFsaXplZE9yZGVyVHlwZTtcbiAgICAgICAgb3JkZXJUeXBlICs9IChzaWRlID09ICdzZWxsJykgPyAgJ09mZmVyJyA6ICdCaWQnO1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLm9yZGVyZWQgKHtcbiAgICAgICAgICAgICdwcmltYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydiYXNlSWQnXSxcbiAgICAgICAgICAgICdzZWNvbmRhcnlDdXJyZW5jeUNvZGUnOiBtYXJrZXRbJ3F1b3RlSWQnXSxcbiAgICAgICAgICAgICdvcmRlclR5cGUnOiBvcmRlclR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgb3JkZXJbJ3ZvbHVtZSddID0gYW1vdW50O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ09yZGVyR3VpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh7ICdvcmRlckd1aWQnOiBpZCB9KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV0gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gW1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAnYXBpS2V5PScgKyB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnbm9uY2U9JyArIG5vbmNlLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBrZXlzb3J0ZWQgPSB0aGlzLmtleXNvcnQgKHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChrZXlzb3J0ZWQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgYXV0aC5wdXNoIChrZXkgKyAnPScgKyBwYXJhbXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGF1dGguam9pbiAoJywnKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChtZXNzYWdlKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmtleXNvcnQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICAvLyB0b2RvIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBpdGJpdCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdpdGJpdCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdpdEJpdCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAyMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzgyMjE1OS02NjE1MzYyMC02MGFkLTExZTctODllNy0wMDVmNmQ3ZjNkZTAuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLml0Yml0LmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5pdGJpdC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2FwaS5pdGJpdC5jb20vZG9jcycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5pdGJpdC5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzL3tzeW1ib2x9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cy97c3ltYm9sfS9vcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzL3tzeW1ib2x9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldHMve3dhbGxldElkfS9iYWxhbmNlcy97Y3VycmVuY3lDb2RlfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0cy97d2FsbGV0SWR9L2Z1bmRpbmdfaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0cy97d2FsbGV0SWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0cy97d2FsbGV0SWR9L29yZGVycy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0X3RyYW5zZmVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0cy97d2FsbGV0SWR9L2NyeXB0b2N1cnJlbmN5X2RlcG9zaXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vY3J5cHRvY3VycmVuY3lfd2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dhbGxldHMve3dhbGxldElkfS9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpcmVfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0cy97d2FsbGV0SWR9L29yZGVycy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnWEJUVVNEJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgICAgICAgICAnQlRDL1NHRCc6IHsgJ2lkJzogJ1hCVFNHRCcsICdzeW1ib2wnOiAnQlRDL1NHRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdTR0QnIH0sXG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdYQlRFVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHNTeW1ib2xPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHNTeW1ib2xUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBzZXJ2ZXJUaW1lVVRDID0gKCdzZXJ2ZXJUaW1lVVRDJyBpbiB0aWNrZXIpO1xuICAgICAgICBpZiAoIXNlcnZlclRpbWVVVEMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hUaWNrZXIgcmV0dXJuZWQgYSBiYWQgcmVzcG9uc2U6ICcgKyB0aGlzLmpzb24gKHRpY2tlcikpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnc2VydmVyVGltZVVUQyddKTtcbiAgICAgICAgbGV0IHZ3YXAgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAyNGgnXSk7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUyNGgnXSk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IGJhc2VWb2x1bWUgKiB2d2FwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaDI0aCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdzI0aCddKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB2d2FwLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW5Ub2RheSddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0UHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSk7XG4gICAgICAgIGxldCBpZCA9IHRyYWRlWydtYXRjaE51bWJlciddLnRvU3RyaW5nICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ29yZGVyJzogaWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0c1N5bWJvbFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3JlY2VudFRyYWRlcyddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZUJhbGFuY2UnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsndG90YWxCYWxhbmNlJ10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgZmV0Y2hXYWxsZXRzICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZUdldFdhbGxldHMgKCk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCB3YWxsZXRJZEluUGFyYW1zID0gKCd3YWxsZXRJZCcgaW4gcGFyYW1zKTtcbiAgICAgICAgaWYgKCF3YWxsZXRJZEluUGFyYW1zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNyZWF0ZU9yZGVyIHJlcXVpcmVzIGEgd2FsbGV0SWQgcGFyYW1ldGVyJyk7XG4gICAgICAgIGFtb3VudCA9IGFtb3VudC50b1N0cmluZyAoKTtcbiAgICAgICAgcHJpY2UgPSBwcmljZS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZGlzcGxheSc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2luc3RydW1lbnQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZUFkZCAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHdhbGxldElkSW5QYXJhbXMgPSAoJ3dhbGxldElkJyBpbiBwYXJhbXMpO1xuICAgICAgICBpZiAoIXdhbGxldElkSW5QYXJhbXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgcmVxdWlyZXMgYSB3YWxsZXRJZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZURlbGV0ZVdhbGxldHNXYWxsZXRJZE9yZGVyc0lkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgdGltZXN0YW1wID0gbm9uY2U7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IFsgbWV0aG9kLCB1cmwsIGJvZHksIG5vbmNlLCB0aW1lc3RhbXAgXTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gbm9uY2UgKyB0aGlzLmpzb24gKGF1dGgpO1xuICAgICAgICAgICAgbGV0IGhhc2ggPSB0aGlzLmhhc2ggKHRoaXMuZW5jb2RlIChtZXNzYWdlKSwgJ3NoYTI1NicsICdiaW5hcnknKTtcbiAgICAgICAgICAgIGxldCBiaW5oYXNoID0gdGhpcy5iaW5hcnlDb25jYXQgKHVybCwgaGFzaCk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjIChiaW5oYXNoLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IHNlbGYuYXBpS2V5ICsgJzonICsgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ1gtQXV0aC1UaW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgJ1gtQXV0aC1Ob25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2NvZGUnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGJ0Y2JveCA9IHJlcXVpcmUgKCcuL2J0Y2JveC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGp1YmkgZXh0ZW5kcyBidGNib3gge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2p1YmknLFxuICAgICAgICAgICAgJ25hbWUnOiAnanViaS5jb20nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1ODEtOWQzOTdkOWEtNWVkZC0xMWU3LThmYjktNWQ4MjM2YzBlNjkyLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5qdWJpLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuanViaS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuanViaS5jb20vaGVscC9hcGkuaHRtbCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0QWxsdGlja2VyICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gJ0NOWSc7IC8vIHRvZG9cbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZU5vdEF2YWlsYWJsZSwgRXhjaGFuZ2VFcnJvciwgT3JkZXJOb3RGb3VuZCwgRERvU1Byb3RlY3Rpb24sIEludmFsaWROb25jZSwgSW5zdWZmaWNpZW50RnVuZHMsIENhbmNlbFBlbmRpbmcsIEludmFsaWRPcmRlciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mga3Jha2VuIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2tyYWtlbicsXG4gICAgICAgICAgICAnbmFtZSc6ICdLcmFrZW4nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgICAgICAgICAndmVyc2lvbic6ICcwJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAzMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hNeVRyYWRlcyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ3VycmVuY2llcyc6IHRydWUsXG4gICAgICAgICAgICAvLyBuZXcgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaEN1cnJlbmNpZXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hNeVRyYWRlcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0c0J5QWx0bmFtZSc6IHt9LFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFtJzogJzEnLFxuICAgICAgICAgICAgICAgICc1bSc6ICc1JyxcbiAgICAgICAgICAgICAgICAnMTVtJzogJzE1JyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJzMwJyxcbiAgICAgICAgICAgICAgICAnMWgnOiAnNjAnLFxuICAgICAgICAgICAgICAgICc0aCc6ICcyNDAnLFxuICAgICAgICAgICAgICAgICcxZCc6ICcxNDQwJyxcbiAgICAgICAgICAgICAgICAnMXcnOiAnMTAwODAnLFxuICAgICAgICAgICAgICAgICcydyc6ICcyMTYwMCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU5OS0yMjcwOTMwNC01ZWRlLTExZTctOWRlMS05ZjMzNzMyZTE1MDkuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmtyYWtlbi5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cua3Jha2VuLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LmtyYWtlbi5jb20vZW4tdXMvaGVscC9hcGknLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL25vdGhpbmdpc2RlYWQvbnBtLWtyYWtlbi1hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2ZlZXMnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5rcmFrZW4uY29tL2VuLXVzL2hlbHAvZmVlcycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3N1cHBvcnQua3Jha2VuLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8yMDEzOTY3NzctV2hhdC1hcmUtdGhlLWRlcG9zaXQtZmVlcy0nLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9zdXBwb3J0LmtyYWtlbi5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMjAxODkzNjA4LVdoYXQtYXJlLXRoZS13aXRoZHJhd2FsLWZlZXMtJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjI2IC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjE2IC8gMTAwLFxuICAgICAgICAgICAgICAgICAgICAndGllcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndGFrZXInOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzAsIDAuMjYgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs1MDAwMCwgMC4yNCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEwMDAwMCwgMC4yMiAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzI1MDAwMCwgMC4yIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNTAwMDAwLCAwLjE4IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTAwMDAwMCwgMC4xNiAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzI1MDAwMDAsIDAuMTQgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs1MDAwMDAwLCAwLjEyIC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMTAwMDAwMDAsIDAuMSAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswLCAwLjE2IC8gMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNTAwMDAsIDAuMTQgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxMDAwMDAsIDAuMTIgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsyNTAwMDAsIDAuMTAgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFs1MDAwMDAsIDAuOCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEwMDAwMDAsIDAuNiAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzI1MDAwMDAsIDAuNCAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzUwMDAwMDAsIDAuMiAvIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzEwMDAwMDAwLCAwLjAgLyAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYUlAnOiAwLjAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hMTSc6IDAuMDAwMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTFRDJzogMC4wMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdET0dFJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdaRUMnOiAwLjAwMDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lDTic6IDAuMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUkVQJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEMnOiAwLjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdNTE4nOiAwLjAwMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYTVInOiAwLjA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLjAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHTk8nOiAwLjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VPUyc6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQ0gnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVU0QnOiA1LCAvLyBpZiBkb21lc3RpYyB3aXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVVSJzogNSwgLy8gaWYgZG9tZXN0aWMgd2lyZVxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NBRCc6IDEwLCAvLyBDQUQgRUZUIFdpdGhkcmF3YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICdKUFknOiAzMDAsIC8vIGlmIGRvbWVzdGljIHdpcmVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1hSUCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWExNJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RPR0UnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1pFQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSUNOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSRVAnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnTUxOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYTVInOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0dOTyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRU9TJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdCQ0gnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VTRCc6IDUsIC8vIGlmIGRvbWVzdGljIHdpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVVInOiAwLCAvLyBmcmVlIGRlcG9zaXQgaWYgRVVSIFNFUEEgRGVwb3NpdFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NBRCc6IDUsIC8vIGlmIGRvbWVzdGljIHdpcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICdKUFknOiAwLCAvLyBEb21lc3RpYyBEZXBvc2l0IChGcmVlLCDCpTUsMDAwIGRlcG9zaXQgbWluaW11bSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdBc3NldHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0Fzc2V0UGFpcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RlcHRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPSExDJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdTcHJlYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGltZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdBZGRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0Nsb3NlZE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRGVwb3NpdEFkZHJlc3NlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRGVwb3NpdE1ldGhvZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RlcG9zaXRTdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xlZGdlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ09wZW5Qb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1F1ZXJ5TGVkZ2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUXVlcnlPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1F1ZXJ5VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZUJhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlc0hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYWRlVm9sdW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2l0aGRyYXdDYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1dpdGhkcmF3SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2l0aGRyYXdTdGF0dXMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb3N0VG9QcmVjaXNpb24gKHN5bWJvbCwgY29zdCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cnVuY2F0ZSAocGFyc2VGbG9hdCAoY29zdCksIHRoaXMubWFya2V0c1tzeW1ib2xdWydwcmVjaXNpb24nXVsncHJpY2UnXSk7XG4gICAgfVxuXG4gICAgZmVlVG9QcmVjaXNpb24gKHN5bWJvbCwgZmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRydW5jYXRlIChwYXJzZUZsb2F0IChmZWUpLCB0aGlzLm1hcmtldHNbc3ltYm9sXVsncHJlY2lzaW9uJ11bJ2Ftb3VudCddKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgaWYgKGJvZHkuaW5kZXhPZiAoJ0ludmFsaWQgbm9uY2UnKSA+PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWROb25jZSAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICBpZiAoYm9keS5pbmRleE9mICgnSW5zdWZmaWNpZW50IGZ1bmRzJykgPj0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICBpZiAoYm9keS5pbmRleE9mICgnQ2FuY2VsIHBlbmRpbmcnKSA+PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IENhbmNlbFBlbmRpbmcgKHRoaXMuaWQgKyAnICcgKyBib2R5KTtcbiAgICAgICAgaWYgKGJvZHkuaW5kZXhPZiAoJ0ludmFsaWQgYXJndW1lbnRzOnZvbHVtZScpID49IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyAnICsgYm9keSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEFzc2V0UGFpcnMgKCk7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHNbJ3Jlc3VsdCddKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sncmVzdWx0J11baWRdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2UnXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsncXVvdGUnXTtcbiAgICAgICAgICAgIGlmICgoYmFzZVswXSA9PSAnWCcpIHx8IChiYXNlWzBdID09ICdaJykpXG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2Uuc2xpY2UgKDEpO1xuICAgICAgICAgICAgaWYgKChxdW90ZVswXSA9PSAnWCcpIHx8IChxdW90ZVswXSA9PSAnWicpKVxuICAgICAgICAgICAgICAgIHF1b3RlID0gcXVvdGUuc2xpY2UgKDEpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBkYXJrcG9vbCA9IGlkLmluZGV4T2YgKCcuZCcpID49IDA7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gZGFya3Bvb2wgPyBtYXJrZXRbJ2FsdG5hbWUnXSA6IChiYXNlICsgJy8nICsgcXVvdGUpO1xuICAgICAgICAgICAgbGV0IG1ha2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCdmZWVzX21ha2VyJyBpbiBtYXJrZXQpIHtcbiAgICAgICAgICAgICAgICBtYWtlciA9IHBhcnNlRmxvYXQgKG1hcmtldFsnZmVlc19tYWtlciddWzBdWzFdKSAvIDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSB7XG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IG1hcmtldFsnbG90X2RlY2ltYWxzJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogbWFya2V0WydwYWlyX2RlY2ltYWxzJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGxvdCA9IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnZGFya3Bvb2wnOiBkYXJrcG9vbCxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnYWx0bmFtZSc6IG1hcmtldFsnYWx0bmFtZSddLFxuICAgICAgICAgICAgICAgICdtYWtlcic6IG1ha2VyLFxuICAgICAgICAgICAgICAgICd0YWtlcic6IHBhcnNlRmxvYXQgKG1hcmtldFsnZmVlcyddWzBdWzFdKSAvIDEwMCxcbiAgICAgICAgICAgICAgICAnbG90JzogbG90LFxuICAgICAgICAgICAgICAgICdhY3RpdmUnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsncHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBlbmRJbmFjdGl2ZU1hcmtldHMgKHJlc3VsdCk7XG4gICAgICAgIHRoaXMubWFya2V0c0J5QWx0bmFtZSA9IHRoaXMuaW5kZXhCeSAocmVzdWx0LCAnYWx0bmFtZScpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFwcGVuZEluYWN0aXZlTWFya2V0cyAocmVzdWx0ID0gW10pIHtcbiAgICAgICAgbGV0IHByZWNpc2lvbiA9IHsgJ2Ftb3VudCc6IDgsICdwcmljZSc6IDggfTtcbiAgICAgICAgbGV0IGNvc3RMaW1pdHMgPSB7ICdtaW4nOiAwLCAnbWF4JzogdW5kZWZpbmVkIH07XG4gICAgICAgIGxldCBwcmljZUxpbWl0cyA9IHsgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsncHJpY2UnXSksICdtYXgnOiB1bmRlZmluZWQgfTtcbiAgICAgICAgbGV0IGFtb3VudExpbWl0cyA9IHsgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pLCAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ2Ftb3VudCddKSB9O1xuICAgICAgICBsZXQgbGltaXRzID0geyAnYW1vdW50JzogYW1vdW50TGltaXRzLCAncHJpY2UnOiBwcmljZUxpbWl0cywgJ2Nvc3QnOiBjb3N0TGltaXRzIH07XG4gICAgICAgIGxldCBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICdkYXJrcG9vbCc6IGZhbHNlLFxuICAgICAgICAgICAgJ2luZm8nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbWFrZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndGFrZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG90JzogYW1vdW50TGltaXRzWydtaW4nXSxcbiAgICAgICAgICAgICdhY3RpdmUnOiBmYWxzZSxcbiAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAnbGltaXRzJzogbGltaXRzLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbWFya2V0cyA9IFtcbiAgICAgICAgICAgIHsgJ2lkJzogJ1hYTE1aRVVSJywgJ3N5bWJvbCc6ICdYTE0vRVVSJywgJ2Jhc2UnOiAnWExNJywgJ3F1b3RlJzogJ0VVUicsICdhbHRuYW1lJzogJ1hMTUVVUicgfSxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5leHRlbmQgKGRlZmF1bHRzLCBtYXJrZXRzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEN1cnJlbmNpZXMgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0QXNzZXRzIChwYXJhbXMpO1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChjdXJyZW5jaWVzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpZF07XG4gICAgICAgICAgICAvLyB0b2RvOiB3aWxsIG5lZWQgdG8gcmV0aGluayB0aGUgZmVlc1xuICAgICAgICAgICAgLy8gdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIHdpdGhkcmF3YWwvZGVwb3NpdCBtZXRob2RzIGFuZFxuICAgICAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgZmVlcyBmb3IgZWFjaCBwYXJ0aWN1bGFyIG1ldGhvZFxuICAgICAgICAgICAgbGV0IGNvZGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3lbJ2FsdG5hbWUnXSk7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBjdXJyZW5jeVsnZGVjaW1hbHMnXSwgLy8gZGVmYXVsdCBwcmVjaXNpb24sIHRvZG86IGZpeCBcIm1hZ2ljIGNvbnN0YW50c1wiXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogY3VycmVuY3lbJ2RlY2ltYWxzJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2NvZGVdID0ge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdjb2RlJzogY29kZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICduYW1lJzogY29kZSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBNYXRoLnBvdyAoMTAsIHByZWNpc2lvblsnYW1vdW50J10pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBNYXRoLnBvdyAoMTAsIHByZWNpc2lvblsncHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBkYXJrcG9vbCA9IHN5bWJvbC5pbmRleE9mICgnLmQnKSA+PSAwO1xuICAgICAgICBpZiAoZGFya3Bvb2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZG9lcyBub3QgcHJvdmlkZSBhbiBvcmRlciBib29rIGZvciBkYXJrcG9vbCBzeW1ib2wgJyArIHN5bWJvbCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydyZXN1bHQnXVttYXJrZXRbJ2lkJ11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3YnXVsxXSk7XG4gICAgICAgIGxldCB2d2FwID0gcGFyc2VGbG9hdCAodGlja2VyWydwJ11bMV0pO1xuICAgICAgICBsZXQgcXVvdGVWb2x1bWUgPSBiYXNlVm9sdW1lICogdndhcDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2gnXVsxXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsJ11bMV0pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYiddWzBdKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2EnXVswXSksXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnbyddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydjJ11bMF0pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IGJhc2VWb2x1bWUsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBxdW90ZVZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5zeW1ib2xzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gdGhpcy5zeW1ib2xzW3NdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICAgICAgaWYgKG1hcmtldFsnYWN0aXZlJ10pXG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrZXRbJ2Rhcmtwb29sJ10pXG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2ggKG1hcmtldFsnaWQnXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbHRlciA9IHBhaXJzLmpvaW4gKCcsJyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBmaWx0ZXIsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGRhcmtwb29sID0gc3ltYm9sLmluZGV4T2YgKCcuZCcpID49IDA7XG4gICAgICAgIGlmIChkYXJrcG9vbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBkb2VzIG5vdCBwcm92aWRlIGEgdGlja2VyIGZvciBkYXJrcG9vbCBzeW1ib2wgJyArIHN5bWJvbCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsncmVzdWx0J11bbWFya2V0WydpZCddXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WzBdICogMTAwMCxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzFdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzJdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzNdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzRdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzZdKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2ludGVydmFsJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3NpbmNlJ10gPSBwYXJzZUludCAoc2luY2UgLyAxMDAwKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPSExDICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvaGxjdnMgPSByZXNwb25zZVsncmVzdWx0J11bbWFya2V0WydpZCddXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKG9obGN2cywgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgc2lkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBwcmljZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGFtb3VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGlkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgb3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBmZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5maW5kTWFya2V0QnlBbHRuYW1lT3JJZCAodHJhZGVbJ3BhaXInXSk7XG4gICAgICAgIGlmICgnb3JkZXJ0eGlkJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgb3JkZXIgPSB0cmFkZVsnb3JkZXJ0eGlkJ107XG4gICAgICAgICAgICBpZCA9IHRyYWRlWydpZCddO1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWyd0aW1lJ10gKiAxMDAwKTtcbiAgICAgICAgICAgIHNpZGUgPSB0cmFkZVsndHlwZSddO1xuICAgICAgICAgICAgdHlwZSA9IHRyYWRlWydvcmRlcnR5cGUnXTtcbiAgICAgICAgICAgIHByaWNlID0gcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pO1xuICAgICAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCAodHJhZGVbJ3ZvbCddKTtcbiAgICAgICAgICAgIGlmICgnZmVlJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeSA9IG1hcmtldFsncXVvdGUnXTtcbiAgICAgICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICdjb3N0JzogcGFyc2VGbG9hdCAodHJhZGVbJ2ZlZSddKSxcbiAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsyXSAqIDEwMDApO1xuICAgICAgICAgICAgc2lkZSA9ICh0cmFkZVszXSA9PSAncycpID8gJ3NlbGwnIDogJ2J1eSc7XG4gICAgICAgICAgICB0eXBlID0gKHRyYWRlWzRdID09ICdsJykgPyAnbGltaXQnIDogJ21hcmtldCc7XG4gICAgICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQgKHRyYWRlWzBdKTtcbiAgICAgICAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQgKHRyYWRlWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ltYm9sID0gKG1hcmtldCkgPyBtYXJrZXRbJ3N5bWJvbCddIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnb3JkZXInOiBvcmRlcixcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmZWUnOiBmZWUsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBpZCA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRyYWRlcyA9IHJlc3BvbnNlWydyZXN1bHQnXVtpZF07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAoYmFsYW5jZXMpO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgY29kZSA9IGN1cnJlbmN5O1xuICAgICAgICAgICAgLy8gWC1JU080MjE3LUEzIHN0YW5kYXJkIGN1cnJlbmN5IGNvZGVzXG4gICAgICAgICAgICBpZiAoY29kZVswXSA9PSAnWCcpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5zbGljZSAoMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGVbMF0gPT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUuc2xpY2UgKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChjb2RlKTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbY3VycmVuY3ldKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjb2RlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnb3JkZXJ0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICd2b2x1bWUnOiB0aGlzLmFtb3VudFRvUHJlY2lzaW9uIChzeW1ib2wsIGFtb3VudCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHRoaXMucHJpY2VUb1ByZWNpc2lvbiAoc3ltYm9sLCBwcmljZSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RBZGRPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHJlc3BvbnNlWydyZXN1bHQnXVsndHhpZCddLmxlbmd0aDtcbiAgICAgICAgbGV0IGlkID0gKGxlbmd0aCA+IDEpID8gcmVzcG9uc2VbJ3Jlc3VsdCddWyd0eGlkJ10gOiByZXNwb25zZVsncmVzdWx0J11bJ3R4aWQnXVswXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmaW5kTWFya2V0QnlBbHRuYW1lT3JJZCAoaWQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c0J5QWx0bmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXJrZXRzQnlBbHRuYW1lW2lkXTtcbiAgICAgICAgfSBlbHNlIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBkZXNjcmlwdGlvbiA9IG9yZGVyWydkZXNjciddO1xuICAgICAgICBsZXQgc2lkZSA9IGRlc2NyaXB0aW9uWyd0eXBlJ107XG4gICAgICAgIGxldCB0eXBlID0gZGVzY3JpcHRpb25bJ29yZGVydHlwZSddO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW1hcmtldClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMuZmluZE1hcmtldEJ5QWx0bmFtZU9ySWQgKGRlc2NyaXB0aW9uWydwYWlyJ10pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyWydvcGVudG0nXSAqIDEwMDApO1xuICAgICAgICBsZXQgYW1vdW50ID0gcGFyc2VGbG9hdCAob3JkZXJbJ3ZvbCddKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHBhcnNlRmxvYXQgKG9yZGVyWyd2b2xfZXhlYyddKTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IGFtb3VudCAtIGZpbGxlZDtcbiAgICAgICAgbGV0IGZlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvc3QgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdjb3N0Jyk7XG4gICAgICAgIGxldCBwcmljZSA9IHRoaXMuc2FmZUZsb2F0IChkZXNjcmlwdGlvbiwgJ3ByaWNlJyk7XG4gICAgICAgIGlmICghcHJpY2UpXG4gICAgICAgICAgICBwcmljZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ3ByaWNlJyk7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBpZiAoJ2ZlZScgaW4gb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBvcmRlclsnb2ZsYWdzJ107XG4gICAgICAgICAgICAgICAgbGV0IGZlZUNvc3QgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdmZWUnKTtcbiAgICAgICAgICAgICAgICBmZWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICdjb3N0JzogZmVlQ29zdCxcbiAgICAgICAgICAgICAgICAgICAgJ3JhdGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZiAoJ2ZjaXEnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlZVsnY3VycmVuY3knXSA9IG1hcmtldFsncXVvdGUnXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLmluZGV4T2YgKCdmY2liJykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZWVbJ2N1cnJlbmN5J10gPSBtYXJrZXRbJ2Jhc2UnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3RhdHVzJzogb3JkZXJbJ3N0YXR1cyddLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgICAgIC8vICd0cmFkZXMnOiB0aGlzLnBhcnNlVHJhZGVzIChvcmRlclsndHJhZGVzJ10sIG1hcmtldCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlcnMgKG9yZGVycywgbWFya2V0ID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKG9yZGVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLmV4dGVuZCAoeyAnaWQnOiBpZCB9LCBvcmRlcnNbaWRdKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLnBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeVNpbmNlTGltaXQgKHJlc3VsdCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UXVlcnlPcmRlcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAndHJhZGVzJzogdHJ1ZSwgLy8gd2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0cmFkZXMgaW4gb3V0cHV0IChvcHRpb25hbCwgZGVmYXVsdCBmYWxzZSlcbiAgICAgICAgICAgICd0eGlkJzogaWQsIC8vIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIHRyYW5zYWN0aW9uIGlkcyB0byBxdWVyeSBpbmZvIGFib3V0ICgyMCBtYXhpbXVtKVxuICAgICAgICAgICAgLy8gJ3VzZXJyZWYnOiAnb3B0aW9uYWwnLCAvLyByZXN0cmljdCByZXN1bHRzIHRvIGdpdmVuIHVzZXIgcmVmZXJlbmNlIGlkIChvcHRpb25hbClcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcnMgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMucGFyc2VPcmRlciAodGhpcy5leHRlbmQgKHsgJ2lkJzogaWQgfSwgb3JkZXJzW2lkXSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmQgKHsgJ2luZm8nOiByZXNwb25zZSB9LCBvcmRlcik7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgLy8gJ3R5cGUnOiAnYWxsJywgLy8gYW55IHBvc2l0aW9uLCBjbG9zZWQgcG9zaXRpb24sIGNsb3NpbmcgcG9zaXRpb24sIG5vIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyAndHJhZGVzJzogZmFsc2UsIC8vIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdHJhZGVzIHJlbGF0ZWQgdG8gcG9zaXRpb24gaW4gb3V0cHV0XG4gICAgICAgICAgICAvLyAnc3RhcnQnOiAxMjM0NTY3ODkwLCAvLyBzdGFydGluZyB1bml4IHRpbWVzdGFtcCBvciB0cmFkZSB0eCBpZCBvZiByZXN1bHRzIChleGNsdXNpdmUpXG4gICAgICAgICAgICAvLyAnZW5kJzogMTIzNDU2Nzg5MCwgLy8gZW5kaW5nIHVuaXggdGltZXN0YW1wIG9yIHRyYWRlIHR4IGlkIG9mIHJlc3VsdHMgKGluY2x1c2l2ZSlcbiAgICAgICAgICAgIC8vICdvZnMnID0gcmVzdWx0IG9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydCddID0gcGFyc2VJbnQgKHNpbmNlIC8gMTAwMCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZXNIaXN0b3J5ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0cmFkZXMgPSByZXNwb25zZVsncmVzdWx0J11bJ3RyYWRlcyddO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRyYWRlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmFkZXNbaWRzW2ldXVsnaWQnXSA9IGlkc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAodHJhZGVzLCB1bmRlZmluZWQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICd0eGlkJzogaWQsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RfaHR0cF9yZXNwb25zZS5pbmRleE9mICgnRU9yZGVyOlVua25vd24gb3JkZXInKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIoKSBlcnJvciAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgaWYgKHNpbmNlKVxuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnQnXSA9IHBhcnNlSW50IChzaW5jZSAvIDEwMDApO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3Blbk9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJzID0gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3Jlc3VsdCddWydvcGVuJ10sIHVuZGVmaW5lZCwgc2luY2UsIGxpbWl0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyT3JkZXJzQnlTeW1ib2wgKG9yZGVycywgc3ltYm9sKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaENsb3NlZE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0J10gPSBwYXJzZUludCAoc2luY2UgLyAxMDAwKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENsb3NlZE9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJzID0gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3Jlc3VsdCddWydjbG9zZWQnXSwgdW5kZWZpbmVkLCBzaW5jZSwgbGltaXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJPcmRlcnNCeVN5bWJvbCAob3JkZXJzLCBzeW1ib2wpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRGVwb3NpdE1ldGhvZHMgKGNvZGUgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmN5IChjb2RlKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ2Fzc2V0J10gPSBjdXJyZW5jeVsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0RGVwb3NpdE1ldGhvZHMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ25ldyc6ICd0cnVlJyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaERlcG9zaXRBZGRyZXNzIChjdXJyZW5jeSwgdGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IHJlc3BvbnNlWydhZGRyZXNzJ10sXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hEZXBvc2l0QWRkcmVzcyAoY29kZSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IHRoaXMuc2FmZVZhbHVlIChwYXJhbXMsICdtZXRob2QnKTtcbiAgICAgICAgaWYgKCFtZXRob2QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hEZXBvc2l0QWRkcmVzcygpIHJlcXVpcmVzIGFuIGV4dHJhIGBtZXRob2RgIHBhcmFtZXRlcicpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmN5IChjb2RlKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnYXNzZXQnOiBjdXJyZW5jeVsnaWQnXSxcbiAgICAgICAgICAgICdtZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAnbmV3JzogJ2ZhbHNlJyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdERlcG9zaXRBZGRyZXNzZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IG51bVJlc3VsdHMgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUmVzdWx0cyA8IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcHJpdmF0ZVBvc3REZXBvc2l0QWRkcmVzc2VzKCkgcmV0dXJuZWQgbm8gYWRkcmVzc2VzJyk7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdGhpcy5zYWZlU3RyaW5nIChyZXN1bHRbMF0sICdhZGRyZXNzJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjb2RlLFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoJ2tleScgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdhc3NldCc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAgICAgLy8gJ2FkZHJlc3MnOiBhZGRyZXNzLCAvLyB0aGV5IGRvbid0IGFsbG93IHdpdGhkcmF3YWxzIHRvIGRpcmVjdCBhZGRyZXNzZXNcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXN1bHQnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyBcIiB3aXRoZHJhdyByZXF1aXJlcyBhICdrZXknIHBhcmFtZXRlciAod2l0aGRyYXdhbCBrZXkgbmFtZSwgYXMgc2V0IHVwIG9uIHlvdXIgYWNjb3VudClcIik7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgYXBpICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLmVuY29kZSAobm9uY2UgKyBib2R5KTtcbiAgICAgICAgICAgIGxldCBoYXNoID0gdGhpcy5oYXNoIChhdXRoLCAnc2hhMjU2JywgJ2JpbmFyeScpO1xuICAgICAgICAgICAgbGV0IGJpbmFyeSA9IHRoaXMuc3RyaW5nVG9CaW5hcnkgKHRoaXMuZW5jb2RlICh1cmwpKTtcbiAgICAgICAgICAgIGxldCBiaW5oYXNoID0gdGhpcy5iaW5hcnlDb25jYXQgKGJpbmFyeSwgaGFzaCk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5iYXNlNjRUb0JpbmFyeSAodGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAoYmluaGFzaCwgc2VjcmV0LCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQVBJLUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdBUEktU2lnbic6IHRoaXMuZGVjb2RlIChzaWduYXR1cmUpLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHVybDtcbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxldCBudW1FcnJvcnMgPSByZXNwb25zZVsnZXJyb3InXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobnVtRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZVsnZXJyb3InXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ11baV0gPT0gJ0VTZXJ2aWNlOlVuYXZhaWxhYmxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZU5vdEF2YWlsYWJsZSAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydlcnJvciddW2ldID09ICdFU2VydmljZTpCdXN5JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEludmFsaWRPcmRlciwgSW5zdWZmaWNpZW50RnVuZHMsIE9yZGVyTm90Rm91bmQgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGt1Y29pbiBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdrdWNvaW4nLFxuICAgICAgICAgICAgJ25hbWUnOiAnS3Vjb2luJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSEsnLCAvLyBIb25nIEtvbmdcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IGZhbHNlLCAvLyBzZWUgdGhlIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiBiZWxvd1xuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE15VHJhZGVzJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hDdXJyZW5jaWVzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAvLyBuZXcgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9ITENWJzogdHJ1ZSwgLy8gc2VlIHRoZSBtZXRob2QgaW1wbGVtZW50YXRpb24gYmVsb3dcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiAnZW11bGF0ZWQnLFxuICAgICAgICAgICAgICAgICdmZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ2ZldGNoQ3VycmVuY2llcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMW1pbicsXG4gICAgICAgICAgICAgICAgJzVtJzogJzVtaW4nLFxuICAgICAgICAgICAgICAgICcxNW0nOiAnMTVtaW4nLFxuICAgICAgICAgICAgICAgICczMG0nOiAnMzBtaW4nLFxuICAgICAgICAgICAgICAgICcxaCc6ICcxaG91cicsXG4gICAgICAgICAgICAgICAgJzhoJzogJzhob3VyJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMWRheScsXG4gICAgICAgICAgICAgICAgJzF3JzogJzF3ZWVrJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMzNzk1NjU1LWIzYzQ2ZTQ4LWRjZjYtMTFlNy04YWJlLWRjNDU4OGJhNzkwMS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkua3Vjb2luLmNvbScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2t1Y29pbi5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9rdWNvaW5hcGlkb2NzLmRvY3MuYXBpYXJ5LmlvJyxcbiAgICAgICAgICAgICAgICAnZmVlcyc6ICdodHRwczovL25ld3Mua3Vjb2luLmNvbS9lbi9mZWUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuL2NoYXJ0L2NvbmZpZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbi9jaGFydC9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuL2NoYXJ0L3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbi9jdXJyZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuL2RlYWwtb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuL2tsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuL2xhbmctbGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbi9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW4vb3JkZXJzLWJ1eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbi9vcmRlcnMtc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3Blbi90aWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvb3Blbi9jb2luLWluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9vcGVuL2NvaW5zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvb3Blbi9jb2lucy10cmVuZGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L29wZW4vc3ltYm9scycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQve2NvaW59L3dhbGxldC9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50L3tjb2lufS93YWxsZXQvcmVjb3JkcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC97Y29pbn0vYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9wcm9tb3Rpb24vaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC9wcm9tb3Rpb24vc3VtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZWFsLW9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXIvYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9kZWFsdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVmZXJyZXIvZGVzY2VuZGFudC9jb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudC97Y29pbn0vd2l0aGRyYXcvYXBwbHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQve2NvaW59L3dpdGhkcmF3L2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsLW9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9jaGFuZ2UtbGFuZycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wMDEwLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjAwMTAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0T3BlblN5bWJvbHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0Wydjb2luVHlwZSddO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0Wydjb2luVHlwZVBhaXInXTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogOCxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiA4LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSBtYXJrZXRbJ3RyYWRpbmcnXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdsb3QnOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDdXJyZW5jaWVzIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldE9wZW5Db2lucyAocGFyYW1zKTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IGN1cnJlbmN5Wydjb2luJ107XG4gICAgICAgICAgICAvLyB0b2RvOiB3aWxsIG5lZWQgdG8gcmV0aGluayB0aGUgZmVlc1xuICAgICAgICAgICAgLy8gdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIHdpdGhkcmF3YWwvZGVwb3NpdCBtZXRob2RzIGFuZFxuICAgICAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgZmVlcyBmb3IgZWFjaCBwYXJ0aWN1bGFyIG1ldGhvZFxuICAgICAgICAgICAgbGV0IGNvZGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoaWQpO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogY3VycmVuY3lbJ3RyYWRlUHJlY2lzaW9uJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogY3VycmVuY3lbJ3RyYWRlUHJlY2lzaW9uJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGRlcG9zaXQgPSBjdXJyZW5jeVsnZW5hYmxlRGVwb3NpdCddO1xuICAgICAgICAgICAgbGV0IHdpdGhkcmF3ID0gY3VycmVuY3lbJ2VuYWJsZVdpdGhkcmF3J107XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gKGRlcG9zaXQgJiYgd2l0aGRyYXcpO1xuICAgICAgICAgICAgcmVzdWx0W2NvZGVdID0ge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdjb2RlJzogY29kZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICduYW1lJzogY3VycmVuY3lbJ25hbWUnXSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICdzdGF0dXMnOiAnb2snLFxuICAgICAgICAgICAgICAgICdmZWUnOiBjdXJyZW5jeVsnd2l0aGRyYXdGZWVSYXRlJ10sIC8vIHRvZG86IHJlZGVzaWduXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydwcmljZSddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGN1cnJlbmN5Wyd3aXRoZHJhd01pbkFtb3VudCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IE1hdGgucG93ICgxMCwgcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaEJhbGFuY2UoKSAvIHByaXZhdGUgQVBJIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgLy8gIEpVTksgRlJPTSBTT01FIE9USEVSIEVYQ0hBTkdFLCBURU1QTEFURVxuICAgICAgICAvLyAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hY2NvdW50R2V0QmFsYW5jZXMgKCk7XG4gICAgICAgIC8vICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIC8vICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIC8vICBsZXQgaW5kZXhlZCA9IHRoaXMuaW5kZXhCeSAoYmFsYW5jZXMsICdDdXJyZW5jeScpO1xuICAgICAgICAvLyAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAoaW5kZXhlZCk7XG4gICAgICAgIC8vICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgICBsZXQgaWQgPSBrZXlzW2ldO1xuICAgICAgICAvLyAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChpZCk7XG4gICAgICAgIC8vICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgIC8vICAgICAgbGV0IGJhbGFuY2UgPSBpbmRleGVkW2lkXTtcbiAgICAgICAgLy8gICAgICBsZXQgZnJlZSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ0F2YWlsYWJsZSddKTtcbiAgICAgICAgLy8gICAgICBsZXQgdG90YWwgPSBwYXJzZUZsb2F0IChiYWxhbmNlWydCYWxhbmNlJ10pO1xuICAgICAgICAvLyAgICAgIGxldCB1c2VkID0gdG90YWwgLSBmcmVlO1xuICAgICAgICAvLyAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGZyZWU7XG4gICAgICAgIC8vICAgICAgYWNjb3VudFsndXNlZCddID0gdXNlZDtcbiAgICAgICAgLy8gICAgICBhY2NvdW50Wyd0b3RhbCddID0gdG90YWw7XG4gICAgICAgIC8vICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIC8vICB9XG4gICAgICAgIC8vIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3Blbk9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnQlVZJywgJ1NFTEwnKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsnZGF0ZXRpbWUnXTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IHRpY2tlclsnY29pblR5cGUnXSArICcvJyArIHRpY2tlclsnY29pblR5cGVQYWlyJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnaGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5JyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3NlbGwnKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0RGVhbFByaWNlJyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbCcpLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbFZhbHVlJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0T3BlblN5bWJvbHMgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpY2tlcnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXJzW3RdKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB0aWNrZXJbJ3N5bWJvbCddO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aWNrZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3BlblRpY2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbMF07XG4gICAgICAgIGxldCBzaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhZGVbMV0gPT0gJ0JVWScpIHtcbiAgICAgICAgICAgIHNpZGUgPSAnYnV5JztcbiAgICAgICAgfSBlbHNlIGlmICh0cmFkZVsxXSA9PSAnU0VMTCcpIHtcbiAgICAgICAgICAgIHNpZGUgPSAnc2VsbCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6ICdsaW1pdCcsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsyXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVszXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcGVuRGVhbE9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ2RhdGEnXSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxZCcsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9obGN2WydUJ10pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgb2hsY3ZbJ08nXSxcbiAgICAgICAgICAgIG9obGN2WydIJ10sXG4gICAgICAgICAgICBvaGxjdlsnTCddLFxuICAgICAgICAgICAgb2hsY3ZbJ0MnXSxcbiAgICAgICAgICAgIG9obGN2WydWJ10sXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRvID0gdGhpcy5zZWNvbmRzICgpO1xuICAgICAgICAvLyB3aGF0ZXZlciBJIHRyeSB3aXRoIGZyb20gKyB0byArIGxpbWl0IGl0IGRvZXMgbm90IHdvcmsgKGFsd2F5cyBhbiBlbXB0eSByZXNwb25zZSlcbiAgICAgICAgLy8gdHJpZWQgYWxsIGNvbWJpbmF0aW9uczpcbiAgICAgICAgLy8gLSByZXZlcnNpbmcgdGhlbVxuICAgICAgICAvLyAtIGNoYW5naW5nIGRpcmVjdGlvbnNcbiAgICAgICAgLy8gLSBzZWNvbmRzXG4gICAgICAgIC8vIC0gbWlsbGlzZWNvbmRzXG4gICAgICAgIC8vIC0gZGF0ZXRpbWUgc3RyaW5nc1xuICAgICAgICAvLyB0aGUgZW5kcG9pbnQgZG9lc24ndCBzZWVtIHRvIHdvcmssIG9yIHNvbWV0aGluZyBpcyBtaXNzaW5nIGluIHRoZWlyIGRvY3NcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgICAgICdmcm9tJzogdG8gLSA4NjQwMCxcbiAgICAgICAgICAgICd0byc6IHRvLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ2Zyb20nXSA9IHBhcnNlSW50IChzaW5jZSAvIDEwMDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3BlbktsaW5lICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZVsnZGF0YSddLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBlbmRwb2ludCA9ICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyBlbmRwb2ludDtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcHJpdmF0ZSBBUEkgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvLyBGUk9NIEtVQ09JTjpcbiAgICAgICAgICAgIC8vIFN0cmluZyBob3N0ID0gXCJodHRwczovL2FwaS5rdWNvaW4uY29tXCI7XG4gICAgICAgICAgICAvLyBTdHJpbmcgZW5kcG9pbnQgPSBcIi92MS9LQ1MtQlRDL29yZGVyXCI7IC8vIEFQSSBlbmRwb2ludFxuICAgICAgICAgICAgLy8gU3RyaW5nIHNlY3JldDsgLy8gVGhlIHNlY3JldCBhc3NpZ25lZCB3aGVuIHRoZSBBUEkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gUE9TVCBwYXJhbWV0ZXJz77yaXG4gICAgICAgICAgICAvLyAgICAgdHlwZTogQlVZXG4gICAgICAgICAgICAvLyAgICAgYW1vdW50OiAxMFxuICAgICAgICAgICAgLy8gICAgIHByaWNlOiAxLjFcbiAgICAgICAgICAgIC8vICAgICBBcnJhbmdlIHRoZSBwYXJhbWV0ZXJzIGluIGFzY2VuZGluZyBhbHBoYWJldGljYWwgb3JkZXIgKGxvd2VyIGNhc2VzIGZpcnN0KSwgdGhlbiBjb21iaW5lIHRoZW0gd2l0aCAmIChkb24ndCB1cmxlbmNvZGUgdGhlbSwgZG9uJ3QgYWRkID8sIGRvbid0IGFkZCBleHRyYSAmKSwgZS5nLiBhbW91bnQ9MTAmcHJpY2U9MS4xJnR5cGU9QlVZXG4gICAgICAgICAgICAvLyAgICAg5bCG5p+l6K+i5Y+C5pWw5oyJ54Wn5a2X5q+N5Y2H5bqPKOWwj+Wtl+avjeWcqOWJjSnmjpLliJflkI7nlKgm6L+b6KGM6L+e5o6lKOivt+S4jeimgei/m+ihjHVybGVuY29kZeaTjeS9nCzlvIDlpLTkuI3opoHluKY/LOmmluS9jeS4jeimgeaciemineWklueahCbnrKblj7cp5b6X5Yiw55qEcXVlcnlTdHJpbmflpoI6ICBhbW91bnQ9MTAmcHJpY2U9MS4xJnR5cGU9QlVZXG4gICAgICAgICAgICAvLyBTdHJpbmcgcXVlcnlTdHJpbmc7XG4gICAgICAgICAgICAvLyAvLyBzcGxpY2Ugc3RyaW5nIGZvciBzaWduaW5nXG4gICAgICAgICAgICAvLyBTdHJpbmcgc3RyRm9yU2lnbiA9IGVuZHBvaW50ICsgXCIvXCIgKyBub25jZSArIFwiL1wiICsgcXVlcnlTdHJpbmc7XG4gICAgICAgICAgICAvLyAvLyBNYWtlIGEgQmFzZTY0IGVuY29kaW5nIG9mIHRoZSBjb21wbGV0ZWQgc3RyaW5nXG4gICAgICAgICAgICAvLyBTdHJpbmcgc2lnbmF0dXJlU3RyID0gQmFzZTY0LmdldEVuY29kZXIoKS5lbmNvZGVUb1N0cmluZyhzdHJGb3JTaWduLmdldEJ5dGVzKFwiVVRGLThcIikpO1xuICAgICAgICAgICAgLy8gLy8gS0MtQVBJLVNJR05BVFVSRSBpbiBoZWFkZXJcbiAgICAgICAgICAgIC8vIFN0cmluZyBzaWduYXR1cmVSZXN1bHQgPSBobWFjRW5jcnlwdChcIkhtYWNTSEEyNTZcIiwgc2lnbmF0dXJlU3RyLCBzZWNyZXQpO1xuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gVEVNUExBVEUgKGl0IGlzIGNsb3NlLCBidXQgaXQgc3RpbGwgbmVlZHMgdGVzdGluZyBhbmQgZGVidWdnaW5nKTpcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgLy8gdGhlaXIgbm9uY2UgaXMgYWx3YXlzIGEgY2FsaWJyYXRlZCBzeW5jaGVkIG1pbGxpc2Vjb25kcy10aW1lc3RhbXBcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5U3RyaW5nID0gJyc7XG4gICAgICAgICAgICBub25jZSA9IG5vbmNlLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSB0aGlzLnJhd2VuY29kZSAodGhpcy5rZXlzb3J0IChxdWVyeSkpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHF1ZXJ5U3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBxdWVyeVN0cmluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXV0aCA9IGVuZHBvaW50ICsgJy8nICsgbm9uY2UgKyAnLycgKyBxdWVyeVN0cmluZztcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gdGhpcy5zdHJpbmdUb0Jhc2U2NCAodGhpcy5lbmNvZGUgKGF1dGgpKTtcbiAgICAgICAgICAgIC8vIHBheWxvYWQgc2hvdWxkIGJlIFwiZW5jb2RlZFwiIGFzIHJldHVybmVkIGZyb20gc3RyaW5nVG9CYXNlNjRcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHBheWxvYWQsIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0tDLUFQSS1LRVknOiB0aGlzLmFwaUtleSAoKSxcbiAgICAgICAgICAgICAgICAnS0MtQVBJLU5PTkNFJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ0tDLUFQSS1TSUdOQVRVUkUnOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3JzIChjb2RlLCByZWFzb24sIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIGlmIChjb2RlID49IDQwMCkge1xuICAgICAgICAgICAgaWYgKGJvZHlbMF0gPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBKU09OLnBhcnNlIChib2R5KTtcbiAgICAgICAgICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ3N1Y2Nlc3MnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnbWVzc2FnZSddID09ICdNSU5fVFJBREVfUkVRVUlSRU1FTlRfTk9UX01FVCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3JkZXIgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydtZXNzYWdlJ10gPT0gJ0FQSUtFWV9JTlZBTElEJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBhY3ggPSByZXF1aXJlICgnLi9hY3guanMnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBJbnN1ZmZpY2llbnRGdW5kcywgT3JkZXJOb3RGb3VuZCB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBrdW5hIGV4dGVuZHMgYWN4IHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdrdW5hJyxcbiAgICAgICAgICAgICduYW1lJzogJ0t1bmEnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVQScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPSExDVic6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMTY5NzYzOC05MTI4MjRmYS1iM2MxLTExZTctOGMzNi1jZjk2MDZlYjk0YWMuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8va3VuYS5pbycsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL2t1bmEuaW8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9rdW5hLmlvL2RvY3VtZW50cy9hcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzL3ttYXJrZXR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rL3ttYXJrZXR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy97bWFya2V0fScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGltZXN0YW1wJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21lbWJlcnMvbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL215JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlci9kZWxldGUnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9VQUgnOiB7ICdpZCc6ICdidGN1YWgnLCAnc3ltYm9sJzogJ0JUQy9VQUgnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVUFIJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDYsICdwcmljZSc6IDAgfSwgJ2xvdCc6IDAuMDAwMDAxLCAnbGltaXRzJzogeyAnYW1vdW50JzogeyAnbWluJzogMC4wMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfSwgJ3ByaWNlJzogeyAnbWluJzogMSwgJ21heCc6IHVuZGVmaW5lZCB9fX0sXG4gICAgICAgICAgICAgICAgJ0VUSC9VQUgnOiB7ICdpZCc6ICdldGh1YWgnLCAnc3ltYm9sJzogJ0VUSC9VQUgnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnVUFIJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDYsICdwcmljZSc6IDAgfSwgJ2xvdCc6IDAuMDAwMDAxLCAnbGltaXRzJzogeyAnYW1vdW50JzogeyAnbWluJzogMC4wMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfSwgJ3ByaWNlJzogeyAnbWluJzogMSwgJ21heCc6IHVuZGVmaW5lZCB9fX0sXG4gICAgICAgICAgICAgICAgJ0dCRy9VQUgnOiB7ICdpZCc6ICdnYmd1YWgnLCAnc3ltYm9sJzogJ0dCRy9VQUgnLCAnYmFzZSc6ICdHQkcnLCAncXVvdGUnOiAnVUFIJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDMsICdwcmljZSc6IDIgfSwgJ2xvdCc6IDAuMDAxLCAnbGltaXRzJzogeyAnYW1vdW50JzogeyAnbWluJzogMC4wMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfSwgJ3ByaWNlJzogeyAnbWluJzogMC4wMSwgJ21heCc6IHVuZGVmaW5lZCB9fX0sIC8vIEdvbG9zIEdvbGQgKEdCRyAhPSBHT0xPUylcbiAgICAgICAgICAgICAgICAnS1VOL0JUQyc6IHsgJ2lkJzogJ2t1bmJ0YycsICdzeW1ib2wnOiAnS1VOL0JUQycsICdiYXNlJzogJ0tVTicsICdxdW90ZSc6ICdCVEMnLCAncHJlY2lzaW9uJzogeyAnYW1vdW50JzogNiwgJ3ByaWNlJzogNiB9LCAnbG90JzogMC4wMDAwMDEsICdsaW1pdHMnOiB7ICdhbW91bnQnOiB7ICdtaW4nOiAwLjAwMDAwMSwgJ21heCc6IHVuZGVmaW5lZCB9LCAncHJpY2UnOiB7ICdtaW4nOiAwLjAwMDAwMSwgJ21heCc6IHVuZGVmaW5lZCB9fX0sXG4gICAgICAgICAgICAgICAgJ0JDSC9CVEMnOiB7ICdpZCc6ICdiY2hidGMnLCAnc3ltYm9sJzogJ0JDSC9CVEMnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQlRDJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDYsICdwcmljZSc6IDYgfSwgJ2xvdCc6IDAuMDAwMDAxLCAnbGltaXRzJzogeyAnYW1vdW50JzogeyAnbWluJzogMC4wMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfSwgJ3ByaWNlJzogeyAnbWluJzogMC4wMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfX19LFxuICAgICAgICAgICAgICAgICdXQVZFUy9VQUgnOiB7ICdpZCc6ICd3YXZlc3VhaCcsICdzeW1ib2wnOiAnV0FWRVMvVUFIJywgJ2Jhc2UnOiAnV0FWRVMnLCAncXVvdGUnOiAnVUFIJywgJ3ByZWNpc2lvbic6IHsgJ2Ftb3VudCc6IDYsICdwcmljZSc6IDAgfSwgJ2xvdCc6IDAuMDAwMDAxLCAnbGltaXRzJzogeyAnYW1vdW50JzogeyAnbWluJzogMC4wMDAwMDEsICdtYXgnOiB1bmRlZmluZWQgfSwgJ3ByaWNlJzogeyAnbWluJzogMSwgJ21heCc6IHVuZGVmaW5lZCB9fX0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMjUgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMjUgLyAxMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhbmRsZUVycm9ycyAoY29kZSwgcmVhc29uLCB1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSkge1xuICAgICAgICBpZiAoY29kZSA9PSA0MDApIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZSAoYm9keSk7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBkYXRhWydlcnJvciddO1xuICAgICAgICAgICAgbGV0IGVycm9yQ29kZSA9IGVycm9yWydjb2RlJ107XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09IDIwMDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50RnVuZHMgKFsgdGhpcy5pZCwgbWV0aG9kLCB1cmwsIGNvZGUsIHJlYXNvbiwgYm9keSBdLmpvaW4gKCcgJykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT0gMjAwMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBjb2RlLCByZWFzb24sIGJvZHkgXS5qb2luICgnICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyQm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlckJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdyZW1haW5pbmdfdm9sdW1lJyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hMM09yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaE9wZW5PcmRlcnMgcmVxdWlyZXMgYSBzeW1ib2wgYXJndW1lbnQnKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIC8vIHRvZG8gZW11bGF0aW9uIG9mIGZldGNoQ2xvc2VkT3JkZXJzLCBmZXRjaE9yZGVycywgZmV0Y2hPcmRlclxuICAgICAgICAvLyB3aXRoIG9yZGVyIGNhY2hlICsgZmV0Y2hPcGVuT3JkZXJzXG4gICAgICAgIC8vIGFzIGluIEJUQy1lLCBMaXF1aSwgWW9iaXQsIERTWCwgVGlkZXgsIFdFWFxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAob3JkZXJzLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydjcmVhdGVkX2F0J10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBwYXJzZU15VHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnY3JlYXRlZF9hdCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsndm9sdW1lJ10sXG4gICAgICAgICAgICAnY29zdCc6IHRyYWRlWydmdW5kcyddLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3NpZGUnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHRyYWRlWydvcmRlcl9pZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlTXlUcmFkZXMgKHRyYWRlcywgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBwYXJzZWRUcmFkZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0cmFkZSA9IHRyYWRlc1tpXTtcbiAgICAgICAgICAgIGxldCBwYXJzZWRUcmFkZSA9IHRoaXMucGFyc2VNeVRyYWRlICh0cmFkZSwgbWFya2V0KTtcbiAgICAgICAgICAgIHBhcnNlZFRyYWRlcy5wdXNoIChwYXJzZWRUcmFkZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZFRyYWRlcztcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcGVuT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIGFyZ3VtZW50Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0VHJhZGVzTXkgKHsgJ21hcmtldCc6IG1hcmtldFsnaWQnXSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNeVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgbGFrZWJ0YyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdsYWtlYnRjJyxcbiAgICAgICAgICAgICduYW1lJzogJ0xha2VCVEMnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgICAgICAgICAndmVyc2lvbic6ICdhcGlfdjInLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODA3NDEyMC03MmI3YzM4YS02NjYwLTExZTctOTJkOS1kOTAyNzUwMjI4MWQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmxha2VidGMuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lmxha2VidGMuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cubGFrZWJ0Yy5jb20vcy9hcGlfdjInLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cubGFrZWJ0Yy5jb20vcy9hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jjb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiY3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXlPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRBY2NvdW50SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0RXh0ZXJuYWxBY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRUcmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGxPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4xNSAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNba107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgcXVvdGUgPSBxdW90ZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRBY2NvdW50SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlcyk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbY3VycmVuY3ldKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRCY29yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW21hcmtldFsnaWQnXV07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnaGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sdW1lJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0QmN0cmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKSArICdPcmRlcic7XG4gICAgICAgIGxldCBtYXJrZXRJZCA9IHRoaXMubWFya2V0SWQgKG1hcmtldCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwYXJhbXMnOiBbIHByaWNlLCBhbW91bnQsIG1hcmtldElkIF0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAncGFyYW1zJzogaWQgfSk7XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWNyb3NlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbjtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9ICcvJyArIHBhdGg7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLmpvaW4gKCcsJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gJyc7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnVybGVuY29kZSAoe1xuICAgICAgICAgICAgICAgICd0b25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdhY2Nlc3NrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAncmVxdWVzdG1ldGhvZCc6IG1ldGhvZC50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICAgICAnaWQnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAncGFyYW1zJzogcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAnaWQnOiBub25jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHF1ZXJ5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTEnKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5lbmNvZGUgKHRoaXMuYXBpS2V5ICsgJzonICsgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0pzb24tUnBjLVRvbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBcIkJhc2ljIFwiICsgdGhpcy5kZWNvZGUgKHRoaXMuc3RyaW5nVG9CYXNlNjQgKGF1dGgpKSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBJbnN1ZmZpY2llbnRGdW5kcywgT3JkZXJOb3RGb3VuZCwgRERvU1Byb3RlY3Rpb24gfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgbGlxdWkgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnbGlxdWknLFxuICAgICAgICAgICAgJ25hbWUnOiAnTGlxdWknLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVQScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMjUwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJzMnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoTXlUcmFkZXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVycyc6ICdlbXVsYXRlZCcsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoQ2xvc2VkT3JkZXJzJzogJ2VtdWxhdGVkJyxcbiAgICAgICAgICAgICAgICAnZmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hNeVRyYWRlcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTgyMDIyLTc1YWVhODI4LTYzYTAtMTFlNy05NTExLWNhNTg0YThlZGQ3NC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkubGlxdWkuaW8vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkubGlxdWkuaW8vdGFwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vbGlxdWkuaW8nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9saXF1aS5pby9hcGknLFxuICAgICAgICAgICAgICAgICdmZWVzJzogJ2h0dHBzOi8vbGlxdWkuaW8vZmVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWN0aXZlT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmRlckluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYW5zSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29pbkRlcG9zaXRBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaXRoZHJhd0NvaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NyZWF0ZUNvdXBvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUmVkZWVtQ291cG9uJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDI1LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmcnOiAwLjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVGZWUgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSwgdGFrZXJPck1ha2VyID0gJ3Rha2VyJywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICBsZXQga2V5ID0gJ3F1b3RlJztcbiAgICAgICAgbGV0IHJhdGUgPSBtYXJrZXRbdGFrZXJPck1ha2VyXTtcbiAgICAgICAgbGV0IGNvc3QgPSBwYXJzZUZsb2F0ICh0aGlzLmNvc3RUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQgKiByYXRlKSk7XG4gICAgICAgIGlmIChzaWRlID09ICdzZWxsJykge1xuICAgICAgICAgICAgY29zdCAqPSBwcmljZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9ICdiYXNlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiB0YWtlck9yTWFrZXIsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRba2V5XSxcbiAgICAgICAgICAgICdyYXRlJzogcmF0ZSxcbiAgICAgICAgICAgICdjb3N0JzogY29zdCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJzdGl0dXRlQ29tbW9uQ3VycmVuY3lDb2RlcylcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW5jeTtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdYQlQnKVxuICAgICAgICAgICAgcmV0dXJuICdCVEMnO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JDQycpXG4gICAgICAgICAgICByZXR1cm4gJ0JDSCc7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRFJLJylcbiAgICAgICAgICAgIHJldHVybiAnREFTSCc7XG4gICAgICAgIC8vIHRoZXkgbWlzc3BlbGwgREFTSCBhcyBkc2ggOi9cbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdEU0gnKVxuICAgICAgICAgICAgcmV0dXJuICdEQVNIJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGdldEJhc2VRdW90ZUZyb21NYXJrZXRJZCAoaWQpIHtcbiAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gdXBwZXJjYXNlLnNwbGl0ICgnXycpO1xuICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgIHJldHVybiBbIGJhc2UsIHF1b3RlIF07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJbmZvICgpO1xuICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydwYWlycyddO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gdGhpcy5nZXRCYXNlUXVvdGVGcm9tTWFya2V0SWQgKGlkKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiB0aGlzLnNhZmVJbnRlZ2VyIChtYXJrZXQsICdkZWNpbWFsX3BsYWNlcycpLFxuICAgICAgICAgICAgICAgICdwcmljZSc6IHRoaXMuc2FmZUludGVnZXIgKG1hcmtldCwgJ2RlY2ltYWxfcGxhY2VzJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGFtb3VudExpbWl0cyA9IHtcbiAgICAgICAgICAgICAgICAnbWluJzogdGhpcy5zYWZlRmxvYXQgKG1hcmtldCwgJ21pbl9hbW91bnQnKSxcbiAgICAgICAgICAgICAgICAnbWF4JzogdGhpcy5zYWZlRmxvYXQgKG1hcmtldCwgJ21heF9hbW91bnQnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcHJpY2VMaW1pdHMgPSB7XG4gICAgICAgICAgICAgICAgJ21pbic6IHRoaXMuc2FmZUZsb2F0IChtYXJrZXQsICdtaW5fcHJpY2UnKSxcbiAgICAgICAgICAgICAgICAnbWF4JzogdGhpcy5zYWZlRmxvYXQgKG1hcmtldCwgJ21heF9wcmljZScpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBjb3N0TGltaXRzID0ge1xuICAgICAgICAgICAgICAgICdtaW4nOiB0aGlzLnNhZmVGbG9hdCAobWFya2V0LCAnbWluX3RvdGFsJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGxpbWl0cyA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogYW1vdW50TGltaXRzLFxuICAgICAgICAgICAgICAgICdwcmljZSc6IHByaWNlTGltaXRzLFxuICAgICAgICAgICAgICAgICdjb3N0JzogY29zdExpbWl0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gKG1hcmtldFsnaGlkZGVuJ10gPT0gMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5leHRlbmQgKHRoaXMuZmVlc1sndHJhZGluZyddLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAndGFrZXInOiBtYXJrZXRbJ2ZlZSddIC8gMTAwLFxuICAgICAgICAgICAgICAgICdsb3QnOiBhbW91bnRMaW1pdHNbJ21pbiddLFxuICAgICAgICAgICAgICAgICdwcmVjaXNpb24nOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgJ2xpbWl0cyc6IGxpbWl0cyxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXR1cm4nXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgZnVuZHMgPSBiYWxhbmNlc1snZnVuZHMnXTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAoZnVuZHMpO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gY3VycmVuY3kudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICB1cHBlcmNhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAodXBwZXJjYXNlKTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCB1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGJhbGFuY2VzWydvcGVuX29yZGVycyddID09IDApIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IGZ1bmRzW2N1cnJlbmN5XTtcbiAgICAgICAgICAgICAgICB1c2VkID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBmdW5kc1tjdXJyZW5jeV0sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB1c2VkLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG1hcmtldF9pZF9pbl9yZXBvbnNlID0gKG1hcmtldFsnaWQnXSBpbiByZXNwb25zZSk7XG4gICAgICAgIGlmICghbWFya2V0X2lkX2luX3JlcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIG1hcmtldFsnc3ltYm9sJ10gKyAnIG9yZGVyIGJvb2sgaXMgZW1wdHkgb3Igbm90IGF2YWlsYWJsZScpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbbWFya2V0WydpZCddXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgICAgIHJlc3VsdFsnYmlkcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYmlkcyddLCAwLCB0cnVlKTtcbiAgICAgICAgcmVzdWx0Wydhc2tzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0Wydhc2tzJ10sIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd1cGRhdGVkJ10gKiAxMDAwO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnaGlnaCcpLFxuICAgICAgICAgICAgJ2xvdyc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5JyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3NlbGwnKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0JyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhdmcnKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbF9jdXInKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2wnKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGlkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzeW1ib2xzKSB7XG4gICAgICAgICAgICBsZXQgbnVtSWRzID0gdGhpcy5pZHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG51bUlkcyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hUaWNrZXJzKCkgcmVxdWlyZXMgc3ltYm9scyBhcmd1bWVudCcpO1xuICAgICAgICAgICAgaWRzID0gdGhpcy5pZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZHMgPSB0aGlzLm1hcmtldElkcyAoc3ltYm9scyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IGlkcy5qb2luICgnLScpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBrZXlzW2tdO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLmZldGNoVGlja2VycyAoWyBzeW1ib2wgXSwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRpY2tlcnNbc3ltYm9sXTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICBsZXQgc2lkZSA9IHRyYWRlWyd0eXBlJ107XG4gICAgICAgIGlmIChzaWRlID09ICdhc2snKVxuICAgICAgICAgICAgc2lkZSA9ICdzZWxsJztcbiAgICAgICAgaWYgKHNpZGUgPT0gJ2JpZCcpXG4gICAgICAgICAgICBzaWRlID0gJ2J1eSc7XG4gICAgICAgIGxldCBwcmljZSA9IHRoaXMuc2FmZUZsb2F0ICh0cmFkZSwgJ3ByaWNlJyk7XG4gICAgICAgIGlmICgncmF0ZScgaW4gdHJhZGUpXG4gICAgICAgICAgICBwcmljZSA9IHRoaXMuc2FmZUZsb2F0ICh0cmFkZSwgJ3JhdGUnKTtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5zYWZlU3RyaW5nICh0cmFkZSwgJ3RpZCcpO1xuICAgICAgICBpZiAoJ3RyYWRlX2lkJyBpbiB0cmFkZSlcbiAgICAgICAgICAgIGlkID0gdGhpcy5zYWZlU3RyaW5nICh0cmFkZSwgJ3RyYWRlX2lkJyk7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsIHRoaXMuZ2V0T3JkZXJJZEtleSAoKSk7XG4gICAgICAgIGlmICgncGFpcicgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXRJZCA9IHRyYWRlWydwYWlyJ107XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbbWFya2V0SWRdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgYW1vdW50ID0gdHJhZGVbJ2Ftb3VudCddO1xuICAgICAgICBsZXQgdHlwZSA9ICdsaW1pdCc7IC8vIGFsbCB0cmFkZXMgYXJlIHN0aWxsIGxpbWl0IHRyYWRlc1xuICAgICAgICBsZXQgZmVlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyB0aGlzIGlzIGZpbGxlZCBieSBmZXRjaE15VHJhZGVzKCkgb25seVxuICAgICAgICAvLyBpc195b3VyX29yZGVyIGlzIGFsd2F5cyBmYWxzZSA6XFxcbiAgICAgICAgLy8gbGV0IGlzWW91ck9yZGVyID0gdGhpcy5zYWZlVmFsdWUgKHRyYWRlLCAnaXNfeW91cl9vcmRlcicpO1xuICAgICAgICAvLyBsZXQgdGFrZXJPck1ha2VyID0gJ3Rha2VyJztcbiAgICAgICAgLy8gaWYgKGlzWW91ck9yZGVyKVxuICAgICAgICAvLyAgICAgdGFrZXJPck1ha2VyID0gJ21ha2VyJztcbiAgICAgICAgLy8gbGV0IGZlZSA9IHRoaXMuY2FsY3VsYXRlRmVlIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UsIHRha2VyT3JNYWtlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmVlJzogZmVlLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc1BhaXIgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlW21hcmtldFsnaWQnXV0sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRoaXMuYW1vdW50VG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50KSxcbiAgICAgICAgICAgICdyYXRlJzogdGhpcy5wcmljZVRvUHJlY2lzaW9uIChzeW1ib2wsIHByaWNlKSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2VbJ3JldHVybiddLCB0aGlzLmdldE9yZGVySWRLZXkgKCkpO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgaWQgPSB0aGlzLnNhZmVTdHJpbmcgKHJlc3BvbnNlWydyZXR1cm4nXSwgJ2luaXRfb3JkZXJfaWQnKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQgKHByaWNlKTtcbiAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCAoYW1vdW50KTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvcGVuJyxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdjb3N0JzogcHJpY2UgKiBhbW91bnQsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiAwLjAsXG4gICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLy8gJ3RyYWRlcyc6IHRoaXMucGFyc2VUcmFkZXMgKG9yZGVyWyd0cmFkZXMnXSwgbWFya2V0KSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gb3JkZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZCAoeyAnaW5mbyc6IHJlc3BvbnNlIH0sIG9yZGVyKTtcbiAgICB9XG5cbiAgICBnZXRPcmRlcklkS2V5ICgpIHtcbiAgICAgICAgcmV0dXJuICdvcmRlcl9pZCc7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgICAgICBsZXQgaWRLZXkgPSB0aGlzLmdldE9yZGVySWRLZXkgKCk7XG4gICAgICAgICAgICByZXF1ZXN0W2lkS2V5XSA9IGlkO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm9yZGVycylcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyc1tpZF1bJ3N0YXR1cyddID0gJ2NhbmNlbGVkJztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdF9qc29uX3Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLnNhZmVTdHJpbmcgKHRoaXMubGFzdF9qc29uX3Jlc3BvbnNlLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5pbmRleE9mICgnbm90IGZvdW5kJykgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIGVycm9yOiAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGlkID0gb3JkZXJbJ2lkJ10udG9TdHJpbmcgKCk7XG4gICAgICAgIGxldCBzdGF0dXMgPSBvcmRlclsnc3RhdHVzJ107XG4gICAgICAgIGlmIChzdGF0dXMgPT0gMCkge1xuICAgICAgICAgICAgc3RhdHVzID0gJ29wZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PSAxKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2xvc2VkJztcbiAgICAgICAgfSBlbHNlIGlmICgoc3RhdHVzID09IDIpIHx8IChzdGF0dXMgPT0gMykpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlclsndGltZXN0YW1wX2NyZWF0ZWQnXSkgKiAxMDAwO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW1hcmtldClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtvcmRlclsncGFpciddXTtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCByZW1haW5pbmcgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdhbW91bnQnKTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ3N0YXJ0X2Ftb3VudCcsIHJlbWFpbmluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYW1vdW50ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5vcmRlcnMpIHtcbiAgICAgICAgICAgICAgICBhbW91bnQgPSB0aGlzLnNhZmVGbG9hdCAodGhpcy5vcmRlcnNbaWRdLCAnYW1vdW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByaWNlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAncmF0ZScpO1xuICAgICAgICBsZXQgZmlsbGVkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29zdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVtYWluaW5nICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZmlsbGVkID0gYW1vdW50IC0gcmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIGNvc3QgPSBwcmljZSAqIGZpbGxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZmVlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAndHlwZSc6ICdsaW1pdCcsXG4gICAgICAgICAgICAnc2lkZSc6IG9yZGVyWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdjb3N0JzogY29zdCxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXMsXG4gICAgICAgICAgICAnZmVlJzogZmVlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXJzIChvcmRlcnMsIG1hcmtldCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAob3JkZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gb3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCBleHRlbmRlZCA9IHRoaXMuZXh0ZW5kIChvcmRlciwgeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLnBhcnNlT3JkZXIgKGV4dGVuZGVkLCBtYXJrZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeVNpbmNlTGltaXQgKHJlc3VsdCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJJbmZvICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVyX2lkJzogcGFyc2VJbnQgKGlkKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGlkID0gaWQudG9TdHJpbmcgKCk7XG4gICAgICAgIGxldCBuZXdPcmRlciA9IHRoaXMucGFyc2VPcmRlciAodGhpcy5leHRlbmQgKHsgJ2lkJzogaWQgfSwgcmVzcG9uc2VbJ3JldHVybiddW2lkXSkpO1xuICAgICAgICBsZXQgb2xkT3JkZXIgPSAoaWQgaW4gdGhpcy5vcmRlcnMpID8gdGhpcy5vcmRlcnNbaWRdIDoge307XG4gICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IHRoaXMuZXh0ZW5kIChvbGRPcmRlciwgbmV3T3JkZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcmRlcnNbaWRdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcmRlcnMgcmVxdWlyZXMgYSBzeW1ib2wnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHsgJ3BhaXInOiBtYXJrZXRbJ2lkJ10gfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEFjdGl2ZU9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3Blbk9yZGVycyA9IFtdO1xuICAgICAgICBpZiAoJ3JldHVybicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBvcGVuT3JkZXJzID0gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3JldHVybiddLCBtYXJrZXQpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9wZW5PcmRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMub3JkZXJzW29wZW5PcmRlcnNbal1bJ2lkJ11dID0gb3Blbk9yZGVyc1tqXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3Blbk9yZGVyc0luZGV4ZWRCeUlkID0gdGhpcy5pbmRleEJ5IChvcGVuT3JkZXJzLCAnaWQnKTtcbiAgICAgICAgbGV0IGNhY2hlZE9yZGVySWRzID0gT2JqZWN0LmtleXMgKHRoaXMub3JkZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNhY2hlZE9yZGVySWRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBjYWNoZWRPcmRlcklkc1trXTtcbiAgICAgICAgICAgIGlmIChpZCBpbiBvcGVuT3JkZXJzSW5kZXhlZEJ5SWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyc1tpZF0gPSB0aGlzLmV4dGVuZCAodGhpcy5vcmRlcnNbaWRdLCBvcGVuT3JkZXJzSW5kZXhlZEJ5SWRbaWRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5vcmRlcnNbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChvcmRlclsnc3RhdHVzJ10gPT0gJ29wZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IHRoaXMuZXh0ZW5kIChvcmRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0YXR1cyc6ICdjbG9zZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiBvcmRlclsnYW1vdW50J10gKiBvcmRlclsncHJpY2UnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsZWQnOiBvcmRlclsnYW1vdW50J10sXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVtYWluaW5nJzogMC4wLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLm9yZGVyc1tpZF07XG4gICAgICAgICAgICBpZiAob3JkZXJbJ3N5bWJvbCddID09IHN5bWJvbClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAob3JkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5U2luY2VMaW1pdCAocmVzdWx0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcmRlcnNbaV1bJ3N0YXR1cyddID09ICdvcGVuJylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAob3JkZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVycyA9IGF3YWl0IHRoaXMuZmV0Y2hPcmRlcnMgKHN5bWJvbCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9yZGVyc1tpXVsnc3RhdHVzJ10gPT0gJ2Nsb3NlZCcpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9yZGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAvLyAnZnJvbSc6IDEyMzQ1Njc4OSwgLy8gdHJhZGUgSUQsIGZyb20gd2hpY2ggdGhlIGRpc3BsYXkgc3RhcnRzIG51bWVyaWNhbCAwXG4gICAgICAgICAgICAvLyAnY291bnQnOiAxMDAwLCAvLyB0aGUgbnVtYmVyIG9mIHRyYWRlcyBmb3IgZGlzcGxheSBudW1lcmljYWwsIGRlZmF1bHQgPSAxMDAwXG4gICAgICAgICAgICAvLyAnZnJvbV9pZCc6IHRyYWRlIElELCBmcm9tIHdoaWNoIHRoZSBkaXNwbGF5IHN0YXJ0cyBudW1lcmljYWwgMFxuICAgICAgICAgICAgLy8gJ2VuZF9pZCc6IHRyYWRlIElEIG9uIHdoaWNoIHRoZSBkaXNwbGF5IGVuZHMgbnVtZXJpY2FsIOKInlxuICAgICAgICAgICAgLy8gJ29yZGVyJzogJ0FTQycsIC8vIHNvcnRpbmcsIGRlZmF1bHQgPSBERVNDXG4gICAgICAgICAgICAvLyAnc2luY2UnOiAxMjM0NTY3ODkwLCAvLyBVVEMgc3RhcnQgdGltZSwgZGVmYXVsdCA9IDBcbiAgICAgICAgICAgIC8vICdlbmQnOiAxMjM0NTY3ODkwLCAvLyBVVEMgZW5kIHRpbWUsIGRlZmF1bHQgPSDiiJ5cbiAgICAgICAgICAgIC8vICdwYWlyJzogJ2V0aF9idGMnLCAvLyBkZWZhdWx0ID0gYWxsIG1hcmtldHNcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydwYWlyJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnY291bnQnXSA9IHBhcnNlSW50IChsaW1pdCk7XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3NpbmNlJ10gPSBwYXJzZUludCAoc2luY2UgLyAxMDAwKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlSGlzdG9yeSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgdHJhZGVzID0gW107XG4gICAgICAgIGlmICgncmV0dXJuJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRyYWRlcyA9IHJlc3BvbnNlWydyZXR1cm4nXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHRyYWRlcywgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXdDb2luICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NvaW5OYW1lJzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAoYW1vdW50KSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3JldHVybiddWyd0SWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduQm9keVdpdGhTZWNyZXQgKGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyk7XG4gICAgfVxuXG4gICAgZ2V0VmVyc2lvblN0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiAnLycgKyB0aGlzLnZlcnNpb247XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICB9LCBxdWVyeSkpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuc2lnbkJvZHlXaXRoU2VjcmV0IChib2R5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbic6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgKz0gdGhpcy5nZXRWZXJzaW9uU3RyaW5nICgpICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoMiAocGF0aCwgYXBpLCBtZXRob2QsIHBhcmFtcywgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ3N1Y2Nlc3MnXSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnZXJyb3InXS5pbmRleE9mICgnTm90IGVub3VndGgnKSA+PSAwKSB7IC8vIG5vdCBlbm91Z1RoIGlzIGEgdHlwbyBpbnNpZGUgTGlxdWkncyBvd24gQVBJLi4uXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlWydlcnJvciddID09ICdSZXF1ZXN0cyB0b28gb2Z0ZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChyZXNwb25zZVsnZXJyb3InXSA9PSAnbm90IGF2YWlsYWJsZScpIHx8IChyZXNwb25zZVsnZXJyb3InXSA9PSAnZXh0ZXJuYWwgc2VydmljZSB1bmF2YWlsYWJsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGxpdmVjb2luIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ2xpdmVjb2luJyxcbiAgICAgICAgICAgICduYW1lJzogJ0xpdmVDb2luJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiBbICdVUycsICdVSycsICdSVScgXSxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk4MDc2OC1mMjJmYzQyNC02MzhhLTExZTctODljOS02MDEwYTU0ZmY5YmUuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmxpdmVjb2luLm5ldCcsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5saXZlY29pbi5uZXQnLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cubGl2ZWNvaW4ubmV0L2FwaT9sYW5nPWVuJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvYWxsL29yZGVyX2Jvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2xhc3RfdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9tYXhiaWRfbWluYXNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9vcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9yZXN0cmljdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3RpY2tlcicsIC8vIG9taXQgcGFyYW1zIHRvIGdldCBhbGwgdGlja2VycyBhdCBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mby9jb2luSW5mbycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9jbGllbnRfb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9jb21taXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9jb21taXNzaW9uQ29tbW9uSW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC9iYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXltZW50L2dldC9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXltZW50L2hpc3Rvcnkvc2l6ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC9oaXN0b3J5L3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2J1eWxpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9idXltYXJrZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2NhbmNlbGxpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZS9zZWxsbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3NlbGxtYXJrZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvb3V0L2NhcGl0YWxpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvb3V0L2NhcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvb3V0L2NvaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvb3V0L29rcGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXltZW50L291dC9wYXllZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvb3V0L3BlcmZlY3Rtb25leScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC92b3VjaGVyL2Ftb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF5bWVudC92b3VjaGVyL21ha2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BheW1lbnQvdm91Y2hlci9yZWRlZW0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VUaWNrZXIgKCk7XG4gICAgICAgIGxldCByZXN0cmljdGlvbnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlUmVzdHJpY3Rpb25zICgpO1xuICAgICAgICBsZXQgcmVzdHJpY3Rpb25zQnlJZCA9IHRoaXMuaW5kZXhCeSAocmVzdHJpY3Rpb25zWydyZXN0cmljdGlvbnMnXSwgJ2N1cnJlbmN5UGFpcicpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIGxldCBjb21taXNzaW9uID0gMC4xOCAvIDEwMDtcbiAgICAgICAgICAgIGxldCBjb2luUmVzdHJpY3Rpb25zID0gdGhpcy5zYWZlVmFsdWUgKHJlc3RyaWN0aW9uc0J5SWQsIHN5bWJvbCk7XG4gICAgICAgICAgICBsZXQgcHJpY2VQcmVjaXNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgYW1vdW50TWluID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvaW5SZXN0cmljdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJpY2VQcmVjaXNpb24gPSB0aGlzLnNhZmVJbnRlZ2VyIChjb2luUmVzdHJpY3Rpb25zLCAncHJpY2VTY2FsZScsIDUpO1xuICAgICAgICAgICAgICAgIGxldCBhbW91bnRNaW4gPSB0aGlzLnNhZmVGbG9hdCAoY29pblJlc3RyaWN0aW9ucywgJ21pbkxpbWl0UXVhbnRpdHknLCAwLjAwMDAwMDAxKTtcbiAgICAgICAgICAgICAgICBhbW91bnRNaW4gKj0gKDEgKyBjb21taXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2VQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiA4LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IDgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGFtb3VudE1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiAxMDAwMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogMC4wMDAwMDAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiAxMDAwMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21ha2VyJzogY29tbWlzc2lvbixcbiAgICAgICAgICAgICAgICAndGFrZXInOiBjb21taXNzaW9uLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldFBheW1lbnRCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIHJlc3VsdClcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gcmVzdWx0W2N1cnJlbmN5XTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGJhbGFuY2VbJ3R5cGUnXSA9PSAndG90YWwnKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlWyd2YWx1ZSddKTtcbiAgICAgICAgICAgIGlmIChiYWxhbmNlWyd0eXBlJ10gPT0gJ2F2YWlsYWJsZScpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsndmFsdWUnXSk7XG4gICAgICAgICAgICBpZiAoYmFsYW5jZVsndHlwZSddID09ICd0cmFkZScpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsndmFsdWUnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hGZWVzIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgY29tbWlzc2lvbkluZm8gPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRFeGNoYW5nZUNvbW1pc3Npb25Db21tb25JbmZvICgpO1xuICAgICAgICBsZXQgY29tbWlzc2lvbiA9IHRoaXMuc2FmZUZsb2F0IChjb21taXNzaW9uSW5mbywgJ2NvbW1pc3Npb24nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogY29tbWlzc2lvbkluZm8sXG4gICAgICAgICAgICAnbWFrZXInOiBjb21taXNzaW9uLFxuICAgICAgICAgICAgJ3Rha2VyJzogY29tbWlzc2lvbixcbiAgICAgICAgICAgICd3aXRoZHJhdyc6IDAuMCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZU9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2dyb3VwQnlQcmljZSc6ICdmYWxzZScsXG4gICAgICAgICAgICAnZGVwdGgnOiAxMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IHZ3YXAgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSk7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSk7XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IGJhc2VWb2x1bWUgKiB2d2FwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Jlc3RfYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmVzdF9hc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKSxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlVGlja2VyIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHRoaXMuaW5kZXhCeSAocmVzcG9uc2UsICdzeW1ib2wnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZVRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0aW1lJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsncXVhbnRpdHknXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZUxhc3RUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5zYWZlSW50ZWdlciAob3JkZXIsICdsYXN0TW9kaWZpY2F0aW9uVGltZScpO1xuICAgICAgICBpZiAoIXRpbWVzdGFtcClcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlclsnbGFzdE1vZGlmaWNhdGlvblRpbWUnXSk7XG4gICAgICAgIGxldCB0cmFkZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgndHJhZGVzJyBpbiBvcmRlcilcbiAgICAgICAgICAgIC8vIFRPRE8gY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgYnkgbGl2ZWNvaW5cbiAgICAgICAgICAgIC8vIHRyYWRlcyA9IHRoaXMucGFyc2VUcmFkZXMgKG9yZGVyWyd0cmFkZXMnXSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgICAgICAgICAgdHJhZGVzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgc3RhdHVzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAob3JkZXJbJ29yZGVyU3RhdHVzJ10gPT0gJ09QRU4nIHx8IG9yZGVyWydvcmRlclN0YXR1cyddID09ICdQQVJUSUFMTFlfRklMTEVEJykge1xuICAgICAgICAgICAgc3RhdHVzID0gJ29wZW4nO1xuICAgICAgICB9IGVsc2UgaWYgKG9yZGVyWydvcmRlclN0YXR1cyddID09ICdFWEVDVVRFRCcgfHwgb3JkZXJbJ29yZGVyU3RhdHVzJ10gPT0gJ1BBUlRJQUxMWV9GSUxMRURfQU5EX0NBTkNFTExFRCcpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjbG9zZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gJ2NhbmNlbGVkJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ltYm9sID0gb3JkZXJbJ2N1cnJlbmN5UGFpciddO1xuICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChvcmRlclsndHlwZSddLmluZGV4T2YgKCdNQVJLRVQnKSA+PSAwKSB7XG4gICAgICAgICAgICB0eXBlID0gJ21hcmtldCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gJ2xpbWl0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJbJ3R5cGUnXS5pbmRleE9mICgnU0VMTCcpID49IDApIHtcbiAgICAgICAgICAgIHNpZGUgPSAnc2VsbCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWRlID0gJ2J1eSc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByaWNlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAncHJpY2UnLCAwLjApO1xuICAgICAgICBsZXQgY29zdCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2NvbW1pc3Npb25CeVRyYWRlJywgMC4wKTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ3JlbWFpbmluZ1F1YW50aXR5JywgMC4wKTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ3F1YW50aXR5JywgcmVtYWluaW5nKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IGFtb3VudCAtIHJlbWFpbmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ3RyYWRlcyc6IHRyYWRlcyxcbiAgICAgICAgICAgICdmZWUnOiB7XG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IHF1b3RlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHBhaXIgPSBtYXJrZXQgPyBtYXJrZXRbJ2lkJ10gOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGlmIChwYWlyKVxuICAgICAgICAgICAgcmVxdWVzdFsnY3VycmVuY3lQYWlyJ10gPSBwYWlyO1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0Wydpc3N1ZWRGcm9tJ10gPSBwYXJzZUludCAoc2luY2UpO1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydlbmRSb3cnXSA9IGxpbWl0IC0gMTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0RXhjaGFuZ2VDbGllbnRPcmRlcnMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgcmF3T3JkZXJzID0gW107XG4gICAgICAgIGlmIChyZXNwb25zZVsnZGF0YSddKVxuICAgICAgICAgICAgcmF3T3JkZXJzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdPcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvcmRlciA9IHJhd09yZGVyc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLnBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHNpbmNlLCBsaW1pdCwgdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcGVuQ2xvc2VkJzogJ09QRU4nLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaENsb3NlZE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHNpbmNlLCBsaW1pdCwgdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcGVuQ2xvc2VkJzogJ0NMT1NFRCcsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RFeGNoYW5nZScgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgdHlwZTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcklkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyIHJlcXVpcmVzIGEgc3ltYm9sIGFyZ3VtZW50Jyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RFeGNoYW5nZUNhbmNlbGxpbWl0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVySWQnOiBpZCxcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRQYXltZW50R2V0QWRkcmVzcyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2UsICd3YWxsZXQnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5rZXlzb3J0IChwYXJhbXMpKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJylcbiAgICAgICAgICAgICAgICBib2R5ID0gcXVlcnk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocXVlcnkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMjU2Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBcGktS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiBzaWduYXR1cmUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgbHVubyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdsdW5vJyxcbiAgICAgICAgICAgICduYW1lJzogJ2x1bm8nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0dCJywgJ1NHJywgJ1pBJyBdLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NjA3LThjMWE2OWQ4LTVlZGUtMTFlNy05MzBjLTU0MGI1ZWI5YmUyNC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkubXliaXR4LmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cubHVuby5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5sdW5vLmNvbS9lbi9hcGknLFxuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9ucG1qcy5vcmcvcGFja2FnZS9iaXR4JyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9iYXVzbWVpZXIvbm9kZS1iaXR4JyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnRzL3tpZH0vcGVuZGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWNjb3VudHMve2lkfS90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZlZV9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kaW5nX2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3RvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3R0cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZXMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zdG9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRvcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RvcG9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kaW5nX2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29hdXRoMi9ncmFudCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwdXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3Rlcy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd2Fscy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWyd0aWNrZXJzJ10ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzWyd0aWNrZXJzJ11bcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3BhaXInXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gaWQuc2xpY2UgKDAsIDMpO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gaWQuc2xpY2UgKDMsIDYpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydiYWxhbmNlJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYWxhbmNlWydhc3NldCddKTtcbiAgICAgICAgICAgIGxldCByZXNlcnZlZCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ3Jlc2VydmVkJ10pO1xuICAgICAgICAgICAgbGV0IHVuY29uZmlybWVkID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsndW5jb25maXJtZWQnXSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB0aGlzLnN1bSAocmVzZXJ2ZWQsIHVuY29uZmlybWVkKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyYm9va1sndGltZXN0YW1wJ107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICd2b2x1bWUnKTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlclsnY3JlYXRpb25fdGltZXN0YW1wJ107XG4gICAgICAgIGxldCBzdGF0dXMgPSAob3JkZXJbJ3N0YXRlJ10gPT0gJ1BFTkRJTkcnKSA/ICdvcGVuJyA6ICdjbG9zZWQnO1xuICAgICAgICBsZXQgc2lkZSA9IChvcmRlclsndHlwZSddID09ICdBU0snKSA/ICdzZWxsJyA6ICdidXknO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IHByaWNlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnbGltaXRfcHJpY2UnKTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2xpbWl0X3ZvbHVtZScpO1xuICAgICAgICBsZXQgcXVvdGVGZWUgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdmZWVfY291bnRlcicpO1xuICAgICAgICBsZXQgYmFzZUZlZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2ZlZV9iYXNlJyk7XG4gICAgICAgIGxldCBmZWUgPSB7ICdjdXJyZW5jeSc6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAocXVvdGVGZWUpIHtcbiAgICAgICAgICAgIGZlZVsnc2lkZSddID0gJ3F1b3RlJztcbiAgICAgICAgICAgIGZlZVsnY29zdCddID0gcXVvdGVGZWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmZWVbJ3NpZGUnXSA9ICdiYXNlJztcbiAgICAgICAgICAgIGZlZVsnY29zdCddID0gYmFzZUZlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ29yZGVyX2lkJ10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RyYWRlcyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmZWUnOiBmZWUsXG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldE9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLnRvU3RyaW5nICgpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF90cmFkZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3JvbGxpbmdfMjRfaG91cl92b2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VycyAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSB0aGlzLmluZGV4QnkgKHJlc3BvbnNlWyd0aWNrZXJzJ10sICdwYWlyJyk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ2lzX2J1eSddKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsndGltZXN0YW1wJ10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWyd2b2x1bWUnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCc7XG4gICAgICAgIGxldCBvcmRlciA9IHsgJ3BhaXInOiB0aGlzLm1hcmtldElkIChtYXJrZXQpIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ01hcmtldG9yZGVyJztcbiAgICAgICAgICAgIG9yZGVyWyd0eXBlJ10gPSBzaWRlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpXG4gICAgICAgICAgICAgICAgb3JkZXJbJ2NvdW50ZXJfdm9sdW1lJ10gPSBhbW91bnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3JkZXJbJ2Jhc2Vfdm9sdW1lJ10gPSBhbW91bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ09yZGVyJztcbiAgICAgICAgICAgIG9yZGVyWyd2b2x1bWUnXSA9IGFtb3VudDtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAnYnV5JylcbiAgICAgICAgICAgICAgICBvcmRlclsndHlwZSddID0gJ0JJRCc7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3JkZXJbJ3R5cGUnXSA9ICdBU0snO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RTdG9wb3JkZXIgKHsgJ29yZGVyX2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLmVuY29kZSAodGhpcy5hcGlLZXkgKyAnOicgKyB0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBhdXRoID0gdGhpcy5zdHJpbmdUb0Jhc2U2NCAoYXV0aCk7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgdGhpcy5kZWNvZGUgKGF1dGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIG1lcmNhZG8gZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnbWVyY2FkbycsXG4gICAgICAgICAgICAnbmFtZSc6ICdNZXJjYWRvIEJpdGNvaW4nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdCUicsIC8vIEJyYXppbFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MycsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzgzNzA2MC1lN2M1ODcxNC02MGVhLTExZTctOTE5Mi1mMDVlODZhZGI4M2YuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vd3d3Lm1lcmNhZG9iaXRjb2luLm5ldC9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3d3dy5tZXJjYWRvYml0Y29pbi5uZXQvdGFwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lm1lcmNhZG9iaXRjb2luLmNvbS5icicsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lm1lcmNhZG9iaXRjb2luLmNvbS5ici9hcGktZG9jJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lm1lcmNhZG9iaXRjb2luLmNvbS5ici90cmFkZS1hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3tjb2lufS9vcmRlcmJvb2svJywgLy8gbGFzdCBzbGFzaCBjcml0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3tjb2lufS90aWNrZXIvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y29pbn0vdHJhZGVzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAne2NvaW59L3RyYWRlcy97ZnJvbX0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y29pbn0vdHJhZGVzL3tmcm9tfS97dG99JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd7Y29pbn0vZGF5LXN1bW1hcnkve3llYXJ9L3ttb250aH0ve2RheX0vJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9hY2NvdW50X2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpc3Rfc3lzdGVtX21lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaXN0X29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdF9vcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWNlX2J1eV9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhY2Vfc2VsbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdfY29pbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0JSTCc6IHsgJ2lkJzogJ0JSTEJUQycsICdzeW1ib2wnOiAnQlRDL0JSTCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdCUkwnLCAnc3VmZml4JzogJ0JpdGNvaW4nIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9CUkwnOiB7ICdpZCc6ICdCUkxMVEMnLCAnc3ltYm9sJzogJ0xUQy9CUkwnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlJMJywgJ3N1ZmZpeCc6ICdMaXRlY29pbicgfSxcbiAgICAgICAgICAgICAgICAnQkNIL0JSTCc6IHsgJ2lkJzogJ0JSTEJDSCcsICdzeW1ib2wnOiAnQkNIL0JSTCcsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdCUkwnLCAnc3VmZml4JzogJ0JDYXNoJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjMgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuNyAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDb2luT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NvaW4nOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDb2luVGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NvaW4nOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsndGlja2VyJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodGlja2VyWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0Q29pblRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2luJzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRBY2NvdW50SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ3Jlc3BvbnNlX2RhdGEnXVsnYmFsYW5jZSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGxvd2VyY2FzZSBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2xvd2VyY2FzZV1bJ2F2YWlsYWJsZSddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbbG93ZXJjYXNlXVsndG90YWwnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdFBsYWNlJyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSkgKyAnT3JkZXInO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY29pbl9wYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IGFtb3VudCxcbiAgICAgICAgICAgICdsaW1pdF9wcmljZSc6IHByaWNlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3Jlc3BvbnNlX2RhdGEnXVsnb3JkZXInXVsnb3JkZXJfaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIoKSByZXF1aXJlcyBhIHN5bWJvbCBhcmd1bWVudCcpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbl9wYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ29yZGVyX2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnb3JkZXJfdHlwZScgaW4gb3JkZXIpXG4gICAgICAgICAgICBzaWRlID0gKG9yZGVyWydvcmRlcl90eXBlJ10gPT0gMSkgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgbGV0IHN0YXR1cyA9IG9yZGVyWydzdGF0dXMnXTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGlmICgnY29pbl9wYWlyJyBpbiBvcmRlcilcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJbJ2NvaW5fcGFpciddIGluIHRoaXMubWFya2V0c19ieV9pZClcbiAgICAgICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW29yZGVyWydjb2luX3BhaXInXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnY3JlYXRlZF90aW1lc3RhbXAnIGluIG9yZGVyKVxuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyWydjcmVhdGVkX3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIGlmICgndXBkYXRlZF90aW1lc3RhbXAnIGluIG9yZGVyKVxuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyWyd1cGRhdGVkX3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIGxldCBmZWUgPSB7XG4gICAgICAgICAgICAnY29zdCc6IHBhcnNlRmxvYXQgKG9yZGVyWydmZWUnXSksXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBwcmljZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2xpbWl0X3ByaWNlJyk7XG4gICAgICAgIC8vIHByaWNlID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnZXhlY3V0ZWRfcHJpY2VfYXZnJywgcHJpY2UpO1xuICAgICAgICBsZXQgYXZlcmFnZSA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2V4ZWN1dGVkX3ByaWNlX2F2ZycpO1xuICAgICAgICBsZXQgYW1vdW50ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAncXVhbnRpdHknKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHRoaXMuc2FmZUZsb2F0IChvcmRlciwgJ2V4ZWN1dGVkX3F1YW50aXR5Jyk7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSBhbW91bnQgLSBmaWxsZWQ7XG4gICAgICAgIGxldCBjb3N0ID0gYW1vdW50ICogYXZlcmFnZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnb3JkZXJfaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IGF2ZXJhZ2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIHJlcXVpcmVzIGEgc3ltYm9sIGFyZ3VtZW50Jyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2luX3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnb3JkZXJfaWQnOiBwYXJzZUludCAoaWQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2VbJ3Jlc3BvbnNlX2RhdGEnXVsnb3JkZXInXSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2NvaW4nOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IGFtb3VudC50b0ZpeGVkICgxMCksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQlJMJykge1xuICAgICAgICAgICAgbGV0IGFjY291bnRfcmVmID0gKCdhY2NvdW50X3JlZicgaW4gcGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghYWNjb3VudF9yZWYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIGFjY291bnRfcmVmIHBhcmFtZXRlciB0byB3aXRoZHJhdyAnICsgY3VycmVuY3kpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ICE9ICdMVEMnKSB7XG4gICAgICAgICAgICBsZXQgdHhfZmVlID0gKCd0eF9mZWUnIGluIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIXR4X2ZlZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgdHhfZmVlIHBhcmFtZXRlciB0byB3aXRoZHJhdyAnICsgY3VycmVuY3kpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhd0NvaW4gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzcG9uc2VfZGF0YSddWyd3aXRoZHJhd2FsJ11bJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICB1cmwgKz0gdGhpcy52ZXJzaW9uICsgJy8nO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAndGFwaV9tZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICd0YXBpX25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gJy90YXBpLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyAnPycgKyBib2R5O1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ1RBUEktSUQnOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnVEFQSS1NQUMnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yX21lc3NhZ2UnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBtaXhjb2lucyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdtaXhjb2lucycsXG4gICAgICAgICAgICAnbmFtZSc6ICdNaXhDb2lucycsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnR0InLCAnSEsnIF0sXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwMjM3MjEyLWVkMjkzMDNjLTk1MzUtMTFlNy04YWY4LWZjZDM4MWNmYTIwYy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9taXhjb2lucy5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vbWl4Y29pbnMuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vbWl4Y29pbnMuY29tL2hlbHAvYXBpLycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXJrZXRzJzoge1xuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnYnRjX3VzZCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnLCAnbWFrZXInOiAwLjAwMTUsICd0YWtlcic6IDAuMDAyNSB9LFxuICAgICAgICAgICAgICAgICdFVEgvQlRDJzogeyAnaWQnOiAnZXRoX2J0YycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnLCAnbWFrZXInOiAwLjAwMSwgJ3Rha2VyJzogMC4wMDE1IH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9CVEMnOiB7ICdpZCc6ICdiY2NfYnRjJywgJ3N5bWJvbCc6ICdCQ0gvQlRDJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0JUQycsICdtYWtlcic6IDAuMDAxLCAndGFrZXInOiAwLjAwMTUgfSxcbiAgICAgICAgICAgICAgICAnTFNLL0JUQyc6IHsgJ2lkJzogJ2xza19idGMnLCAnc3ltYm9sJzogJ0xTSy9CVEMnLCAnYmFzZSc6ICdMU0snLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDE1LCAndGFrZXInOiAwLjAwMjUgfSxcbiAgICAgICAgICAgICAgICAnQkNIL1VTRCc6IHsgJ2lkJzogJ2JjY191c2QnLCAnc3ltYm9sJzogJ0JDSC9VU0QnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnVVNEJywgJ21ha2VyJzogMC4wMDEsICd0YWtlcic6IDAuMDAxNSB9LFxuICAgICAgICAgICAgICAgICdFVEgvVVNEJzogeyAnaWQnOiAnZXRoX3VzZCcsICdzeW1ib2wnOiAnRVRIL1VTRCcsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdVU0QnLCAnbWFrZXInOiAwLjAwMSwgJ3Rha2VyJzogMC4wMDE1IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlWydyZXN1bHQnXVsnd2FsbGV0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChsb3dlcmNhc2UgaW4gYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbbG93ZXJjYXNlXVsnYXZhaWwnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtsb3dlcmNhc2VdWydsb2NrJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChyZXNwb25zZVsncmVzdWx0J10pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsncmVzdWx0J10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdvcCc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0Jykge1xuICAgICAgICAgICAgb3JkZXJbJ29yZGVyX3R5cGUnXSA9IDE7XG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ29yZGVyX3R5cGUnXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXN1bHQnXVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWwgKHsgJ2lkJzogaWQgfSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5zZWNyZXQsICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdGF0dXMnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydzdGF0dXMnXSA9PSAyMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBub3ZhIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ25vdmEnLFxuICAgICAgICAgICAgJ25hbWUnOiAnTm92YWV4Y2hhbmdlJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVFonLCAvLyBUYW56YW5pYVxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDUxODU3MS03OGNhMGJjYS05YjhhLTExZTctODg0MC02NGI4M2E0YTk0YjIuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vbm92YWV4Y2hhbmdlLmNvbS9yZW1vdGUnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9ub3ZhZXhjaGFuZ2UuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vbm92YWV4Y2hhbmdlLmNvbS9yZW1vdGUvZmFxJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldHMve2Jhc2VjdXJyZW5jeX0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvaW5mby97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvb3JkZXJoaXN0b3J5L3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9vcGVub3JkZXJzL3twYWlyfS9idXkvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXQvb3Blbm9yZGVycy97cGFpcn0vc2VsbC8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldC9vcGVub3JkZXJzL3twYWlyfS9ib3RoLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0L29wZW5vcmRlcnMve3BhaXJ9L3tvcmRlcnR5cGV9LycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0YmFsYW5jZXMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRiYWxhbmNlL3tjdXJyZW5jeX0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRkZXBvc2l0cy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldHdpdGhkcmF3YWxzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0bmV3ZGVwb3NpdGFkZHJlc3Mve2N1cnJlbmN5fS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldGRlcG9zaXRhZGRyZXNzL3tjdXJyZW5jeX0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdteW9wZW5vcmRlcnMvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdteW9wZW5vcmRlcnNfbWFya2V0L3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbG9yZGVyL3tvcmRlcmlkfS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3L3tjdXJyZW5jeX0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZS97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZWhpc3RvcnkvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRkZXBvc2l0aGlzdG9yeS8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldHdpdGhkcmF3YWxoaXN0b3J5LycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0c3RhdHVzLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2FsbGV0c3RhdHVzL3tjdXJyZW5jeX0vJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydtYXJrZXRzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpXTtcbiAgICAgICAgICAgIGlmICghbWFya2V0WydkaXNhYmxlZCddKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydtYXJrZXRuYW1lJ107XG4gICAgICAgICAgICAgICAgbGV0IFsgcXVvdGUsIGJhc2UgXSA9IGlkLnNwbGl0ICgnXycpO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0T3Blbm9yZGVyc1BhaXJCb3RoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5b3JkZXJzJywgJ3NlbGxvcmRlcnMnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRJbmZvUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnbWFya2V0cyddWzBdO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoMjRoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93MjRoJ10pLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdiaWQnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXNrJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RfcHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydjaGFuZ2UyNGgnXSksXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZTI0aCddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd1bml4X3RfZGF0ZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHJhZGV0eXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRPcmRlcmhpc3RvcnlQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ2l0ZW1zJ10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRiYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgbG9ja2JveCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF9sb2NrYm94J10pO1xuICAgICAgICAgICAgbGV0IHRyYWRlcyA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF90cmFkZXMnXSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHRoaXMuc3VtIChsb2NrYm94LCB0cmFkZXMpLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF90b3RhbCddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGFtb3VudCA9IGFtb3VudC50b1N0cmluZyAoKTtcbiAgICAgICAgcHJpY2UgPSBwcmljZS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAndHJhZGV0eXBlJzogc2lkZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICd0cmFkZWFtb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICd0cmFkZXByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAndHJhZGViYXNlJzogMSxcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGVQYWlyICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxvcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcmlkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLyc7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKVxuICAgICAgICAgICAgdXJsICs9IGFwaSArICcvJztcbiAgICAgICAgdXJsICs9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHsgJ25vbmNlJzogbm9uY2UgfSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAodXJsKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdGF0dXMnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydzdGF0dXMnXSAhPSAnc3VjY2VzcycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9rY29pbnVzZCA9IHJlcXVpcmUgKCcuL29rY29pbnVzZC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIG9rY29pbmNueSBleHRlbmRzIG9rY29pbnVzZCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnb2tjb2luY255JyxcbiAgICAgICAgICAgICduYW1lJzogJ09LQ29pbiBDTlknLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2Njc5Mi04YmU5MTU3YS01ZWU1LTExZTctOTI2Yy02ZDY5YjhkMzM3OGQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAnd2ViJzogJ2h0dHBzOi8vd3d3Lm9rY29pbi5jbicsXG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly93d3cub2tjb2luLmNuL3BhaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vd3d3Lm9rY29pbi5jbi9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5va2NvaW4uY24nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cub2tjb2luLmNuL3Jlc3RfZ2V0U3RhcnRlZC5odG1sJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgICAgICAgICAnQlRDL0NOWSc6IHsgJ2lkJzogJ2J0Y19jbnknLCAnc3ltYm9sJzogJ0JUQy9DTlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ05ZJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0xUQy9DTlknOiB7ICdpZCc6ICdsdGNfY255JywgJ3N5bWJvbCc6ICdMVEMvQ05ZJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0NOWScsICd0eXBlJzogJ3Nwb3QnLCAnc3BvdCc6IHRydWUsICdmdXR1cmUnOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICdFVEgvQ05ZJzogeyAnaWQnOiAnZXRoX2NueScsICdzeW1ib2wnOiAnRVRIL0NOWScsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdDTlknLCAndHlwZSc6ICdzcG90JywgJ3Nwb3QnOiB0cnVlLCAnZnV0dXJlJzogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAnRVRDL0NOWSc6IHsgJ2lkJzogJ2V0Y19jbnknLCAnc3ltYm9sJzogJ0VUQy9DTlknLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQ05ZJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgJ0JDSC9DTlknOiB7ICdpZCc6ICdiY2NfY255JywgJ3N5bWJvbCc6ICdCQ0gvQ05ZJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0NOWScsICd0eXBlJzogJ3Nwb3QnLCAnc3BvdCc6IHRydWUsICdmdXR1cmUnOiBmYWxzZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBva2NvaW51c2QgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnb2tjb2ludXNkJyxcbiAgICAgICAgICAgICduYW1lJzogJ09LQ29pbiBVU0QnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0NOJywgJ1VTJyBdLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLCAvLyB1cCB0byAzMDAwIHJlcXVlc3RzIHBlciA1IG1pbnV0ZXMg4omIIDYwMCByZXF1ZXN0cyBwZXIgbWludXRlIOKJiCAxMCByZXF1ZXN0cyBwZXIgc2Vjb25kIOKJiCAxMDAgbXNcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9wZW5PcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNXaXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICAvLyBuZXcgbWV0YWluZm8gaW50ZXJmYWNlXG4gICAgICAgICAgICAnaGFzJzoge1xuICAgICAgICAgICAgICAgICdmZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2V4dGVuc2lvbic6ICcuZG8nLCAvLyBhcHBlbmRlZCB0byBlbmRwb2ludCBVUkxcbiAgICAgICAgICAgICdoYXNGdXR1cmVNYXJrZXRzJzogZmFsc2UsXG4gICAgICAgICAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgICAgICAgICAnMW0nOiAnMW1pbicsXG4gICAgICAgICAgICAgICAgJzNtJzogJzNtaW4nLFxuICAgICAgICAgICAgICAgICc1bSc6ICc1bWluJyxcbiAgICAgICAgICAgICAgICAnMTVtJzogJzE1bWluJyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJzMwbWluJyxcbiAgICAgICAgICAgICAgICAnMWgnOiAnMWhvdXInLFxuICAgICAgICAgICAgICAgICcyaCc6ICcyaG91cicsXG4gICAgICAgICAgICAgICAgJzRoJzogJzRob3VyJyxcbiAgICAgICAgICAgICAgICAnNmgnOiAnNmhvdXInLFxuICAgICAgICAgICAgICAgICcxMmgnOiAnMTJob3VyJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMWRheScsXG4gICAgICAgICAgICAgICAgJzNkJzogJzNkYXknLFxuICAgICAgICAgICAgICAgICcxdyc6ICcxd2VlaycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAnd2ViJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmtldHMvY3VycmVuY2llcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cy9wcm9kdWN0cycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZV9yYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfZGVwdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9lc3RpbWF0ZWRfcHJpY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9ob2xkX2Ftb3VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX2luZGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfa2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9wcmljZV9saW1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAna2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ290Y3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50X3JlY29yZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhdGNoX3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib3Jyb3dfbW9uZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcnJvd19vcmRlcl9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib3Jyb3dzX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9ib3Jyb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX290Y19vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsX3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfYmF0Y2hfdHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9kZXZvbHZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfZXhwbG9zaXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfb3JkZXJfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX29yZGVyc19pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfcG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV9wb3NpdGlvbl80Zml4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfdHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1dHVyZV90cmFkZXNfaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnV0dXJlX3VzZXJpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdXR1cmVfdXNlcmluZm9fNGZpeCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGVuZF9kZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJfZmVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnNfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3RjX29yZGVyX2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ290Y19vcmRlcl9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXBheW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N1Ym1pdF9vdGNfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZV9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZV9vdGNfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd19pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1bnJlcGF5bWVudHNfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcmluZm8nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2Njc5MS04OWZmYjUwMi01ZWU1LTExZTctOGE1Yi1jNTk1MGI2OGFjNjUuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAnd2ViJzogJ2h0dHBzOi8vd3d3Lm9rY29pbi5jb20vdjInLFxuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vd3d3Lm9rY29pbi5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly93d3cub2tjb2luLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5va2NvaW4uY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cub2tjb2luLmNvbS9yZXN0X2dldFN0YXJ0ZWQuaHRtbCcsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9va2NvaW4uY29tJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53ZWJHZXRNYXJrZXRzUHJvZHVjdHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldHNbaV1bJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHVwcGVyY2FzZS5zcGxpdCAoJ18nKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBtYXJrZXRzW2ldWydtYXhTaXplRGlnaXQnXSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBtYXJrZXRzW2ldWydtYXhQcmljZURpZ2l0J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGxvdCA9IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0c1tpXSxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdzcG90JyxcbiAgICAgICAgICAgICAgICAnc3BvdCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZSc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IG1hcmtldHNbaV1bJ21pblRyYWRlU2l6ZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG1hcmtldCk7XG4gICAgICAgICAgICBpZiAoKHRoaXMuaGFzRnV0dXJlTWFya2V0cykgJiYgKG1hcmtldFsncXVvdGUnXSA9PSAnVVNEVCcpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kIChtYXJrZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJzogJ1VTRCcsXG4gICAgICAgICAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2Jhc2UnXSArICcvVVNEJyxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLnJlcGxhY2UgKCd1c2R0JywgJ3VzZCcpLFxuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdmdXR1cmUnLFxuICAgICAgICAgICAgICAgICAgICAnc3BvdCc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAnZnV0dXJlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHVibGljR2V0JztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWFya2V0WydmdXR1cmUnXSkge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdGdXR1cmUnO1xuICAgICAgICAgICAgcmVxdWVzdFsnY29udHJhY3RfdHlwZSddID0gJ3RoaXNfd2Vlayc7IC8vIG5leHRfd2VlaywgcXVhcnRlclxuICAgICAgICB9XG4gICAgICAgIG1ldGhvZCArPSAnRGVwdGgnO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdiaWRzJzogb3JkZXJib29rWydiaWRzJ10sXG4gICAgICAgICAgICAnYXNrcyc6IHRoaXMuc29ydEJ5IChvcmRlcmJvb2tbJ2Fza3MnXSwgMCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwdWJsaWNHZXQnO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXJrZXRbJ2Z1dHVyZSddKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0Z1dHVyZSc7XG4gICAgICAgICAgICByZXF1ZXN0Wydjb250cmFjdF90eXBlJ10gPSAndGhpc193ZWVrJzsgLy8gbmV4dF93ZWVrLCBxdWFydGVyXG4gICAgICAgIH1cbiAgICAgICAgbWV0aG9kICs9ICdUaWNrZXInO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChyZXNwb25zZVsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIGxldCB0aWNrZXIgPSB0aGlzLmV4dGVuZCAocmVzcG9uc2VbJ3RpY2tlciddLCB7ICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdHJhZGVbJ2RhdGVfbXMnXSxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodHJhZGVbJ2RhdGVfbXMnXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwdWJsaWNHZXQnO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXJrZXRbJ2Z1dHVyZSddKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0Z1dHVyZSc7XG4gICAgICAgICAgICByZXF1ZXN0Wydjb250cmFjdF90eXBlJ10gPSAndGhpc193ZWVrJzsgLy8gbmV4dF93ZWVrLCBxdWFydGVyXG4gICAgICAgIH1cbiAgICAgICAgbWV0aG9kICs9ICdUcmFkZXMnO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSAxNDQwLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHVibGljR2V0JztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hcmtldFsnZnV0dXJlJ10pIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnRnV0dXJlJztcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvbnRyYWN0X3R5cGUnXSA9ICd0aGlzX3dlZWsnOyAvLyBuZXh0X3dlZWssIHF1YXJ0ZXJcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgKz0gJ0tsaW5lJztcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnc2l6ZSddID0gcGFyc2VJbnQgKGxpbWl0KTtcbiAgICAgICAgaWYgKHNpbmNlKSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzaW5jZSddID0gc2luY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzaW5jZSddID0gdGhpcy5taWxsaXNlY29uZHMgKCkgLSA4NjQwMDAwMDsgLy8gbGFzdCAyNCBob3Vyc1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFVzZXJpbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnaW5mbyddWydmdW5kcyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2VzWydmcmVlJ10sIGxvd2VyY2FzZSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlc1snZnJlZXplZCddLCBsb3dlcmNhc2UsIDAuMCk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWFya2V0WydmdXR1cmUnXSkge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdGdXR1cmUnO1xuICAgICAgICAgICAgb3JkZXIgPSB0aGlzLmV4dGVuZCAob3JkZXIsIHtcbiAgICAgICAgICAgICAgICAnY29udHJhY3RfdHlwZSc6ICd0aGlzX3dlZWsnLCAvLyBuZXh0X3dlZWssIHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICAnbWF0Y2hfcHJpY2UnOiAwLCAvLyBtYXRjaCBiZXN0IGNvdW50ZXIgcGFydHkgcHJpY2U/IDAgb3IgMSwgaWdub3JlcyBwcmljZSBpZiAxXG4gICAgICAgICAgICAgICAgJ2xldmVyX3JhdGUnOiAxMCwgLy8gbGV2ZXJhZ2UgcmF0ZSB2YWx1ZTogMTAgb3IgMjAgKDEwIGJ5IGRlZmF1bHQpXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0Jykge1xuICAgICAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgICAgICAgICAgb3JkZXJbJ2Ftb3VudCddID0gYW1vdW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcmRlclsndHlwZSddICs9ICdfbWFya2V0JztcbiAgICAgICAgICAgICAgICBpZiAoc2lkZSA9PSAnYnV5Jykge1xuICAgICAgICAgICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHRoaXMuc2FmZUZsb2F0IChwYXJhbXMsICdjb3N0Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JkZXJbJ3ByaWNlJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgbWFya2V0IGJ1eSBvcmRlcnMgcmVxdWlyZSBhbiBhZGRpdGlvbmFsIGNvc3QgcGFyYW1ldGVyLCBjb3N0ID0gcHJpY2UgKiBhbW91bnQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmRlclsnYW1vdW50J10gPSBhbW91bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHRoaXMub21pdCAocGFyYW1zLCAnY29zdCcpO1xuICAgICAgICBtZXRob2QgKz0gJ1RyYWRlJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlcigpIHJlcXVpcmVzIGEgc3ltYm9sIGFyZ3VtZW50Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ29yZGVyX2lkJzogaWQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnO1xuICAgICAgICBpZiAobWFya2V0WydmdXR1cmUnXSkge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdGdXR1cmVDYW5jZWwnO1xuICAgICAgICAgICAgcmVxdWVzdFsnY29udHJhY3RfdHlwZSddID0gJ3RoaXNfd2Vlayc7IC8vIG5leHRfd2VlaywgcXVhcnRlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdDYW5jZWxPcmRlcic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBwYXJzZU9yZGVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnY2FuY2VsZWQnO1xuICAgICAgICBpZiAoc3RhdHVzID09IDApXG4gICAgICAgICAgICByZXR1cm4gJ29wZW4nO1xuICAgICAgICBpZiAoc3RhdHVzID09IDEpXG4gICAgICAgICAgICByZXR1cm4gJ3BhcnRpYWwnO1xuICAgICAgICBpZiAoc3RhdHVzID09IDIpXG4gICAgICAgICAgICByZXR1cm4gJ2Nsb3NlZCc7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gNClcbiAgICAgICAgICAgIHJldHVybiAnY2FuY2VsZWQnO1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3R5cGUnIGluIG9yZGVyKSB7XG4gICAgICAgICAgICBpZiAoKG9yZGVyWyd0eXBlJ10gPT0gJ2J1eScpIHx8IChvcmRlclsndHlwZSddID09ICdzZWxsJykpIHtcbiAgICAgICAgICAgICAgICBzaWRlID0gb3JkZXJbJ3R5cGUnXTtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2xpbWl0JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lkZSA9IChvcmRlclsndHlwZSddID09ICdidXlfbWFya2V0JykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ21hcmtldCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXR1cyA9IHRoaXMucGFyc2VPcmRlclN0YXR1cyAob3JkZXJbJ3N0YXR1cyddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGlmICgnc3ltYm9sJyBpbiBvcmRlcilcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJbJ3N5bWJvbCddIGluIHRoaXMubWFya2V0c19ieV9pZClcbiAgICAgICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW29yZGVyWydzeW1ib2wnXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnY3JlYXRlX2RhdGUnIGluIG9yZGVyKVxuICAgICAgICAgICAgdGltZXN0YW1wID0gb3JkZXJbJ2NyZWF0ZV9kYXRlJ107XG4gICAgICAgIGxldCBhbW91bnQgPSBvcmRlclsnYW1vdW50J107XG4gICAgICAgIGxldCBmaWxsZWQgPSBvcmRlclsnZGVhbF9hbW91bnQnXTtcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IGFtb3VudCAtIGZpbGxlZDtcbiAgICAgICAgbGV0IGF2ZXJhZ2UgPSBvcmRlclsnYXZnX3ByaWNlJ107XG4gICAgICAgIGxldCBjb3N0ID0gYXZlcmFnZSAqIGZpbGxlZDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnb3JkZXJfaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogb3JkZXJbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYXZlcmFnZSc6IGF2ZXJhZ2UsXG4gICAgICAgICAgICAnY29zdCc6IGNvc3QsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgJ2ZlZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJ2ZldGNoT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtZXRlcicpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IGlkLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgIC8vICdzdGF0dXMnOiAwLCAvLyAwIGZvciB1bmZpbGxlZCBvcmRlcnMsIDEgZm9yIGZpbGxlZCBvcmRlcnNcbiAgICAgICAgICAgIC8vICdjdXJyZW50X3BhZ2UnOiAxLCAvLyBjdXJyZW50IHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAvLyAncGFnZV9sZW5ndGgnOiAyMDAsIC8vIG51bWJlciBvZiBvcmRlcnMgcmV0dXJuZWQgcGVyIHBhZ2UsIG1heGltdW0gMjAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtYXJrZXRbJ2Z1dHVyZSddKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0Z1dHVyZSc7XG4gICAgICAgICAgICByZXF1ZXN0Wydjb250cmFjdF90eXBlJ10gPSAndGhpc193ZWVrJzsgLy8gbmV4dF93ZWVrLCBxdWFydGVyXG4gICAgICAgIH1cbiAgICAgICAgbWV0aG9kICs9ICdPcmRlckluZm8nO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2VbJ29yZGVycyddWzBdKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICghc3ltYm9sKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnZmV0Y2hPcmRlcnMgcmVxdWlyZXMgYSBzeW1ib2wgcGFyYW1ldGVyJyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IG9yZGVyX2lkX2luX3BhcmFtcyA9ICgnb3JkZXJfaWQnIGluIHBhcmFtcyk7XG4gICAgICAgIGlmIChtYXJrZXRbJ2Z1dHVyZSddKSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0Z1dHVyZU9yZGVyc0luZm8nO1xuICAgICAgICAgICAgcmVxdWVzdFsnY29udHJhY3RfdHlwZSddID0gJ3RoaXNfd2Vlayc7IC8vIG5leHRfd2VlaywgcXVhcnRlclxuICAgICAgICAgICAgaWYgKCFvcmRlcl9pZF9pbl9wYXJhbXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXJzKCkgcmVxdWlyZXMgb3JkZXJfaWQgcGFyYW0gZm9yIGZ1dHVyZXMgbWFya2V0ICcgKyBzeW1ib2wgKyAnIChhIHN0cmluZyBvZiBvbmUgb3IgbW9yZSBvcmRlciBpZHMsIGNvbW1hLXNlcGFyYXRlZCknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoJ3R5cGUnIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHBhcmFtc1sndHlwZSddO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnc3RhdHVzJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBwYXJhbXNbJ3N0YXR1cyddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcmRlcnMoKSByZXF1aXJlcyB0eXBlIHBhcmFtIG9yIHN0YXR1cyBwYXJhbSBmb3Igc3BvdCBtYXJrZXQgJyArIHN5bWJvbCArICcgKDAgb3IgXCJvcGVuXCIgZm9yIHVuZmlsbGVkIG9yZGVycywgMSBvciBcImNsb3NlZFwiIGZvciBmaWxsZWQgb3JkZXJzKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSAnb3BlbicpXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT0gJ2Nsb3NlZCcpXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gMTtcbiAgICAgICAgICAgIGlmIChvcmRlcl9pZF9pbl9wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgKz0gJ09yZGVyc0luZm8nO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kICs9ICdPcmRlckhpc3RvcnknO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAocmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAnY3VycmVudF9wYWdlJzogMSwgLy8gY3VycmVudCBwYWdlIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAncGFnZV9sZW5ndGgnOiAyMDAsIC8vIG51bWJlciBvZiBvcmRlcnMgcmV0dXJuZWQgcGVyIHBhZ2UsIG1heGltdW0gMjAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMgPSB0aGlzLm9taXQgKHBhcmFtcywgWyAndHlwZScsICdzdGF0dXMnIF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ29yZGVycyddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9wZW4gPSAwOyAvLyAwIGZvciB1bmZpbGxlZCBvcmRlcnMsIDEgZm9yIGZpbGxlZCBvcmRlcnNcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hPcmRlcnMgKHN5bWJvbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3RhdHVzJzogb3BlbixcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY2xvc2VkID0gMTsgLy8gMCBmb3IgdW5maWxsZWQgb3JkZXJzLCAxIGZvciBmaWxsZWQgb3JkZXJzXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N0YXR1cyc6IGNsb3NlZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKSArICdfdXNkJztcbiAgICAgICAgLy8gaWYgKGFtb3VudCA8IDAuMDEpXG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgd2l0aGRyYXcoKSByZXF1aXJlcyBhbW91bnQgPiAwLjAxJyk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IGxvd2VyY2FzZSxcbiAgICAgICAgICAgICd3aXRoZHJhd19hZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgICd3aXRoZHJhd19hbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAndGFyZ2V0JzogJ2FkZHJlc3MnLCAvLyBvciBva2NuLCBva2NvbSwgb2tleFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcXVlcnkgPSBwYXJhbXM7XG4gICAgICAgIGlmICgnY2hhcmdlZmVlJyBpbiBxdWVyeSkge1xuICAgICAgICAgICAgcmVxdWVzdFsnY2hhcmdlZmVlJ10gPSBxdWVyeVsnY2hhcmdlZmVlJ107XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMub21pdCAocXVlcnksICdjaGFyZ2VmZWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyB3aXRoZHJhdygpIHJlcXVpcmVzIGEgYGNoYXJnZWZlZWAgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhc3N3b3JkID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5wYXNzd29yZCkge1xuICAgICAgICAgICAgcGFzc3dvcmQgPSB0aGlzLnBhc3N3b3JkO1xuICAgICAgICB9IGVsc2UgaWYgKCdwYXNzd29yZCcgaW4gcXVlcnkpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3RyYWRlX3B3ZCddID0gcXVlcnlbJ3Bhc3N3b3JkJ107XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMub21pdCAocXVlcnksICdwYXNzd29yZCcpO1xuICAgICAgICB9IGVsc2UgaWYgKCd0cmFkZV9wd2QnIGluIHF1ZXJ5KSB7XG4gICAgICAgICAgICByZXF1ZXN0Wyd0cmFkZV9wd2QnXSA9IHF1ZXJ5Wyd0cmFkZV9wd2QnXTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5vbWl0IChxdWVyeSwgJ3RyYWRlX3B3ZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFzc3dvcmQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgd2l0aGRyYXcoKSByZXF1aXJlcyB0aGlzLnBhc3N3b3JkIHNldCBvbiB0aGUgZXhjaGFuZ2UgaW5zdGFuY2Ugb3IgYSBwYXNzd29yZCAvIHRyYWRlX3B3ZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcXVlcnkpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiB0aGlzLnNhZmVTdHJpbmcgKHJlc3BvbnNlLCAnd2l0aGRyYXdfaWQnKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSAnLyc7XG4gICAgICAgIGlmIChhcGkgIT0gJ3dlYicpXG4gICAgICAgICAgICB1cmwgKz0gdGhpcy52ZXJzaW9uICsgJy8nO1xuICAgICAgICB1cmwgKz0gcGF0aCArIHRoaXMuZXh0ZW5zaW9uO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmtleXNvcnQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2FwaV9rZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgLy8gc2VjcmV0IGtleSBtdXN0IGJlIGF0IHRoZSBlbmQgb2YgcXVlcnlcbiAgICAgICAgICAgIGxldCBxdWVyeVN0cmluZyA9IHRoaXMucmF3ZW5jb2RlIChxdWVyeSkgKyAnJnNlY3JldF9rZXk9JyArIHRoaXMuc2VjcmV0O1xuICAgICAgICAgICAgcXVlcnlbJ3NpZ24nXSA9IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKHF1ZXJ5U3RyaW5nKSkudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgdXJsO1xuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydyZXN1bHQnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgaWYgKCdlcnJvcl9jb2RlJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBva2NvaW51c2QgPSByZXF1aXJlICgnLi9va2NvaW51c2QuanMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBva2V4IGV4dGVuZHMgb2tjb2ludXNkIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdva2V4JyxcbiAgICAgICAgICAgICduYW1lJzogJ09LRVgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0NOJywgJ1VTJyBdLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGdXR1cmVNYXJrZXRzJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzI1NTI3NjgtMGQ2ZGQzYzYtYzRhNi0xMWU3LTkwZjgtYzA0M2I2NDc1NmE3LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3dlYic6ICdodHRwczovL3d3dy5va2V4LmNvbS92MicsXG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly93d3cub2tleC5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly93d3cub2tleC5jb20vYXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cub2tleC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cub2tleC5jb20vcmVzdF9nZXRTdGFydGVkLmh0bWwnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgcGF5bWl1bSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdwYXltaXVtJyxcbiAgICAgICAgICAgICduYW1lJzogJ1BheW1pdW0nLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0ZSJywgJ0VVJyBdLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzkwNTY0LWE5NDVhOWQ0LTVmZjktMTFlNy05ZDJkLWI2MzU3NjNmMmYyNC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9wYXltaXVtLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cucGF5bWl1bS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vUGF5bWl1bS9hcGktZG9jdW1lbnRhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5wYXltaXVtLmNvbS9wYWdlL2RldmVsb3BlcnMnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvdW50cmllcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS97aWR9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS97aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS97aWR9L2RlcHRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiaXRjb2luX2NoYXJ0cy97aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYml0Y29pbl9jaGFydHMve2lkfS9kZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZXJjaGFudC9nZXRfcGF5bWVudC97VVVJRH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvYWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2FkZHJlc3Nlcy97YnRjX2FkZHJlc3N9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9vcmRlcnMve1VVSUR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3ByaWNlX2FsZXJ0cycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL2FkZHJlc3NlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlci9wYXltZW50X3JlcXVlc3RzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2VyL3ByaWNlX2FsZXJ0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWVyY2hhbnQvY3JlYXRlX3BheW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvb3JkZXJzL3tVVUlEfS9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXIvcHJpY2VfYWxlcnRzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdldXInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAwNTksXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMDA1OSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRVc2VyICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKHRoaXMuY3VycmVuY2llcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSAnYmFsYW5jZV8nICsgbG93ZXJjYXNlO1xuICAgICAgICAgICAgbGV0IGxvY2tlZCA9ICdsb2NrZWRfJyArIGxvd2VyY2FzZTtcbiAgICAgICAgICAgIGlmIChiYWxhbmNlIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VzW2JhbGFuY2VdO1xuICAgICAgICAgICAgaWYgKGxvY2tlZCBpbiBiYWxhbmNlcylcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBiYWxhbmNlc1tsb2NrZWRdO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0RGF0YUlkRGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ2Ftb3VudCcpO1xuICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0RGF0YUlkVGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ2F0J10gKiAxMDAwO1xuICAgICAgICBsZXQgdndhcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHZ3YXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2JpZCcpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2snKSxcbiAgICAgICAgICAgICd2d2FwJzogdndhcCxcbiAgICAgICAgICAgICdvcGVuJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ29wZW4nKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ByaWNlJyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndmFyaWF0aW9uJyksXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydjcmVhdGVkX2F0X2ludCddKSAqIDEwMDA7XG4gICAgICAgIGxldCB2b2x1bWUgPSAndHJhZGVkXycgKyBtYXJrZXRbJ2Jhc2UnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndXVpZCddLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVt2b2x1bWVdLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERhdGFJZFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChtYXJrZXQsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICd0eXBlJzogdGhpcy5jYXBpdGFsaXplICh0eXBlKSArICdPcmRlcicsXG4gICAgICAgICAgICAnY3VycmVuY3knOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICAgICAgJ2RpcmVjdGlvbic6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RVc2VyT3JkZXJzICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWyd1dWlkJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJOdW1iZXInOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHVybCArIGJvZHk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBcGktS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FwaS1TaWduYXR1cmUnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5zZWNyZXQpLFxuICAgICAgICAgICAgICAgICdBcGktTm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9ycycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIEluc3VmZmljaWVudEZ1bmRzLCBPcmRlck5vdEZvdW5kLCBPcmRlck5vdENhY2hlZCB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgcG9sb25pZXggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAncG9sb25pZXgnLFxuICAgICAgICAgICAgJ25hbWUnOiAnUG9sb25pZXgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCwgLy8gdXAgdG8gNiBjYWxscyBwZXIgc2Vjb25kXG4gICAgICAgICAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgICAgICAgICAvLyBvYnNvbGV0ZSBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXNGZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVyJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaEN1cnJlbmNpZXMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE15VHJhZGVzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcmRlcic6ICdlbXVsYXRlZCcsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXJzJzogJ2VtdWxhdGVkJyxcbiAgICAgICAgICAgICAgICAnZmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnZmV0Y2hDbG9zZWRPcmRlcnMnOiAnZW11bGF0ZWQnLFxuICAgICAgICAgICAgICAgICdmZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaEN1cnJlbmNpZXMnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzVtJzogMzAwLFxuICAgICAgICAgICAgICAgICcxNW0nOiA5MDAsXG4gICAgICAgICAgICAgICAgJzMwbSc6IDE4MDAsXG4gICAgICAgICAgICAgICAgJzJoJzogNzIwMCxcbiAgICAgICAgICAgICAgICAnNGgnOiAxNDQwMCxcbiAgICAgICAgICAgICAgICAnMWQnOiA4NjQwMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2ODE3LWU5NDU2MzEyLTVlZTYtMTFlNy05YjNjLWI2MjhjYTU2MjZhNS5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9wb2xvbmlleC5jb20vcHVibGljJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9wb2xvbmlleC5jb20vdHJhZGluZ0FwaScsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vcG9sb25pZXguY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9wb2xvbmlleC5jb20vc3VwcG9ydC9hcGkvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly9wYXN0ZWJpbi5jb20vZE1YN21aRTAnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2ZlZXMnOiAnaHR0cHM6Ly9wb2xvbmlleC5jb20vZmVlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybjI0aFZvbHVtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuQ2hhcnREYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5DdXJyZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5Mb2FuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5PcmRlckJvb2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVyblRpY2tlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbExvYW5PZmZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Nsb3NlTWFyZ2luUG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyZWF0ZUxvYW5PZmZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2VuZXJhdGVOZXdBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRNYXJnaW5Qb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luQnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW5TZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtb3ZlT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybkFjdGl2ZUxvYW5zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5BdmFpbGFibGVBY2NvdW50QmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybkJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5Db21wbGV0ZUJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5EZXBvc2l0QWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5EZXBvc2l0c1dpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5GZWVJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5MZW5kaW5nSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuTWFyZ2luQWNjb3VudFN1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JldHVybk9wZW5Mb2FuT2ZmZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5PcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXR1cm5PcmRlclRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuVHJhZGFibGVCYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmV0dXJuVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b2dnbGVBdXRvUmVuZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZmVyQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMDAxNSxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDI1LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmcnOiAwLjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2xpbWl0cyc6IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAnbWluJzogMC4wMDAwMDAwMSxcbiAgICAgICAgICAgICAgICAgICAgJ21heCc6IDEwMDAwMDAwMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICdtaW4nOiAwLjAwMDAwMDAxLFxuICAgICAgICAgICAgICAgICAgICAnbWF4JzogMTAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdjb3N0Jzoge1xuICAgICAgICAgICAgICAgICAgICAnbWluJzogMC4wMDAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgJ21heCc6IDEwMDAwMDAwMDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHJlY2lzaW9uJzoge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiA4LFxuICAgICAgICAgICAgICAgICdwcmljZSc6IDgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVGZWUgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSwgdGFrZXJPck1ha2VyID0gJ3Rha2VyJywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICBsZXQga2V5ID0gJ3F1b3RlJztcbiAgICAgICAgbGV0IHJhdGUgPSBtYXJrZXRbdGFrZXJPck1ha2VyXTtcbiAgICAgICAgbGV0IGNvc3QgPSBwYXJzZUZsb2F0ICh0aGlzLmNvc3RUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQgKiByYXRlKSk7XG4gICAgICAgIGlmIChzaWRlID09ICdzZWxsJykge1xuICAgICAgICAgICAgY29zdCAqPSBwcmljZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9ICdiYXNlJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3R5cGUnOiB0YWtlck9yTWFrZXIsXG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRba2V5XSxcbiAgICAgICAgICAgICdyYXRlJzogcmF0ZSxcbiAgICAgICAgICAgICdjb3N0JzogcGFyc2VGbG9hdCAodGhpcy5mZWVUb1ByZWNpc2lvbiAoc3ltYm9sLCBjb3N0KSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tbW9uQ3VycmVuY3lDb2RlIChjdXJyZW5jeSkge1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JUTScpXG4gICAgICAgICAgICByZXR1cm4gJ0JpdG1hcmsnO1xuICAgICAgICByZXR1cm4gY3VycmVuY3k7XG4gICAgfVxuXG4gICAgY3VycmVuY3lJZCAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCaXRtYXJrJylcbiAgICAgICAgICAgIHJldHVybiAnQlRNJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICc1bScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbJ2RhdGUnXSAqIDEwMDAsXG4gICAgICAgICAgICBvaGxjdlsnb3BlbiddLFxuICAgICAgICAgICAgb2hsY3ZbJ2hpZ2gnXSxcbiAgICAgICAgICAgIG9obGN2Wydsb3cnXSxcbiAgICAgICAgICAgIG9obGN2WydjbG9zZSddLFxuICAgICAgICAgICAgb2hsY3ZbJ3ZvbHVtZSddLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzVtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGlmICghc2luY2UpXG4gICAgICAgICAgICBzaW5jZSA9IDA7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdwZXJpb2QnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgICAgICdzdGFydCc6IHBhcnNlSW50IChzaW5jZSAvIDEwMDApLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydlbmQnXSA9IHRoaXMuc3VtIChyZXF1ZXN0WydzdGFydCddLCBsaW1pdCAqIHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRSZXR1cm5DaGFydERhdGEgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuVGlja2VyICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgWyBxdW90ZSwgYmFzZSBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAodGhpcy5mZWVzWyd0cmFkaW5nJ10sIHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAnbG90JzogdGhpcy5saW1pdHNbJ2Ftb3VudCddWydtaW4nXSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJldHVybkNvbXBsZXRlQmFsYW5jZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYWNjb3VudCc6ICdhbGwnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlcyk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbaWRdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGlkKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnb25PcmRlcnMnXSksXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogMC4wLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRmVlcyAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGZlZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UmV0dXJuRmVlSW5mbyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogZmVlcyxcbiAgICAgICAgICAgICdtYWtlcic6IHBhcnNlRmxvYXQgKGZlZXNbJ21ha2VyRmVlJ10pLFxuICAgICAgICAgICAgJ3Rha2VyJzogcGFyc2VGbG9hdCAoZmVlc1sndGFrZXJGZWUnXSksXG4gICAgICAgICAgICAnd2l0aGRyYXcnOiAwLjAsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuT3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gyNGhyJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93MjRociddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2hlc3RCaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydsb3dlc3RBc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydwZXJjZW50Q2hhbmdlJ10pLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydxdW90ZVZvbHVtZSddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmFzZVZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFJldHVyblRpY2tlciAocGFyYW1zKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDdXJyZW5jaWVzIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuQ3VycmVuY2llcyAocGFyYW1zKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChjdXJyZW5jaWVzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tpZF07XG4gICAgICAgICAgICAvLyB0b2RvOiB3aWxsIG5lZWQgdG8gcmV0aGluayB0aGUgZmVlc1xuICAgICAgICAgICAgLy8gdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpcGxlIHdpdGhkcmF3YWwvZGVwb3NpdCBtZXRob2RzIGFuZFxuICAgICAgICAgICAgLy8gZGlmZmVyZW50aWF0ZWQgZmVlcyBmb3IgZWFjaCBwYXJ0aWN1bGFyIG1ldGhvZFxuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogOCwgLy8gZGVmYXVsdCBwcmVjaXNpb24sIHRvZG86IGZpeCBcIm1hZ2ljIGNvbnN0YW50c1wiXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogOCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgY29kZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChpZCk7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gKGN1cnJlbmN5WydkZWxpc3RlZCddID09IDApO1xuICAgICAgICAgICAgbGV0IHN0YXR1cyA9IChjdXJyZW5jeVsnZGlzYWJsZWQnXSkgPyAnZGlzYWJsZWQnIDogJ29rJztcbiAgICAgICAgICAgIHJlc3VsdFtjb2RlXSA9IHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnY29kZSc6IGNvZGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAnbmFtZSc6IGN1cnJlbmN5WyduYW1lJ10sXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IGFjdGl2ZSxcbiAgICAgICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICAgICAgICAgICdmZWUnOiBjdXJyZW5jeVsndHhGZWUnXSwgLy8gdG9kbzogcmVkZXNpZ25cbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJzogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICdsaW1pdHMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogTWF0aC5wb3cgKDEwLCAtcHJlY2lzaW9uWydhbW91bnQnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaWNlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsncHJpY2UnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnY29zdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogY3VycmVuY3lbJ3R4RmVlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogTWF0aC5wb3cgKDEwLCBwcmVjaXNpb25bJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFJldHVyblRpY2tlciAocGFyYW1zKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbbWFya2V0WydpZCddXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2RhdGUnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgoIW1hcmtldCkgJiYgKCdjdXJyZW5jeVBhaXInIGluIHRyYWRlKSlcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFt0cmFkZVsnY3VycmVuY3lQYWlyJ11dO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgbGV0IHNpZGUgPSB0cmFkZVsndHlwZSddO1xuICAgICAgICBsZXQgZmVlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29zdCA9IHRoaXMuc2FmZUZsb2F0ICh0cmFkZSwgJ3RvdGFsJyk7XG4gICAgICAgIGxldCBhbW91bnQgPSBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pO1xuICAgICAgICBpZiAoJ2ZlZScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIGxldCByYXRlID0gcGFyc2VGbG9hdCAodHJhZGVbJ2ZlZSddKTtcbiAgICAgICAgICAgIGxldCBmZWVDb3N0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9IG1hcmtldFsnYmFzZSddO1xuICAgICAgICAgICAgICAgIGZlZUNvc3QgPSBhbW91bnQgKiByYXRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9IG1hcmtldFsncXVvdGUnXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvc3QgIT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIGZlZUNvc3QgPSBjb3N0ICogcmF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZlZSA9IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAncmF0ZSc6IHJhdGUsXG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBmZWVDb3N0LFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ2lkJzogdGhpcy5zYWZlU3RyaW5nICh0cmFkZSwgJ3RyYWRlSUQnKSxcbiAgICAgICAgICAgICdvcmRlcic6IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICdvcmRlck51bWJlcicpLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3JhdGUnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2Nvc3QnOiBjb3N0LFxuICAgICAgICAgICAgJ2ZlZSc6IGZlZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0J10gPSBwYXJzZUludCAoc2luY2UgLyAxMDAwKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ2VuZCddID0gdGhpcy5zZWNvbmRzICgpOyAvLyBsYXN0IDUwMDAwIHRyYWRlcyBieSBkZWZhdWx0XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYWRlcyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuVHJhZGVIaXN0b3J5ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN5bWJvbClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcGFpciA9IG1hcmtldCA/IG1hcmtldFsnaWQnXSA6ICdhbGwnO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHsgJ2N1cnJlbmN5UGFpcic6IHBhaXIgfTtcbiAgICAgICAgaWYgKHNpbmNlKSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydCddID0gcGFyc2VJbnQgKHNpbmNlIC8gMTAwMCk7XG4gICAgICAgICAgICByZXF1ZXN0WydlbmQnXSA9IHRoaXMuc2Vjb25kcyAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsaW1pdCBpcyBkaXNhYmxlZCAoZG9lcyBub3QgcmVhbGx5IHdvcmsgYXMgZXhwZWN0ZWQpXG4gICAgICAgIC8vIGlmIChsaW1pdClcbiAgICAgICAgLy8gICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBwYXJzZUludCAobGltaXQpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UmV0dXJuVHJhZGVIaXN0b3J5ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWRlcyA9IHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlW2lkXSwgbWFya2V0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0cmFkZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0cmFkZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5U2luY2VMaW1pdCAocmVzdWx0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMuc2FmZUludGVnZXIgKG9yZGVyLCAndGltZXN0YW1wJyk7XG4gICAgICAgIGlmICghdGltZXN0YW1wKVxuICAgICAgICAgICAgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydkYXRlJ10pO1xuICAgICAgICBsZXQgdHJhZGVzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3Jlc3VsdGluZ1RyYWRlcycgaW4gb3JkZXIpXG4gICAgICAgICAgICB0cmFkZXMgPSB0aGlzLnBhcnNlVHJhZGVzIChvcmRlclsncmVzdWx0aW5nVHJhZGVzJ10sIG1hcmtldCk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICBsZXQgcHJpY2UgPSBwYXJzZUZsb2F0IChvcmRlclsncHJpY2UnXSk7XG4gICAgICAgIGxldCBjb3N0ID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAndG90YWwnLCAwLjApO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnYW1vdW50Jyk7XG4gICAgICAgIGxldCBhbW91bnQgPSB0aGlzLnNhZmVGbG9hdCAob3JkZXIsICdzdGFydGluZ0Ftb3VudCcsIHJlbWFpbmluZyk7XG4gICAgICAgIGxldCBmaWxsZWQgPSBhbW91bnQgLSByZW1haW5pbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ29yZGVyTnVtYmVyJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IG9yZGVyWydzdGF0dXMnXSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyWyd0eXBlJ10sXG4gICAgICAgICAgICAnc2lkZSc6IG9yZGVyWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdjb3N0JzogY29zdCxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmlsbGVkJzogZmlsbGVkLFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IHJlbWFpbmluZyxcbiAgICAgICAgICAgICd0cmFkZXMnOiB0cmFkZXMsXG4gICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlT3Blbk9yZGVycyAob3JkZXJzLCBtYXJrZXQsIHJlc3VsdCA9IFtdKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3JkZXIgPSBvcmRlcnNbaV07XG4gICAgICAgICAgICBsZXQgZXh0ZW5kZWQgPSB0aGlzLmV4dGVuZCAob3JkZXIsIHtcbiAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ29wZW4nLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAnc2lkZSc6IG9yZGVyWyd0eXBlJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogb3JkZXJbJ3JhdGUnXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMucGFyc2VPcmRlciAoZXh0ZW5kZWQsIG1hcmtldCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBwYWlyID0gbWFya2V0ID8gbWFya2V0WydpZCddIDogJ2FsbCc7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RSZXR1cm5PcGVuT3JkZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHBhaXIsXG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IG9wZW5PcmRlcnMgPSBbXTtcbiAgICAgICAgaWYgKG1hcmtldCkge1xuICAgICAgICAgICAgb3Blbk9yZGVycyA9IHRoaXMucGFyc2VPcGVuT3JkZXJzIChyZXNwb25zZSwgbWFya2V0LCBvcGVuT3JkZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXRJZHMgPSBPYmplY3Qua2V5cyAocmVzcG9uc2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya2V0SWQgPSBtYXJrZXRJZHNbaV07XG4gICAgICAgICAgICAgICAgbGV0IG9yZGVycyA9IHJlc3BvbnNlW21hcmtldElkXTtcbiAgICAgICAgICAgICAgICBsZXQgbSA9IHRoaXMubWFya2V0c19ieV9pZFttYXJrZXRJZF07XG4gICAgICAgICAgICAgICAgb3Blbk9yZGVycyA9IHRoaXMucGFyc2VPcGVuT3JkZXJzIChvcmRlcnMsIG0sIG9wZW5PcmRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3Blbk9yZGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhpcy5vcmRlcnNbb3Blbk9yZGVyc1tqXVsnaWQnXV0gPSBvcGVuT3JkZXJzW2pdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVuT3JkZXJzSW5kZXhlZEJ5SWQgPSB0aGlzLmluZGV4QnkgKG9wZW5PcmRlcnMsICdpZCcpO1xuICAgICAgICBsZXQgY2FjaGVkT3JkZXJJZHMgPSBPYmplY3Qua2V5cyAodGhpcy5vcmRlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2FjaGVkT3JkZXJJZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGNhY2hlZE9yZGVySWRzW2tdO1xuICAgICAgICAgICAgaWYgKGlkIGluIG9wZW5PcmRlcnNJbmRleGVkQnlJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXSA9IHRoaXMuZXh0ZW5kICh0aGlzLm9yZGVyc1tpZF0sIG9wZW5PcmRlcnNJbmRleGVkQnlJZFtpZF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLm9yZGVyc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gdGhpcy5leHRlbmQgKG9yZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ2Nsb3NlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29zdCc6IG9yZGVyWydhbW91bnQnXSAqIG9yZGVyWydwcmljZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxlZCc6IG9yZGVyWydhbW91bnQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZW1haW5pbmcnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcmRlciA9IHRoaXMub3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJbJ3N5bWJvbCddID09IHN5bWJvbClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9yZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKG9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeVNpbmNlTGltaXQgKHJlc3VsdCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgc2luY2UgPSB0aGlzLnNhZmVWYWx1ZSAocGFyYW1zLCAnc2luY2UnKTtcbiAgICAgICAgbGV0IGxpbWl0ID0gdGhpcy5zYWZlVmFsdWUgKHBhcmFtcywgJ2xpbWl0Jyk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5vbWl0IChwYXJhbXMsIFsgJ3NpbmNlJywgJ2xpbWl0JyBdKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IGF3YWl0IHRoaXMuZmV0Y2hPcmRlcnMgKHN5bWJvbCwgc2luY2UsIGxpbWl0LCByZXF1ZXN0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcmRlcnNbaV1bJ2lkJ10gPT0gaWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RDYWNoZWQgKHRoaXMuaWQgKyAnIG9yZGVyIGlkICcgKyBpZC50b1N0cmluZyAoKSArICcgbm90IGZvdW5kIGluIGNhY2hlJyk7XG4gICAgfVxuXG4gICAgZmlsdGVyT3JkZXJzQnlTdGF0dXMgKG9yZGVycywgc3RhdHVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvcmRlcnNbaV1bJ3N0YXR1cyddID09IHN0YXR1cylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAob3JkZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHNpbmNlLCBsaW1pdCwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyT3JkZXJzQnlTdGF0dXMgKG9yZGVycywgJ29wZW4nKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaENsb3NlZE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJzIChzeW1ib2wsIHNpbmNlLCBsaW1pdCwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyT3JkZXJzQnlTdGF0dXMgKG9yZGVycywgJ2Nsb3NlZCcpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgcHJpY2UgPSBwYXJzZUZsb2F0IChwcmljZSk7XG4gICAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQgKGFtb3VudCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAncmF0ZSc6IHRoaXMucHJpY2VUb1ByZWNpc2lvbiAoc3ltYm9sLCBwcmljZSksXG4gICAgICAgICAgICAnYW1vdW50JzogdGhpcy5hbW91bnRUb1ByZWNpc2lvbiAoc3ltYm9sLCBhbW91bnQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLnBhcnNlT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvcGVuJyxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfSwgcmVzcG9uc2UpLCBtYXJrZXQpO1xuICAgICAgICBsZXQgaWQgPSBvcmRlclsnaWQnXTtcbiAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gb3JkZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZCAoeyAnaW5mbyc6IHJlc3BvbnNlIH0sIG9yZGVyKTtcbiAgICB9XG5cbiAgICBhc3luYyBlZGl0T3JkZXIgKGlkLCBzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHByaWNlID0gcGFyc2VGbG9hdCAocHJpY2UpO1xuICAgICAgICBhbW91bnQgPSBwYXJzZUZsb2F0IChhbW91bnQpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdvcmRlck51bWJlcic6IGlkLFxuICAgICAgICAgICAgJ3JhdGUnOiB0aGlzLnByaWNlVG9QcmVjaXNpb24gKHN5bWJvbCwgcHJpY2UpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRoaXMuYW1vdW50VG9QcmVjaXNpb24gKHN5bWJvbCwgYW1vdW50KSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE1vdmVPcmRlciAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaWQgaW4gdGhpcy5vcmRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMub3JkZXJzW2lkXVsnc3RhdHVzJ10gPSAnY2FuY2VsZWQnO1xuICAgICAgICAgICAgbGV0IG5ld2lkID0gcmVzcG9uc2VbJ29yZGVyTnVtYmVyJ107XG4gICAgICAgICAgICB0aGlzLm9yZGVyc1tuZXdpZF0gPSB0aGlzLmV4dGVuZCAodGhpcy5vcmRlcnNbaWRdLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogbmV3aWQsXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICAgICAnc3RhdHVzJzogJ29wZW4nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmV4dGVuZCAodGhpcy5vcmRlcnNbbmV3aWRdLCB7ICdpbmZvJzogcmVzcG9uc2UgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJOdW1iZXInXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ29yZGVyTnVtYmVyJzogaWQsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm9yZGVycylcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyc1tpZF1bJ3N0YXR1cyddID0gJ2NhbmNlbGVkJztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdF9odHRwX3Jlc3BvbnNlLmluZGV4T2YgKCdJbnZhbGlkIG9yZGVyJykgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyKCkgZXJyb3I6ICcgKyB0aGlzLmxhc3RfaHR0cF9yZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyU3RhdHVzIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhd2FpdCB0aGlzLmZldGNoT3Blbk9yZGVycyAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGluZGV4ZWQgPSB0aGlzLmluZGV4QnkgKG9yZGVycywgJ2lkJyk7XG4gICAgICAgIHJldHVybiAoaWQgaW4gaW5kZXhlZCkgPyAnb3BlbicgOiAnY2xvc2VkJztcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyVHJhZGVzIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdHJhZGVzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJldHVybk9yZGVyVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVyTnVtYmVyJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAodHJhZGVzKTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBjdXJyZW5jeUlkID0gdGhpcy5jdXJyZW5jeUlkIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZW5lcmF0ZU5ld0FkZHJlc3MgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5SWRcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBhZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSA9PSAxKVxuICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2UsICdyZXNwb25zZScpO1xuICAgICAgICBpZiAoIWFkZHJlc3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY3JlYXRlRGVwb3NpdEFkZHJlc3MgZmFpbGVkOiAnICsgdGhpcy5sYXN0X2h0dHBfcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgICAgICAnc3RhdHVzJzogJ29rJyxcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hEZXBvc2l0QWRkcmVzcyAoY3VycmVuY3ksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RSZXR1cm5EZXBvc2l0QWRkcmVzc2VzICgpO1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuc2FmZVN0cmluZyAocmVzcG9uc2UsIGN1cnJlbmN5SWQpO1xuICAgICAgICBsZXQgc3RhdHVzID0gYWRkcmVzcyA/ICdvaycgOiAnbm9uZSc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXMsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3lJZCxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXN1bHQsXG4gICAgICAgICAgICAnaWQnOiByZXN1bHRbJ3Jlc3BvbnNlJ10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmV4dGVuZCAoeyAnY29tbWFuZCc6IHBhdGggfSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIHF1ZXJ5Wydub25jZSddID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdTaWduJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxldCBmYWlsZWQgPSByZXNwb25zZVsnZXJyb3InXS5pbmRleE9mICgnTm90IGVub3VnaCcpID49IDA7XG4gICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgT3JkZXJOb3RGb3VuZCwgSW52YWxpZE9yZGVyLCBJbnN1ZmZpY2llbnRGdW5kcyB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgcXJ5cHRvcyBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdxcnlwdG9zJyxcbiAgICAgICAgICAgICduYW1lJzogJ1FSWVBUT1MnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0NOJywgJ1RXJyBdLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ2ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgICAgICdmZXRjaE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoT3Blbk9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ZldGNoQ2xvc2VkT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwOTUzOTE1LWIxNjExZGMwLWE0MzYtMTFlNy04OTQ3LWM5NWJkNWE0MjA4Ni5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkucXJ5cHRvcy5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cucXJ5cHRvcy5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kZXZlbG9wZXJzLnF1b2luZS5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcm9kdWN0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfS9wcmljZV9sZXZlbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4ZWN1dGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lyX2xhZGRlcnMve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhY2NvdW50cy9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjcnlwdG9fYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V4ZWN1dGlvbnMvbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpYXRfYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYW5fYmlkcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy97aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve2lkfS9sb2FucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZ19hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGluZ19hY2NvdW50cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmlhdF9hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9hbl9iaWRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvYW5fYmlkcy97aWR9L2Nsb3NlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2Fucy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzL3tpZH0vY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzL3tpZH0vY2xvc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy9jbG9zZV9hbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRpbmdfYWNjb3VudHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2VfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsncXVvdGVkX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IG1ha2VyID0gcGFyc2VGbG9hdCAobWFya2V0WydtYWtlcl9mZWUnXSk7XG4gICAgICAgICAgICBsZXQgdGFrZXIgPSBwYXJzZUZsb2F0IChtYXJrZXRbJ3Rha2VyX2ZlZSddKTtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSAhbWFya2V0WydkaXNhYmxlZCddO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBtYWtlcixcbiAgICAgICAgICAgICAgICAndGFrZXInOiB0YWtlcixcbiAgICAgICAgICAgICAgICAnYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFjY291bnRzQmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHRvdGFsLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkUHJpY2VMZXZlbHMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5X3ByaWNlX2xldmVscycsICdzZWxsX3ByaWNlX2xldmVscycpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2xhc3RfdHJhZGVkX3ByaWNlJyBpbiB0aWNrZXIpIHtcbiAgICAgICAgICAgIGlmICh0aWNrZXJbJ2xhc3RfdHJhZGVkX3ByaWNlJ10pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gdGlja2VyWydsYXN0X3RyYWRlZF9wcmljZSddLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF90cmFkZWRfcHJpY2UnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoX21hcmtldF9hc2snXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3dfbWFya2V0X2JpZCddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ21hcmtldF9iaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydtYXJrZXRfYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogbGFzdCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV8yNGgnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0cyAocGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpY2tlcnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW3RdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aWNrZXJbJ2Jhc2VfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHRpY2tlclsncXVvdGVkX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFByb2R1Y3RzSWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydjcmVhdGVkX2F0J10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0YWtlcl9zaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ3F1YW50aXR5J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdwcm9kdWN0X2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhlY3V0aW9ucyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ21vZGVscyddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ29yZGVyX3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3Byb2R1Y3RfaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcihyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVQdXRPcmRlcnNJZENhbmNlbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5wYXJzZU9yZGVyKHJlc3VsdCk7XG4gICAgICAgIGlmICghb3JkZXJbJ3R5cGUnXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBPcmRlck5vdEZvdW5kICh0aGlzLmlkICsgJyAnICsgb3JkZXIpO1xuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyWydjcmVhdGVkX2F0J10gKiAxMDAwO1xuICAgICAgICBsZXQgbWFya2V0SWQgPSBvcmRlclsncHJvZHVjdF9pZCddO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzQnlJZFttYXJrZXRJZF07XG4gICAgICAgIGxldCBzdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiBvcmRlcikge1xuICAgICAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnbGl2ZScpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnZmlsbGVkJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdjbG9zZWQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmRlclsnc3RhdHVzJ10gPT0gJ2NhbmNlbGxlZCcpIHsgLy8gJ2xsJyBpbnRlbmRlZFxuICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKG9yZGVyWydxdWFudGl0eSddKTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IHBhcnNlRmxvYXQgKG9yZGVyWydmaWxsZWRfcXVhbnRpdHknXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICd0eXBlJzogb3JkZXJbJ29yZGVyX3R5cGUnXSxcbiAgICAgICAgICAgICdzdGF0dXMnOiBzdGF0dXMsXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3NpZGUnOiBvcmRlclsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogb3JkZXJbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiBhbW91bnQgLSBmaWxsZWQsXG4gICAgICAgICAgICAndHJhZGVzJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZlZSc6IHtcbiAgICAgICAgICAgICAgICAnY3VycmVuY3knOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgJ2Nvc3QnOiBwYXJzZUZsb2F0IChvcmRlclsnb3JkZXJfZmVlJ10pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXJzSWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXIgKG9yZGVyKTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcz17fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3Byb2R1Y3RfaWQnXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHVzID0gcGFyYW1zWydzdGF0dXMnXTtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAnb3BlbicpIHtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXR1cyddID0gJ2xpdmUnO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmVxdWVzdFsnc3RhdHVzJ10gPSAnZmlsbGVkJztcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ2NhbmNlbGVkJykge1xuICAgICAgICAgICAgcmVxdWVzdFsnc3RhdHVzJ10gPSAnY2FuY2VsbGVkJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXJzIChyZXF1ZXN0KTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHJlc3VsdFsnbW9kZWxzJ107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChvcmRlcnMsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBzaW5jZSwgbGltaXQsIHRoaXMuZXh0ZW5kICh7ICdzdGF0dXMnOiAnb3BlbicgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaE9yZGVycyAoc3ltYm9sLCBzaW5jZSwgbGltaXQsIHRoaXMuZXh0ZW5kICh7ICdzdGF0dXMnOiAnY2xvc2VkJyB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcnMgKGNvZGUsIHJlYXNvbiwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY29kZSA9PSAyMDAgfHwgY29kZSA9PSA0MDQgfHwgY29kZSA9PSA0MjIpIHtcbiAgICAgICAgICAgIGlmICgoYm9keVswXSA9PSAneycpIHx8IChib2R5WzBdID09ICdbJykpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UgKGJvZHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgYSBKU09OIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHJldHVybmVkIGEgbm9uLUpTT04gcmVwbHk6ICcgKyBib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA9PSA0MDQpIHtcbiAgICAgICAgICAgIGlmICgnbWVzc2FnZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ21lc3NhZ2UnXSA9PSAnT3JkZXIgbm90IGZvdW5kJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3JkZXJOb3RGb3VuZCAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09IDQyMikge1xuICAgICAgICAgICAgaWYgKCdlcnJvcnMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9ycyA9IHJlc3BvbnNlWydlcnJvcnMnXTtcbiAgICAgICAgICAgICAgICBpZiAoJ3VzZXInIGluIGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZXMgPSBlcnJvcnNbJ3VzZXInXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzLmluZGV4T2YgKCdub3RfZW5vdWdoX2ZyZWVfYmFsYW5jZScpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgncXVhbnRpdHknIGluIGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZXMgPSBlcnJvcnNbJ3F1YW50aXR5J107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlcy5pbmRleE9mICgnbGVzc190aGFuX29yZGVyX3NpemUnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9yZGVyICh0aGlzLmlkICsgJyAnICsgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdYLVF1b2luZS1BUEktVmVyc2lvbic6IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICdwYXRoJzogdXJsLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICd0b2tlbl9pZCc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdpYXQnOiBNYXRoLmZsb29yIChub25jZSAvIDEwMDApLCAvLyBpc3N1ZWQgYXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBoZWFkZXJzWydYLVF1b2luZS1BdXRoJ10gPSB0aGlzLmp3dCAocmVxdWVzdCwgdGhpcy5zZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmw7XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgcXVhZHJpZ2FjeCBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdxdWFkcmlnYWN4JyxcbiAgICAgICAgICAgICduYW1lJzogJ1F1YWRyaWdhQ1gnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdDQScsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG9ic29sZXRlIG1ldGFpbmZvIGludGVyZmFjZVxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIC8vIG5ldyBtZXRhaW5mbyBpbnRlcmZhY2VcbiAgICAgICAgICAgICdoYXMnOiB7XG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2ODI1LTk4YTZkMGRlLTVlZTctMTFlNy05ZmE0LTM4ZTExYTJjNmY1Mi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkucXVhZHJpZ2FjeC5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cucXVhZHJpZ2FjeC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cucXVhZHJpZ2FjeC5jb20vYXBpX2luZm8nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd1aWQnOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYml0Y29pbl9kZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpdGNvaW5fd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2V0aGVyX2RlcG9zaXRfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXRoZXJfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbG9va3VwX29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuX29yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlcl90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ21hcmtldHMnOiB7XG4gICAgICAgICAgICAgICAgJ0JUQy9DQUQnOiB7ICdpZCc6ICdidGNfY2FkJywgJ3N5bWJvbCc6ICdCVEMvQ0FEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NBRCcsICdtYWtlcic6IDAuMDA1LCAndGFrZXInOiAwLjAwNSB9LFxuICAgICAgICAgICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnYnRjX3VzZCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnLCAnbWFrZXInOiAwLjAwNSwgJ3Rha2VyJzogMC4wMDUgfSxcbiAgICAgICAgICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aF9idGMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJywgJ21ha2VyJzogMC4wMDIsICd0YWtlcic6IDAuMDAyIH0sXG4gICAgICAgICAgICAgICAgJ0VUSC9DQUQnOiB7ICdpZCc6ICdldGhfY2FkJywgJ3N5bWJvbCc6ICdFVEgvQ0FEJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0NBRCcsICdtYWtlcic6IDAuMDA1LCAndGFrZXInOiAwLjAwNSB9LFxuICAgICAgICAgICAgICAgICdMVEMvQ0FEJzogeyAnaWQnOiAnbHRjX2NhZCcsICdzeW1ib2wnOiAnTFRDL0NBRCcsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdDQUQnLCAnbWFrZXInOiAwLjAwNSwgJ3Rha2VyJzogMC4wMDUgfSxcbiAgICAgICAgICAgICAgICAnQkNIL0NBRCc6IHsgJ2lkJzogJ2J0Y19jYWQnLCAnc3ltYm9sJzogJ0JDSC9DQUQnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQ0FEJywgJ21ha2VyJzogMC4wMDUsICd0YWtlcic6IDAuMDA1IH0sXG4gICAgICAgICAgICAgICAgJ0JURy9DQUQnOiB7ICdpZCc6ICdidGdfY2FkJywgJ3N5bWJvbCc6ICdCVEcvQ0FEJywgJ2Jhc2UnOiAnQlRHJywgJ3F1b3RlJzogJ0NBRCcsICdtYWtlcic6IDAuMDA1LCAndGFrZXInOiAwLjAwNSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2xvd2VyY2FzZSArICdfYXZhaWxhYmxlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogcGFyc2VGbG9hdCAoYmFsYW5jZXNbbG93ZXJjYXNlICsgJ19yZXNlcnZlZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBwYXJzZUZsb2F0IChiYWxhbmNlc1tsb3dlcmNhc2UgKyAnX2JhbGFuY2UnXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdib29rJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJib29rWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdib29rJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodGlja2VyWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICBsZXQgdndhcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKTtcbiAgICAgICAgbGV0IGJhc2VWb2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHZ3YXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB2d2FwLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBiYXNlVm9sdW1lLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcXVvdGVWb2x1bWUsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhbnNhY3Rpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Jvb2snOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnYm9vayc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgd2l0aGRyYXdhbE1ldGhvZCAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdFVEgnKVxuICAgICAgICAgICAgcmV0dXJuICdFdGhlcic7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnQlRDJylcbiAgICAgICAgICAgIHJldHVybiAnQml0Y29pbic7XG4gICAgfVxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzc1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMud2l0aGRyYXdhbE1ldGhvZCAoY3VycmVuY3kpICsgJ1dpdGhkcmF3YWwnO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gWyBub25jZS50b1N0cmluZyAoKSwgdGhpcy51aWQsIHRoaXMuYXBpS2V5IF0uam9pbiAoJycpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBxcnlwdG9zID0gcmVxdWlyZSAoJy4vcXJ5cHRvcy5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHF1b2luZSBleHRlbmRzIHFyeXB0b3Mge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3F1b2luZScsXG4gICAgICAgICAgICAnbmFtZSc6ICdRVU9JTkUnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6IFsgJ0pQJywgJ1NHJywgJ1ZOJyBdLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMicsXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4NDQtOTYxNWE0ZTgtNWVlOC0xMWU3LTg4MTQtZmNkMDA0ZGI4Y2RkLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5xdW9pbmUuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LnF1b2luZS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kZXZlbG9wZXJzLnF1b2luZS5jb20nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHNvdXRoeGNoYW5nZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICdzb3V0aHhjaGFuZ2UnLFxuICAgICAgICAgICAgJ25hbWUnOiAnU291dGhYY2hhbmdlJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQVInLCAvLyBBcmdlbnRpbmFcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc4Mzg5MTItNGY5NGVjOGEtNjBmNi0xMWU3LTllNWQtYmJmOWJkNTBhNTU5LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5zb3V0aHhjaGFuZ2UuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5zb3V0aHhjaGFuZ2UuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LnNvdXRoeGNoYW5nZS5jb20vSG9tZS9BcGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwcmljZS97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncHJpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29rL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbE1hcmtldE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dlbmVyYXRlbmV3YWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGlzdEJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RpZXJCYXNlZCc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAncGVyY2VudGFnZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMiAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbMF07XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbMV07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IGlkID0gc3ltYm9sO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TGlzdEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydDdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSBwYXJzZUZsb2F0IChiYWxhbmNlWydBdmFpbGFibGUnXSk7XG4gICAgICAgICAgICBsZXQgdXNlZCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ1VuY29uZmlybWVkJ10pO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gdGhpcy5zdW0gKGZyZWUsIHVzZWQpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBmcmVlLFxuICAgICAgICAgICAgICAgICd1c2VkJzogdXNlZCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiB0b3RhbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJvb2tTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ0J1eU9yZGVycycsICdTZWxsT3JkZXJzJywgJ1ByaWNlJywgJ0Ftb3VudCcpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ0JpZCcpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdBc2snKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdMYXN0JyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ1ZhcmlhdGlvbjI0SHInKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdWb2x1bWUyNEhyJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJpY2VzIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHRoaXMuaW5kZXhCeSAocmVzcG9uc2UsICdNYXJrZXQnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJpY2VTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnQXQnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydUeXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsnUHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnQW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzU3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2xpc3RpbmdDdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICAgICAgJ3JlZmVyZW5jZUN1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydsaW1pdFByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFBsYWNlT3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2UudG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJDb2RlJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdIYXNoJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZm94Yml0ID0gcmVxdWlyZSAoJy4vZm94Yml0LmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mgc3VyYml0Y29pbiBleHRlbmRzIGZveGJpdCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnc3VyYml0Y29pbicsXG4gICAgICAgICAgICAnbmFtZSc6ICdTdXJCaXRjb2luJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVkUnLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTE1MTEtZjBhNTAxOTQtNjQ4MS0xMWU3LTk5YjUtOGYwMjkzMjQyNGNjLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly9zdXJiaXRjb2luLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6ICdodHRwczovL2JsaW5rdHJhZGUuY29tL2RvY3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgRXhjaGFuZ2UgPSByZXF1aXJlICgnLi9iYXNlL0V4Y2hhbmdlJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgdGhlcm9jayBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICd0aGVyb2NrJyxcbiAgICAgICAgICAgICduYW1lJzogJ1RoZVJvY2tUcmFkaW5nJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnTVQnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2ODY5LTc1MDU3ZmEyLTVlZTktMTFlNy05YTZmLTEzZTY0MWZhNDcwNy5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkudGhlcm9ja3RyYWRpbmcuY29tJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vdGhlcm9ja3RyYWRpbmcuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcGkudGhlcm9ja3RyYWRpbmcuY29tL2RvYy92MS9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLnRoZXJvY2t0cmFkaW5nLmNvbS9kb2MvJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97aWR9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHMve2lkfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRzL3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy90aWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWxhbmNlcy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXNjb3VudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Rpc2NvdW50cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHMve2lkfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZnVuZHMve2Z1bmRfaWR9L3Bvc2l0aW9uX2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vcG9zaXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vcG9zaXRpb25zL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2xpbWl0cy97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhd19saW1pdHMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdG1zL3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMvcmVtb3ZlX2FsbCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmVlcyc6IHtcbiAgICAgICAgICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ21ha2VyJzogMC4wMiAvIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4yIC8gMTAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNUaWNrZXJzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0c1sndGlja2VycyddLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sndGlja2VycyddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydmdW5kX2lkJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnYmFsYW5jZXMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBmcmVlID0gYmFsYW5jZVsndHJhZGluZ19iYWxhbmNlJ107XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBiYWxhbmNlWydiYWxhbmNlJ107XG4gICAgICAgICAgICBsZXQgdXNlZCA9IHRvdGFsIC0gZnJlZTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogZnJlZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHVzZWQsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogdG90YWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEZ1bmRzSWRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlcmJvb2tbJ2RhdGUnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9XG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0aWNrZXJbJ2RhdGUnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Nsb3NlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWVfdHJhZGVkJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNUaWNrZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHRoaXMuaW5kZXhCeSAocmVzcG9uc2VbJ3RpY2tlcnMnXSwgJ2Z1bmRfaWQnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRGdW5kc0lkVGlja2VyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydmdW5kX2lkJ11dO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydkYXRlJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNJZFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsndHJhZGVzJ10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEZ1bmRzRnVuZElkT3JkZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Z1bmRfaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZURlbGV0ZUZ1bmRzRnVuZElkT3JkZXJzSWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHVybDtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtVFJULUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdYLVRSVC1OT05DRSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdYLVRSVC1TSUdOJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcnMnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGxpcXVpID0gcmVxdWlyZSAoJy4vbGlxdWkuanMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB0aWRleCBleHRlbmRzIGxpcXVpIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICd0aWRleCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdUaWRleCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1VLJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAyMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMycsXG4gICAgICAgICAgICAvLyAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgLy8gJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwNzgxNzgwLTAzMTQ5ZGM0LWExMmUtMTFlNy04MmJiLTMxM2IyNjlkMjRkNC5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkudGlkZXguY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLnRpZGV4LmNvbS90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly90aWRleC5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly90aWRleC5jb20vcHVibGljLWFwaScsXG4gICAgICAgICAgICAgICAgJ2ZlZXMnOiAnaHR0cHM6Ly90aWRleC5jb20vcGFpcnMtc3BlYycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZlZXMnOiB7XG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0aWVyQmFzZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndGFrZXInOiAwLjEgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICdtYWtlcic6IDAuMSAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAndGllckJhc2VkJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICdwZXJjZW50YWdlJzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdCVEMnOiAwLjAwMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRVRIJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdMVEMnOiAwLjAwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdET0dFJzogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdJQ04nOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0RBU0gnOiAwLjAwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdHTk8nOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VPUyc6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkNIJzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICdVU0RUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnQlRDJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFVEgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xUQyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnRE9HRSc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnSUNOJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdEQVNIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHTk8nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0VPUyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQkNIJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdVU0RUJzogMCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBmb3hiaXQgPSByZXF1aXJlICgnLi9mb3hiaXQuanMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB1cmR1Yml0IGV4dGVuZHMgZm94Yml0IHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICd1cmR1Yml0JyxcbiAgICAgICAgICAgICduYW1lJzogJ1VyZHVCaXQnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdQSycsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk5MTQ1My0xNTZiZjNhZS02NDgwLTExZTctODJlYi03Mjk1ZmUxYjViYjQuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmJsaW5rdHJhZGUuY29tL2FwaScsXG4gICAgICAgICAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmJsaW5rdHJhZGUuY29tL3RhcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3VyZHViaXQuY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYmxpbmt0cmFkZS5jb20vZG9jcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHZhdWx0b3JvIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3ZhdWx0b3JvJyxcbiAgICAgICAgICAgICduYW1lJzogJ1ZhdWx0b3JvJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ0gnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICcxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4ODAtZjIwNWU4NzAtNWVlOS0xMWU3LThmZTItMGQ1YjE1ODgwNzUyLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS52YXVsdG9yby5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cudmF1bHRvcm8uY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYXBpLnZhdWx0b3JvLmNvbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JpZGFuZGFzaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYnV5b3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsYXRlc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhdGVzdHRyYWRlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxsb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMvZGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMvaG91cicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zL21vbnRoJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ215dHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdidXkve3N5bWJvbH0ve3R5cGV9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWwve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsbC97c3ltYm9sfS97dHlwZX0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ2RhdGEnXTtcbiAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ0Jhc2VDdXJyZW5jeSddO1xuICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ01hcmtldEN1cnJlbmN5J107XG4gICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgIGxldCBiYXNlSWQgPSBiYXNlO1xuICAgICAgICBsZXQgcXVvdGVJZCA9IHF1b3RlO1xuICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ01hcmtldE5hbWUnXTtcbiAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgJ2Jhc2VJZCc6IGJhc2VJZCxcbiAgICAgICAgICAgICdxdW90ZUlkJzogcXVvdGVJZCxcbiAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5X2NvZGUnXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBmcmVlID0gYmFsYW5jZVsnY2FzaCddO1xuICAgICAgICAgICAgbGV0IHVzZWQgPSBiYWxhbmNlWydyZXNlcnZlZCddO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gdGhpcy5zdW0gKGZyZWUsIHVzZWQpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBmcmVlLFxuICAgICAgICAgICAgICAgICd1c2VkJzogdXNlZCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiB0b3RhbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rIChwYXJhbXMpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiByZXNwb25zZVsnZGF0YSddWzBdWydiJ10sXG4gICAgICAgICAgICAnYXNrcyc6IHJlc3BvbnNlWydkYXRhJ11bMV1bJ3MnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkcycsICdhc2tzJywgJ0dvbGRfUHJpY2UnLCAnR29sZF9BbW91bnQnKTtcbiAgICAgICAgcmVzdWx0WydiaWRzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0WydiaWRzJ10sIDAsIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBxdW90ZSA9IGF3YWl0IHRoaXMucHVibGljR2V0QmlkYW5kYXNrIChwYXJhbXMpO1xuICAgICAgICBsZXQgYmlkc0xlbmd0aCA9IHF1b3RlWydiaWRzJ10ubGVuZ3RoO1xuICAgICAgICBsZXQgYmlkID0gcXVvdGVbJ2JpZHMnXVtiaWRzTGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBhc2sgPSBxdW90ZVsnYXNrcyddWzBdO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWycyNGhIaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnMjRoTG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IGJpZFswXSxcbiAgICAgICAgICAgICdhc2snOiBhc2tbMF0sXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0xhc3RQcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJzI0aFZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnVGltZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ0dvbGRfUHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnR29sZF9BbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFuc2FjdGlvbnNEYXkgKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0LCBzaW5jZSwgbGltaXQpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgJ1N5bWJvbFR5cGUnO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydxdW90ZUlkJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAnZ2xkJzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UgfHwgMSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2RhdGEnXVsnT3JkZXJfSUQnXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9XG5cbiAgICBzaWduIChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIHVybCArPSB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdhcGlrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIH0sIHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKSk7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnWC1TaWduYXR1cmUnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlICh1cmwpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAndXJsJzogdXJsLCAnbWV0aG9kJzogbWV0aG9kLCAnYm9keSc6IGJvZHksICdoZWFkZXJzJzogaGVhZGVycyB9O1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZm94Yml0ID0gcmVxdWlyZSAoJy4vZm94Yml0LmpzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgdmJ0YyBleHRlbmRzIGZveGJpdCB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAndmJ0YycsXG4gICAgICAgICAgICAnbmFtZSc6ICdWQlRDJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnVk4nLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTE0ODEtMWY1M2QxZDgtNjQ4MS0xMWU3LTg4NGUtMjFkMTdlNzkzOWRiLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly92YnRjLmV4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYmxpbmt0cmFkZS5jb20vZG9jcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFeGNoYW5nZSA9IHJlcXVpcmUgKCcuL2Jhc2UvRXhjaGFuZ2UnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB2aXJ3b3ggZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAndmlyd294JyxcbiAgICAgICAgICAgICduYW1lJzogJ1ZpcldvWCcsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogWyAnQVQnLCAnRVUnIF0sXG4gICAgICAgICAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAgICAgICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4OTQtNmRhOWQzNjAtNWVlYS0xMWU3LTkwYWEtNDFmMjcxMWI3NDA1LmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwOi8vYXBpLnZpcndveC5jb20vYXBpL2pzb24ucGhwJyxcbiAgICAgICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly93d3cudmlyd294LmNvbS9hcGkvdHJhZGluZy5waHAnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy52aXJ3b3guY29tJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LnZpcndveC5jb20vZGV2ZWxvcGVycy5waHAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdyZXF1aXJlZENyZWRlbnRpYWxzJzoge1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0cnVlLFxuICAgICAgICAgICAgICAgICdzZWNyZXQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnbG9naW4nOiB0cnVlLFxuICAgICAgICAgICAgICAgICdwYXNzd29yZCc6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0SW5zdHJ1bWVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEJlc3RQcmljZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE1hcmtldERlcHRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdlc3RpbWF0ZU1hcmtldE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRUcmFkZWRQcmljZVZvbHVtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0UmF3VHJhZGVEYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRTdGF0aXN0aWNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRUZXJtaW5hbExpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEdyaWRMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRHcmlkU3RhdGlzdGljcycsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEluc3RydW1lbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRCZXN0UHJpY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRNYXJrZXREZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZXN0aW1hdGVNYXJrZXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VHJhZGVkUHJpY2VWb2x1bWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldFJhd1RyYWRlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0U3RhdGlzdGljcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VGVybWluYWxMaXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRHcmlkTGlzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0R3JpZFN0YXRpc3RpY3MnLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDb21taXNzaW9uRGlzY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDb21taXNzaW9uRGlzY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE9yZGVycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwbGFjZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEluc3RydW1lbnRzICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzWydyZXN1bHQnXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sncmVzdWx0J11ba2V5c1twXV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2luc3RydW1lbnRJRCddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnbG9uZ0N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3Nob3J0Q3VycmVuY3knXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmVzdWx0J11bJ2FjY291bnRMaXN0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBiYWxhbmNlWydiYWxhbmNlJ107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHRvdGFsLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE1hcmtldFByaWNlIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljUG9zdEdldEJlc3RQcmljZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9scyc6IFsgc3ltYm9sIF0sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0IChyZXN1bHRbMF0sICdiZXN0QnV5UHJpY2UnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAocmVzdWx0WzBdLCAnYmVzdFNlbGxQcmljZScpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljUG9zdEdldE1hcmtldERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbHMnOiBbIHN5bWJvbCBdLFxuICAgICAgICAgICAgJ2J1eURlcHRoJzogMTAwLFxuICAgICAgICAgICAgJ3NlbGxEZXB0aCc6IDEwMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsncmVzdWx0J11bMF07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2J1eScsICdzZWxsJywgJ3ByaWNlJywgJ3ZvbHVtZScpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gZW5kIC0gODY0MDAwMDA7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVkUHJpY2VWb2x1bWUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaW5zdHJ1bWVudCc6IHN5bWJvbCxcbiAgICAgICAgICAgICdlbmREYXRlJzogdGhpcy5ZbWRITVMgKGVuZCksXG4gICAgICAgICAgICAnc3RhcnREYXRlJzogdGhpcy5ZbWRITVMgKHN0YXJ0KSxcbiAgICAgICAgICAgICdITE9DJzogMSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBtYXJrZXRQcmljZSA9IGF3YWl0IHRoaXMuZmV0Y2hNYXJrZXRQcmljZSAoc3ltYm9sLCBwYXJhbXMpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydyZXN1bHQnXVsncHJpY2VWb2x1bWVMaXN0J107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBsYXN0S2V5ID0ga2V5c1tsZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbbGFzdEtleV07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogbWFya2V0UHJpY2VbJ2JpZCddLFxuICAgICAgICAgICAgJ2Fzayc6IG1hcmtldFByaWNlWydhc2snXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Nsb3NlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydsb25nVm9sdW1lJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydzaG9ydFZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wdWJsaWNHZXRSYXdUcmFkZURhdGEgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaW5zdHJ1bWVudCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICd0aW1lc3Bhbic6IDM2MDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChtYXJrZXQsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdpbnN0cnVtZW50JzogdGhpcy5zeW1ib2wgKG1hcmtldCksXG4gICAgICAgICAgICAnb3JkZXJUeXBlJzogc2lkZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UGxhY2VPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJJRCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVySUQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgc2lnbiAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBsZXQgYXV0aCA9IHt9O1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQ3JlZGVudGlhbHMgKCk7XG4gICAgICAgICAgICBhdXRoWydrZXknXSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgYXV0aFsndXNlciddID0gdGhpcy5sb2dpbjtcbiAgICAgICAgICAgIGF1dGhbJ3Bhc3MnXSA9IHRoaXMucGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICdpZCc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgYXV0aCwgcGFyYW1zKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHRoaXMuZXh0ZW5kIChhdXRoLCBwYXJhbXMpLFxuICAgICAgICAgICAgICAgICdpZCc6IG5vbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGxpcXVpID0gcmVxdWlyZSAoJy4vbGlxdWkuanMnKVxuY29uc3QgeyBFeGNoYW5nZUVycm9yLCBJbnN1ZmZpY2llbnRGdW5kcywgT3JkZXJOb3RGb3VuZCwgRERvU1Byb3RlY3Rpb24gfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mgd2V4IGV4dGVuZHMgbGlxdWkge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3dleCcsXG4gICAgICAgICAgICAnbmFtZSc6ICdXRVgnLFxuICAgICAgICAgICAgJ2NvdW50cmllcyc6ICdOWicsIC8vIE5ldyBaZWFsYW5kXG4gICAgICAgICAgICAndmVyc2lvbic6ICczJyxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzA2NTI3NTEtZDc0ZWM4ZjgtOWUzMS0xMWU3LTk4YzUtNzE0NjlmY2VmMDNlLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL3dleC5uei9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3dleC5uei90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93ZXgubnonLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3dleC5uei9hcGkvMy9kb2NzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd2V4Lm56L3RhcGkvZG9jcycsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQWN0aXZlT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmRlckluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1RyYW5zSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29pbkRlcG9zaXRBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaXRoZHJhd0NvaW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NyZWF0ZUNvdXBvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnUmVkZWVtQ291cG9uJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjIgLyAxMDAsXG4gICAgICAgICAgICAgICAgICAgICd0YWtlcic6IDAuMiAvIDEwMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3VwZGF0ZWQnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdoaWdoJyksXG4gICAgICAgICAgICAnbG93JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xvdycpLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdzZWxsJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eScpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2xhc3QnKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2F2ZycpLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sX2N1cicpLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbCcpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaGFuZGxlRXJyb3JzIChjb2RlLCByZWFzb24sIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIGlmIChjb2RlID09IDIwMCkge1xuICAgICAgICAgICAgaWYgKGJvZHlbMF0gIT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgaXMgbm90IEpTT05cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcmV0dXJuZWQgYSBub24tSlNPTiByZXBseTogJyArIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gSlNPTi5wYXJzZSAoYm9keSk7XG4gICAgICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IHRoaXMuc2FmZVZhbHVlIChyZXNwb25zZSwgJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXR1cm5lZCBhIG1hbGZvcm1lZCBlcnJvcjogJyArIGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yID09ICdiYWQgc3RhdHVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9yZGVyTm90Rm91bmQgKHRoaXMuaWQgKyAnICcgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuaW5kZXhPZiAoJ0l0IGlzIG5vdCBlbm91Z2gnKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50RnVuZHMgKHRoaXMuaWQgKyAnICcgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT0gJ1JlcXVlc3RzIHRvbyBvZnRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciA9PSAnbm90IGF2YWlsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvciA9PSAnZXh0ZXJuYWwgc2VydmljZSB1bmF2YWlsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBERG9TUHJvdGVjdGlvbiAodGhpcy5pZCArICcgJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCdzIHdoYXQgZmV0Y2hPcGVuT3JkZXJzIHJldHVybiBpZiBubyBvcGVuIG9yZGVycyAoZml4IGZvciAjNDg5KVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yICE9ICdubyBvcmRlcnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IsIE5vdFN1cHBvcnRlZCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSAoJy4vYmFzZS9lcnJvcnMnKVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB4YnRjZSBleHRlbmRzIEV4Y2hhbmdlIHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICd4YnRjZScsXG4gICAgICAgICAgICAnbmFtZSc6ICd4QlRDZScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ1JVJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAyMDAwLCAvLyByZXNwb25zZXMgYXJlIGNhY2hlZCBldmVyeSAyIHNlY29uZHNcbiAgICAgICAgICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAgICAgICAgICdoYXNQdWJsaWNBUEknOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaE9ITENWJzogZmFsc2UsXG4gICAgICAgICAgICAndXJscyc6IHtcbiAgICAgICAgICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4MDU5NDE0LWUyMzU5NzBjLTY2MmMtMTFlNy04YzNhLTA4ZTMxZjc4Njg0Yi5qcGcnLFxuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly9jcnlwdG90dGxpdmV3ZWJhcGkueGJ0Y2UubmV0Ojg0NDMvYXBpJyxcbiAgICAgICAgICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LnhidGNlLmNvbScsXG4gICAgICAgICAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LnhidGNlLmNvbS90cmFkZWFwaScsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3N1cHBvcnQueGJ0Y2UuaW5mby9Lbm93bGVkZ2ViYXNlL0FydGljbGUvVmlldy81Mi8yNS94YnRjZS1leGNoYW5nZS1hcGknLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3JlcXVpcmVkQ3JlZGVudGlhbHMnOiB7XG4gICAgICAgICAgICAgICAgJ2FwaUtleSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3NlY3JldCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3VpZCc6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeS97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGV2ZWwyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZXZlbDIve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS97c3ltYm9sfS97cGVyaW9kaWNpdHl9L2JhcnMvYXNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2JpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L2xldmVsMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3RpY2tzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbC97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGljaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGljay97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlc2Vzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXNlcnZlcmluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlc2Vzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVuY3knLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5L3tmaWx0ZXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZXZlbDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xldmVsMi97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzeW1ib2wve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2sve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjY291bnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Fzc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhc3NldC97aWR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb24ve2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlL3tpZH0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS97c3ltYm9sfS97cGVyaW9kaWNpdHl9L2JhcnMvYXNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2Fzay9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2JpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3twZXJpb2RpY2l0eX0vYmFycy9iaWQvaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L2xldmVsMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L2xldmVsMi9pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0vcGVyaW9kaWNpdGllcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3RpY2tzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0vdGlja3MvaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L2NhY2hlL3tzeW1ib2x9L3twZXJpb2RpY2l0eX0vYmFycy9hc2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS9jYWNoZS97c3ltYm9sfS97cGVyaW9kaWNpdHl9L2JhcnMvYmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3RvcnkvY2FjaGUve3N5bWJvbH0vbGV2ZWwyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3RvcnkvY2FjaGUve3N5bWJvbH0vdGlja3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS9zeW1ib2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdxdW90ZWhpc3RvcnkvdmVyc2lvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZWhpc3RvcnknLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0U3ltYm9sICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ1N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ01hcmdpbkN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ1Byb2ZpdEN1cnJlbmN5J107XG4gICAgICAgICAgICBpZiAoYmFzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICBiYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnSXNUcmFkZUFsbG93ZWQnXSA/IHN5bWJvbCA6IGlkO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBc3NldCAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIC8vIHhidGNlIG5hbWVzIERBU0ggaW5jb3JyZWN0bHkgYXMgRFNIXG4gICAgICAgICAgICBpZiAodXBwZXJjYXNlID09ICdEU0gnKVxuICAgICAgICAgICAgICAgIHVwcGVyY2FzZSA9ICdEQVNIJztcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnRnJlZUFtb3VudCddLFxuICAgICAgICAgICAgICAgICd1c2VkJzogYmFsYW5jZVsnTG9ja2VkQW1vdW50J10sXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZVsnQW1vdW50J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W3VwcGVyY2FzZV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmFsYW5jZSAocmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRMZXZlbDJGaWx0ZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnZmlsdGVyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgb3JkZXJib29rID0gb3JkZXJib29rWzBdO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWydUaW1lc3RhbXAnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnQmlkcycsICdBc2tzJywgJ1ByaWNlJywgJ1ZvbHVtZScpO1xuICAgIH1cblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gMDtcbiAgICAgICAgbGV0IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnTGFzdEJ1eVRpbWVzdGFtcCcgaW4gdGlja2VyKVxuICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA8IHRpY2tlclsnTGFzdEJ1eVRpbWVzdGFtcCddKSB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gdGlja2VyWydMYXN0QnV5VGltZXN0YW1wJ107XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRpY2tlclsnTGFzdEJ1eVByaWNlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmICgnTGFzdFNlbGxUaW1lc3RhbXAnIGluIHRpY2tlcilcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPCB0aWNrZXJbJ0xhc3RTZWxsVGltZXN0YW1wJ10pIHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSB0aWNrZXJbJ0xhc3RTZWxsVGltZXN0YW1wJ107XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRpY2tlclsnTGFzdFNlbGxQcmljZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVzdGFtcClcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB0aWNrZXJbJ0RhaWx5QmVzdEJ1eVByaWNlJ10sXG4gICAgICAgICAgICAnbG93JzogdGlja2VyWydEYWlseUJlc3RTZWxsUHJpY2UnXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbJ0Jlc3RCaWQnXSxcbiAgICAgICAgICAgICdhc2snOiB0aWNrZXJbJ0Jlc3RBc2snXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IGxhc3QsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGlja2VyWydEYWlseVRyYWRlZFRvdGFsVm9sdW1lJ10sXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKHN5bWJvbHMgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHBhcmFtcyk7XG4gICAgICAgIHRpY2tlcnMgPSB0aGlzLmluZGV4QnkgKHRpY2tlcnMsICdTeW1ib2wnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5tYXJrZXRzX2J5X2lkKSB7XG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgPT0gJ0RTSCcpXG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSAnREFTSCc7XG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlID09ICdEU0gnKVxuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9ICdEQVNIJztcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlckZpbHRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdmaWx0ZXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGlja2Vycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoVGlja2VyIHJldHVybmVkIGVtcHR5IHJlc3BvbnNlLCB4QlRDZSBwdWJsaWMgQVBJIGVycm9yJyk7XG4gICAgICAgIHRpY2tlcnMgPSB0aGlzLmluZGV4QnkgKHRpY2tlcnMsICdTeW1ib2wnKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbbWFya2V0WydpZCddXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIC8vIG5vIG1ldGhvZCBmb3IgdHJhZGVzP1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlR2V0VHJhZGUgKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvaGxjdlsnVGltZXN0YW1wJ10sXG4gICAgICAgICAgICBvaGxjdlsnT3BlbiddLFxuICAgICAgICAgICAgb2hsY3ZbJ0hpZ2gnXSxcbiAgICAgICAgICAgIG9obGN2WydMb3cnXSxcbiAgICAgICAgICAgIG9obGN2WydDbG9zZSddLFxuICAgICAgICAgICAgb2hsY3ZbJ1ZvbHVtZSddLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9ITENWIGlzIGRpc2FibGVkIGJ5IHRoZSBleGNoYW5nZScpO1xuICAgICAgICBsZXQgbWludXRlcyA9IHBhcnNlSW50ICh0aW1lZnJhbWUgLyA2MCk7IC8vIDEgbWludXRlIGJ5IGRlZmF1bHRcbiAgICAgICAgbGV0IHBlcmlvZGljaXR5ID0gbWludXRlcy50b1N0cmluZyAoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBpZiAoIXNpbmNlKVxuICAgICAgICAgICAgc2luY2UgPSB0aGlzLnNlY29uZHMgKCkgLSA4NjQwMCAqIDc7IC8vIGxhc3QgZGF5IGJ5IGRlZnVsYXRcbiAgICAgICAgaWYgKCFsaW1pdClcbiAgICAgICAgICAgIGxpbWl0ID0gMTAwMDsgLy8gZGVmYXVsdFxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRRdW90ZWhpc3RvcnlTeW1ib2xQZXJpb2RpY2l0eUJhcnNCaWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3BlcmlvZGljaXR5JzogcGVyaW9kaWNpdHksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogc2luY2UsXG4gICAgICAgICAgICAnY291bnQnOiBsaW1pdCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZVsnQmFycyddLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50YXBpUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydJZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlRGVsZXRlVHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnVHlwZSc6ICdDYW5jZWwnLFxuICAgICAgICAgICAgJ0lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFwaUtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhcGlLZXkgZm9yIGFsbCByZXF1ZXN0cywgdGhlaXIgcHVibGljIEFQSSBpcyBhbHdheXMgYnVzeScpO1xuICAgICAgICBpZiAoIXRoaXMudWlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIHVpZCBwcm9wZXJ0eSBmb3IgYXV0aGVudGljYXRpb24gYW5kIHRyYWRpbmcsIHRoZWlyIHB1YmxpYyBBUEkgaXMgYWx3YXlzIGJ1c3knKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb247XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpXG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgYXBpO1xuICAgICAgICB1cmwgKz0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJyB9O1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHRoaXMudWlkICsgdGhpcy5hcGlLZXkgKyBtZXRob2QgKyB1cmw7XG4gICAgICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgICAgICBhdXRoICs9IGJvZHk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGEyNTYnLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBsZXQgY3JlZGVudGlhbHMgPSB0aGlzLnVpZCArICc6JyArIHRoaXMuYXBpS2V5ICsgJzonICsgbm9uY2UgKyAnOicgKyB0aGlzLmJpbmFyeVRvU3RyaW5nIChzaWduYXR1cmUpO1xuICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0hNQUMgJyArIGNyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICd1cmwnOiB1cmwsICdtZXRob2QnOiBtZXRob2QsICdib2R5JzogYm9keSwgJ2hlYWRlcnMnOiBoZWFkZXJzIH07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBsaXF1aSA9IHJlcXVpcmUgKCcuL2xpcXVpLmpzJylcbmNvbnN0IHsgRXhjaGFuZ2VFcnJvciwgSW5zdWZmaWNpZW50RnVuZHMsIEREb1NQcm90ZWN0aW9uIH0gPSByZXF1aXJlICgnLi9iYXNlL2Vycm9ycycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHlvYml0IGV4dGVuZHMgbGlxdWkge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3lvYml0JyxcbiAgICAgICAgICAgICduYW1lJzogJ1lvQml0JyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnUlUnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDMwMDAsIC8vIHJlc3BvbnNlcyBhcmUgY2FjaGVkIGV2ZXJ5IDIgc2Vjb25kc1xuICAgICAgICAgICAgJ3ZlcnNpb24nOiAnMycsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiBmYWxzZSxcbiAgICAgICAgICAgICd1cmxzJzoge1xuICAgICAgICAgICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY5MTAtY2RjYmZkYWUtNWVlYS0xMWU3LTk4NTktMDNmZWE4NzMyNzJkLmpwZycsXG4gICAgICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL3lvYml0Lm5ldC9hcGknLFxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3lvYml0Lm5ldC90YXBpJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cueW9iaXQubmV0JyxcbiAgICAgICAgICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LnlvYml0Lm5ldC9lbi9hcGkvJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwdGgve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXIve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY3RpdmVPcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdHZXREZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0SW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JkZXJJbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdUcmFkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaXRoZHJhd0NvaW5zVG9BZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmZWVzJzoge1xuICAgICAgICAgICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAnbWFrZXInOiAwLjAwMixcbiAgICAgICAgICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZnVuZGluZyc6IDAuMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpIHtcbiAgICAgICAgbGV0IHN1YnN0aXR1dGlvbnMgPSB7XG4gICAgICAgICAgICAnQUlSJzogJ0FpckNvaW4nLFxuICAgICAgICAgICAgJ0FOSSc6ICdBTklDb2luJyxcbiAgICAgICAgICAgICdBTlQnOiAnQW50c0NvaW4nLFxuICAgICAgICAgICAgJ0FUTSc6ICdBdXR1bW5jb2luJyxcbiAgICAgICAgICAgICdCQ0MnOiAnQkNIJyxcbiAgICAgICAgICAgICdCVFMnOiAnQml0c2hhcmVzMicsXG4gICAgICAgICAgICAnRENUJzogJ0Rpc2NvdW50JyxcbiAgICAgICAgICAgICdER0QnOiAnRGFya0dvbGRDb2luJyxcbiAgICAgICAgICAgICdJQ04nOiAnaUNvaW4nLFxuICAgICAgICAgICAgJ0xJWkknOiAnTGlaaScsXG4gICAgICAgICAgICAnTFVOJzogJ0x1bmFyQ29pbicsXG4gICAgICAgICAgICAnTkFWJzogJ05hdmFqb0NvaW4nLFxuICAgICAgICAgICAgJ09NRyc6ICdPTUdhbWUnLFxuICAgICAgICAgICAgJ1BBWSc6ICdFUEFZJyxcbiAgICAgICAgICAgICdSRVAnOiAnUmVwdWJsaWNvaW4nLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY3VycmVuY3kgaW4gc3Vic3RpdHV0aW9ucylcbiAgICAgICAgICAgIHJldHVybiBzdWJzdGl0dXRpb25zW2N1cnJlbmN5XTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH1cblxuICAgIGN1cnJlbmN5SWQgKGNvbW1vbkNvZGUpIHtcbiAgICAgICAgbGV0IHN1YnN0aXR1dGlvbnMgPSB7XG4gICAgICAgICAgICAnQWlyQ29pbic6ICdBSVInLFxuICAgICAgICAgICAgJ0FOSUNvaW4nOiAnQU5JJyxcbiAgICAgICAgICAgICdBbnRzQ29pbic6ICdBTlQnLFxuICAgICAgICAgICAgJ0F1dHVtbmNvaW4nOiAnQVRNJyxcbiAgICAgICAgICAgICdCQ0gnOiAnQkNDJyxcbiAgICAgICAgICAgICdCaXRzaGFyZXMyJzogJ0JUUycsXG4gICAgICAgICAgICAnRGlzY291bnQnOiAnRENUJyxcbiAgICAgICAgICAgICdEYXJrR29sZENvaW4nOiAnREdEJyxcbiAgICAgICAgICAgICdpQ29pbic6ICdJQ04nLFxuICAgICAgICAgICAgJ0xpWmknOiAnTElaSScsXG4gICAgICAgICAgICAnTHVuYXJDb2luJzogJ0xVTicsXG4gICAgICAgICAgICAnTmF2YWpvQ29pbic6ICdOQVYnLFxuICAgICAgICAgICAgJ09NR2FtZSc6ICdPTUcnLFxuICAgICAgICAgICAgJ0VQQVknOiAnUEFZJyxcbiAgICAgICAgICAgICdSZXB1YmxpY29pbic6ICdSRVAnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29tbW9uQ29kZSBpbiBzdWJzdGl0dXRpb25zKVxuICAgICAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGlvbnNbY29tbW9uQ29kZV07XG4gICAgICAgIHJldHVybiBjb21tb25Db2RlO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXR1cm4nXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgc2lkZXMgPSB7ICdmcmVlJzogJ2Z1bmRzJywgJ3RvdGFsJzogJ2Z1bmRzX2luY2xfb3JkZXJzJyB9O1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChzaWRlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBsZXQgc2lkZSA9IHNpZGVzW2tleV07XG4gICAgICAgICAgICBpZiAoc2lkZSBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzW3NpZGVdKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJlbmNpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmNpZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBsb3dlcmNhc2UudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWNjb3VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudCA9IHJlc3VsdFtjdXJyZW5jeV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRba2V5XSA9IGJhbGFuY2VzW3NpZGVdW2xvd2VyY2FzZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2NvdW50Wyd0b3RhbCddICYmIGFjY291bnRbJ2ZyZWUnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJhbGFuY2UgKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ25lZWRfbmV3JzogMSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogcmVzcG9uc2VbJ2FkZHJlc3MnXSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb2snLFxuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZVsnaW5mbyddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoRGVwb3NpdEFkZHJlc3MgKGN1cnJlbmN5LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY3lJZCA9IHRoaXMuY3VycmVuY3lJZCAoY3VycmVuY3kpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjb2luTmFtZSc6IGN1cnJlbmN5SWQsXG4gICAgICAgICAgICAnbmVlZF9uZXcnOiAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0RGVwb3NpdEFkZHJlc3MgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGFkZHJlc3MgPSB0aGlzLnNhZmVTdHJpbmcgKHJlc3BvbnNlWydyZXR1cm4nXSwgJ2FkZHJlc3MnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgJ3N0YXR1cyc6ICdvaycsXG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXdDb2luc1RvQWRkcmVzcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2luTmFtZSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaDIgKHBhdGgsIGFwaSwgbWV0aG9kLCBwYXJhbXMsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydzdWNjZXNzJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10uaW5kZXhPZiAoJ0luc3VmZmljaWVudCBmdW5kcycpID49IDApIHsgLy8gbm90IGVub3VnVGggaXMgYSB0eXBvIGluc2lkZSBMaXF1aSdzIG93biBBUEkuLi5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VbJ2Vycm9yJ10gPT0gJ1JlcXVlc3RzIHRvbyBvZnRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEREb1NQcm90ZWN0aW9uICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3BvbnNlWydlcnJvciddID09ICdub3QgYXZhaWxhYmxlJykgfHwgKHJlc3BvbnNlWydlcnJvciddID09ICdleHRlcm5hbCBzZXJ2aWNlIHVuYXZhaWxhYmxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEREb1NQcm90ZWN0aW9uICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGFjeCA9IHJlcXVpcmUgKCcuL2FjeC5qcycpXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHl1bmJpIGV4dGVuZHMgYWN4IHtcblxuICAgIGRlc2NyaWJlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVlcEV4dGVuZCAoc3VwZXIuZGVzY3JpYmUgKCksIHtcbiAgICAgICAgICAgICdpZCc6ICd5dW5iaScsXG4gICAgICAgICAgICAnbmFtZSc6ICdZVU5CSScsXG4gICAgICAgICAgICAnY291bnRyaWVzJzogJ0NOJyxcbiAgICAgICAgICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiAndjInLFxuICAgICAgICAgICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAgICAgICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICAgICAgICAgJzFtJzogJzEnLFxuICAgICAgICAgICAgICAgICc1bSc6ICc1JyxcbiAgICAgICAgICAgICAgICAnMTVtJzogJzE1JyxcbiAgICAgICAgICAgICAgICAnMzBtJzogJzMwJyxcbiAgICAgICAgICAgICAgICAnMWgnOiAnNjAnLFxuICAgICAgICAgICAgICAgICcyaCc6ICcxMjAnLFxuICAgICAgICAgICAgICAgICc0aCc6ICcyNDAnLFxuICAgICAgICAgICAgICAgICcxMmgnOiAnNzIwJyxcbiAgICAgICAgICAgICAgICAnMWQnOiAnMTQ0MCcsXG4gICAgICAgICAgICAgICAgJzNkJzogJzQzMjAnLFxuICAgICAgICAgICAgICAgICcxdyc6ICcxMDA4MCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODU3MDU0OC00ZDY0NmM0MC03MTQ3LTExZTctOWNmNi04MzliOTNlNmQ2MjIuanBnJyxcbiAgICAgICAgICAgICAgICAnZXh0ZW5zaW9uJzogJy5qc29uJywgLy8gZGVmYXVsdCBleHRlbnNpb24gYXBwZW5kZWQgdG8gZW5kcG9pbnQgVVJMc1xuICAgICAgICAgICAgICAgICdhcGknOiAnaHR0cHM6Ly95dW5iaS5jb20nLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly95dW5iaS5jb20nLFxuICAgICAgICAgICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3l1bmJpLmNvbS9kb2N1bWVudHMvYXBpL2d1aWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8veXVuYmkuY29tL3N3YWdnZXIvJyxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aWNrZXJzL3ttYXJrZXR9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdrX3dpdGhfcGVuZGluZ190cmFkZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWRkcmVzc2VzL3thZGRyZXNzfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFydG5lcnMvb3JkZXJzL3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZW1iZXJzL21lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy9teScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVyL2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcmRlcnMvbXVsdGknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29yZGVycy9jbGVhcicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHphaWYgZXh0ZW5kcyBFeGNoYW5nZSB7XG5cbiAgICBkZXNjcmliZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZXBFeHRlbmQgKHN1cGVyLmRlc2NyaWJlICgpLCB7XG4gICAgICAgICAgICAnaWQnOiAnemFpZicsXG4gICAgICAgICAgICAnbmFtZSc6ICdaYWlmJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnSlAnLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICcxJyxcbiAgICAgICAgICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgICAgICAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAgICAgICAgICdoYXNGZXRjaENsb3NlZE9yZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjkyNy0zOWNhMmFkYS01ZWViLTExZTctOTcyZi0xYjQxOTk1MThjYTYuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLnphaWYuanAnLFxuICAgICAgICAgICAgICAgICd3d3cnOiAnaHR0cHM6Ly96YWlmLmpwJyxcbiAgICAgICAgICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgICAgICAgICAnaHR0cDovL3RlY2hidXJlYXUtYXBpLWRvY3VtZW50LnJlYWR0aGVkb2NzLmlvL2phL2xhdGVzdC9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY29ycC56YWlmLmpwL2FwaS1kb2NzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY29ycC56YWlmLmpwL2FwaS1kb2NzL2FwaV9saW5rcycsXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS96YWlmLmpwJyxcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS95b3UyMTk3OS9ub2RlLXphaWYnLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoL3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3VycmVuY2llcy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmNpZXMvYWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjdXJyZW5jeV9wYWlycy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbmN5X3BhaXJzL2FsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGFzdF9wcmljZS97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpY2tlci97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlcy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FjdGl2ZV9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVwb3NpdF9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRfaWRfaW5mbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldF9pbmZvMicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X3BlcnNvbmFsX2luZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZV9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGRyYXdfaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZWNhcGknOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NyZWF0ZUludm9pY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEludm9pY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldEludm9pY2VJZHNCeU9yZGVyTnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjYW5jZWxJbnZvaWNlJyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0bGFwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0X3Bvc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9zaXRpb25faGlzdG9yeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlX3Bvc2l0aW9ucycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY3JlYXRlX3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjaGFuZ2VfcG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbF9wb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZmFwaSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdncm91cHMve2dyb3VwX2lkfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGFzdF9wcmljZS97Z3JvdXBfaWR9L3twYWlyfScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyL3tncm91cF9pZH0ve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0cmFkZXMve2dyb3VwX2lkfS97cGFpcn0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcHRoL3tncm91cF9pZH0ve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5UGFpcnNBbGwgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnY3VycmVuY3lfcGFpciddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnbmFtZSddO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXR1cm4nXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlc1snZnVuZHMnXSk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbJ2Z1bmRzJ11bY3VycmVuY3ldO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCdkZXBvc2l0JyBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlc1snZGVwb3NpdCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBiYWxhbmNlc1snZGVwb3NpdCddW2N1cnJlbmN5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCB2d2FwID0gdGlja2VyWyd2d2FwJ107XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gdGlja2VyWyd2b2x1bWUnXTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gYmFzZVZvbHVtZSAqIHZ3YXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGlja2VyWydoaWdoJ10sXG4gICAgICAgICAgICAnbG93JzogdGlja2VyWydsb3cnXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbJ2JpZCddLFxuICAgICAgICAgICAgJ2Fzayc6IHRpY2tlclsnYXNrJ10sXG4gICAgICAgICAgICAndndhcCc6IHZ3YXAsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdGlja2VyWydsYXN0J10sXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogYmFzZVZvbHVtZSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHF1b3RlVm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsndHJhZGVfdHlwZSddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICdpZCcpO1xuICAgICAgICBpZCA9IHRoaXMuc2FmZVN0cmluZyAodHJhZGUsICd0aWQnLCBpZCk7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeV9wYWlyJ11dO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9wYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhY3Rpb24nOiAoc2lkZSA9PSAnYnV5JykgPyAnYmlkJyA6ICdhc2snLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmV0dXJuJ11bJ29yZGVyX2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJfaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfVxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9IChvcmRlclsnYWN0aW9uJ10gPT0gJ2JpZCcpID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW29yZGVyWydjdXJyZW5jeV9wYWlyJ11dO1xuICAgICAgICBsZXQgcHJpY2UgPSBvcmRlclsncHJpY2UnXTtcbiAgICAgICAgbGV0IGFtb3VudCA9IG9yZGVyWydhbW91bnQnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb3BlbicsXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbWl0JyxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Nvc3QnOiBwcmljZSAqIGFtb3VudCxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnZmlsbGVkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0cmFkZXMnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmVlJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcnNlT3JkZXJzIChvcmRlcnMsIG1hcmtldCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAob3JkZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gb3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCBleHRlbmRlZCA9IHRoaXMuZXh0ZW5kIChvcmRlciwgeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLnBhcnNlT3JkZXIgKGV4dGVuZGVkLCBtYXJrZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJCeVNpbmNlTGltaXQgKHJlc3VsdCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC8vICdpc190b2tlbic6IGZhbHNlLFxuICAgICAgICAgICAgLy8gJ2lzX3Rva2VuX2JvdGgnOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgICAgICByZXF1ZXN0WydjdXJyZW5jeV9wYWlyJ10gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEFjdGl2ZU9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3JldHVybiddLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hDbG9zZWRPcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIC8vICdmcm9tJzogMCxcbiAgICAgICAgICAgIC8vICdjb3VudCc6IDEwMDAsXG4gICAgICAgICAgICAvLyAnZnJvbV9pZCc6IDAsXG4gICAgICAgICAgICAvLyAnZW5kX2lkJzogMTAwMCxcbiAgICAgICAgICAgIC8vICdvcmRlcic6ICdERVNDJyxcbiAgICAgICAgICAgIC8vICdzaW5jZSc6IDE1MDM4MjEwNTEsXG4gICAgICAgICAgICAvLyAnZW5kJzogMTUwMzgyMTA1MSxcbiAgICAgICAgICAgIC8vICdpc190b2tlbic6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ2N1cnJlbmN5X3BhaXInXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGVIaXN0b3J5ICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZVsncmV0dXJuJ10sIG1hcmtldCwgc2luY2UsIGxpbWl0KTtcbiAgICB9XG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdKUFknKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGRvZXMgbm90IGFsbG93ICcgKyBjdXJyZW5jeSArICcgd2l0aGRyYXdhbHMnKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgICAgIC8vICdtZXNzYWdlJzogJ0hpIScsIC8vIFhFTSBvbmx5XG4gICAgICAgICAgICAvLyAnb3B0X2ZlZSc6IDAuMDAzLCAvLyBCVEMgYW5kIE1PTkEgb25seVxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydyZXR1cm4nXVsndHhpZCddLFxuICAgICAgICAgICAgJ2ZlZSc6IHJlc3VsdFsncmV0dXJuJ11bJ2ZlZSddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLyc7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnYXBpLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXBpID09ICdmYXBpJykge1xuICAgICAgICAgICAgdXJsICs9ICdmYXBpLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRDcmVkZW50aWFscyAoKTtcbiAgICAgICAgICAgIGlmIChhcGkgPT0gJ2VjYXBpJykge1xuICAgICAgICAgICAgICAgIHVybCArPSAnZWNhcGknO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcGkgPT0gJ3RsYXBpJykge1xuICAgICAgICAgICAgICAgIHVybCArPSAndGxhcGknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJ3RhcGknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdTaWduJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAnYXBpJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHJlc3BvbnNlWydlcnJvciddKTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IEV4Y2hhbmdlID0gcmVxdWlyZSAoJy4vYmFzZS9FeGNoYW5nZScpXG5jb25zdCB7IEV4Y2hhbmdlRXJyb3IgfSA9IHJlcXVpcmUgKCcuL2Jhc2UvZXJyb3JzJylcblxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHpiIGV4dGVuZHMgRXhjaGFuZ2Uge1xuXG4gICAgZGVzY3JpYmUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWVwRXh0ZW5kIChzdXBlci5kZXNjcmliZSAoKSwge1xuICAgICAgICAgICAgJ2lkJzogJ3piJyxcbiAgICAgICAgICAgICduYW1lJzogJ1pCJyxcbiAgICAgICAgICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICAgICAgICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgICAgICAgICAndmVyc2lvbic6ICd2MScsXG4gICAgICAgICAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICAgICAgICAgJ2hhc0ZldGNoT3JkZXInOiB0cnVlLFxuICAgICAgICAgICAgJ3VybHMnOiB7XG4gICAgICAgICAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMjg1OTE4Ny1jZDUyMTRmMC1jYTVlLTExZTctOTY3ZC05NjU2OGUyZTJiZDEuanBnJyxcbiAgICAgICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICAgICAncHVibGljJzogJ2h0dHA6Ly9hcGkuemIuY29tL2RhdGEnLCAvLyBubyBodHRwcyBmb3IgcHVibGljIEFQSVxuICAgICAgICAgICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3RyYWRlLnpiLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3d3dyc6ICdodHRwczovL3RyYWRlLnpiLmNvbS9hcGknLFxuICAgICAgICAgICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuemIuY29tL2kvZGV2ZWxvcGVyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFya2V0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdrbGluZScsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRPcmRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRPcmRlcnNOZXcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldE9yZGVyc0lnbm9yZVRyYWRlVHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0VW5maW5pc2hlZE9yZGVyc0lnbm9yZVRyYWRlVHlwZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZ2V0QWNjb3VudEluZm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldFVzZXJBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRXaXRoZHJhd0FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldFdpdGhkcmF3UmVjb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDaGFyZ2VSZWNvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2dldENueVdpdGhkcmF3UmVjb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZXRDbnlDaGFyZ2VSZWNvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0VHJhZGluZ0ZlZUZyb21CYXNlUXVvdGUgKGJhc2UsIHF1b3RlKSB7XG4gICAgICAgIC8vIGJhc2U6IHF1b3RlXG4gICAgICAgIGxldCBmZWVzID0ge1xuICAgICAgICAgICAgJ0JUQyc6IHsgJ1VTRFQnOiAwLjAgfSxcbiAgICAgICAgICAgICdCQ0gnOiB7ICdCVEMnOiAwLjAwMSwgJ1VTRFQnOiAwLjAwMSB9LFxuICAgICAgICAgICAgJ0xUQyc6IHsgJ0JUQyc6IDAuMDAxLCAnVVNEVCc6IDAuMCB9LFxuICAgICAgICAgICAgJ0VUSCc6IHsgJ0JUQyc6IDAuMDAxLCAnVVNEVCc6IDAuMCB9LFxuICAgICAgICAgICAgJ0VUQyc6IHsgJ0JUQyc6IDAuMDAxLCAnVVNEVCc6IDAuMCB9LFxuICAgICAgICAgICAgJ0JUUyc6IHsgJ0JUQyc6IDAuMDAxLCAnVVNEVCc6IDAuMDAxIH0sXG4gICAgICAgICAgICAnRU9TJzogeyAnQlRDJzogMC4wMDEsICdVU0RUJzogMC4wMDEgfSxcbiAgICAgICAgICAgICdIU1InOiB7ICdCVEMnOiAwLjAwMSwgJ1VTRFQnOiAwLjAwMSB9LFxuICAgICAgICAgICAgJ1FUVU0nOiB7ICdCVEMnOiAwLjAwMSwgJ1VTRFQnOiAwLjAwMSB9LFxuICAgICAgICAgICAgJ1VTRFQnOiB7ICdCVEMnOiAwLjAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGJhc2UgaW4gZmVlcykge1xuICAgICAgICAgICAgbGV0IHF1b3RlRmVlcyA9IGZlZXNbYmFzZV07XG4gICAgICAgICAgICBpZiAocXVvdGUgaW4gcXVvdGVGZWVzKVxuICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZUZlZXNbcXVvdGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2lkXTtcbiAgICAgICAgICAgIGxldCBbIGJhc2VJZCwgcXVvdGVJZCBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlSWQudG9VcHBlckNhc2UgKCkpO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlSWQudG9VcHBlckNhc2UgKCkpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCBmZWUgPSB0aGlzLmdldFRyYWRpbmdGZWVGcm9tQmFzZVF1b3RlIChiYXNlLCBxdW90ZSk7XG4gICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0ge1xuICAgICAgICAgICAgICAgICdhbW91bnQnOiBtYXJrZXRbJ2Ftb3VudFNjYWxlJ10sXG4gICAgICAgICAgICAgICAgJ3ByaWNlJzogbWFya2V0WydwcmljZVNjYWxlJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGxvdCA9IE1hdGgucG93ICgxMCwgLXByZWNpc2lvblsnYW1vdW50J10pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlSWQnOiBiYXNlSWQsXG4gICAgICAgICAgICAgICAgJ3F1b3RlSWQnOiBxdW90ZUlkLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBmZWUsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogZmVlLFxuICAgICAgICAgICAgICAgICdsb3QnOiBsb3QsXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3ByZWNpc2lvbic6IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAnbGltaXRzJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IGxvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcmljZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBNYXRoLnBvdyAoMTAsIC1wcmVjaXNpb25bJ3ByaWNlJ10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2Nvc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzICh0aGlzLmN1cnJlbmNpZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlc1snYmFsYW5jZSddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzWydiYWxhbmNlJ11bY3VycmVuY3ldWydhbW91bnQnXSk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZXNbJ2Zyb3plbiddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzWydmcm96ZW4nXVtjdXJyZW5jeV1bJ2Ftb3VudCddKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCYWxhbmNlIChyZXN1bHQpO1xuICAgIH1cblxuICAgIGdldE1hcmtldEZpZWxkTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiAnbWFya2V0JztcbiAgICB9XG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtYXJrZXRGaWVsZE5hbWUgPSB0aGlzLmdldE1hcmtldEZpZWxkTmFtZSAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgcmVxdWVzdFttYXJrZXRGaWVsZE5hbWVdID0gbWFya2V0WydpZCddO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aCAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBiaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYXNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdiaWRzJyBpbiBvcmRlcmJvb2spXG4gICAgICAgICAgICBiaWRzID0gb3JkZXJib29rWydiaWRzJ107XG4gICAgICAgIGlmICgnYXNrcycgaW4gb3JkZXJib29rKVxuICAgICAgICAgICAgYXNrcyA9IG9yZGVyYm9va1snYXNrcyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiBiaWRzLFxuICAgICAgICAgICAgJ2Fza3MnOiBhc2tzLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlc3VsdFsnYmlkcyddKVxuICAgICAgICAgICAgcmVzdWx0WydiaWRzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0WydiaWRzJ10sIDAsIHRydWUpO1xuICAgICAgICBpZiAocmVzdWx0Wydhc2tzJ10pXG4gICAgICAgICAgICByZXN1bHRbJ2Fza3MnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2Fza3MnXSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWFya2V0RmllbGROYW1lID0gdGhpcy5nZXRNYXJrZXRGaWVsZE5hbWUgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIHJlcXVlc3RbbWFya2V0RmllbGROYW1lXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWyd0aWNrZXInXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3RyYWRlX3R5cGUnXSA9PSAnYmlkJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWFya2V0RmllbGROYW1lID0gdGhpcy5nZXRNYXJrZXRGaWVsZE5hbWUgKCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIHJlcXVlc3RbbWFya2V0RmllbGROYW1lXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQsIHNpbmNlLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHBhcmFtU3RyaW5nID0gJyZwcmljZT0nICsgcHJpY2UudG9TdHJpbmcgKCk7XG4gICAgICAgIHBhcmFtU3RyaW5nICs9ICcmYW1vdW50PScgKyBhbW91bnQudG9TdHJpbmcgKCk7XG4gICAgICAgIGxldCB0cmFkZVR5cGUgPSAoc2lkZSA9PSAnYnV5JykgPyAnMScgOiAnMCc7XG4gICAgICAgIHBhcmFtU3RyaW5nICs9ICcmdHJhZGVUeXBlPScgKyB0cmFkZVR5cGU7XG4gICAgICAgIHBhcmFtU3RyaW5nICs9ICcmY3VycmVuY3k9JyArIHRoaXMubWFya2V0SWQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlciAocGFyYW1TdHJpbmcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSAnJmlkPScgKyBpZC50b1N0cmluZyAoKTtcbiAgICAgICAgaWYgKCdjdXJyZW5jeScgaW4gcGFyYW1zKVxuICAgICAgICAgICAgcGFyYW1TdHJpbmcgKz0gJyZjdXJyZW5jeT0nICsgcGFyYW1zWydjdXJyZW5jeSddO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyIChwYXJhbVN0cmluZyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHBhcmFtU3RyaW5nID0gJyZpZD0nICsgaWQudG9TdHJpbmcgKCk7XG4gICAgICAgIGlmICgnY3VycmVuY3knIGluIHBhcmFtcylcbiAgICAgICAgICAgIHBhcmFtU3RyaW5nICs9ICcmY3VycmVuY3k9JyArIHBhcmFtc1snY3VycmVuY3knXTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRPcmRlciAocGFyYW1TdHJpbmcpO1xuICAgIH1cblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH1cblxuICAgIHNpZ24gKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9ICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHBhdGg7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZENyZWRlbnRpYWxzICgpO1xuICAgICAgICAgICAgbGV0IHBhcmFtc0xlbmd0aCA9IHBhcmFtcy5sZW5ndGg7IC8vIHBhcmFtcyBzaG91bGQgYmUgYSBzdHJpbmcgaGVyZVxuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gJ21ldGhvZD0nICsgcGF0aDtcbiAgICAgICAgICAgIGF1dGggKz0gJyZhY2Nlc3NrZXk9JyArIHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgYXV0aCArPSBwYXJhbXNMZW5ndGggPyBwYXJhbXMgOiAnJztcbiAgICAgICAgICAgIGxldCBzZWNyZXQgPSB0aGlzLmhhc2ggKHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGExJyk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlIChzZWNyZXQpLCAnbWQ1Jyk7XG4gICAgICAgICAgICBsZXQgc3VmZml4ID0gJ3NpZ249JyArIHNpZ25hdHVyZSArICcmcmVxVGltZT0nICsgbm9uY2UudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgcGF0aCArICc/JyArIGF1dGggKyAnJicgKyBzdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJ3VybCc6IHVybCwgJ21ldGhvZCc6IG1ldGhvZCwgJ2JvZHknOiBib2R5LCAnaGVhZGVycyc6IGhlYWRlcnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2gyIChwYXRoLCBhcGksIG1ldGhvZCwgcGFyYW1zLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpXG4gICAgICAgICAgICBpZiAoJ2NvZGUnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuIiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gTG9va3VwIHRhYmxlc1xuXHQgICAgdmFyIFNCT1ggPSBbXTtcblx0ICAgIHZhciBJTlZfU0JPWCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG5cdCAgICAgICAgdmFyIGQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBXYWxrIEdGKDJeOClcblx0ICAgICAgICB2YXIgeCA9IDA7XG5cdCAgICAgICAgdmFyIHhpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc2JveFxuXHQgICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcblx0ICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuXHQgICAgICAgICAgICBTQk9YW3hdID0gc3g7XG5cdCAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xuXHQgICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcblx0ICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cdCAgICAgICAgICAgIGlmICgheCkge1xuXHQgICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG5cdCAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXG5cdCAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNraXAgcmVzZXQgb2YgblJvdW5kcyBoYXMgYmVlbiBzZXQgYmVmb3JlIGFuZCBrZXkgZGlkIG5vdCBjaGFuZ2Vcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX25Sb3VuZHMgJiYgdGhpcy5fa2V5UHJpb3JSZXNldCA9PT0gdGhpcy5fa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleVByaW9yUmVzZXQgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuXHQgICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IFJjb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlTaXplID4gNiAmJiBrc1JvdyAlIGtleVNpemUgPT0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGludktzUm93ID0gMDsgaW52S3NSb3cgPCBrc1Jvd3M7IGludktzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblxuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xuXG5cdCAgICAgICAgICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIGtleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xuXG5cdCAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XG5cdCAgICAgICAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcblx0ICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuXHQgICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XG5cblx0ICAgICAgICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXG5cdCAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgICAgICB2YXIgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczEgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMiA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBTVUJfTUlYXzBbczIgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMSAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgICAgICB2YXIgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczAgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMSA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgczAgPSB0MDtcblx0ICAgICAgICAgICAgICAgIHMxID0gdDE7XG5cdCAgICAgICAgICAgICAgICBzMiA9IHQyO1xuXHQgICAgICAgICAgICAgICAgczMgPSB0Mztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQxID0gKChTQk9YW3MxID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MwICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MiA9ICgoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMSAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgb3V0cHV0XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSAgICAgPSB0MDtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHQxO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDJdID0gdDI7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0Mztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5BRVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuQUVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVMpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkFFUztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZXZwa2RmXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdENyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGlzIGNpcGhlcidzIGtleSBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9ERUNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxuXHQgICAgICAgICAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG5cdCAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KCkpXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RlIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZW5jcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cblx0ICAgICAgICAgICAgLy8gQ2hvb3NlIG1peGluZyBibG9ja1xuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGl2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFhPUiBibG9ja3Ncblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gQ0JDO1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfcGFkID0gQy5wYWQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgbW9kZTogQ0JDLFxuXHQgICAgICAgICAgICBwYWRkaW5nOiBQa2NzN1xuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgY2lwaGVyXG5cdCAgICAgICAgICAgIENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcblx0ICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XG5cdCAgICAgICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgJiYgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPT0gbW9kZUNyZWF0b3IpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuaW5pdCh0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZUNyZWF0b3IuY2FsbChtb2RlLCB0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLl9fY3JlYXRvciA9IG1vZGVDcmVhdG9yO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcblxuXHQgICAgICAgICAgICAvLyBGaW5hbGl6ZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxuXHQgICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcblx0ICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuXHQgICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxuXHQgICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuXHQgICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBGb3JtYXRcblx0ICAgICAgICAgICAgaWYgKHNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUzNjE2Yzc0LCAweDY1NjQ1ZjVmXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBUZXN0IGZvciBzYWx0XG5cdCAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG5cdCAgICAgICAgICAgICAgICB2YXIgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxuXHQgICAgICAgICAgICAgICAga2V5OiBrZXksXG5cdCAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG5cdCAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuXHQgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxuXHQgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG5cdCAgICAgICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xLZGYgPSBDX2tkZi5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIpO1xuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG5cdCAgICAgICAgICAgIGlmICghc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQvOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIga2V5ID0gRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG5cdCAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxuXHQgICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBhc3N3b3JkQmFzZWRDaXBoZXIgPSBDX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyID0gU2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgY2lwaGVydGV4dC5zYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblx0ICAgIC8qXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsIG9mIE9iamVjdC5jcmVhdGVcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBGKCkge307XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSlcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlicmFyeSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTcGF3blxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSB8fCB0aGlzLmluaXQgPT09IHN1YnR5cGUuaW5pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICB2YXIgciA9IChmdW5jdGlvbiAobV93KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV93ID0gbV93O1xuXHQgICAgICAgICAgICAgICAgdmFyIG1feiA9IDB4M2FkZTY4YjE7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFzayA9IDB4ZmZmZmZmZmY7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbV96ID0gKDB4OTA2OSAqIChtX3ogJiAweEZGRkYpICsgKG1feiA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIG1fdyA9ICgweDQ2NTAgKiAobV93ICYgMHhGRkZGKSArIChtX3cgPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gKChtX3ogPDwgMHgxMCkgKyBtX3cpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgLz0gMHgxMDAwMDAwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IDAuNTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAuNSA/IDEgOiAtMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByY2FjaGU7IGkgPCBuQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9yID0gcigocmNhY2hlIHx8IE1hdGgucmFuZG9tKCkpICogMHgxMDAwMDAwMDApO1xuXG5cdCAgICAgICAgICAgICAgICByY2FjaGUgPSBfcigpICogMHgzYWRlNjdiNztcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKF9yKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9tYXA6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IChiaXRzMSB8IGJpdHMyKSA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTE2IEJFIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmMTZCRSA9IENfZW5jLlV0ZjE2ID0gQ19lbmMuVXRmMTZCRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGYxNi5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmO1xuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtMTYgQkUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTYucGFyc2UodXRmMTZTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmMTZTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gdXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgTEUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIENfZW5jLlV0ZjE2TEUgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHIgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gc3dhcEVuZGlhbigod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmYpO1xuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtMTYgTEUgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTZMRS5wYXJzZSh1dGYxNlN0cik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSBzd2FwRW5kaWFuKHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBzd2FwRW5kaWFuKHdvcmQpIHtcblx0ICAgICAgICByZXR1cm4gKCh3b3JkIDw8IDgpICYgMHhmZjAwZmYwMCkgfCAoKHdvcmQgPj4+IDgpICYgMHgwMGZmMDBmZik7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0ZjE2O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTFcIiksIHJlcXVpcmUoXCIuL2htYWNcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vc2hhMVwiLCBcIi4vaG1hY1wiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cblx0ICAgICAqIHd3dy5vcGVuc3NsLm9yZy9kb2NzL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXG5cdCAgICAgKi9cblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogTUQ1LFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IGNmZy5oYXNoZXIuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxuXHQgICAgICAgICAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG5cdCAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLkV2cEtERiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuRXZwS0RGO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4O1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQ7XG5cblx0ICAgIHZhciBIZXhGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhlIGNpcGhlcnRleHQgb2YgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoSGV4KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgY2lwaGVydGV4dCBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBIZXgucGFyc2UoaW5wdXQpO1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5mb3JtYXQuSGV4O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8qKlxuXHQgICAgICogSE1BQyBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBITUFDID0gQ19hbGdvLkhNQUMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjSGFzaGVyID0gQ3J5cHRvSlMuYWxnby5ITUFDLmNyZWF0ZShDcnlwdG9KUy5hbGdvLlNIQTI1Niwga2V5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGFzaGVyLCBrZXkpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgaGFzaGVyID0gdGhpcy5faGFzaGVyID0gbmV3IGhhc2hlci5pbml0KCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gVXRmOC5wYXJzZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemUgPSBoYXNoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEFsbG93IGFyYml0cmFyeSBsZW5ndGgga2V5c1xuXHQgICAgICAgICAgICBpZiAoa2V5LnNpZ0J5dGVzID4gaGFzaGVyQmxvY2tTaXplQnl0ZXMpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAga2V5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUga2V5IGZvciBpbm5lciBhbmQgb3V0ZXIgcGFkc1xuXHQgICAgICAgICAgICB2YXIgb0tleSA9IHRoaXMuX29LZXkgPSBrZXkuY2xvbmUoKTtcblx0ICAgICAgICAgICAgdmFyIGlLZXkgPSB0aGlzLl9pS2V5ID0ga2V5LmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5V29yZHMgPSBvS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaUtleVdvcmRzID0gaUtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBYT1Iga2V5cyB3aXRoIHBhZCBjb25zdGFudHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgb0tleVdvcmRzW2ldIF49IDB4NWM1YzVjNWM7XG5cdCAgICAgICAgICAgICAgICBpS2V5V29yZHNbaV0gXj0gMHgzNjM2MzYzNjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvS2V5LnNpZ0J5dGVzID0gaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIEhNQUMgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICBoYXNoZXIudXBkYXRlKHRoaXMuX2lLZXkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgSE1BQyB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtITUFDfSBUaGlzIEhNQUMgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoZXIudXBkYXRlKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBITUFDIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIEhNQUNcblx0ICAgICAgICAgICAgdmFyIGlubmVySGFzaCA9IGhhc2hlci5maW5hbGl6ZShtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIHZhciBobWFjID0gaGFzaGVyLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoaW5uZXJIYXNoKSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhtYWM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi94NjQtY29yZVwiKSwgcmVxdWlyZShcIi4vbGliLXR5cGVkYXJyYXlzXCIpLCByZXF1aXJlKFwiLi9lbmMtdXRmMTZcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vc2hhMVwiKSwgcmVxdWlyZShcIi4vc2hhMjU2XCIpLCByZXF1aXJlKFwiLi9zaGEyMjRcIiksIHJlcXVpcmUoXCIuL3NoYTUxMlwiKSwgcmVxdWlyZShcIi4vc2hhMzg0XCIpLCByZXF1aXJlKFwiLi9zaGEzXCIpLCByZXF1aXJlKFwiLi9yaXBlbWQxNjBcIiksIHJlcXVpcmUoXCIuL2htYWNcIiksIHJlcXVpcmUoXCIuL3Bia2RmMlwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSwgcmVxdWlyZShcIi4vbW9kZS1jZmJcIiksIHJlcXVpcmUoXCIuL21vZGUtY3RyXCIpLCByZXF1aXJlKFwiLi9tb2RlLWN0ci1nbGFkbWFuXCIpLCByZXF1aXJlKFwiLi9tb2RlLW9mYlwiKSwgcmVxdWlyZShcIi4vbW9kZS1lY2JcIiksIHJlcXVpcmUoXCIuL3BhZC1hbnNpeDkyM1wiKSwgcmVxdWlyZShcIi4vcGFkLWlzbzEwMTI2XCIpLCByZXF1aXJlKFwiLi9wYWQtaXNvOTc5NzFcIiksIHJlcXVpcmUoXCIuL3BhZC16ZXJvcGFkZGluZ1wiKSwgcmVxdWlyZShcIi4vcGFkLW5vcGFkZGluZ1wiKSwgcmVxdWlyZShcIi4vZm9ybWF0LWhleFwiKSwgcmVxdWlyZShcIi4vYWVzXCIpLCByZXF1aXJlKFwiLi90cmlwbGVkZXNcIiksIHJlcXVpcmUoXCIuL3JjNFwiKSwgcmVxdWlyZShcIi4vcmFiYml0XCIpLCByZXF1aXJlKFwiLi9yYWJiaXQtbGVnYWN5XCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3g2NC1jb3JlXCIsIFwiLi9saWItdHlwZWRhcnJheXNcIiwgXCIuL2VuYy11dGYxNlwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9zaGExXCIsIFwiLi9zaGEyNTZcIiwgXCIuL3NoYTIyNFwiLCBcIi4vc2hhNTEyXCIsIFwiLi9zaGEzODRcIiwgXCIuL3NoYTNcIiwgXCIuL3JpcGVtZDE2MFwiLCBcIi4vaG1hY1wiLCBcIi4vcGJrZGYyXCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCIsIFwiLi9tb2RlLWNmYlwiLCBcIi4vbW9kZS1jdHJcIiwgXCIuL21vZGUtY3RyLWdsYWRtYW5cIiwgXCIuL21vZGUtb2ZiXCIsIFwiLi9tb2RlLWVjYlwiLCBcIi4vcGFkLWFuc2l4OTIzXCIsIFwiLi9wYWQtaXNvMTAxMjZcIiwgXCIuL3BhZC1pc285Nzk3MVwiLCBcIi4vcGFkLXplcm9wYWRkaW5nXCIsIFwiLi9wYWQtbm9wYWRkaW5nXCIsIFwiLi9mb3JtYXQtaGV4XCIsIFwiLi9hZXNcIiwgXCIuL3RyaXBsZWRlc1wiLCBcIi4vcmM0XCIsIFwiLi9yYWJiaXRcIiwgXCIuL3JhYmJpdC1sZWdhY3lcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRyb290LkNyeXB0b0pTID0gZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBDaGVjayBpZiB0eXBlZCBhcnJheXMgYXJlIHN1cHBvcnRlZFxuXHQgICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cblx0ICAgIC8vIFJlZmVyZW5jZSBvcmlnaW5hbCBpbml0XG5cdCAgICB2YXIgc3VwZXJJbml0ID0gV29yZEFycmF5LmluaXQ7XG5cblx0ICAgIC8vIEF1Z21lbnQgV29yZEFycmF5LmluaXQgdG8gaGFuZGxlIHR5cGVkIGFycmF5c1xuXHQgICAgdmFyIHN1YkluaXQgPSBXb3JkQXJyYXkuaW5pdCA9IGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdCAgICAgICAgLy8gQ29udmVydCBidWZmZXJzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ29udmVydCBvdGhlciBhcnJheSB2aWV3cyB0byB1aW50OFxuXHQgICAgICAgIGlmIChcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxuXHQgICAgICAgICAgICAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXlcblx0ICAgICAgICApIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gSGFuZGxlIFVpbnQ4QXJyYXlcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXlCeXRlTGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIEV4dHJhY3QgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWRBcnJheUJ5dGVMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gdHlwZWRBcnJheVtpXSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoaXMgd29yZCBhcnJheVxuXHQgICAgICAgICAgICBzdXBlckluaXQuY2FsbCh0aGlzLCB3b3JkcywgdHlwZWRBcnJheUJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIEVsc2UgY2FsbCBub3JtYWwgaW5pdFxuXHQgICAgICAgICAgICBzdXBlckluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBzdWJJbml0LnByb3RvdHlwZSA9IFdvcmRBcnJheTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVcblx0ICAgIHZhciBUID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcblx0ICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMiAgPSBNW29mZnNldCArIDJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNSAgPSBNW29mZnNldCArIDVdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOCAgPSBNW29mZnNldCArIDhdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsICAxMiwgVFsxXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTcsIFRbMl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA3LCAgVFs0XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAgMTIsIFRbNV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzcsICAyMiwgVFs3XSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNywgIFRbOF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE3LCBUWzE0XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcblxuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDUsICBUWzE2XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgIDIwLCBUWzE5XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksICBUWzI1XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsICBUWzI4XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XG5cblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA0LCAgVFszMl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfOCwgIDExLCBUWzMzXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE0LCAyMywgVFszNV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDQsICBUWzM2XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAgMTEsIFRbMzddKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNiwgVFszOF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgIFRbNDBdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsICAxMSwgVFs0MV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE2LCBUWzQyXSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAgMjMsIFRbNDNdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA0LCAgVFs0NF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsICAyMywgVFs0N10pO1xuXG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzcsICAxMCwgVFs0OV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCAgVFs1Ml0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMywgIDEwLCBUWzUzXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsICAyMSwgVFs1NV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDYsICBUWzU2XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNSwgVFs1OF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTMsIDIxLCBUWzU5XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE1LCBUWzYyXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgOCkgIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCA4KSAgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcblx0ICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XG5cblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIEZGKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLk1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5NRDU7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDaXBoZXIgRmVlZGJhY2sgYmxvY2sgbW9kZS5cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuQ0ZCID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBDRkIgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICBDRkIuRW5jcnlwdG9yID0gQ0ZCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0LmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIENGQi5EZWNyeXB0b3IgPSBDRkIuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgdmFyIHRoaXNCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcik7XG5cblx0ICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdCh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcikge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cblx0ICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblx0ICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgdmFyIGtleXN0cmVhbSA9IGl2LnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGtleXN0cmVhbSA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG5cdCAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIENGQjtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLkNGQjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqIEBwcmVzZXJ2ZVxuXHQgKiBDb3VudGVyIGJsb2NrIG1vZGUgY29tcGF0aWJsZSB3aXRoICBEciBCcmlhbiBHbGFkbWFuIGZpbGVlbmMuY1xuXHQgKiBkZXJpdmVkIGZyb20gQ3J5cHRvSlMubW9kZS5DVFJcblx0ICogSmFuIEhydWJ5IGpocnVieS53ZWJAZ21haWwuY29tXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLkNUUkdsYWRtYW4gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIENUUkdsYWRtYW4gPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdFx0ZnVuY3Rpb24gaW5jV29yZCh3b3JkKVxuXHRcdHtcblx0XHRcdGlmICgoKHdvcmQgPj4gMjQpICYgMHhmZikgPT09IDB4ZmYpIHsgLy9vdmVyZmxvd1xuXHRcdFx0dmFyIGIxID0gKHdvcmQgPj4gMTYpJjB4ZmY7XG5cdFx0XHR2YXIgYjIgPSAod29yZCA+PiA4KSYweGZmO1xuXHRcdFx0dmFyIGIzID0gd29yZCAmIDB4ZmY7XG5cblx0XHRcdGlmIChiMSA9PT0gMHhmZikgLy8gb3ZlcmZsb3cgYjFcblx0XHRcdHtcblx0XHRcdGIxID0gMDtcblx0XHRcdGlmIChiMiA9PT0gMHhmZilcblx0XHRcdHtcblx0XHRcdFx0YjIgPSAwO1xuXHRcdFx0XHRpZiAoYjMgPT09IDB4ZmYpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRiMyA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0KytiMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHQrK2IyO1xuXHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0KytiMTtcblx0XHRcdH1cblxuXHRcdFx0d29yZCA9IDA7XG5cdFx0XHR3b3JkICs9IChiMSA8PCAxNik7XG5cdFx0XHR3b3JkICs9IChiMiA8PCA4KTtcblx0XHRcdHdvcmQgKz0gYjM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHR3b3JkICs9ICgweDAxIDw8IDI0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3b3JkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluY0NvdW50ZXIoY291bnRlcilcblx0XHR7XG5cdFx0XHRpZiAoKGNvdW50ZXJbMF0gPSBpbmNXb3JkKGNvdW50ZXJbMF0pKSA9PT0gMClcblx0XHRcdHtcblx0XHRcdFx0Ly8gZW5jcl9kYXRhIGluIGZpbGVlbmMuYyBmcm9tICBEciBCcmlhbiBHbGFkbWFuJ3MgY291bnRzIG9ubHkgd2l0aCBEV09SRCBqIDwgOFxuXHRcdFx0XHRjb3VudGVyWzFdID0gaW5jV29yZChjb3VudGVyWzFdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3VudGVyO1xuXHRcdH1cblxuXHQgICAgdmFyIEVuY3J5cHRvciA9IENUUkdsYWRtYW4uRW5jcnlwdG9yID0gQ1RSR2xhZG1hbi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXJcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXHQgICAgICAgICAgICB2YXIgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXIgPSBpdi5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblxuXHRcdFx0XHRpbmNDb3VudGVyKGNvdW50ZXIpO1xuXG5cdFx0XHRcdHZhciBrZXlzdHJlYW0gPSBjb3VudGVyLnNsaWNlKDApO1xuXHQgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgQ1RSR2xhZG1hbi5EZWNyeXB0b3IgPSBFbmNyeXB0b3I7XG5cblx0ICAgIHJldHVybiBDVFJHbGFkbWFuO1xuXHR9KCkpO1xuXG5cblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLkNUUkdsYWRtYW47XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBDb3VudGVyIGJsb2NrIG1vZGUuXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLkNUUiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgQ1RSID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgdmFyIEVuY3J5cHRvciA9IENUUi5FbmNyeXB0b3IgPSBDVFIuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyXG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblx0ICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyID0gaXYuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBrZXlzdHJlYW0gPSBjb3VudGVyLnNsaWNlKDApO1xuXHQgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXJcblx0ICAgICAgICAgICAgY291bnRlcltibG9ja1NpemUgLSAxXSA9IChjb3VudGVyW2Jsb2NrU2l6ZSAtIDFdICsgMSkgfCAwXG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgQ1RSLkRlY3J5cHRvciA9IEVuY3J5cHRvcjtcblxuXHQgICAgcmV0dXJuIENUUjtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLkNUUjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIEVsZWN0cm9uaWMgQ29kZWJvb2sgYmxvY2sgbW9kZS5cblx0ICovXG5cdENyeXB0b0pTLm1vZGUuRUNCID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBFQ0IgPSBDcnlwdG9KUy5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICBFQ0IuRW5jcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBFQ0IuRGVjcnlwdG9yID0gRUNCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gRUNCO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuRUNCO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogT3V0cHV0IEZlZWRiYWNrIGJsb2NrIG1vZGUuXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLk9GQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgT0ZCID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgdmFyIEVuY3J5cHRvciA9IE9GQi5FbmNyeXB0b3IgPSBPRkIuZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyXG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblx0ICAgICAgICAgICAgdmFyIGtleXN0cmVhbSA9IHRoaXMuX2tleXN0cmVhbTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBrZXlzdHJlYW0gPSB0aGlzLl9rZXlzdHJlYW0gPSBpdi5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIE9GQi5EZWNyeXB0b3IgPSBFbmNyeXB0b3I7XG5cblx0ICAgIHJldHVybiBPRkI7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5PRkI7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBBTlNJIFguOTIzIHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuQW5zaVg5MjMgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhU2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgIC8vIENvbXB1dGUgbGFzdCBieXRlIHBvc2l0aW9uXG5cdCAgICAgICAgdmFyIGxhc3RCeXRlUG9zID0gZGF0YVNpZ0J5dGVzICsgblBhZGRpbmdCeXRlcyAtIDE7XG5cblx0ICAgICAgICAvLyBQYWRcblx0ICAgICAgICBkYXRhLmNsYW1wKCk7XG5cdCAgICAgICAgZGF0YS53b3Jkc1tsYXN0Qnl0ZVBvcyA+Pj4gMl0gfD0gblBhZGRpbmdCeXRlcyA8PCAoMjQgLSAobGFzdEJ5dGVQb3MgJSA0KSAqIDgpO1xuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgKz0gblBhZGRpbmdCeXRlcztcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuQW5zaXg5MjM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBJU08gMTAxMjYgcGFkZGluZyBzdHJhdGVneS5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5Jc28xMDEyNiA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgLy8gUGFkXG5cdCAgICAgICAgZGF0YS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oblBhZGRpbmdCeXRlcyAtIDEpKS5cblx0ICAgICAgICAgICAgIGNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbblBhZGRpbmdCeXRlcyA8PCAyNF0sIDEpKTtcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuSXNvMTAxMjY7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBJU08vSUVDIDk3OTctMSBQYWRkaW5nIE1ldGhvZCAyLlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLklzbzk3OTcxID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgLy8gQWRkIDB4ODAgYnl0ZVxuXHQgICAgICAgIGRhdGEuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDgwMDAwMDAwXSwgMSkpO1xuXG5cdCAgICAgICAgLy8gWmVybyBwYWQgdGhlIHJlc3Rcblx0ICAgICAgICBDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcucGFkKGRhdGEsIGJsb2NrU2l6ZSk7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAvLyBSZW1vdmUgemVybyBwYWRkaW5nXG5cdCAgICAgICAgQ3J5cHRvSlMucGFkLlplcm9QYWRkaW5nLnVucGFkKGRhdGEpO1xuXG5cdCAgICAgICAgLy8gUmVtb3ZlIG9uZSBtb3JlIGJ5dGUgLS0gdGhlIDB4ODAgYnl0ZVxuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMtLTtcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuSXNvOTc5NzE7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBBIG5vb3AgcGFkZGluZyBzdHJhdGVneS5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5Ob1BhZGRpbmcgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLk5vUGFkZGluZztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIFplcm8gcGFkZGluZyBzdHJhdGVneS5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZyA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgIC8vIFBhZFxuXHQgICAgICAgIGRhdGEuY2xhbXAoKTtcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzICs9IGJsb2NrU2l6ZUJ5dGVzIC0gKChkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXMpIHx8IGJsb2NrU2l6ZUJ5dGVzKTtcblx0ICAgIH0sXG5cblx0ICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAvLyBVbnBhZFxuXHQgICAgICAgIHZhciBpID0gZGF0YS5zaWdCeXRlcyAtIDE7XG5cdCAgICAgICAgd2hpbGUgKCEoKGRhdGFXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmYpKSB7XG5cdCAgICAgICAgICAgIGktLTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGkgKyAxO1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGExXCIpLCByZXF1aXJlKFwiLi9obWFjXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3NoYTFcIiwgXCIuL2htYWNcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMTtcblx0ICAgIHZhciBITUFDID0gQ19hbGdvLkhNQUM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMiBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBQQktERjIgPSBDX2FsZ28uUEJLREYyID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZS4gRGVmYXVsdDogU0hBMVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcblx0ICAgICAgICAgICAgaGFzaGVyOiBTSEExLFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5QQktERjIuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5QQktERjIuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbXB1dGVzIHRoZSBQYXNzd29yZC1CYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBITUFDXG5cdCAgICAgICAgICAgIHZhciBobWFjID0gSE1BQy5jcmVhdGUoY2ZnLmhhc2hlciwgcGFzc3dvcmQpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tJbmRleCA9IFdvcmRBcnJheS5jcmVhdGUoWzB4MDAwMDAwMDFdKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja0luZGV4V29yZHMgPSBibG9ja0luZGV4LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxuXHQgICAgICAgICAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGhtYWMudXBkYXRlKHNhbHQpLmZpbmFsaXplKGJsb2NrSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgaG1hYy5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1dvcmRzID0gYmxvY2sud29yZHM7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tXb3Jkc0xlbmd0aCA9IGJsb2NrV29yZHMubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICB2YXIgaW50ZXJtZWRpYXRlID0gYmxvY2s7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IGhtYWMuZmluYWxpemUoaW50ZXJtZWRpYXRlKTtcblx0ICAgICAgICAgICAgICAgICAgICBobWFjLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcm1lZGlhdGVXb3JkcyA9IGludGVybWVkaWF0ZS53b3JkcztcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFhPUiBpbnRlcm1lZGlhdGUgd2l0aCBibG9ja1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tXb3Jkc0xlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrV29yZHNbal0gXj0gaW50ZXJtZWRpYXRlV29yZHNbal07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG5cdCAgICAgICAgICAgICAgICBibG9ja0luZGV4V29yZHNbMF0rKztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29tcHV0ZXMgdGhlIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLlBCS0RGMiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIFBCS0RGMi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUEJLREYyO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3RzXG5cdCAgICB2YXIgUyAgPSBbXTtcblx0ICAgIHZhciBDXyA9IFtdO1xuXHQgICAgdmFyIEcgID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmFiYml0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICpcblx0ICAgICAqIFRoaXMgaXMgYSBsZWdhY3kgdmVyc2lvbiB0aGF0IG5lZ2xlY3RlZCB0byBjb252ZXJ0IHRoZSBrZXkgdG8gbGl0dGxlLWVuZGlhbi5cblx0ICAgICAqIFRoaXMgZXJyb3IgZG9lc24ndCBhZmZlY3QgdGhlIGNpcGhlcidzIHNlY3VyaXR5LFxuXHQgICAgICogYnV0IGl0IGRvZXMgYWZmZWN0IGl0cyBjb21wYXRpYmlsaXR5IHdpdGggb3RoZXIgaW1wbGVtZW50YXRpb25zLlxuXHQgICAgICovXG5cdCAgICB2YXIgUmFiYml0TGVnYWN5ID0gQ19hbGdvLlJhYmJpdExlZ2FjeSA9IFN0cmVhbUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSyA9IHRoaXMuX2tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5jZmcuaXY7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBzdGF0ZSB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIFggPSB0aGlzLl9YID0gW1xuXHQgICAgICAgICAgICAgICAgS1swXSwgKEtbM10gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbMV0sIChLWzBdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzJdLCAoS1sxXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1szXSwgKEtbMl0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KVxuXHQgICAgICAgICAgICBdO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIEMgPSB0aGlzLl9DID0gW1xuXHQgICAgICAgICAgICAgICAgKEtbMl0gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSwgKEtbMF0gJiAweGZmZmYwMDAwKSB8IChLWzFdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1szXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLCAoS1sxXSAmIDB4ZmZmZjAwMDApIHwgKEtbMl0gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzBdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksIChLWzJdICYgMHhmZmZmMDAwMCkgfCAoS1szXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbMV0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KSwgKEtbM10gJiAweGZmZmYwMDAwKSB8IChLWzBdICYgMHgwMDAwZmZmZilcblx0ICAgICAgICAgICAgXTtcblxuXHQgICAgICAgICAgICAvLyBDYXJyeSBiaXRcblx0ICAgICAgICAgICAgdGhpcy5fYiA9IDA7XG5cblx0ICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSBjb3VudGVyc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgQ1tpXSBePSBYWyhpICsgNCkgJiA3XTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElWIHNldHVwXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgSVYgPSBpdi53b3Jkcztcblx0ICAgICAgICAgICAgICAgIHZhciBJVl8wID0gSVZbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgSVZfMSA9IElWWzFdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3VyIHN1YnZlY3RvcnNcblx0ICAgICAgICAgICAgICAgIHZhciBpMCA9ICgoKElWXzAgPDwgOCkgfCAoSVZfMCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHwgKCgoSVZfMCA8PCAyNCkgfCAoSVZfMCA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTIgPSAoKChJVl8xIDw8IDgpIHwgKElWXzEgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8ICgoKElWXzEgPDwgMjQpIHwgKElWXzEgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkxID0gKGkwID4+PiAxNikgfCAoaTIgJiAweGZmZmYwMDAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMyA9IChpMiA8PCAxNikgIHwgKGkwICYgMHgwMDAwZmZmZik7XG5cblx0ICAgICAgICAgICAgICAgIC8vIE1vZGlmeSBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgQ1swXSBePSBpMDtcblx0ICAgICAgICAgICAgICAgIENbMV0gXj0gaTE7XG5cdCAgICAgICAgICAgICAgICBDWzJdIF49IGkyO1xuXHQgICAgICAgICAgICAgICAgQ1szXSBePSBpMztcblx0ICAgICAgICAgICAgICAgIENbNF0gXj0gaTA7XG5cdCAgICAgICAgICAgICAgICBDWzVdIF49IGkxO1xuXHQgICAgICAgICAgICAgICAgQ1s2XSBePSBpMjtcblx0ICAgICAgICAgICAgICAgIENbN10gXj0gaTM7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgWCA9IHRoaXMuX1g7XG5cblx0ICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtXG5cdCAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGZvdXIga2V5c3RyZWFtIHdvcmRzXG5cdCAgICAgICAgICAgIFNbMF0gPSBYWzBdIF4gKFhbNV0gPj4+IDE2KSBeIChYWzNdIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1sxXSA9IFhbMl0gXiAoWFs3XSA+Pj4gMTYpIF4gKFhbNV0gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzJdID0gWFs0XSBeIChYWzFdID4+PiAxNikgXiAoWFs3XSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbM10gPSBYWzZdIF4gKFhbM10gPj4+IDE2KSBeIChYWzFdIDw8IDE2KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgICAgIFNbaV0gPSAoKChTW2ldIDw8IDgpICB8IChTW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKFNbaV0gPDwgMjQpIHwgKFNbaV0gPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXQgKyBpXSBePSBTW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiA2NC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICB2YXIgWCA9IHRoaXMuX1g7XG5cdCAgICAgICAgdmFyIEMgPSB0aGlzLl9DO1xuXG5cdCAgICAgICAgLy8gU2F2ZSBvbGQgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICBDX1tpXSA9IENbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgIENbMF0gPSAoQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iKSB8IDA7XG5cdCAgICAgICAgQ1sxXSA9IChDWzFdICsgMHhkMzRkMzRkMyArICgoQ1swXSA+Pj4gMCkgPCAoQ19bMF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1syXSA9IChDWzJdICsgMHgzNGQzNGQzNCArICgoQ1sxXSA+Pj4gMCkgPCAoQ19bMV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1szXSA9IChDWzNdICsgMHg0ZDM0ZDM0ZCArICgoQ1syXSA+Pj4gMCkgPCAoQ19bMl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s0XSA9IChDWzRdICsgMHhkMzRkMzRkMyArICgoQ1szXSA+Pj4gMCkgPCAoQ19bM10gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s1XSA9IChDWzVdICsgMHgzNGQzNGQzNCArICgoQ1s0XSA+Pj4gMCkgPCAoQ19bNF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s2XSA9IChDWzZdICsgMHg0ZDM0ZDM0ZCArICgoQ1s1XSA+Pj4gMCkgPCAoQ19bNV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s3XSA9IChDWzddICsgMHhkMzRkMzRkMyArICgoQ1s2XSA+Pj4gMCkgPCAoQ19bNl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgdGhpcy5fYiA9IChDWzddID4+PiAwKSA8IChDX1s3XSA+Pj4gMCkgPyAxIDogMDtcblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZy12YWx1ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZ3ggPSBYW2ldICsgQ1tpXTtcblxuXHQgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgaGlnaCBhbmQgbG93IGFyZ3VtZW50IGZvciBzcXVhcmluZ1xuXHQgICAgICAgICAgICB2YXIgZ2EgPSBneCAmIDB4ZmZmZjtcblx0ICAgICAgICAgICAgdmFyIGdiID0gZ3ggPj4+IDE2O1xuXG5cdCAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBoaWdoIGFuZCBsb3cgcmVzdWx0IG9mIHNxdWFyaW5nXG5cdCAgICAgICAgICAgIHZhciBnaCA9ICgoKChnYSAqIGdhKSA+Pj4gMTcpICsgZ2EgKiBnYikgPj4+IDE1KSArIGdiICogZ2I7XG5cdCAgICAgICAgICAgIHZhciBnbCA9ICgoKGd4ICYgMHhmZmZmMDAwMCkgKiBneCkgfCAwKSArICgoKGd4ICYgMHgwMDAwZmZmZikgKiBneCkgfCAwKTtcblxuXHQgICAgICAgICAgICAvLyBIaWdoIFhPUiBsb3dcblx0ICAgICAgICAgICAgR1tpXSA9IGdoIF4gZ2w7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzdGF0ZSB2YWx1ZXNcblx0ICAgICAgICBYWzBdID0gKEdbMF0gKyAoKEdbN10gPDwgMTYpIHwgKEdbN10gPj4+IDE2KSkgKyAoKEdbNl0gPDwgMTYpIHwgKEdbNl0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzFdID0gKEdbMV0gKyAoKEdbMF0gPDwgOCkgIHwgKEdbMF0gPj4+IDI0KSkgKyBHWzddKSB8IDA7XG5cdCAgICAgICAgWFsyXSA9IChHWzJdICsgKChHWzFdIDw8IDE2KSB8IChHWzFdID4+PiAxNikpICsgKChHWzBdIDw8IDE2KSB8IChHWzBdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFszXSA9IChHWzNdICsgKChHWzJdIDw8IDgpICB8IChHWzJdID4+PiAyNCkpICsgR1sxXSkgfCAwO1xuXHQgICAgICAgIFhbNF0gPSAoR1s0XSArICgoR1szXSA8PCAxNikgfCAoR1szXSA+Pj4gMTYpKSArICgoR1syXSA8PCAxNikgfCAoR1syXSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbNV0gPSAoR1s1XSArICgoR1s0XSA8PCA4KSAgfCAoR1s0XSA+Pj4gMjQpKSArIEdbM10pIHwgMDtcblx0ICAgICAgICBYWzZdID0gKEdbNl0gKyAoKEdbNV0gPDwgMTYpIHwgKEdbNV0gPj4+IDE2KSkgKyAoKEdbNF0gPDwgMTYpIHwgKEdbNF0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzddID0gKEdbN10gKyAoKEdbNl0gPDwgOCkgIHwgKEdbNl0gPj4+IDI0KSkgKyBHWzVdKSB8IDA7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUmFiYml0TGVnYWN5LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUmFiYml0TGVnYWN5LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlJhYmJpdExlZ2FjeSA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdExlZ2FjeSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUmFiYml0TGVnYWN5O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3RzXG5cdCAgICB2YXIgUyAgPSBbXTtcblx0ICAgIHZhciBDXyA9IFtdO1xuXHQgICAgdmFyIEcgID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmFiYml0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtXG5cdCAgICAgKi9cblx0ICAgIHZhciBSYWJiaXQgPSBDX2FsZ28uUmFiYml0ID0gU3RyZWFtQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBLID0gdGhpcy5fa2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLmNmZy5pdjtcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgS1tpXSA9ICgoKEtbaV0gPDwgOCkgIHwgKEtbaV0gPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoS1tpXSA8PCAyNCkgfCAoS1tpXSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgaW5pdGlhbCBzdGF0ZSB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIFggPSB0aGlzLl9YID0gW1xuXHQgICAgICAgICAgICAgICAgS1swXSwgKEtbM10gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbMV0sIChLWzBdIDw8IDE2KSB8IChLWzNdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzJdLCAoS1sxXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1szXSwgKEtbMl0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KVxuXHQgICAgICAgICAgICBdO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIEMgPSB0aGlzLl9DID0gW1xuXHQgICAgICAgICAgICAgICAgKEtbMl0gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSwgKEtbMF0gJiAweGZmZmYwMDAwKSB8IChLWzFdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1szXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLCAoS1sxXSAmIDB4ZmZmZjAwMDApIHwgKEtbMl0gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzBdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksIChLWzJdICYgMHhmZmZmMDAwMCkgfCAoS1szXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbMV0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KSwgKEtbM10gJiAweGZmZmYwMDAwKSB8IChLWzBdICYgMHgwMDAwZmZmZilcblx0ICAgICAgICAgICAgXTtcblxuXHQgICAgICAgICAgICAvLyBDYXJyeSBiaXRcblx0ICAgICAgICAgICAgdGhpcy5fYiA9IDA7XG5cblx0ICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSBjb3VudGVyc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgQ1tpXSBePSBYWyhpICsgNCkgJiA3XTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIElWIHNldHVwXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgSVYgPSBpdi53b3Jkcztcblx0ICAgICAgICAgICAgICAgIHZhciBJVl8wID0gSVZbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgSVZfMSA9IElWWzFdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3VyIHN1YnZlY3RvcnNcblx0ICAgICAgICAgICAgICAgIHZhciBpMCA9ICgoKElWXzAgPDwgOCkgfCAoSVZfMCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHwgKCgoSVZfMCA8PCAyNCkgfCAoSVZfMCA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTIgPSAoKChJVl8xIDw8IDgpIHwgKElWXzEgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8ICgoKElWXzEgPDwgMjQpIHwgKElWXzEgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkxID0gKGkwID4+PiAxNikgfCAoaTIgJiAweGZmZmYwMDAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMyA9IChpMiA8PCAxNikgIHwgKGkwICYgMHgwMDAwZmZmZik7XG5cblx0ICAgICAgICAgICAgICAgIC8vIE1vZGlmeSBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgQ1swXSBePSBpMDtcblx0ICAgICAgICAgICAgICAgIENbMV0gXj0gaTE7XG5cdCAgICAgICAgICAgICAgICBDWzJdIF49IGkyO1xuXHQgICAgICAgICAgICAgICAgQ1szXSBePSBpMztcblx0ICAgICAgICAgICAgICAgIENbNF0gXj0gaTA7XG5cdCAgICAgICAgICAgICAgICBDWzVdIF49IGkxO1xuXHQgICAgICAgICAgICAgICAgQ1s2XSBePSBpMjtcblx0ICAgICAgICAgICAgICAgIENbN10gXj0gaTM7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgWCA9IHRoaXMuX1g7XG5cblx0ICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtXG5cdCAgICAgICAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGZvdXIga2V5c3RyZWFtIHdvcmRzXG5cdCAgICAgICAgICAgIFNbMF0gPSBYWzBdIF4gKFhbNV0gPj4+IDE2KSBeIChYWzNdIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1sxXSA9IFhbMl0gXiAoWFs3XSA+Pj4gMTYpIF4gKFhbNV0gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzJdID0gWFs0XSBeIChYWzFdID4+PiAxNikgXiAoWFs3XSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbM10gPSBYWzZdIF4gKFhbM10gPj4+IDE2KSBeIChYWzFdIDw8IDE2KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgICAgIFNbaV0gPSAoKChTW2ldIDw8IDgpICB8IChTW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKFNbaV0gPDwgMjQpIHwgKFNbaV0gPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXQgKyBpXSBePSBTW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiA2NC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICB2YXIgWCA9IHRoaXMuX1g7XG5cdCAgICAgICAgdmFyIEMgPSB0aGlzLl9DO1xuXG5cdCAgICAgICAgLy8gU2F2ZSBvbGQgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICBDX1tpXSA9IENbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBjb3VudGVyIHZhbHVlc1xuXHQgICAgICAgIENbMF0gPSAoQ1swXSArIDB4NGQzNGQzNGQgKyB0aGlzLl9iKSB8IDA7XG5cdCAgICAgICAgQ1sxXSA9IChDWzFdICsgMHhkMzRkMzRkMyArICgoQ1swXSA+Pj4gMCkgPCAoQ19bMF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1syXSA9IChDWzJdICsgMHgzNGQzNGQzNCArICgoQ1sxXSA+Pj4gMCkgPCAoQ19bMV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1szXSA9IChDWzNdICsgMHg0ZDM0ZDM0ZCArICgoQ1syXSA+Pj4gMCkgPCAoQ19bMl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s0XSA9IChDWzRdICsgMHhkMzRkMzRkMyArICgoQ1szXSA+Pj4gMCkgPCAoQ19bM10gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s1XSA9IChDWzVdICsgMHgzNGQzNGQzNCArICgoQ1s0XSA+Pj4gMCkgPCAoQ19bNF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s2XSA9IChDWzZdICsgMHg0ZDM0ZDM0ZCArICgoQ1s1XSA+Pj4gMCkgPCAoQ19bNV0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgQ1s3XSA9IChDWzddICsgMHhkMzRkMzRkMyArICgoQ1s2XSA+Pj4gMCkgPCAoQ19bNl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgdGhpcy5fYiA9IChDWzddID4+PiAwKSA8IChDX1s3XSA+Pj4gMCkgPyAxIDogMDtcblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZy12YWx1ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZ3ggPSBYW2ldICsgQ1tpXTtcblxuXHQgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgaGlnaCBhbmQgbG93IGFyZ3VtZW50IGZvciBzcXVhcmluZ1xuXHQgICAgICAgICAgICB2YXIgZ2EgPSBneCAmIDB4ZmZmZjtcblx0ICAgICAgICAgICAgdmFyIGdiID0gZ3ggPj4+IDE2O1xuXG5cdCAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBoaWdoIGFuZCBsb3cgcmVzdWx0IG9mIHNxdWFyaW5nXG5cdCAgICAgICAgICAgIHZhciBnaCA9ICgoKChnYSAqIGdhKSA+Pj4gMTcpICsgZ2EgKiBnYikgPj4+IDE1KSArIGdiICogZ2I7XG5cdCAgICAgICAgICAgIHZhciBnbCA9ICgoKGd4ICYgMHhmZmZmMDAwMCkgKiBneCkgfCAwKSArICgoKGd4ICYgMHgwMDAwZmZmZikgKiBneCkgfCAwKTtcblxuXHQgICAgICAgICAgICAvLyBIaWdoIFhPUiBsb3dcblx0ICAgICAgICAgICAgR1tpXSA9IGdoIF4gZ2w7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzdGF0ZSB2YWx1ZXNcblx0ICAgICAgICBYWzBdID0gKEdbMF0gKyAoKEdbN10gPDwgMTYpIHwgKEdbN10gPj4+IDE2KSkgKyAoKEdbNl0gPDwgMTYpIHwgKEdbNl0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzFdID0gKEdbMV0gKyAoKEdbMF0gPDwgOCkgIHwgKEdbMF0gPj4+IDI0KSkgKyBHWzddKSB8IDA7XG5cdCAgICAgICAgWFsyXSA9IChHWzJdICsgKChHWzFdIDw8IDE2KSB8IChHWzFdID4+PiAxNikpICsgKChHWzBdIDw8IDE2KSB8IChHWzBdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFszXSA9IChHWzNdICsgKChHWzJdIDw8IDgpICB8IChHWzJdID4+PiAyNCkpICsgR1sxXSkgfCAwO1xuXHQgICAgICAgIFhbNF0gPSAoR1s0XSArICgoR1szXSA8PCAxNikgfCAoR1szXSA+Pj4gMTYpKSArICgoR1syXSA8PCAxNikgfCAoR1syXSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbNV0gPSAoR1s1XSArICgoR1s0XSA8PCA4KSAgfCAoR1s0XSA+Pj4gMjQpKSArIEdbM10pIHwgMDtcblx0ICAgICAgICBYWzZdID0gKEdbNl0gKyAoKEdbNV0gPDwgMTYpIHwgKEdbNV0gPj4+IDE2KSkgKyAoKEdbNF0gPDwgMTYpIHwgKEdbNF0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzddID0gKEdbN10gKyAoKEdbNl0gPDwgOCkgIHwgKEdbNl0gPj4+IDI0KSkgKyBHWzVdKSB8IDA7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUmFiYml0LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUmFiYml0LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlJhYmJpdCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdCk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUmFiYml0O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJDNCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFJDNCA9IENfYWxnby5SQzQgPSBTdHJlYW1DaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2lnQnl0ZXMgPSBrZXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBzYm94XG5cdCAgICAgICAgICAgIHZhciBTID0gdGhpcy5fUyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBTW2ldID0gaTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEtleSBzZXR1cFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleUJ5dGVJbmRleCA9IGkgJSBrZXlTaWdCeXRlcztcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlCeXRlID0gKGtleVdvcmRzW2tleUJ5dGVJbmRleCA+Pj4gMl0gPj4+ICgyNCAtIChrZXlCeXRlSW5kZXggJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIGogPSAoaiArIFNbaV0gKyBrZXlCeXRlKSAlIDI1NjtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcFxuXHQgICAgICAgICAgICAgICAgdmFyIHQgPSBTW2ldO1xuXHQgICAgICAgICAgICAgICAgU1tpXSA9IFNbal07XG5cdCAgICAgICAgICAgICAgICBTW2pdID0gdDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50ZXJzXG5cdCAgICAgICAgICAgIHRoaXMuX2kgPSB0aGlzLl9qID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSBePSBnZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkKCkge1xuXHQgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgIHZhciBTID0gdGhpcy5fUztcblx0ICAgICAgICB2YXIgaSA9IHRoaXMuX2k7XG5cdCAgICAgICAgdmFyIGogPSB0aGlzLl9qO1xuXG5cdCAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtIHdvcmRcblx0ICAgICAgICB2YXIga2V5c3RyZWFtV29yZCA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCA0OyBuKyspIHtcblx0ICAgICAgICAgICAgaSA9IChpICsgMSkgJSAyNTY7XG5cdCAgICAgICAgICAgIGogPSAoaiArIFNbaV0pICUgMjU2O1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXBcblx0ICAgICAgICAgICAgdmFyIHQgPSBTW2ldO1xuXHQgICAgICAgICAgICBTW2ldID0gU1tqXTtcblx0ICAgICAgICAgICAgU1tqXSA9IHQ7XG5cblx0ICAgICAgICAgICAga2V5c3RyZWFtV29yZCB8PSBTWyhTW2ldICsgU1tqXSkgJSAyNTZdIDw8ICgyNCAtIG4gKiA4KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBVcGRhdGUgY291bnRlcnNcblx0ICAgICAgICB0aGlzLl9pID0gaTtcblx0ICAgICAgICB0aGlzLl9qID0gajtcblxuXHQgICAgICAgIHJldHVybiBrZXlzdHJlYW1Xb3JkO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJDNC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJDNC5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5SQzQgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSQzQpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1vZGlmaWVkIFJDNCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFJDNERyb3AgPSBDX2FsZ28uUkM0RHJvcCA9IFJDNC5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcm9wIFRoZSBudW1iZXIgb2Yga2V5c3RyZWFtIHdvcmRzIHRvIGRyb3AuIERlZmF1bHQgMTkyXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBSQzQuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGRyb3A6IDE5MlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgUkM0Ll9kb1Jlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gRHJvcFxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5jZmcuZHJvcDsgaSA+IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SQzREcm9wLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUkM0RHJvcC5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5SQzREcm9wID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0RHJvcCk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuUkM0O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKiogQHByZXNlcnZlXG5cdChjKSAyMDEyIGJ5IEPDqWRyaWMgTWVzbmlsLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5cdFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuXHQgICAgLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cdCAgICAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuXHRUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cdCovXG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlXG5cdCAgICB2YXIgX3psID0gV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgMCwgIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcblx0ICAgICAgICA3LCAgNCwgMTMsICAxLCAxMCwgIDYsIDE1LCAgMywgMTIsICAwLCAgOSwgIDUsICAyLCAxNCwgMTEsICA4LFxuXHQgICAgICAgIDMsIDEwLCAxNCwgIDQsICA5LCAxNSwgIDgsICAxLCAgMiwgIDcsICAwLCAgNiwgMTMsIDExLCAgNSwgMTIsXG5cdCAgICAgICAgMSwgIDksIDExLCAxMCwgIDAsICA4LCAxMiwgIDQsIDEzLCAgMywgIDcsIDE1LCAxNCwgIDUsICA2LCAgMixcblx0ICAgICAgICA0LCAgMCwgIDUsICA5LCAgNywgMTIsICAyLCAxMCwgMTQsICAxLCAgMywgIDgsIDExLCAgNiwgMTUsIDEzXSk7XG5cdCAgICB2YXIgX3pyID0gV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgNSwgMTQsICA3LCAgMCwgIDksICAyLCAxMSwgIDQsIDEzLCAgNiwgMTUsICA4LCAgMSwgMTAsICAzLCAxMixcblx0ICAgICAgICA2LCAxMSwgIDMsICA3LCAgMCwgMTMsICA1LCAxMCwgMTQsIDE1LCAgOCwgMTIsICA0LCAgOSwgIDEsICAyLFxuXHQgICAgICAgIDE1LCAgNSwgIDEsICAzLCAgNywgMTQsICA2LCAgOSwgMTEsICA4LCAxMiwgIDIsIDEwLCAgMCwgIDQsIDEzLFxuXHQgICAgICAgIDgsICA2LCAgNCwgIDEsICAzLCAxMSwgMTUsICAwLCAgNSwgMTIsICAyLCAxMywgIDksICA3LCAxMCwgMTQsXG5cdCAgICAgICAgMTIsIDE1LCAxMCwgIDQsICAxLCAgNSwgIDgsICA3LCAgNiwgIDIsIDEzLCAxNCwgIDAsICAzLCAgOSwgMTFdKTtcblx0ICAgIHZhciBfc2wgPSBXb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICAgMTEsIDE0LCAxNSwgMTIsICA1LCAgOCwgIDcsICA5LCAxMSwgMTMsIDE0LCAxNSwgIDYsICA3LCAgOSwgIDgsXG5cdCAgICAgICAgNywgNiwgICA4LCAxMywgMTEsICA5LCAgNywgMTUsICA3LCAxMiwgMTUsICA5LCAxMSwgIDcsIDEzLCAxMixcblx0ICAgICAgICAxMSwgMTMsICA2LCAgNywgMTQsICA5LCAxMywgMTUsIDE0LCAgOCwgMTMsICA2LCAgNSwgMTIsICA3LCAgNSxcblx0ICAgICAgICAgIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsICA5LCAgOCwgIDksIDE0LCAgNSwgIDYsICA4LCAgNiwgIDUsIDEyLFxuXHQgICAgICAgIDksIDE1LCAgNSwgMTEsICA2LCAgOCwgMTMsIDEyLCAgNSwgMTIsIDEzLCAxNCwgMTEsICA4LCAgNSwgIDYgXSk7XG5cdCAgICB2YXIgX3NyID0gV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgOCwgIDksICA5LCAxMSwgMTMsIDE1LCAxNSwgIDUsICA3LCAgNywgIDgsIDExLCAxNCwgMTQsIDEyLCAgNixcblx0ICAgICAgICA5LCAxMywgMTUsICA3LCAxMiwgIDgsICA5LCAxMSwgIDcsICA3LCAxMiwgIDcsICA2LCAxNSwgMTMsIDExLFxuXHQgICAgICAgIDksICA3LCAxNSwgMTEsICA4LCAgNiwgIDYsIDE0LCAxMiwgMTMsICA1LCAxNCwgMTMsIDEzLCAgNywgIDUsXG5cdCAgICAgICAgMTUsICA1LCAgOCwgMTEsIDE0LCAxNCwgIDYsIDE0LCAgNiwgIDksIDEyLCAgOSwgMTIsICA1LCAxNSwgIDgsXG5cdCAgICAgICAgOCwgIDUsIDEyLCAgOSwgMTIsICA1LCAxNCwgIDYsICA4LCAxMywgIDYsICA1LCAxNSwgMTMsIDExLCAxMSBdKTtcblxuXHQgICAgdmFyIF9obCA9ICBXb3JkQXJyYXkuY3JlYXRlKFsgMHgwMDAwMDAwMCwgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSwgMHg4RjFCQkNEQywgMHhBOTUzRkQ0RV0pO1xuXHQgICAgdmFyIF9ociA9ICBXb3JkQXJyYXkuY3JlYXRlKFsgMHg1MEEyOEJFNiwgMHg1QzRERDEyNCwgMHg2RDcwM0VGMywgMHg3QTZENzZFOSwgMHgwMDAwMDAwMF0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJJUEVNRDE2MCBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFJJUEVNRDE2MCA9IENfYWxnby5SSVBFTUQxNjAgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoICA9IFdvcmRBcnJheS5jcmVhdGUoWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG5cdCAgICAgICAgICAgICAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwXG5cdCAgICAgICAgICAgICAgICBNW29mZnNldF9pXSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCAgPSB0aGlzLl9oYXNoLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaGwgPSBfaGwud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBociA9IF9oci53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHpsID0gX3psLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgenIgPSBfenIud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzbCA9IF9zbC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNyID0gX3NyLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhbCwgYmwsIGNsLCBkbCwgZWw7XG5cdCAgICAgICAgICAgIHZhciBhciwgYnIsIGNyLCBkciwgZXI7XG5cblx0ICAgICAgICAgICAgYXIgPSBhbCA9IEhbMF07XG5cdCAgICAgICAgICAgIGJyID0gYmwgPSBIWzFdO1xuXHQgICAgICAgICAgICBjciA9IGNsID0gSFsyXTtcblx0ICAgICAgICAgICAgZHIgPSBkbCA9IEhbM107XG5cdCAgICAgICAgICAgIGVyID0gZWwgPSBIWzRdO1xuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICB2YXIgdDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSArPSAxKSB7XG5cdCAgICAgICAgICAgICAgICB0ID0gKGFsICsgIE1bb2Zmc2V0K3psW2ldXSl8MDtcblx0ICAgICAgICAgICAgICAgIGlmIChpPDE2KXtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMShibCxjbCxkbCkgKyBobFswXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTwzMikge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYyKGJsLGNsLGRsKSArIGhsWzFdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDQ4KSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjMoYmwsY2wsZGwpICsgaGxbMl07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8NjQpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmNChibCxjbCxkbCkgKyBobFszXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmNShibCxjbCxkbCkgKyBobFs0XTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHQgPSB0fDA7XG5cdCAgICAgICAgICAgICAgICB0ID0gIHJvdGwodCxzbFtpXSk7XG5cdCAgICAgICAgICAgICAgICB0ID0gKHQrZWwpfDA7XG5cdCAgICAgICAgICAgICAgICBhbCA9IGVsO1xuXHQgICAgICAgICAgICAgICAgZWwgPSBkbDtcblx0ICAgICAgICAgICAgICAgIGRsID0gcm90bChjbCwgMTApO1xuXHQgICAgICAgICAgICAgICAgY2wgPSBibDtcblx0ICAgICAgICAgICAgICAgIGJsID0gdDtcblxuXHQgICAgICAgICAgICAgICAgdCA9IChhciArIE1bb2Zmc2V0K3pyW2ldXSl8MDtcblx0ICAgICAgICAgICAgICAgIGlmIChpPDE2KXtcblx0XHQgICAgICAgICAgICB0ICs9ICBmNShicixjcixkcikgKyBoclswXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTwzMikge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGY0KGJyLGNyLGRyKSArIGhyWzFdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDQ4KSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjMoYnIsY3IsZHIpICsgaHJbMl07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8NjQpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMihicixjcixkcikgKyBoclszXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMShicixjcixkcikgKyBocls0XTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHQgPSB0fDA7XG5cdCAgICAgICAgICAgICAgICB0ID0gIHJvdGwodCxzcltpXSkgO1xuXHQgICAgICAgICAgICAgICAgdCA9ICh0K2VyKXwwO1xuXHQgICAgICAgICAgICAgICAgYXIgPSBlcjtcblx0ICAgICAgICAgICAgICAgIGVyID0gZHI7XG5cdCAgICAgICAgICAgICAgICBkciA9IHJvdGwoY3IsIDEwKTtcblx0ICAgICAgICAgICAgICAgIGNyID0gYnI7XG5cdCAgICAgICAgICAgICAgICBiciA9IHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgdCAgICA9IChIWzFdICsgY2wgKyBkcil8MDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzJdICsgZGwgKyBlcil8MDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzNdICsgZWwgKyBhcil8MDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzRdICsgYWwgKyBicil8MDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzBdICsgYmwgKyBjcil8MDtcblx0ICAgICAgICAgICAgSFswXSA9ICB0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbCA8PCA4KSAgfCAobkJpdHNUb3RhbCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWwgPDwgMjQpIHwgKG5CaXRzVG90YWwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XG5cdCAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwXG5cdCAgICAgICAgICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cblx0ICAgIGZ1bmN0aW9uIGYxKHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCh4KSBeICh5KSBeICh6KSk7XG5cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZjIoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKCh4KSYoeSkpIHwgKCh+eCkmKHopKSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGYzKHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCgoeCkgfCAofih5KSkpIF4gKHopKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZjQoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKCh4KSAmICh6KSkgfCAoKHkpJih+KHopKSkpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmNSh4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoeCkgXiAoKHkpIHwofih6KSkpKTtcblxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiByb3RsKHgsbikge1xuXHQgICAgICAgIHJldHVybiAoeDw8bikgfCAoeD4+PigzMi1uKSk7XG5cdCAgICB9XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlJJUEVNRDE2MCgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuUklQRU1EMTYwKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuUklQRU1EMTYwID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoUklQRU1EMTYwKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNSSVBFTUQxNjAobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjUklQRU1EMTYwID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFJJUEVNRDE2MCk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlJJUEVNRDE2MDtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTEgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEExID0gQ19hbGdvLlNIQTEgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LFxuXHQgICAgICAgICAgICAgICAgMHhjM2QyZTFmMFxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIDB4NWE4Mjc5OTk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA0MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgKyAweDZlZDllYmExO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoaSA8IDgwKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSAtIDB4MzU5ZDNlMmE7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGUgPSBkO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gdDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEExKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEExO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTI1NlwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9zaGEyNTZcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTY7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTIyNCBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTIyNCA9IENfYWxnby5TSEEyMjQgPSBTSEEyNTYuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG5cdCAgICAgICAgICAgICAgICAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0XG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IFNIQTI1Ni5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIGhhc2guc2lnQnl0ZXMgLT0gNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTIyNCgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjI0KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMjI0ID0gU0hBMjU2Ll9jcmVhdGVIZWxwZXIoU0hBMjI0KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEyMjQobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMjI0ID0gU0hBMjU2Ll9jcmVhdGVIbWFjSGVscGVyKFNIQTIyNCk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjI0O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBJbml0aWFsaXphdGlvbiBhbmQgcm91bmQgY29uc3RhbnRzIHRhYmxlc1xuXHQgICAgdmFyIEggPSBbXTtcblx0ICAgIHZhciBLID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGlzUHJpbWUobikge1xuXHQgICAgICAgICAgICB2YXIgc3FydE4gPSBNYXRoLnNxcnQobik7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGZhY3RvciA9IDI7IGZhY3RvciA8PSBzcXJ0TjsgZmFjdG9yKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICghKG4gJSBmYWN0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnJhY3Rpb25hbEJpdHMobikge1xuXHQgICAgICAgICAgICByZXR1cm4gKChuIC0gKG4gfCAwKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBuID0gMjtcblx0ICAgICAgICB2YXIgblByaW1lID0gMDtcblx0ICAgICAgICB3aGlsZSAoblByaW1lIDwgNjQpIHtcblx0ICAgICAgICAgICAgaWYgKGlzUHJpbWUobikpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChuUHJpbWUgPCA4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgSFtuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDIpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAzKSk7XG5cblx0ICAgICAgICAgICAgICAgIG5QcmltZSsrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbisrO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMjU2IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NiA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoSC5zbGljZSgwKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cdCAgICAgICAgICAgIHZhciBmID0gSFs1XTtcblx0ICAgICAgICAgICAgdmFyIGcgPSBIWzZdO1xuXHQgICAgICAgICAgICB2YXIgaCA9IEhbN107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweCA9IFdbaSAtIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwICA9ICgoZ2FtbWEweCA8PCAyNSkgfCAoZ2FtbWEweCA+Pj4gNykpICBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMHggPDwgMTQpIHwgKGdhbW1hMHggPj4+IDE4KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTB4ID4+PiAzKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4ID0gV1tpIC0gMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMSAgPSAoKGdhbW1hMXggPDwgMTUpIHwgKGdhbW1hMXggPj4+IDE3KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTF4IDw8IDEzKSB8IChnYW1tYTF4ID4+PiAxOSkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWExeCA+Pj4gMTApO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggID0gKGUgJiBmKSBeICh+ZSAmIGcpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1haiA9IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMCA9ICgoYSA8PCAzMCkgfCAoYSA+Pj4gMikpIF4gKChhIDw8IDE5KSB8IChhID4+PiAxMykpIF4gKChhIDw8IDEwKSB8IChhID4+PiAyMikpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMSA9ICgoZSA8PCAyNikgfCAoZSA+Pj4gNikpIF4gKChlIDw8IDIxKSB8IChlID4+PiAxMSkpIF4gKChlIDw8IDcpICB8IChlID4+PiAyNSkpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IHNpZ21hMCArIG1hajtcblxuXHQgICAgICAgICAgICAgICAgaCA9IGc7XG5cdCAgICAgICAgICAgICAgICBnID0gZjtcblx0ICAgICAgICAgICAgICAgIGYgPSBlO1xuXHQgICAgICAgICAgICAgICAgZSA9IChkICsgdDEpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IGI7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSAodDEgKyB0MikgfCAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNV0gPSAoSFs1XSArIGYpIHwgMDtcblx0ICAgICAgICAgICAgSFs2XSA9IChIWzZdICsgZykgfCAwO1xuXHQgICAgICAgICAgICBIWzddID0gKEhbN10gKyBoKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1NignbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMjU2KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEyNTYobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1Nik7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTI1NjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi94NjQtY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi94NjQtY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfeDY0ID0gQy54NjQ7XG5cdCAgICB2YXIgWDY0V29yZCA9IENfeDY0LldvcmQ7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgUkhPX09GRlNFVFMgPSBbXTtcblx0ICAgIHZhciBQSV9JTkRFWEVTICA9IFtdO1xuXHQgICAgdmFyIFJPVU5EX0NPTlNUQU5UUyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIENvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBDb21wdXRlIHJobyBvZmZzZXQgY29uc3RhbnRzXG5cdCAgICAgICAgdmFyIHggPSAxLCB5ID0gMDtcblx0ICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDI0OyB0KyspIHtcblx0ICAgICAgICAgICAgUkhPX09GRlNFVFNbeCArIDUgKiB5XSA9ICgodCArIDEpICogKHQgKyAyKSAvIDIpICUgNjQ7XG5cblx0ICAgICAgICAgICAgdmFyIG5ld1ggPSB5ICUgNTtcblx0ICAgICAgICAgICAgdmFyIG5ld1kgPSAoMiAqIHggKyAzICogeSkgJSA1O1xuXHQgICAgICAgICAgICB4ID0gbmV3WDtcblx0ICAgICAgICAgICAgeSA9IG5ld1k7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ29tcHV0ZSBwaSBpbmRleCBjb25zdGFudHNcblx0ICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgUElfSU5ERVhFU1t4ICsgNSAqIHldID0geSArICgoMiAqIHggKyAzICogeSkgJSA1KSAqIDU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb21wdXRlIHJvdW5kIGNvbnN0YW50c1xuXHQgICAgICAgIHZhciBMRlNSID0gMHgwMTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHJvdW5kQ29uc3RhbnRNc3cgPSAwO1xuXHQgICAgICAgICAgICB2YXIgcm91bmRDb25zdGFudExzdyA9IDA7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA3OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChMRlNSICYgMHgwMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBiaXRQb3NpdGlvbiA9ICgxIDw8IGopIC0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYml0UG9zaXRpb24gPCAzMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3VuZENvbnN0YW50THN3IF49IDEgPDwgYml0UG9zaXRpb247XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChiaXRQb3NpdGlvbiA+PSAzMikgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3VuZENvbnN0YW50TXN3IF49IDEgPDwgKGJpdFBvc2l0aW9uIC0gMzIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IExGU1Jcblx0ICAgICAgICAgICAgICAgIGlmIChMRlNSICYgMHg4MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSBwb2x5bm9taWFsIG92ZXIgR0YoMik6IHheOCArIHheNiArIHheNSArIHheNCArIDFcblx0ICAgICAgICAgICAgICAgICAgICBMRlNSID0gKExGU1IgPDwgMSkgXiAweDcxO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBMRlNSIDw8PSAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgUk9VTkRfQ09OU1RBTlRTW2ldID0gWDY0V29yZC5jcmVhdGUocm91bmRDb25zdGFudE1zdywgcm91bmRDb25zdGFudExzdyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0cyBmb3IgdGVtcG9yYXJ5IHZhbHVlc1xuXHQgICAgdmFyIFQgPSBbXTtcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSBYNjRXb3JkLmNyZWF0ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTMgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEzID0gQ19hbGdvLlNIQTMgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gb3V0cHV0TGVuZ3RoXG5cdCAgICAgICAgICogICBUaGUgZGVzaXJlZCBudW1iZXIgb2YgYml0cyBpbiB0aGUgb3V0cHV0IGhhc2guXG5cdCAgICAgICAgICogICBPbmx5IHZhbHVlcyBwZXJtaXR0ZWQgYXJlOiAyMjQsIDI1NiwgMzg0LCA1MTIuXG5cdCAgICAgICAgICogICBEZWZhdWx0OiA1MTJcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEhhc2hlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgb3V0cHV0TGVuZ3RoOiA1MTJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlID0gW11cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZVtpXSA9IG5ldyBYNjRXb3JkLmluaXQoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMuYmxvY2tTaXplID0gKDE2MDAgLSAyICogdGhpcy5jZmcub3V0cHV0TGVuZ3RoKSAvIDMyO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgICAgICAgICB2YXIgbkJsb2NrU2l6ZUxhbmVzID0gdGhpcy5ibG9ja1NpemUgLyAyO1xuXG5cdCAgICAgICAgICAgIC8vIEFic29yYlxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5CbG9ja1NpemVMYW5lczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBNMmkgID0gTVtvZmZzZXQgKyAyICogaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgTTJpMSA9IE1bb2Zmc2V0ICsgMiAqIGkgKyAxXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgICAgIE0yaSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNMmkgPDwgOCkgIHwgKE0yaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNMmkgPDwgMjQpIHwgKE0yaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICAgICAgTTJpMSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNMmkxIDw8IDgpICB8IChNMmkxID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE0yaTEgPDwgMjQpIHwgKE0yaTEgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQWJzb3JiIG1lc3NhZ2UgaW50byBzdGF0ZVxuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtpXTtcblx0ICAgICAgICAgICAgICAgIGxhbmUuaGlnaCBePSBNMmkxO1xuXHQgICAgICAgICAgICAgICAgbGFuZS5sb3cgIF49IE0yaTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFRoZXRhXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIE1peCBjb2x1bW4gbGFuZXNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdE1zdyA9IDAsIHRMc3cgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbeCArIDUgKiB5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdE1zdyBePSBsYW5lLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRMc3cgXj0gbGFuZS5sb3c7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHZhbHVlc1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeCA9IFRbeF07XG5cdCAgICAgICAgICAgICAgICAgICAgVHguaGlnaCA9IHRNc3c7XG5cdCAgICAgICAgICAgICAgICAgICAgVHgubG93ICA9IHRMc3c7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDU7IHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeDQgPSBUWyh4ICsgNCkgJSA1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHgxID0gVFsoeCArIDEpICUgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4MU1zdyA9IFR4MS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeDFMc3cgPSBUeDEubG93O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTWl4IHN1cnJvdW5kaW5nIGNvbHVtbnNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdE1zdyA9IFR4NC5oaWdoIF4gKChUeDFNc3cgPDwgMSkgfCAoVHgxTHN3ID4+PiAzMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0THN3ID0gVHg0LmxvdyAgXiAoKFR4MUxzdyA8PCAxKSB8IChUeDFNc3cgPj4+IDMxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVt4ICsgNSAqIHldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5lLmhpZ2ggXj0gdE1zdztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZS5sb3cgIF49IHRMc3c7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSaG8gUGlcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGxhbmVJbmRleCA9IDE7IGxhbmVJbmRleCA8IDI1OyBsYW5lSW5kZXgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbbGFuZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZU1zdyA9IGxhbmUuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZUxzdyA9IGxhbmUubG93O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByaG9PZmZzZXQgPSBSSE9fT0ZGU0VUU1tsYW5lSW5kZXhdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUm90YXRlIGxhbmVzXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJob09mZnNldCA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0TXN3ID0gKGxhbmVNc3cgPDwgcmhvT2Zmc2V0KSB8IChsYW5lTHN3ID4+PiAoMzIgLSByaG9PZmZzZXQpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRMc3cgPSAobGFuZUxzdyA8PCByaG9PZmZzZXQpIHwgKGxhbmVNc3cgPj4+ICgzMiAtIHJob09mZnNldCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAocmhvT2Zmc2V0ID49IDMyKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0TXN3ID0gKGxhbmVMc3cgPDwgKHJob09mZnNldCAtIDMyKSkgfCAobGFuZU1zdyA+Pj4gKDY0IC0gcmhvT2Zmc2V0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0THN3ID0gKGxhbmVNc3cgPDwgKHJob09mZnNldCAtIDMyKSkgfCAobGFuZUxzdyA+Pj4gKDY0IC0gcmhvT2Zmc2V0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNwb3NlIGxhbmVzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFRQaUxhbmUgPSBUW1BJX0lOREVYRVNbbGFuZUluZGV4XV07XG5cdCAgICAgICAgICAgICAgICAgICAgVFBpTGFuZS5oaWdoID0gdE1zdztcblx0ICAgICAgICAgICAgICAgICAgICBUUGlMYW5lLmxvdyAgPSB0THN3O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSaG8gcGkgYXQgeCA9IHkgPSAwXG5cdCAgICAgICAgICAgICAgICB2YXIgVDAgPSBUWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXRlMCA9IHN0YXRlWzBdO1xuXHQgICAgICAgICAgICAgICAgVDAuaGlnaCA9IHN0YXRlMC5oaWdoO1xuXHQgICAgICAgICAgICAgICAgVDAubG93ICA9IHN0YXRlMC5sb3c7XG5cblx0ICAgICAgICAgICAgICAgIC8vIENoaVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVJbmRleCA9IHggKyA1ICogeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtsYW5lSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVExhbmUgPSBUW2xhbmVJbmRleF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBUeDFMYW5lID0gVFsoKHggKyAxKSAlIDUpICsgNSAqIHldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVHgyTGFuZSA9IFRbKCh4ICsgMikgJSA1KSArIDUgKiB5XTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggcm93c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5lLmhpZ2ggPSBUTGFuZS5oaWdoIF4gKH5UeDFMYW5lLmhpZ2ggJiBUeDJMYW5lLmhpZ2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5lLmxvdyAgPSBUTGFuZS5sb3cgIF4gKH5UeDFMYW5lLmxvdyAgJiBUeDJMYW5lLmxvdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJb3RhXG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJvdW5kQ29uc3RhbnQgPSBST1VORF9DT05TVEFOVFNbcm91bmRdO1xuXHQgICAgICAgICAgICAgICAgbGFuZS5oaWdoIF49IHJvdW5kQ29uc3RhbnQuaGlnaDtcblx0ICAgICAgICAgICAgICAgIGxhbmUubG93ICBePSByb3VuZENvbnN0YW50Lmxvdzs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJpdHMgPSB0aGlzLmJsb2NrU2l6ZSAqIDMyO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4MSA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKE1hdGguY2VpbCgobkJpdHNMZWZ0ICsgMSkgLyBibG9ja1NpemVCaXRzKSAqIGJsb2NrU2l6ZUJpdHMpID4+PiA1KSAtIDFdIHw9IDB4ODA7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgICAgICAgICB2YXIgb3V0cHV0TGVuZ3RoQnl0ZXMgPSB0aGlzLmNmZy5vdXRwdXRMZW5ndGggLyA4O1xuXHQgICAgICAgICAgICB2YXIgb3V0cHV0TGVuZ3RoTGFuZXMgPSBvdXRwdXRMZW5ndGhCeXRlcyAvIDg7XG5cblx0ICAgICAgICAgICAgLy8gU3F1ZWV6ZVxuXHQgICAgICAgICAgICB2YXIgaGFzaFdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoTGFuZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmVNc3cgPSBsYW5lLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGFuZUxzdyA9IGxhbmUubG93O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICAgICAgbGFuZU1zdyA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChsYW5lTXN3IDw8IDgpICB8IChsYW5lTXN3ID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKGxhbmVNc3cgPDwgMjQpIHwgKGxhbmVNc3cgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgIGxhbmVMc3cgPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgobGFuZUxzdyA8PCA4KSAgfCAobGFuZUxzdyA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChsYW5lTHN3IDw8IDI0KSB8IChsYW5lTHN3ID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNxdWVlemUgc3RhdGUgdG8gcmV0cmlldmUgaGFzaFxuXHQgICAgICAgICAgICAgICAgaGFzaFdvcmRzLnB1c2gobGFuZUxzdyk7XG5cdCAgICAgICAgICAgICAgICBoYXNoV29yZHMucHVzaChsYW5lTXN3KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQoaGFzaFdvcmRzLCBvdXRwdXRMZW5ndGhCeXRlcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IGNsb25lLl9zdGF0ZSA9IHRoaXMuX3N0YXRlLnNsaWNlKDApO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHN0YXRlW2ldID0gc3RhdGVbaV0uY2xvbmUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTMoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTMod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEzID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMyk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMyhtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEzID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTMpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEzO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3g2NC1jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGE1MTJcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4veDY0LWNvcmVcIiwgXCIuL3NoYTUxMlwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX3g2NCA9IEMueDY0O1xuXHQgICAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkO1xuXHQgICAgdmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgU0hBNTEyID0gQ19hbGdvLlNIQTUxMjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMzg0IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMzg0ID0gQ19hbGdvLlNIQTM4NCA9IFNIQTUxMi5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4KSwgbmV3IFg2NFdvcmQuaW5pdCgweDYyOWEyOTJhLCAweDM2N2NkNTA3KSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyksIG5ldyBYNjRXb3JkLmluaXQoMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEpLCBuZXcgWDY0V29yZC5pbml0KDB4OGViNDRhODcsIDB4Njg1ODE1MTEpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweGRiMGMyZTBkLCAweDY0Zjk4ZmE3KSwgbmV3IFg2NFdvcmQuaW5pdCgweDQ3YjU0ODFkLCAweGJlZmE0ZmE0KVxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSBTSEE1MTIuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICBoYXNoLnNpZ0J5dGVzIC09IDE2O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMzg0KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzODQod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEzODQgPSBTSEE1MTIuX2NyZWF0ZUhlbHBlcihTSEEzODQpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTM4NChtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEzODQgPSBTSEE1MTIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMzg0KTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEzODQ7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4veDY0LWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4veDY0LWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ194NjQgPSBDLng2NDtcblx0ICAgIHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcblx0ICAgIHZhciBYNjRXb3JkQXJyYXkgPSBDX3g2NC5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICBmdW5jdGlvbiBYNjRXb3JkX2NyZWF0ZSgpIHtcblx0ICAgICAgICByZXR1cm4gWDY0V29yZC5jcmVhdGUuYXBwbHkoWDY0V29yZCwgYXJndW1lbnRzKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29uc3RhbnRzXG5cdCAgICB2YXIgSyA9IFtcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDQyOGEyZjk4LCAweGQ3MjhhZTIyKSwgWDY0V29yZF9jcmVhdGUoMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiksIFg2NFdvcmRfY3JlYXRlKDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgpLCBYNjRXb3JkX2NyZWF0ZSgweDU5ZjExMWYxLCAweGI2MDVkMDE5KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDkyM2Y4MmE0LCAweGFmMTk0ZjliKSwgWDY0V29yZF9jcmVhdGUoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhkODA3YWE5OCwgMHhhMzAzMDI0MiksIFg2NFdvcmRfY3JlYXRlKDB4MTI4MzViMDEsIDB4NDU3MDZmYmUpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMpLCBYNjRXb3JkX2NyZWF0ZSgweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDcyYmU1ZDc0LCAweGYyN2I4OTZmKSwgWDY0V29yZF9jcmVhdGUoMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg5YmRjMDZhNywgMHgyNWM3MTIzNSksIFg2NFdvcmRfY3JlYXRlKDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIpLCBYNjRXb3JkX2NyZWF0ZSgweGVmYmU0Nzg2LCAweDM4NGYyNWUzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDBmYzE5ZGM2LCAweDhiOGNkNWI1KSwgWDY0V29yZF9jcmVhdGUoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSksIFg2NFdvcmRfY3JlYXRlKDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQpLCBYNjRXb3JkX2NyZWF0ZSgweDc2Zjk4OGRhLCAweDgzMTE1M2I1KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDk4M2U1MTUyLCAweGVlNjZkZmFiKSwgWDY0V29yZF9jcmVhdGUoMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiksIFg2NFdvcmRfY3JlYXRlKDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YzZlMDBiZjMsIDB4M2RhODhmYzIpLCBYNjRXb3JkX2NyZWF0ZSgweGQ1YTc5MTQ3LCAweDkzMGFhNzI1KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDA2Y2E2MzUxLCAweGUwMDM4MjZmKSwgWDY0V29yZF9jcmVhdGUoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyN2I3MGE4NSwgMHg0NmQyMmZmYyksIFg2NFdvcmRfY3JlYXRlKDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQpLCBYNjRXb3JkX2NyZWF0ZSgweDUzMzgwZDEzLCAweDlkOTViM2RmKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDY1MGE3MzU0LCAweDhiYWY2M2RlKSwgWDY0V29yZF9jcmVhdGUoMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiksIFg2NFdvcmRfY3JlYXRlKDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQpLCBYNjRXb3JkX2NyZWF0ZSgweGE4MWE2NjRiLCAweGJjNDIzMDAxKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGMyNGI4YjcwLCAweGQwZjg5NzkxKSwgWDY0V29yZF9jcmVhdGUoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCksIFg2NFdvcmRfY3JlYXRlKDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEpLCBYNjRXb3JkX2NyZWF0ZSgweDEwNmFhMDcwLCAweDMyYmJkMWI4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDE5YTRjMTE2LCAweGI4ZDJkMGM4KSwgWDY0V29yZF9jcmVhdGUoMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSksIFg2NFdvcmRfY3JlYXRlKDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMpLCBYNjRXb3JkX2NyZWF0ZSgweDRlZDhhYTRhLCAweGUzNDE4YWNiKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDViOWNjYTRmLCAweDc3NjNlMzczKSwgWDY0V29yZF9jcmVhdGUoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg3NDhmODJlZSwgMHg1ZGVmYjJmYyksIFg2NFdvcmRfY3JlYXRlKDB4NzhhNTYzNmYsIDB4NDMxNzJmNjApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ODRjODc4MTQsIDB4YTFmMGFiNzIpLCBYNjRXb3JkX2NyZWF0ZSgweDhjYzcwMjA4LCAweDFhNjQzOWVjKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDkwYmVmZmZhLCAweDIzNjMxZTI4KSwgWDY0V29yZF9jcmVhdGUoMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhiZWY5YTNmNywgMHhiMmM2NzkxNSksIFg2NFdvcmRfY3JlYXRlKDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMpLCBYNjRXb3JkX2NyZWF0ZSgweGQxODZiOGM3LCAweDIxYzBjMjA3KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGVhZGE3ZGQ2LCAweGNkZTBlYjFlKSwgWDY0V29yZF9jcmVhdGUoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSksIFg2NFdvcmRfY3JlYXRlKDB4MGE2MzdkYzUsIDB4YTJjODk4YTYpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUpLCBYNjRXb3JkX2NyZWF0ZSgweDFiNzEwYjM1LCAweDEzMWM0NzFiKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0KSwgWDY0V29yZF9jcmVhdGUoMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgzYzllYmUwYSwgMHgxNWM5YmViYyksIFg2NFdvcmRfY3JlYXRlKDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYpLCBYNjRXb3JkX2NyZWF0ZSgweDU5N2YyOTljLCAweGZjNjU3ZTJhKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDVmY2I2ZmFiLCAweDNhZDZmYWVjKSwgWDY0V29yZF9jcmVhdGUoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNylcblx0ICAgIF07XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdHNcblx0ICAgIHZhciBXID0gW107XG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICBXW2ldID0gWDY0V29yZF9jcmVhdGUoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS01MTIgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEE1MTIgPSBDX2FsZ28uU0hBNTEyID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBYNjRXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgpLCBuZXcgWDY0V29yZC5pbml0KDB4YmI2N2FlODUsIDB4ODRjYWE3M2IpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDNjNmVmMzcyLCAweGZlOTRmODJiKSwgbmV3IFg2NFdvcmQuaW5pdCgweGE1NGZmNTNhLCAweDVmMWQzNmYxKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSksIG5ldyBYNjRXb3JkLmluaXQoMHg5YjA1Njg4YywgMHgyYjNlNmMxZiksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIpLCBuZXcgWDY0V29yZC5pbml0KDB4NWJlMGNkMTksIDB4MTM3ZTIxNzkpXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgSDAgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgSDEgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgSDIgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgSDMgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgSDQgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgSDUgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgSDYgPSBIWzZdO1xuXHQgICAgICAgICAgICB2YXIgSDcgPSBIWzddO1xuXG5cdCAgICAgICAgICAgIHZhciBIMGggPSBIMC5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDBsID0gSDAubG93O1xuXHQgICAgICAgICAgICB2YXIgSDFoID0gSDEuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEgxbCA9IEgxLmxvdztcblx0ICAgICAgICAgICAgdmFyIEgyaCA9IEgyLmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIMmwgPSBIMi5sb3c7XG5cdCAgICAgICAgICAgIHZhciBIM2ggPSBIMy5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDNsID0gSDMubG93O1xuXHQgICAgICAgICAgICB2YXIgSDRoID0gSDQuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEg0bCA9IEg0Lmxvdztcblx0ICAgICAgICAgICAgdmFyIEg1aCA9IEg1LmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBINWwgPSBINS5sb3c7XG5cdCAgICAgICAgICAgIHZhciBINmggPSBINi5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDZsID0gSDYubG93O1xuXHQgICAgICAgICAgICB2YXIgSDdoID0gSDcuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEg3bCA9IEg3LmxvdztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYWggPSBIMGg7XG5cdCAgICAgICAgICAgIHZhciBhbCA9IEgwbDtcblx0ICAgICAgICAgICAgdmFyIGJoID0gSDFoO1xuXHQgICAgICAgICAgICB2YXIgYmwgPSBIMWw7XG5cdCAgICAgICAgICAgIHZhciBjaCA9IEgyaDtcblx0ICAgICAgICAgICAgdmFyIGNsID0gSDJsO1xuXHQgICAgICAgICAgICB2YXIgZGggPSBIM2g7XG5cdCAgICAgICAgICAgIHZhciBkbCA9IEgzbDtcblx0ICAgICAgICAgICAgdmFyIGVoID0gSDRoO1xuXHQgICAgICAgICAgICB2YXIgZWwgPSBINGw7XG5cdCAgICAgICAgICAgIHZhciBmaCA9IEg1aDtcblx0ICAgICAgICAgICAgdmFyIGZsID0gSDVsO1xuXHQgICAgICAgICAgICB2YXIgZ2ggPSBINmg7XG5cdCAgICAgICAgICAgIHZhciBnbCA9IEg2bDtcblx0ICAgICAgICAgICAgdmFyIGhoID0gSDdoO1xuXHQgICAgICAgICAgICB2YXIgaGwgPSBIN2w7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBXaSA9IFdbaV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIEV4dGVuZCBtZXNzYWdlXG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpaCA9IFdpLmhpZ2ggPSBNW29mZnNldCArIGkgKiAyXSAgICAgfCAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWwgPSBXaS5sb3cgID0gTVtvZmZzZXQgKyBpICogMiArIDFdIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gR2FtbWEwXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4aCA9IGdhbW1hMHguaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweGwgPSBnYW1tYTB4Lmxvdztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEwaCAgPSAoKGdhbW1hMHhoID4+PiAxKSB8IChnYW1tYTB4bCA8PCAzMSkpIF4gKChnYW1tYTB4aCA+Pj4gOCkgfCAoZ2FtbWEweGwgPDwgMjQpKSBeIChnYW1tYTB4aCA+Pj4gNyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMGwgID0gKChnYW1tYTB4bCA+Pj4gMSkgfCAoZ2FtbWEweGggPDwgMzEpKSBeICgoZ2FtbWEweGwgPj4+IDgpIHwgKGdhbW1hMHhoIDw8IDI0KSkgXiAoKGdhbW1hMHhsID4+PiA3KSB8IChnYW1tYTB4aCA8PCAyNSkpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gR2FtbWExXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggID0gV1tpIC0gMl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXhoID0gZ2FtbWExeC5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4bCA9IGdhbW1hMXgubG93O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTFoICA9ICgoZ2FtbWExeGggPj4+IDE5KSB8IChnYW1tYTF4bCA8PCAxMykpIF4gKChnYW1tYTF4aCA8PCAzKSB8IChnYW1tYTF4bCA+Pj4gMjkpKSBeIChnYW1tYTF4aCA+Pj4gNik7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMWwgID0gKChnYW1tYTF4bCA+Pj4gMTkpIHwgKGdhbW1hMXhoIDw8IDEzKSkgXiAoKGdhbW1hMXhsIDw8IDMpIHwgKGdhbW1hMXhoID4+PiAyOSkpIF4gKChnYW1tYTF4bCA+Pj4gNikgfCAoZ2FtbWExeGggPDwgMjYpKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTcgID0gV1tpIC0gN107XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpN2ggPSBXaTcuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2k3bCA9IFdpNy5sb3c7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2kxNiAgPSBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpMTZoID0gV2kxNi5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTE2bCA9IFdpMTYubG93O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpbCA9IGdhbW1hMGwgKyBXaTdsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWggPSBnYW1tYTBoICsgV2k3aCArICgoV2lsID4+PiAwKSA8IChnYW1tYTBsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2lsID0gV2lsICsgZ2FtbWExbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2loID0gV2loICsgZ2FtbWExaCArICgoV2lsID4+PiAwKSA8IChnYW1tYTFsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2lsID0gV2lsICsgV2kxNmw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpaCA9IFdpaCArIFdpMTZoICsgKChXaWwgPj4+IDApIDwgKFdpMTZsID4+PiAwKSA/IDEgOiAwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdpLmhpZ2ggPSBXaWg7XG5cdCAgICAgICAgICAgICAgICAgICAgV2kubG93ICA9IFdpbDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoaCAgPSAoZWggJiBmaCkgXiAofmVoICYgZ2gpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGNobCAgPSAoZWwgJiBmbCkgXiAofmVsICYgZ2wpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hamggPSAoYWggJiBiaCkgXiAoYWggJiBjaCkgXiAoYmggJiBjaCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqbCA9IChhbCAmIGJsKSBeIChhbCAmIGNsKSBeIChibCAmIGNsKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMGggPSAoKGFoID4+PiAyOCkgfCAoYWwgPDwgNCkpICBeICgoYWggPDwgMzApICB8IChhbCA+Pj4gMikpIF4gKChhaCA8PCAyNSkgfCAoYWwgPj4+IDcpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTBsID0gKChhbCA+Pj4gMjgpIHwgKGFoIDw8IDQpKSAgXiAoKGFsIDw8IDMwKSAgfCAoYWggPj4+IDIpKSBeICgoYWwgPDwgMjUpIHwgKGFoID4+PiA3KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExaCA9ICgoZWggPj4+IDE0KSB8IChlbCA8PCAxOCkpIF4gKChlaCA+Pj4gMTgpIHwgKGVsIDw8IDE0KSkgXiAoKGVoIDw8IDIzKSB8IChlbCA+Pj4gOSkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMWwgPSAoKGVsID4+PiAxNCkgfCAoZWggPDwgMTgpKSBeICgoZWwgPj4+IDE4KSB8IChlaCA8PCAxNCkpIF4gKChlbCA8PCAyMykgfCAoZWggPj4+IDkpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXVxuXHQgICAgICAgICAgICAgICAgdmFyIEtpICA9IEtbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgS2loID0gS2kuaGlnaDtcblx0ICAgICAgICAgICAgICAgIHZhciBLaWwgPSBLaS5sb3c7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MWwgPSBobCArIHNpZ21hMWw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFoID0gaGggKyBzaWdtYTFoICsgKCh0MWwgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWwgPSB0MWwgKyBjaGw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFoID0gdDFoICsgY2hoICsgKCh0MWwgPj4+IDApIDwgKGNobCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFsID0gdDFsICsgS2lsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxaCA9IHQxaCArIEtpaCArICgodDFsID4+PiAwKSA8IChLaWwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxbCA9IHQxbCArIFdpbDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWggPSB0MWggKyBXaWggKyAoKHQxbCA+Pj4gMCkgPCAoV2lsID4+PiAwKSA/IDEgOiAwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcblx0ICAgICAgICAgICAgICAgIHZhciB0MmwgPSBzaWdtYTBsICsgbWFqbDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MmggPSBzaWdtYTBoICsgbWFqaCArICgodDJsID4+PiAwKSA8IChzaWdtYTBsID4+PiAwKSA/IDEgOiAwKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgICAgICBoaCA9IGdoO1xuXHQgICAgICAgICAgICAgICAgaGwgPSBnbDtcblx0ICAgICAgICAgICAgICAgIGdoID0gZmg7XG5cdCAgICAgICAgICAgICAgICBnbCA9IGZsO1xuXHQgICAgICAgICAgICAgICAgZmggPSBlaDtcblx0ICAgICAgICAgICAgICAgIGZsID0gZWw7XG5cdCAgICAgICAgICAgICAgICBlbCA9IChkbCArIHQxbCkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZWggPSAoZGggKyB0MWggKyAoKGVsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGRoID0gY2g7XG5cdCAgICAgICAgICAgICAgICBkbCA9IGNsO1xuXHQgICAgICAgICAgICAgICAgY2ggPSBiaDtcblx0ICAgICAgICAgICAgICAgIGNsID0gYmw7XG5cdCAgICAgICAgICAgICAgICBiaCA9IGFoO1xuXHQgICAgICAgICAgICAgICAgYmwgPSBhbDtcblx0ICAgICAgICAgICAgICAgIGFsID0gKHQxbCArIHQybCkgfCAwO1xuXHQgICAgICAgICAgICAgICAgYWggPSAodDFoICsgdDJoICsgKChhbCA+Pj4gMCkgPCAodDFsID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSDBsID0gSDAubG93ICA9IChIMGwgKyBhbCk7XG5cdCAgICAgICAgICAgIEgwLmhpZ2ggPSAoSDBoICsgYWggKyAoKEgwbCA+Pj4gMCkgPCAoYWwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDFsID0gSDEubG93ICA9IChIMWwgKyBibCk7XG5cdCAgICAgICAgICAgIEgxLmhpZ2ggPSAoSDFoICsgYmggKyAoKEgxbCA+Pj4gMCkgPCAoYmwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDJsID0gSDIubG93ICA9IChIMmwgKyBjbCk7XG5cdCAgICAgICAgICAgIEgyLmhpZ2ggPSAoSDJoICsgY2ggKyAoKEgybCA+Pj4gMCkgPCAoY2wgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDNsID0gSDMubG93ICA9IChIM2wgKyBkbCk7XG5cdCAgICAgICAgICAgIEgzLmhpZ2ggPSAoSDNoICsgZGggKyAoKEgzbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDRsID0gSDQubG93ICA9IChINGwgKyBlbCk7XG5cdCAgICAgICAgICAgIEg0LmhpZ2ggPSAoSDRoICsgZWggKyAoKEg0bCA+Pj4gMCkgPCAoZWwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDVsID0gSDUubG93ICA9IChINWwgKyBmbCk7XG5cdCAgICAgICAgICAgIEg1LmhpZ2ggPSAoSDVoICsgZmggKyAoKEg1bCA+Pj4gMCkgPCAoZmwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDZsID0gSDYubG93ICA9IChINmwgKyBnbCk7XG5cdCAgICAgICAgICAgIEg2LmhpZ2ggPSAoSDZoICsgZ2ggKyAoKEg2bCA+Pj4gMCkgPCAoZ2wgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICAgICAgSDdsID0gSDcubG93ICA9IChIN2wgKyBobCk7XG5cdCAgICAgICAgICAgIEg3LmhpZ2ggPSAoSDdoICsgaGggKyAoKEg3bCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgMTI4KSA+Pj4gMTApIDw8IDUpICsgMzBdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgMTI4KSA+Pj4gMTApIDw8IDUpICsgMzFdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IGhhc2ggdG8gMzItYml0IHdvcmQgYXJyYXkgYmVmb3JlIHJldHVybmluZ1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2gudG9YMzIoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMDI0LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTUxMignbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBNTEyKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBNTEyID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBNTEyKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEE1MTIobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBNTEyID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTUxMik7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBNTEyO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2VuYy1iYXNlNjRcIiksIHJlcXVpcmUoXCIuL21kNVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9lbmMtYmFzZTY0XCIsIFwiLi9tZDVcIiwgXCIuL2V2cGtkZlwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFBlcm11dGVkIENob2ljZSAxIGNvbnN0YW50c1xuXHQgICAgdmFyIFBDMSA9IFtcblx0ICAgICAgICA1NywgNDksIDQxLCAzMywgMjUsIDE3LCA5LCAgMSxcblx0ICAgICAgICA1OCwgNTAsIDQyLCAzNCwgMjYsIDE4LCAxMCwgMixcblx0ICAgICAgICA1OSwgNTEsIDQzLCAzNSwgMjcsIDE5LCAxMSwgMyxcblx0ICAgICAgICA2MCwgNTIsIDQ0LCAzNiwgNjMsIDU1LCA0NywgMzksXG5cdCAgICAgICAgMzEsIDIzLCAxNSwgNywgIDYyLCA1NCwgNDYsIDM4LFxuXHQgICAgICAgIDMwLCAyMiwgMTQsIDYsICA2MSwgNTMsIDQ1LCAzNyxcblx0ICAgICAgICAyOSwgMjEsIDEzLCA1LCAgMjgsIDIwLCAxMiwgNFxuXHQgICAgXTtcblxuXHQgICAgLy8gUGVybXV0ZWQgQ2hvaWNlIDIgY29uc3RhbnRzXG5cdCAgICB2YXIgUEMyID0gW1xuXHQgICAgICAgIDE0LCAxNywgMTEsIDI0LCAxLCAgNSxcblx0ICAgICAgICAzLCAgMjgsIDE1LCA2LCAgMjEsIDEwLFxuXHQgICAgICAgIDIzLCAxOSwgMTIsIDQsICAyNiwgOCxcblx0ICAgICAgICAxNiwgNywgIDI3LCAyMCwgMTMsIDIsXG5cdCAgICAgICAgNDEsIDUyLCAzMSwgMzcsIDQ3LCA1NSxcblx0ICAgICAgICAzMCwgNDAsIDUxLCA0NSwgMzMsIDQ4LFxuXHQgICAgICAgIDQ0LCA0OSwgMzksIDU2LCAzNCwgNTMsXG5cdCAgICAgICAgNDYsIDQyLCA1MCwgMzYsIDI5LCAzMlxuXHQgICAgXTtcblxuXHQgICAgLy8gQ3VtdWxhdGl2ZSBiaXQgc2hpZnQgY29uc3RhbnRzXG5cdCAgICB2YXIgQklUX1NISUZUUyA9IFsxLCAgMiwgIDQsICA2LCAgOCwgIDEwLCAxMiwgMTQsIDE1LCAxNywgMTksIDIxLCAyMywgMjUsIDI3LCAyOF07XG5cblx0ICAgIC8vIFNCT1hlcyBhbmQgcm91bmQgcGVybXV0YXRpb24gY29uc3RhbnRzXG5cdCAgICB2YXIgU0JPWF9QID0gW1xuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDgwODIwMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwMDogMHg4MDAwLFxuXHQgICAgICAgICAgICAweDIwMDAwMDAwOiAweDgwODAwMixcblx0ICAgICAgICAgICAgMHgzMDAwMDAwMDogMHgyLFxuXHQgICAgICAgICAgICAweDQwMDAwMDAwOiAweDIwMCxcblx0ICAgICAgICAgICAgMHg1MDAwMDAwMDogMHg4MDgyMDIsXG5cdCAgICAgICAgICAgIDB4NjAwMDAwMDA6IDB4ODAwMjAyLFxuXHQgICAgICAgICAgICAweDcwMDAwMDAwOiAweDgwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMDogMHgyMDIsXG5cdCAgICAgICAgICAgIDB4OTAwMDAwMDA6IDB4ODAwMjAwLFxuXHQgICAgICAgICAgICAweGEwMDAwMDAwOiAweDgyMDAsXG5cdCAgICAgICAgICAgIDB4YjAwMDAwMDA6IDB4ODA4MDAwLFxuXHQgICAgICAgICAgICAweGMwMDAwMDAwOiAweDgwMDIsXG5cdCAgICAgICAgICAgIDB4ZDAwMDAwMDA6IDB4ODAwMDAyLFxuXHQgICAgICAgICAgICAweGUwMDAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZjAwMDAwMDA6IDB4ODIwMixcblx0ICAgICAgICAgICAgMHg4MDAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDA6IDB4ODA4MjAyLFxuXHQgICAgICAgICAgICAweDI4MDAwMDAwOiAweDgyMDIsXG5cdCAgICAgICAgICAgIDB4MzgwMDAwMDA6IDB4ODAwMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDAwMDogMHg4MDgyMDAsXG5cdCAgICAgICAgICAgIDB4NTgwMDAwMDA6IDB4MjAwLFxuXHQgICAgICAgICAgICAweDY4MDAwMDAwOiAweDgwODAwMixcblx0ICAgICAgICAgICAgMHg3ODAwMDAwMDogMHgyLFxuXHQgICAgICAgICAgICAweDg4MDAwMDAwOiAweDgwMDIwMCxcblx0ICAgICAgICAgICAgMHg5ODAwMDAwMDogMHg4MjAwLFxuXHQgICAgICAgICAgICAweGE4MDAwMDAwOiAweDgwODAwMCxcblx0ICAgICAgICAgICAgMHhiODAwMDAwMDogMHg4MDAyMDIsXG5cdCAgICAgICAgICAgIDB4YzgwMDAwMDA6IDB4ODAwMDAyLFxuXHQgICAgICAgICAgICAweGQ4MDAwMDAwOiAweDgwMDIsXG5cdCAgICAgICAgICAgIDB4ZTgwMDAwMDA6IDB4MjAyLFxuXHQgICAgICAgICAgICAweGY4MDAwMDAwOiAweDgwMDAwMCxcblx0ICAgICAgICAgICAgMHgxOiAweDgwMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDE6IDB4Mixcblx0ICAgICAgICAgICAgMHgyMDAwMDAwMTogMHg4MDgyMDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDAwMDE6IDB4ODAwMDAwLFxuXHQgICAgICAgICAgICAweDQwMDAwMDAxOiAweDgwODAwMixcblx0ICAgICAgICAgICAgMHg1MDAwMDAwMTogMHg4MjAwLFxuXHQgICAgICAgICAgICAweDYwMDAwMDAxOiAweDIwMCxcblx0ICAgICAgICAgICAgMHg3MDAwMDAwMTogMHg4MDAyMDIsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDE6IDB4ODA4MjAyLFxuXHQgICAgICAgICAgICAweDkwMDAwMDAxOiAweDgwODAwMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDAwMTogMHg4MDAwMDIsXG5cdCAgICAgICAgICAgIDB4YjAwMDAwMDE6IDB4ODIwMixcblx0ICAgICAgICAgICAgMHhjMDAwMDAwMTogMHgyMDIsXG5cdCAgICAgICAgICAgIDB4ZDAwMDAwMDE6IDB4ODAwMjAwLFxuXHQgICAgICAgICAgICAweGUwMDAwMDAxOiAweDgwMDIsXG5cdCAgICAgICAgICAgIDB4ZjAwMDAwMDE6IDB4MCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxOiAweDgwODIwMixcblx0ICAgICAgICAgICAgMHgxODAwMDAwMTogMHg4MDgwMDAsXG5cdCAgICAgICAgICAgIDB4MjgwMDAwMDE6IDB4ODAwMDAwLFxuXHQgICAgICAgICAgICAweDM4MDAwMDAxOiAweDIwMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDAwMTogMHg4MDAwLFxuXHQgICAgICAgICAgICAweDU4MDAwMDAxOiAweDgwMDAwMixcblx0ICAgICAgICAgICAgMHg2ODAwMDAwMTogMHgyLFxuXHQgICAgICAgICAgICAweDc4MDAwMDAxOiAweDgyMDIsXG5cdCAgICAgICAgICAgIDB4ODgwMDAwMDE6IDB4ODAwMixcblx0ICAgICAgICAgICAgMHg5ODAwMDAwMTogMHg4MDAyMDIsXG5cdCAgICAgICAgICAgIDB4YTgwMDAwMDE6IDB4MjAyLFxuXHQgICAgICAgICAgICAweGI4MDAwMDAxOiAweDgwODIwMCxcblx0ICAgICAgICAgICAgMHhjODAwMDAwMTogMHg4MDAyMDAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDAwMDE6IDB4MCxcblx0ICAgICAgICAgICAgMHhlODAwMDAwMTogMHg4MjAwLFxuXHQgICAgICAgICAgICAweGY4MDAwMDAxOiAweDgwODAwMlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4NDAwODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDogMHg0MDAwLFxuXHQgICAgICAgICAgICAweDIwMDAwMDA6IDB4ODAwMDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDAwMDogMHg0MDA4MDAxMCxcblx0ICAgICAgICAgICAgMHg0MDAwMDAwOiAweDQwMDAwMDEwLFxuXHQgICAgICAgICAgICAweDUwMDAwMDA6IDB4NDAwODQwMDAsXG5cdCAgICAgICAgICAgIDB4NjAwMDAwMDogMHg0MDAwNDAwMCxcblx0ICAgICAgICAgICAgMHg3MDAwMDAwOiAweDEwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA6IDB4ODQwMDAsXG5cdCAgICAgICAgICAgIDB4OTAwMDAwMDogMHg0MDAwNDAxMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDAwOiAweDQwMDAwMDAwLFxuXHQgICAgICAgICAgICAweGIwMDAwMDA6IDB4ODQwMTAsXG5cdCAgICAgICAgICAgIDB4YzAwMDAwMDogMHg4MDAxMCxcblx0ICAgICAgICAgICAgMHhkMDAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDAwMDogMHg0MDEwLFxuXHQgICAgICAgICAgICAweGYwMDAwMDA6IDB4NDAwODAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwOiAweDQwMDA0MDAwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDA6IDB4ODQwMTAsXG5cdCAgICAgICAgICAgIDB4MjgwMDAwMDogMHgxMCxcblx0ICAgICAgICAgICAgMHgzODAwMDAwOiAweDQwMDA0MDEwLFxuXHQgICAgICAgICAgICAweDQ4MDAwMDA6IDB4NDAwODQwMTAsXG5cdCAgICAgICAgICAgIDB4NTgwMDAwMDogMHg0MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg2ODAwMDAwOiAweDgwMDAwLFxuXHQgICAgICAgICAgICAweDc4MDAwMDA6IDB4NDAwODAwMTAsXG5cdCAgICAgICAgICAgIDB4ODgwMDAwMDogMHg4MDAxMCxcblx0ICAgICAgICAgICAgMHg5ODAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDAwMDogMHg0MDAwLFxuXHQgICAgICAgICAgICAweGI4MDAwMDA6IDB4NDAwODAwMDAsXG5cdCAgICAgICAgICAgIDB4YzgwMDAwMDogMHg0MDAwMDAxMCxcblx0ICAgICAgICAgICAgMHhkODAwMDAwOiAweDg0MDAwLFxuXHQgICAgICAgICAgICAweGU4MDAwMDA6IDB4NDAwODQwMDAsXG5cdCAgICAgICAgICAgIDB4ZjgwMDAwMDogMHg0MDEwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDAwMDA6IDB4NDAwODAwMTAsXG5cdCAgICAgICAgICAgIDB4MTIwMDAwMDA6IDB4NDAwMDQwMTAsXG5cdCAgICAgICAgICAgIDB4MTMwMDAwMDA6IDB4NDAwODQwMDAsXG5cdCAgICAgICAgICAgIDB4MTQwMDAwMDA6IDB4NDAwODAwMDAsXG5cdCAgICAgICAgICAgIDB4MTUwMDAwMDA6IDB4MTAsXG5cdCAgICAgICAgICAgIDB4MTYwMDAwMDA6IDB4ODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTcwMDAwMDA6IDB4NDAwMCxcblx0ICAgICAgICAgICAgMHgxODAwMDAwMDogMHg0MDEwLFxuXHQgICAgICAgICAgICAweDE5MDAwMDAwOiAweDgwMDAwLFxuXHQgICAgICAgICAgICAweDFhMDAwMDAwOiAweDgwMDEwLFxuXHQgICAgICAgICAgICAweDFiMDAwMDAwOiAweDQwMDAwMDEwLFxuXHQgICAgICAgICAgICAweDFjMDAwMDAwOiAweDg0MDAwLFxuXHQgICAgICAgICAgICAweDFkMDAwMDAwOiAweDQwMDA0MDAwLFxuXHQgICAgICAgICAgICAweDFlMDAwMDAwOiAweDQwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFmMDAwMDAwOiAweDQwMDg0MDEwLFxuXHQgICAgICAgICAgICAweDEwODAwMDAwOiAweDg0MDEwLFxuXHQgICAgICAgICAgICAweDExODAwMDAwOiAweDgwMDAwLFxuXHQgICAgICAgICAgICAweDEyODAwMDAwOiAweDQwMDgwMDAwLFxuXHQgICAgICAgICAgICAweDEzODAwMDAwOiAweDQwMDAsXG5cdCAgICAgICAgICAgIDB4MTQ4MDAwMDA6IDB4NDAwMDQwMDAsXG5cdCAgICAgICAgICAgIDB4MTU4MDAwMDA6IDB4NDAwODQwMTAsXG5cdCAgICAgICAgICAgIDB4MTY4MDAwMDA6IDB4MTAsXG5cdCAgICAgICAgICAgIDB4MTc4MDAwMDA6IDB4NDAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTg4MDAwMDA6IDB4NDAwODQwMDAsXG5cdCAgICAgICAgICAgIDB4MTk4MDAwMDA6IDB4NDAwMDAwMTAsXG5cdCAgICAgICAgICAgIDB4MWE4MDAwMDA6IDB4NDAwMDQwMTAsXG5cdCAgICAgICAgICAgIDB4MWI4MDAwMDA6IDB4ODAwMTAsXG5cdCAgICAgICAgICAgIDB4MWM4MDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxZDgwMDAwMDogMHg0MDEwLFxuXHQgICAgICAgICAgICAweDFlODAwMDAwOiAweDQwMDgwMDEwLFxuXHQgICAgICAgICAgICAweDFmODAwMDAwOiAweDg0MDAwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHgxMDQsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDAwOiAweDQwMDAxMDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDAwOiAweDEwMTA0LFxuXHQgICAgICAgICAgICAweDQwMDAwMDogMHgxMDAwNCxcblx0ICAgICAgICAgICAgMHg1MDAwMDA6IDB4NDAwMDAwNCxcblx0ICAgICAgICAgICAgMHg2MDAwMDA6IDB4NDAxMDEwNCxcblx0ICAgICAgICAgICAgMHg3MDAwMDA6IDB4NDAxMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDA6IDB4NDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg5MDAwMDA6IDB4NDAxMDEwMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDA6IDB4MTAxMDAsXG5cdCAgICAgICAgICAgIDB4YjAwMDAwOiAweDQwMTAwMDQsXG5cdCAgICAgICAgICAgIDB4YzAwMDAwOiAweDQwMDAxMDQsXG5cdCAgICAgICAgICAgIDB4ZDAwMDAwOiAweDEwMDAwLFxuXHQgICAgICAgICAgICAweGUwMDAwMDogMHg0LFxuXHQgICAgICAgICAgICAweGYwMDAwMDogMHgxMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDA6IDB4NDAxMDEwMCxcblx0ICAgICAgICAgICAgMHgxODAwMDA6IDB4NDAxMDAwNCxcblx0ICAgICAgICAgICAgMHgyODAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgzODAwMDA6IDB4NDAwMDEwMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDA6IDB4NDAwMDAwNCxcblx0ICAgICAgICAgICAgMHg1ODAwMDA6IDB4MTAwMDAsXG5cdCAgICAgICAgICAgIDB4NjgwMDAwOiAweDEwMDA0LFxuXHQgICAgICAgICAgICAweDc4MDAwMDogMHgxMDQsXG5cdCAgICAgICAgICAgIDB4ODgwMDAwOiAweDQsXG5cdCAgICAgICAgICAgIDB4OTgwMDAwOiAweDEwMCxcblx0ICAgICAgICAgICAgMHhhODAwMDA6IDB4NDAxMDAwMCxcblx0ICAgICAgICAgICAgMHhiODAwMDA6IDB4MTAxMDQsXG5cdCAgICAgICAgICAgIDB4YzgwMDAwOiAweDEwMTAwLFxuXHQgICAgICAgICAgICAweGQ4MDAwMDogMHg0MDAwMTA0LFxuXHQgICAgICAgICAgICAweGU4MDAwMDogMHg0MDEwMTA0LFxuXHQgICAgICAgICAgICAweGY4MDAwMDogMHg0MDAwMDAwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDA6IDB4NDAxMDEwMCxcblx0ICAgICAgICAgICAgMHgxMTAwMDAwOiAweDEwMDA0LFxuXHQgICAgICAgICAgICAweDEyMDAwMDA6IDB4MTAwMDAsXG5cdCAgICAgICAgICAgIDB4MTMwMDAwMDogMHg0MDAwMTAwLFxuXHQgICAgICAgICAgICAweDE0MDAwMDA6IDB4MTAwLFxuXHQgICAgICAgICAgICAweDE1MDAwMDA6IDB4NDAxMDEwNCxcblx0ICAgICAgICAgICAgMHgxNjAwMDAwOiAweDQwMDAwMDQsXG5cdCAgICAgICAgICAgIDB4MTcwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDA6IDB4NDAwMDEwNCxcblx0ICAgICAgICAgICAgMHgxOTAwMDAwOiAweDQwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDAwMDogMHg0LFxuXHQgICAgICAgICAgICAweDFiMDAwMDA6IDB4MTAxMDAsXG5cdCAgICAgICAgICAgIDB4MWMwMDAwMDogMHg0MDEwMDAwLFxuXHQgICAgICAgICAgICAweDFkMDAwMDA6IDB4MTA0LFxuXHQgICAgICAgICAgICAweDFlMDAwMDA6IDB4MTAxMDQsXG5cdCAgICAgICAgICAgIDB4MWYwMDAwMDogMHg0MDEwMDA0LFxuXHQgICAgICAgICAgICAweDEwODAwMDA6IDB4NDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMTgwMDAwOiAweDEwNCxcblx0ICAgICAgICAgICAgMHgxMjgwMDAwOiAweDQwMTAxMDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDE0ODAwMDA6IDB4MTAwMDQsXG5cdCAgICAgICAgICAgIDB4MTU4MDAwMDogMHg0MDAwMTAwLFxuXHQgICAgICAgICAgICAweDE2ODAwMDA6IDB4MTAwLFxuXHQgICAgICAgICAgICAweDE3ODAwMDA6IDB4NDAxMDAwNCxcblx0ICAgICAgICAgICAgMHgxODgwMDAwOiAweDEwMDAwLFxuXHQgICAgICAgICAgICAweDE5ODAwMDA6IDB4NDAxMDEwNCxcblx0ICAgICAgICAgICAgMHgxYTgwMDAwOiAweDEwMTA0LFxuXHQgICAgICAgICAgICAweDFiODAwMDA6IDB4NDAwMDAwNCxcblx0ICAgICAgICAgICAgMHgxYzgwMDAwOiAweDQwMDAxMDQsXG5cdCAgICAgICAgICAgIDB4MWQ4MDAwMDogMHg0MDEwMDAwLFxuXHQgICAgICAgICAgICAweDFlODAwMDA6IDB4NCxcblx0ICAgICAgICAgICAgMHgxZjgwMDAwOiAweDEwMTAwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg4MDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDogMHg4MDAwMTA0MCxcblx0ICAgICAgICAgICAgMHgyMDAwMDogMHg0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDA6IDB4ODA0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHg1MDAwMDogMHg0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4NjAwMDA6IDB4ODAwMDAwNDAsXG5cdCAgICAgICAgICAgIDB4NzAwMDA6IDB4NDAwMDQwLFxuXHQgICAgICAgICAgICAweDgwMDAwOiAweDgwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDkwMDAwOiAweDQwMDAwMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDogMHg0MCxcblx0ICAgICAgICAgICAgMHhiMDAwMDogMHg4MDAwMTAwMCxcblx0ICAgICAgICAgICAgMHhjMDAwMDogMHg4MDQwMDA0MCxcblx0ICAgICAgICAgICAgMHhkMDAwMDogMHgxMDQwLFxuXHQgICAgICAgICAgICAweGUwMDAwOiAweDEwMDAsXG5cdCAgICAgICAgICAgIDB4ZjAwMDA6IDB4ODA0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDogMHg4MDAwMTA0MCxcblx0ICAgICAgICAgICAgMHgxODAwMDogMHg0MCxcblx0ICAgICAgICAgICAgMHgyODAwMDogMHg4MDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgzODAwMDogMHg4MDAwMTAwMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDogMHg0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4NTgwMDA6IDB4ODA0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4NjgwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHg3ODAwMDogMHg4MDQwMDAwMCxcblx0ICAgICAgICAgICAgMHg4ODAwMDogMHgxMDAwLFxuXHQgICAgICAgICAgICAweDk4MDAwOiAweDgwNDAxMDAwLFxuXHQgICAgICAgICAgICAweGE4MDAwOiAweDQwMDAwMCxcblx0ICAgICAgICAgICAgMHhiODAwMDogMHgxMDQwLFxuXHQgICAgICAgICAgICAweGM4MDAwOiAweDgwMDAwMDAwLFxuXHQgICAgICAgICAgICAweGQ4MDAwOiAweDQwMDA0MCxcblx0ICAgICAgICAgICAgMHhlODAwMDogMHg0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4ZjgwMDA6IDB4ODAwMDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwOiAweDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgxMTAwMDA6IDB4NDAxMDAwLFxuXHQgICAgICAgICAgICAweDEyMDAwMDogMHg4MDAwMDA0MCxcblx0ICAgICAgICAgICAgMHgxMzAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxNDAwMDA6IDB4MTA0MCxcblx0ICAgICAgICAgICAgMHgxNTAwMDA6IDB4ODA0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTYwMDAwOiAweDgwNDAxMDAwLFxuXHQgICAgICAgICAgICAweDE3MDAwMDogMHg4MDAwMTA0MCxcblx0ICAgICAgICAgICAgMHgxODAwMDA6IDB4ODA0MDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTkwMDAwOiAweDgwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFhMDAwMDogMHg4MDQwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYjAwMDA6IDB4NDAxMDQwLFxuXHQgICAgICAgICAgICAweDFjMDAwMDogMHg4MDAwMTAwMCxcblx0ICAgICAgICAgICAgMHgxZDAwMDA6IDB4NDAwMDAwLFxuXHQgICAgICAgICAgICAweDFlMDAwMDogMHg0MCxcblx0ICAgICAgICAgICAgMHgxZjAwMDA6IDB4MTAwMCxcblx0ICAgICAgICAgICAgMHgxMDgwMDA6IDB4ODA0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTE4MDAwOiAweDgwNDAxMDQwLFxuXHQgICAgICAgICAgICAweDEyODAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDEzODAwMDogMHg0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTQ4MDAwOiAweDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgxNTgwMDA6IDB4ODAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTY4MDAwOiAweDgwMDAxMDQwLFxuXHQgICAgICAgICAgICAweDE3ODAwMDogMHg0MCxcblx0ICAgICAgICAgICAgMHgxODgwMDA6IDB4ODAwMDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTk4MDAwOiAweDEwMDAsXG5cdCAgICAgICAgICAgIDB4MWE4MDAwOiAweDgwMDAxMDAwLFxuXHQgICAgICAgICAgICAweDFiODAwMDogMHg4MDQwMDA0MCxcblx0ICAgICAgICAgICAgMHgxYzgwMDA6IDB4MTA0MCxcblx0ICAgICAgICAgICAgMHgxZDgwMDA6IDB4ODA0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MWU4MDAwOiAweDQwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZjgwMDA6IDB4NDAxMDQwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg4MCxcblx0ICAgICAgICAgICAgMHgxMDAwOiAweDEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDogMHg0MDAwMCxcblx0ICAgICAgICAgICAgMHgzMDAwOiAweDIwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDQwMDA6IDB4MjAwNDAwODAsXG5cdCAgICAgICAgICAgIDB4NTAwMDogMHgxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDYwMDA6IDB4MjEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4NzAwMDogMHg0MDA4MCxcblx0ICAgICAgICAgICAgMHg4MDAwOiAweDEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4OTAwMDogMHgyMDA0MDAwMCxcblx0ICAgICAgICAgICAgMHhhMDAwOiAweDIwMDAwMDgwLFxuXHQgICAgICAgICAgICAweGIwMDA6IDB4MjEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4YzAwMDogMHgyMTA0MDAwMCxcblx0ICAgICAgICAgICAgMHhkMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZTAwMDogMHgxMDQwMDgwLFxuXHQgICAgICAgICAgICAweGYwMDA6IDB4MjEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwOiAweDEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTgwMDogMHgyMTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgyODAwOiAweDgwLFxuXHQgICAgICAgICAgICAweDM4MDA6IDB4MTA0MDAwMCxcblx0ICAgICAgICAgICAgMHg0ODAwOiAweDQwMDAwLFxuXHQgICAgICAgICAgICAweDU4MDA6IDB4MjAwNDAwODAsXG5cdCAgICAgICAgICAgIDB4NjgwMDogMHgyMTA0MDAwMCxcblx0ICAgICAgICAgICAgMHg3ODAwOiAweDIwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDg4MDA6IDB4MjAwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4OTgwMDogMHgwLFxuXHQgICAgICAgICAgICAweGE4MDA6IDB4MjEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4YjgwMDogMHgxMDAwMDgwLFxuXHQgICAgICAgICAgICAweGM4MDA6IDB4MjAwMDAwODAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDogMHgyMTAwMDAwMCxcblx0ICAgICAgICAgICAgMHhlODAwOiAweDEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZjgwMDogMHg0MDA4MCxcblx0ICAgICAgICAgICAgMHgxMDAwMDogMHg0MDAwMCxcblx0ICAgICAgICAgICAgMHgxMTAwMDogMHg4MCxcblx0ICAgICAgICAgICAgMHgxMjAwMDogMHgyMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMzAwMDogMHgyMTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxNDAwMDogMHgxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDE1MDAwOiAweDIxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDE2MDAwOiAweDIwMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE3MDAwOiAweDEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDA6IDB4MjEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTkwMDA6IDB4MjEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDA6IDB4MTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxYjAwMDogMHgyMDA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxYzAwMDogMHg0MDA4MCxcblx0ICAgICAgICAgICAgMHgxZDAwMDogMHgyMDAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxZTAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDFmMDAwOiAweDEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTA4MDA6IDB4MjEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MTE4MDA6IDB4MTAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMjgwMDogMHgxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDEzODAwOiAweDIwMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE0ODAwOiAweDIwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE1ODAwOiAweDEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MTY4MDA6IDB4ODAsXG5cdCAgICAgICAgICAgIDB4MTc4MDA6IDB4MjEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTg4MDA6IDB4NDAwODAsXG5cdCAgICAgICAgICAgIDB4MTk4MDA6IDB4MjEwNDAwODAsXG5cdCAgICAgICAgICAgIDB4MWE4MDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxYjgwMDogMHgyMTAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYzgwMDogMHgxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDFkODAwOiAweDQwMDAwLFxuXHQgICAgICAgICAgICAweDFlODAwOiAweDIwMDQwMDAwLFxuXHQgICAgICAgICAgICAweDFmODAwOiAweDIwMDAwMDgwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHgxMDAwMDAwOCxcblx0ICAgICAgICAgICAgMHgxMDA6IDB4MjAwMCxcblx0ICAgICAgICAgICAgMHgyMDA6IDB4MTAyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MzAwOiAweDEwMjAyMDA4LFxuXHQgICAgICAgICAgICAweDQwMDogMHgxMDAwMjAwMCxcblx0ICAgICAgICAgICAgMHg1MDA6IDB4MjAwMDAwLFxuXHQgICAgICAgICAgICAweDYwMDogMHgyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4NzAwOiAweDEwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDogMHgwLFxuXHQgICAgICAgICAgICAweDkwMDogMHgxMDAwMjAwOCxcblx0ICAgICAgICAgICAgMHhhMDA6IDB4MjAyMDAwLFxuXHQgICAgICAgICAgICAweGIwMDogMHg4LFxuXHQgICAgICAgICAgICAweGMwMDogMHgxMDIwMDAwOCxcblx0ICAgICAgICAgICAgMHhkMDA6IDB4MjAyMDA4LFxuXHQgICAgICAgICAgICAweGUwMDogMHgyMDA4LFxuXHQgICAgICAgICAgICAweGYwMDogMHgxMDIwMjAwMCxcblx0ICAgICAgICAgICAgMHg4MDogMHgxMDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxODA6IDB4MTAyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MjgwOiAweDgsXG5cdCAgICAgICAgICAgIDB4MzgwOiAweDIwMDAwMCxcblx0ICAgICAgICAgICAgMHg0ODA6IDB4MjAyMDA4LFxuXHQgICAgICAgICAgICAweDU4MDogMHgxMDAwMDAwOCxcblx0ICAgICAgICAgICAgMHg2ODA6IDB4MTAwMDIwMDAsXG5cdCAgICAgICAgICAgIDB4NzgwOiAweDIwMDgsXG5cdCAgICAgICAgICAgIDB4ODgwOiAweDIwMDAwOCxcblx0ICAgICAgICAgICAgMHg5ODA6IDB4MjAwMCxcblx0ICAgICAgICAgICAgMHhhODA6IDB4MTAwMDIwMDgsXG5cdCAgICAgICAgICAgIDB4YjgwOiAweDEwMjAwMDA4LFxuXHQgICAgICAgICAgICAweGM4MDogMHgwLFxuXHQgICAgICAgICAgICAweGQ4MDogMHgxMDIwMjAwMCxcblx0ICAgICAgICAgICAgMHhlODA6IDB4MjAyMDAwLFxuXHQgICAgICAgICAgICAweGY4MDogMHgxMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMDAwOiAweDEwMDAyMDAwLFxuXHQgICAgICAgICAgICAweDExMDA6IDB4MTAyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTIwMDogMHgxMDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgxMzAwOiAweDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTQwMDogMHgyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTUwMDogMHgxMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNjAwOiAweDEwMDAwMDA4LFxuXHQgICAgICAgICAgICAweDE3MDA6IDB4MjAyMDAwLFxuXHQgICAgICAgICAgICAweDE4MDA6IDB4MjAyMDA4LFxuXHQgICAgICAgICAgICAweDE5MDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxYTAwOiAweDgsXG5cdCAgICAgICAgICAgIDB4MWIwMDogMHgxMDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYzAwOiAweDIwMDAsXG5cdCAgICAgICAgICAgIDB4MWQwMDogMHgxMDAwMjAwOCxcblx0ICAgICAgICAgICAgMHgxZTAwOiAweDEwMjAyMDAwLFxuXHQgICAgICAgICAgICAweDFmMDA6IDB4MjAwMDA4LFxuXHQgICAgICAgICAgICAweDEwODA6IDB4OCxcblx0ICAgICAgICAgICAgMHgxMTgwOiAweDIwMjAwMCxcblx0ICAgICAgICAgICAgMHgxMjgwOiAweDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMzgwOiAweDEwMDAwMDA4LFxuXHQgICAgICAgICAgICAweDE0ODA6IDB4MTAwMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTU4MDogMHgyMDA4LFxuXHQgICAgICAgICAgICAweDE2ODA6IDB4MTAyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTc4MDogMHgxMDIwMDAwMCxcblx0ICAgICAgICAgICAgMHgxODgwOiAweDEwMjAyMDAwLFxuXHQgICAgICAgICAgICAweDE5ODA6IDB4MTAyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MWE4MDogMHgyMDAwLFxuXHQgICAgICAgICAgICAweDFiODA6IDB4MjAyMDA4LFxuXHQgICAgICAgICAgICAweDFjODA6IDB4MjAwMDA4LFxuXHQgICAgICAgICAgICAweDFkODA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxZTgwOiAweDEwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFmODA6IDB4MTAwMDIwMDhcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMDogMHgyMDAwNDAxLFxuXHQgICAgICAgICAgICAweDIwOiAweDQwMCxcblx0ICAgICAgICAgICAgMHgzMDogMHgxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4NDA6IDB4MjEwMDQwMSxcblx0ICAgICAgICAgICAgMHg1MDogMHgwLFxuXHQgICAgICAgICAgICAweDYwOiAweDEsXG5cdCAgICAgICAgICAgIDB4NzA6IDB4MjEwMDAwMSxcblx0ICAgICAgICAgICAgMHg4MDogMHgyMDAwNDAwLFxuXHQgICAgICAgICAgICAweDkwOiAweDEwMDAwMSxcblx0ICAgICAgICAgICAgMHhhMDogMHgyMDAwMDAxLFxuXHQgICAgICAgICAgICAweGIwOiAweDIxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4YzA6IDB4MjEwMDAwMCxcblx0ICAgICAgICAgICAgMHhkMDogMHg0MDEsXG5cdCAgICAgICAgICAgIDB4ZTA6IDB4MTAwNDAwLFxuXHQgICAgICAgICAgICAweGYwOiAweDIwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODogMHgyMTAwMDAxLFxuXHQgICAgICAgICAgICAweDE4OiAweDAsXG5cdCAgICAgICAgICAgIDB4Mjg6IDB4MjAwMDQwMSxcblx0ICAgICAgICAgICAgMHgzODogMHgyMTAwNDAwLFxuXHQgICAgICAgICAgICAweDQ4OiAweDEwMDAwMCxcblx0ICAgICAgICAgICAgMHg1ODogMHgyMDAwMDAxLFxuXHQgICAgICAgICAgICAweDY4OiAweDIwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4Nzg6IDB4NDAxLFxuXHQgICAgICAgICAgICAweDg4OiAweDEwMDQwMSxcblx0ICAgICAgICAgICAgMHg5ODogMHgyMDAwNDAwLFxuXHQgICAgICAgICAgICAweGE4OiAweDIxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4Yjg6IDB4MTAwMDAxLFxuXHQgICAgICAgICAgICAweGM4OiAweDQwMCxcblx0ICAgICAgICAgICAgMHhkODogMHgyMTAwNDAxLFxuXHQgICAgICAgICAgICAweGU4OiAweDEsXG5cdCAgICAgICAgICAgIDB4Zjg6IDB4MTAwNDAwLFxuXHQgICAgICAgICAgICAweDEwMDogMHgyMDAwMDAwLFxuXHQgICAgICAgICAgICAweDExMDogMHgxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTIwOiAweDIwMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MTMwOiAweDIxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTQwOiAweDEwMDAwMSxcblx0ICAgICAgICAgICAgMHgxNTA6IDB4MjAwMDQwMCxcblx0ICAgICAgICAgICAgMHgxNjA6IDB4MjEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxNzA6IDB4MTAwNDAxLFxuXHQgICAgICAgICAgICAweDE4MDogMHg0MDEsXG5cdCAgICAgICAgICAgIDB4MTkwOiAweDIxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MWEwOiAweDEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxYjA6IDB4MSxcblx0ICAgICAgICAgICAgMHgxYzA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxZDA6IDB4MjEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZTA6IDB4MjAwMDAwMSxcblx0ICAgICAgICAgICAgMHgxZjA6IDB4NDAwLFxuXHQgICAgICAgICAgICAweDEwODogMHgxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTE4OiAweDIwMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MTI4OiAweDIxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTM4OiAweDEsXG5cdCAgICAgICAgICAgIDB4MTQ4OiAweDIwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTU4OiAweDEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNjg6IDB4NDAxLFxuXHQgICAgICAgICAgICAweDE3ODogMHgyMTAwNDAwLFxuXHQgICAgICAgICAgICAweDE4ODogMHgyMDAwMDAxLFxuXHQgICAgICAgICAgICAweDE5ODogMHgyMTAwMDAwLFxuXHQgICAgICAgICAgICAweDFhODogMHgwLFxuXHQgICAgICAgICAgICAweDFiODogMHgyMTAwNDAxLFxuXHQgICAgICAgICAgICAweDFjODogMHgxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4MWQ4OiAweDQwMCxcblx0ICAgICAgICAgICAgMHgxZTg6IDB4MjAwMDQwMCxcblx0ICAgICAgICAgICAgMHgxZjg6IDB4MTAwMDAxXG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg4MDAwODIwLFxuXHQgICAgICAgICAgICAweDE6IDB4MjAwMDAsXG5cdCAgICAgICAgICAgIDB4MjogMHg4MDAwMDAwLFxuXHQgICAgICAgICAgICAweDM6IDB4MjAsXG5cdCAgICAgICAgICAgIDB4NDogMHgyMDAyMCxcblx0ICAgICAgICAgICAgMHg1OiAweDgwMjA4MjAsXG5cdCAgICAgICAgICAgIDB4NjogMHg4MDIwODAwLFxuXHQgICAgICAgICAgICAweDc6IDB4ODAwLFxuXHQgICAgICAgICAgICAweDg6IDB4ODAyMDAwMCxcblx0ICAgICAgICAgICAgMHg5OiAweDgwMDA4MDAsXG5cdCAgICAgICAgICAgIDB4YTogMHgyMDgwMCxcblx0ICAgICAgICAgICAgMHhiOiAweDgwMjAwMjAsXG5cdCAgICAgICAgICAgIDB4YzogMHg4MjAsXG5cdCAgICAgICAgICAgIDB4ZDogMHgwLFxuXHQgICAgICAgICAgICAweGU6IDB4ODAwMDAyMCxcblx0ICAgICAgICAgICAgMHhmOiAweDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAwOiAweDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMTogMHg4MDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAyOiAweDgwMDA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDM6IDB4ODAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwNDogMHg4MDIwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA1OiAweDIwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA2OiAweDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA3OiAweDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA4OiAweDgwMDAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDk6IDB4ODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBhOiAweDIwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBiOiAweDgwMjA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGM6IDB4MCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwZDogMHg4MDIwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBlOiAweDgwMDA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGY6IDB4MjAwMDAsXG5cdCAgICAgICAgICAgIDB4MTA6IDB4MjA4MjAsXG5cdCAgICAgICAgICAgIDB4MTE6IDB4ODAyMDgwMCxcblx0ICAgICAgICAgICAgMHgxMjogMHgyMCxcblx0ICAgICAgICAgICAgMHgxMzogMHg4MDAsXG5cdCAgICAgICAgICAgIDB4MTQ6IDB4ODAwMDgwMCxcblx0ICAgICAgICAgICAgMHgxNTogMHg4MDAwMDIwLFxuXHQgICAgICAgICAgICAweDE2OiAweDgwMjAwMjAsXG5cdCAgICAgICAgICAgIDB4MTc6IDB4MjAwMDAsXG5cdCAgICAgICAgICAgIDB4MTg6IDB4MCxcblx0ICAgICAgICAgICAgMHgxOTogMHgyMDAyMCxcblx0ICAgICAgICAgICAgMHgxYTogMHg4MDIwMDAwLFxuXHQgICAgICAgICAgICAweDFiOiAweDgwMDA4MjAsXG5cdCAgICAgICAgICAgIDB4MWM6IDB4ODAyMDgyMCxcblx0ICAgICAgICAgICAgMHgxZDogMHgyMDgwMCxcblx0ICAgICAgICAgICAgMHgxZTogMHg4MjAsXG5cdCAgICAgICAgICAgIDB4MWY6IDB4ODAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxMDogMHgyMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxMTogMHg4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTI6IDB4ODAyMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxMzogMHgyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxNDogMHgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxNTogMHg4MDIwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE2OiAweDgwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTc6IDB4ODAwMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxODogMHg4MDIwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE5OiAweDgwMDAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWE6IDB4ODAwMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxYjogMHgwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFjOiAweDIwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFkOiAweDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxZTogMHgyMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxZjogMHg4MDIwODAwXG5cdCAgICAgICAgfVxuXHQgICAgXTtcblxuXHQgICAgLy8gTWFza3MgdGhhdCBzZWxlY3QgdGhlIFNCT1ggaW5wdXRcblx0ICAgIHZhciBTQk9YX01BU0sgPSBbXG5cdCAgICAgICAgMHhmODAwMDAwMSwgMHgxZjgwMDAwMCwgMHgwMWY4MDAwMCwgMHgwMDFmODAwMCxcblx0ICAgICAgICAweDAwMDFmODAwLCAweDAwMDAxZjgwLCAweDAwMDAwMWY4LCAweDgwMDAwMDFmXG5cdCAgICBdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgREVTID0gQ19hbGdvLkRFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTZWxlY3QgNTYgYml0cyBhY2NvcmRpbmcgdG8gUEMxXG5cdCAgICAgICAgICAgIHZhciBrZXlCaXRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleUJpdFBvcyA9IFBDMVtpXSAtIDE7XG5cdCAgICAgICAgICAgICAgICBrZXlCaXRzW2ldID0gKGtleVdvcmRzW2tleUJpdFBvcyA+Pj4gNV0gPj4+ICgzMSAtIGtleUJpdFBvcyAlIDMyKSkgJiAxO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXNzZW1ibGUgMTYgc3Via2V5c1xuXHQgICAgICAgICAgICB2YXIgc3ViS2V5cyA9IHRoaXMuX3N1YktleXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgblN1YktleSA9IDA7IG5TdWJLZXkgPCAxNjsgblN1YktleSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc3Via2V5XG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViS2V5ID0gc3ViS2V5c1tuU3ViS2V5XSA9IFtdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIGJpdFNoaWZ0ID0gQklUX1NISUZUU1tuU3ViS2V5XTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU2VsZWN0IDQ4IGJpdHMgYWNjb3JkaW5nIHRvIFBDMlxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZyb20gdGhlIGxlZnQgMjgga2V5IGJpdHNcblx0ICAgICAgICAgICAgICAgICAgICBzdWJLZXlbKGkgLyA2KSB8IDBdIHw9IGtleUJpdHNbKChQQzJbaV0gLSAxKSArIGJpdFNoaWZ0KSAlIDI4XSA8PCAoMzEgLSBpICUgNik7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3QgZnJvbSB0aGUgcmlnaHQgMjgga2V5IGJpdHNcblx0ICAgICAgICAgICAgICAgICAgICBzdWJLZXlbNCArICgoaSAvIDYpIHwgMCldIHw9IGtleUJpdHNbMjggKyAoKChQQzJbaSArIDI0XSAtIDEpICsgYml0U2hpZnQpICUgMjgpXSA8PCAoMzEgLSBpICUgNik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNpbmNlIGVhY2ggc3Via2V5IGlzIGFwcGxpZWQgdG8gYW4gZXhwYW5kZWQgMzItYml0IGlucHV0LFxuXHQgICAgICAgICAgICAgICAgLy8gdGhlIHN1YmtleSBjYW4gYmUgYnJva2VuIGludG8gOCB2YWx1ZXMgc2NhbGVkIHRvIDMyLWJpdHMsXG5cdCAgICAgICAgICAgICAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGtleSB0byBiZSB1c2VkIHdpdGhvdXQgZXhwYW5zaW9uXG5cdCAgICAgICAgICAgICAgICBzdWJLZXlbMF0gPSAoc3ViS2V5WzBdIDw8IDEpIHwgKHN1YktleVswXSA+Pj4gMzEpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCA3OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJLZXlbaV0gPSBzdWJLZXlbaV0gPj4+ICgoaSAtIDEpICogNCArIDMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc3ViS2V5WzddID0gKHN1YktleVs3XSA8PCA1KSB8IChzdWJLZXlbN10gPj4+IDI3KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52ZXJzZSBzdWJrZXlzXG5cdCAgICAgICAgICAgIHZhciBpbnZTdWJLZXlzID0gdGhpcy5faW52U3ViS2V5cyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGludlN1YktleXNbaV0gPSBzdWJLZXlzWzE1IC0gaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX3N1YktleXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52U3ViS2V5cyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0NyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQsIHN1YktleXMpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IGlucHV0XG5cdCAgICAgICAgICAgIHRoaXMuX2xCbG9jayA9IE1bb2Zmc2V0XTtcblx0ICAgICAgICAgICAgdGhpcy5fckJsb2NrID0gTVtvZmZzZXQgKyAxXTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHBlcm11dGF0aW9uXG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCA0LCAgMHgwZjBmMGYwZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxNiwgMHgwMDAwZmZmZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCAyLCAgMHgzMzMzMzMzMyk7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCA4LCAgMHgwMGZmMDBmZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAgMHg1NTU1NTU1NSk7XG5cblx0ICAgICAgICAgICAgLy8gUm91bmRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMDsgcm91bmQgPCAxNjsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViS2V5ID0gc3ViS2V5c1tyb3VuZF07XG5cdCAgICAgICAgICAgICAgICB2YXIgbEJsb2NrID0gdGhpcy5fbEJsb2NrO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJCbG9jayA9IHRoaXMuX3JCbG9jaztcblxuXHQgICAgICAgICAgICAgICAgLy8gRmVpc3RlbCBmdW5jdGlvblxuXHQgICAgICAgICAgICAgICAgdmFyIGYgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBmIHw9IFNCT1hfUFtpXVsoKHJCbG9jayBeIHN1YktleVtpXSkgJiBTQk9YX01BU0tbaV0pID4+PiAwXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xCbG9jayA9IHJCbG9jaztcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JCbG9jayA9IGxCbG9jayBeIGY7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBVbmRvIHN3YXAgZnJvbSBsYXN0IHJvdW5kXG5cdCAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbEJsb2NrO1xuXHQgICAgICAgICAgICB0aGlzLl9sQmxvY2sgPSB0aGlzLl9yQmxvY2s7XG5cdCAgICAgICAgICAgIHRoaXMuX3JCbG9jayA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gRmluYWwgcGVybXV0YXRpb25cblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDEsICAweDU1NTU1NTU1KTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsICAweDAwZmYwMGZmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDIsICAweDMzMzMzMzMzKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDE2LCAweDAwMDBmZmZmKTtcblx0ICAgICAgICAgICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDQsICAweDBmMGYwZjBmKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgb3V0cHV0XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSA9IHRoaXMuX2xCbG9jaztcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IHRoaXMuX3JCbG9jaztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogNjQvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDY0LzMyLFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA2NC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8vIFN3YXAgYml0cyBhY3Jvc3MgdGhlIGxlZnQgYW5kIHJpZ2h0IHdvcmRzXG5cdCAgICBmdW5jdGlvbiBleGNoYW5nZUxSKG9mZnNldCwgbWFzaykge1xuXHQgICAgICAgIHZhciB0ID0gKCh0aGlzLl9sQmxvY2sgPj4+IG9mZnNldCkgXiB0aGlzLl9yQmxvY2spICYgbWFzaztcblx0ICAgICAgICB0aGlzLl9yQmxvY2sgXj0gdDtcblx0ICAgICAgICB0aGlzLl9sQmxvY2sgXj0gdCA8PCBvZmZzZXQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGV4Y2hhbmdlUkwob2Zmc2V0LCBtYXNrKSB7XG5cdCAgICAgICAgdmFyIHQgPSAoKHRoaXMuX3JCbG9jayA+Pj4gb2Zmc2V0KSBeIHRoaXMuX2xCbG9jaykgJiBtYXNrO1xuXHQgICAgICAgIHRoaXMuX2xCbG9jayBePSB0O1xuXHQgICAgICAgIHRoaXMuX3JCbG9jayBePSB0IDw8IG9mZnNldDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5ERVMuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5ERVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuREVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihERVMpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFRyaXBsZS1ERVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFRyaXBsZURFUyA9IENfYWxnby5UcmlwbGVERVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIERFUyBpbnN0YW5jZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMSA9IERFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSgwLCAyKSkpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMyID0gREVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDIsIDQpKSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczMgPSBERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoNCwgNikpKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczEuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczIuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlczMuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMzLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMyLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMxLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAxOTIvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDY0LzMyLFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA2NC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuVHJpcGxlREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuVHJpcGxlREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLlRyaXBsZURFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoVHJpcGxlREVTKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5UcmlwbGVERVM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBYMzJXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogeDY0IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfeDY0ID0gQy54NjQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIDY0LWJpdCB3b3JkLlxuXHQgICAgICovXG5cdCAgICB2YXIgWDY0V29yZCA9IENfeDY0LldvcmQgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIDY0LWJpdCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggMzIgYml0cy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgMzIgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHg2NFdvcmQgPSBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhpZ2gsIGxvdykge1xuXHQgICAgICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoO1xuXHQgICAgICAgICAgICB0aGlzLmxvdyA9IGxvdztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBCaXR3aXNlIE5PVHMgdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIG5lZ2F0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbmVnYXRlZCA9IHg2NFdvcmQubm90KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gbm90OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gfnRoaXMuaGlnaDtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9IH50aGlzLmxvdztcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQml0d2lzZSBBTkRzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gQU5EIHdpdGggdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIEFORGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGFuZGVkID0geDY0V29yZC5hbmQoYW5vdGhlclg2NFdvcmQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIGFuZDogZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggJiB3b3JkLmhpZ2g7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyAmIHdvcmQubG93O1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBCaXR3aXNlIE9ScyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIE9SIHdpdGggdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIE9SaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3JlZCA9IHg2NFdvcmQub3IoYW5vdGhlclg2NFdvcmQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIG9yOiBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCB8IHdvcmQuaGlnaDtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMubG93IHwgd29yZC5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEJpdHdpc2UgWE9ScyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIFhPUiB3aXRoIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBYT1JpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB4b3JlZCA9IHg2NFdvcmQueG9yKGFub3RoZXJYNjRXb3JkKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyB4b3I6IGZ1bmN0aW9uICh3b3JkKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoIF4gd29yZC5oaWdoO1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgXiB3b3JkLmxvdztcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogU2hpZnRzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIGxlZnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgc2hpZnRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzaGlmdGVkID0geDY0V29yZC5zaGlmdEwoMjUpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHNoaWZ0TDogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgLy8gaWYgKG4gPCAzMikge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSAodGhpcy5oaWdoIDw8IG4pIHwgKHRoaXMubG93ID4+PiAoMzIgLSBuKSk7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgPDwgbjtcblx0ICAgICAgICAgICAgLy8gfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5sb3cgPDwgKG4gLSAzMik7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgbG93ID0gMDtcblx0ICAgICAgICAgICAgLy8gfVxuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTaGlmdHMgdGhpcyB3b3JkIG4gYml0cyB0byB0aGUgcmlnaHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgc2hpZnRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzaGlmdGVkID0geDY0V29yZC5zaGlmdFIoNyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gc2hpZnRSOiBmdW5jdGlvbiAobikge1xuXHQgICAgICAgICAgICAvLyBpZiAobiA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgbG93ID0gKHRoaXMubG93ID4+PiBuKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbikpO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggPj4+IG47XG5cdCAgICAgICAgICAgIC8vIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5oaWdoID4+PiAobiAtIDMyKTtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBoaWdoID0gMDtcblx0ICAgICAgICAgICAgLy8gfVxuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSb3RhdGVzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIGxlZnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gcm90YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHJvdGF0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcm90YXRlZCA9IHg2NFdvcmQucm90TCgyNSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gcm90TDogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuc2hpZnRMKG4pLm9yKHRoaXMuc2hpZnRSKDY0IC0gbikpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSb3RhdGVzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIHJpZ2h0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciByb3RhdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHJvdGF0ZWQgPSB4NjRXb3JkLnJvdFIoNyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8gcm90UjogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuc2hpZnRSKG4pLm9yKHRoaXMuc2hpZnRMKDY0IC0gbikpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIHRoaXMgd29yZCB3aXRoIHRoZSBwYXNzZWQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7WDY0V29yZH0gd29yZCBUaGUgeDY0LVdvcmQgdG8gYWRkIHdpdGggdGhpcyB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIGFkZGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGFkZGVkID0geDY0V29yZC5hZGQoYW5vdGhlclg2NFdvcmQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIGFkZDogZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9ICh0aGlzLmxvdyArIHdvcmQubG93KSB8IDA7XG5cdCAgICAgICAgICAgIC8vIHZhciBjYXJyeSA9IChsb3cgPj4+IDApIDwgKHRoaXMubG93ID4+PiAwKSA/IDEgOiAwO1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9ICh0aGlzLmhpZ2ggKyB3b3JkLmhpZ2ggKyBjYXJyeSkgfCAwO1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDY0LWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgQ3J5cHRvSlMueDY0LldvcmQgb2JqZWN0cy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFg2NFdvcmRBcnJheSA9IENfeDY0LldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgQ3J5cHRvSlMueDY0LldvcmQgb2JqZWN0cy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KSxcblx0ICAgICAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDE4MTkxYTFiLCAweDFjMWQxZTFmKVxuXHQgICAgICAgICAqICAgICBdKTtcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMueDY0LldvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpLFxuXHQgICAgICAgICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MTgxOTFhMWIsIDB4MWMxZDFlMWYpXG5cdCAgICAgICAgICogICAgIF0sIDEwKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgNjQtYml0IHdvcmQgYXJyYXkgdG8gYSAzMi1iaXQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NyeXB0b0pTLmxpYi5Xb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheSdzIGRhdGEgYXMgYSAzMi1iaXQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHgzMldvcmRBcnJheSA9IHg2NFdvcmRBcnJheS50b1gzMigpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvWDMyOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgeDY0V29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgeDY0V29yZHNMZW5ndGggPSB4NjRXb3Jkcy5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgeDMyV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4NjRXb3Jkc0xlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgeDY0V29yZCA9IHg2NFdvcmRzW2ldO1xuXHQgICAgICAgICAgICAgICAgeDMyV29yZHMucHVzaCh4NjRXb3JkLmhpZ2gpO1xuXHQgICAgICAgICAgICAgICAgeDMyV29yZHMucHVzaCh4NjRXb3JkLmxvdyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gWDMyV29yZEFycmF5LmNyZWF0ZSh4MzJXb3JkcywgdGhpcy5zaWdCeXRlcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB4NjRXb3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUgXCJ3b3Jkc1wiIGFycmF5XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAvLyBDbG9uZSBlYWNoIFg2NFdvcmQgb2JqZWN0XG5cdCAgICAgICAgICAgIHZhciB3b3Jkc0xlbmd0aCA9IHdvcmRzLmxlbmd0aDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkc0xlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpXSA9IHdvcmRzW2ldLmNsb25lKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTsiLCIoZnVuY3Rpb24gKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIGZldGNoUG9ueWZpbGwob3B0aW9ucykge1xuICAgIHZhciBQcm9taXNlID0gb3B0aW9ucyAmJiBvcHRpb25zLlByb21pc2UgfHwgc2VsZi5Qcm9taXNlO1xuICAgIHZhciBYTUxIdHRwUmVxdWVzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5YTUxIdHRwUmVxdWVzdCB8fCBzZWxmLlhNTEh0dHBSZXF1ZXN0O1xuICAgIHZhciBnbG9iYWwgPSBzZWxmO1xuXG4gICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsLCB7XG4gICAgICAgIGZldGNoOiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGlmIChzZWxmLmZldGNoKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3VwcG9ydCA9IHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgICAgICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgICAgICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCksXG4gICAgICAgICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICAgICAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAgICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgICAgICAgIF1cblxuICAgICAgICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICAgICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgICAgICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgICAgICAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgICAgICAgfVxuXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpdGVtcyA9IFtdXG4gICAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSkgfSlcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gICAgICAgIH1cblxuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKSB9KVxuICAgICAgICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgICAgICAgfVxuXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSBbXVxuICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pIH0pXG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgICAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgICAgICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICAgICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgICAgICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgICAgICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgICAgICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgICAgICAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICAgICAgICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICAgICAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgICAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICAgICAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICAgICAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgICAgICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICAgICAgICB9XG5cbiAgICAgICAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICAgICAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBmb3JtXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgICAgICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAgICAgICAgIHJhd0hlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBoZWFkZXJzXG4gICAgICAgIH1cblxuICAgICAgICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbiAgICAgICAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gJ3N0YXR1cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzIDogMjAwXG4gICAgICAgICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJ1xuICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gICAgICAgICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG4gICAgICAgIH1cblxuICAgICAgICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG4gICAgICAgIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gICAgICAgICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG4gICAgICAgIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICAgICAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzXG4gICAgICAgIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3RcbiAgICAgICAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlXG5cbiAgICAgICAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgICAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcbiAgICAgIH0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaDogc2VsZi5mZXRjaCxcbiAgICAgICAgSGVhZGVyczogc2VsZi5IZWFkZXJzLFxuICAgICAgICBSZXF1ZXN0OiBzZWxmLlJlcXVlc3QsXG4gICAgICAgIFJlc3BvbnNlOiBzZWxmLlJlc3BvbnNlXG4gICAgICB9O1xuICAgIH0oKSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmZXRjaFBvbnlmaWxsO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmV0Y2hQb255ZmlsbDtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmZldGNoUG9ueWZpbGwgPSBmZXRjaFBvbnlmaWxsO1xuICB9XG59KHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyA/IHRoaXMgOiBzZWxmKSk7XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xudmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2RlZmF1bHQnOiAnUkZDMzk4NicsXG4gICAgZm9ybWF0dGVyczoge1xuICAgICAgICBSRkMxNzM4OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlLmNhbGwodmFsdWUsIHBlcmNlbnRUd2VudGllcywgJysnKTtcbiAgICAgICAgfSxcbiAgICAgICAgUkZDMzk4NjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFJGQzE3Mzg6ICdSRkMxNzM4JyxcbiAgICBSRkMzOTg2OiAnUkZDMzk4Nidcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYXJyYXlMaW1pdDogMjAsXG4gICAgZGVjb2RlcjogdXRpbHMuZGVjb2RlLFxuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGRlcHRoOiA1LFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxudmFyIHBhcnNlVmFsdWVzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ1ZhbHVlcyhzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIGNsZWFuU3RyID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA/IHN0ci5yZXBsYWNlKC9eXFw/LywgJycpIDogc3RyO1xuICAgIHZhciBsaW1pdCA9IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdDtcbiAgICB2YXIgcGFydHMgPSBjbGVhblN0ci5zcGxpdChvcHRpb25zLmRlbGltaXRlciwgbGltaXQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgIHZhciBicmFja2V0RXF1YWxzUG9zID0gcGFydC5pbmRleE9mKCddPScpO1xuICAgICAgICB2YXIgcG9zID0gYnJhY2tldEVxdWFsc1BvcyA9PT0gLTEgPyBwYXJ0LmluZGV4T2YoJz0nKSA6IGJyYWNrZXRFcXVhbHNQb3MgKyAxO1xuXG4gICAgICAgIHZhciBrZXksIHZhbDtcbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LCBkZWZhdWx0cy5kZWNvZGVyKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UoMCwgcG9zKSwgZGVmYXVsdHMuZGVjb2Rlcik7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZShwb3MgKyAxKSwgZGVmYXVsdHMuZGVjb2Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBbXS5jb25jYXQob2JqW2tleV0pLmNvbmNhdCh2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGVhZiA9IHZhbDtcblxuICAgIGZvciAodmFyIGkgPSBjaGFpbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgb2JqO1xuICAgICAgICB2YXIgcm9vdCA9IGNoYWluW2ldO1xuXG4gICAgICAgIGlmIChyb290ID09PSAnW10nKSB7XG4gICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgIG9iaiA9IG9iai5jb25jYXQobGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFpc05hTihpbmRleClcbiAgICAgICAgICAgICAgICAmJiByb290ICE9PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBTdHJpbmcoaW5kZXgpID09PSBjbGVhblJvb3RcbiAgICAgICAgICAgICAgICAmJiBpbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWYgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYWY7XG59O1xuXG52YXIgcGFyc2VLZXlzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ0tleXMoZ2l2ZW5LZXksIHZhbCwgb3B0aW9ucykge1xuICAgIGlmICghZ2l2ZW5LZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBkb3Qgbm90YXRpb24gdG8gYnJhY2tldCBub3RhdGlvblxuICAgIHZhciBrZXkgPSBvcHRpb25zLmFsbG93RG90cyA/IGdpdmVuS2V5LnJlcGxhY2UoL1xcLihbXi5bXSspL2csICdbJDFdJykgOiBnaXZlbktleTtcblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBicmFja2V0cyA9IC8oXFxbW15bXFxdXSpdKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXltcXF1dKl0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBicmFja2V0cy5leGVjKGtleSk7XG4gICAgdmFyIHBhcmVudCA9IHNlZ21lbnQgPyBrZXkuc2xpY2UoMCwgc2VnbWVudC5pbmRleCkgOiBrZXk7XG5cbiAgICAvLyBTdGFzaCB0aGUgcGFyZW50IGlmIGl0IGV4aXN0c1xuXG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCB1c2luZyBwbGFpbiBvYmplY3RzLCBvcHRpb25hbGx5IHByZWZpeCBrZXlzXG4gICAgICAgIC8vIHRoYXQgd291bGQgb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLnB1c2gocGFyZW50KTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzZWdtZW50WzFdLnNsaWNlKDEsIC0xKSkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzID8gdXRpbHMuYXNzaWduKHt9LCBvcHRzKSA6IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGVjb2RlciAhPT0gbnVsbCAmJiBvcHRpb25zLmRlY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5kZWNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWU7XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IHV0aWxzLmlzUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyKSA/IG9wdGlvbnMuZGVsaW1pdGVyIDogZGVmYXVsdHMuZGVsaW1pdGVyO1xuICAgIG9wdGlvbnMuZGVwdGggPSB0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmRlcHRoIDogZGVmYXVsdHMuZGVwdGg7XG4gICAgb3B0aW9ucy5hcnJheUxpbWl0ID0gdHlwZW9mIG9wdGlvbnMuYXJyYXlMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmFycmF5TGltaXQgOiBkZWZhdWx0cy5hcnJheUxpbWl0O1xuICAgIG9wdGlvbnMucGFyc2VBcnJheXMgPSBvcHRpb25zLnBhcnNlQXJyYXlzICE9PSBmYWxzZTtcbiAgICBvcHRpb25zLmRlY29kZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5kZWNvZGVyIDogZGVmYXVsdHMuZGVjb2RlcjtcbiAgICBvcHRpb25zLmFsbG93RG90cyA9IHR5cGVvZiBvcHRpb25zLmFsbG93RG90cyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5hbGxvd0RvdHMgOiBkZWZhdWx0cy5hbGxvd0RvdHM7XG4gICAgb3B0aW9ucy5wbGFpbk9iamVjdHMgPSB0eXBlb2Ygb3B0aW9ucy5wbGFpbk9iamVjdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMucGxhaW5PYmplY3RzIDogZGVmYXVsdHMucGxhaW5PYmplY3RzO1xuICAgIG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcztcbiAgICBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID0gdHlwZW9mIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA6IGRlZmF1bHRzLnBhcmFtZXRlckxpbWl0O1xuICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID0gdHlwZW9mIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZztcblxuICAgIGlmIChzdHIgPT09ICcnIHx8IHN0ciA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgfVxuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBwYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMpO1xuICAgICAgICBvYmogPSB1dGlscy5tZXJnZShvYmosIG5ld09iaiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLmNvbXBhY3Qob2JqKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBhcnJheVByZWZpeEdlbmVyYXRvcnMgPSB7XG4gICAgYnJhY2tldHM6IGZ1bmN0aW9uIGJyYWNrZXRzKHByZWZpeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1tdJztcbiAgICB9LFxuICAgIGluZGljZXM6IGZ1bmN0aW9uIGluZGljZXMocHJlZml4LCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcbiAgICB9LFxuICAgIHJlcGVhdDogZnVuY3Rpb24gcmVwZWF0KHByZWZpeCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgIH1cbn07XG5cbnZhciB0b0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5OiBmYWxzZSxcbiAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XG4gICAgfSxcbiAgICBza2lwTnVsbHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgb2JqZWN0LFxuICAgIHByZWZpeCxcbiAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICBza2lwTnVsbHMsXG4gICAgZW5jb2RlcixcbiAgICBmaWx0ZXIsXG4gICAgc29ydCxcbiAgICBhbGxvd0RvdHMsXG4gICAgc2VyaWFsaXplRGF0ZSxcbiAgICBmb3JtYXR0ZXIsXG4gICAgZW5jb2RlVmFsdWVzT25seVxuKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBzZXJpYWxpemVEYXRlKG9iaik7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlcikgOiBwcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSAnJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nIHx8IHV0aWxzLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGVuY29kZVZhbHVlc09ubHkgPyBwcmVmaXggOiBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2Rlcik7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihrZXlWYWx1ZSkgKyAnPScgKyBmb3JtYXR0ZXIoZW5jb2RlcihvYmosIGRlZmF1bHRzLmVuY29kZXIpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIocHJlZml4KSArICc9JyArIGZvcm1hdHRlcihTdHJpbmcob2JqKSldO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHZhciBvYmpLZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIG9iaktleXMgPSBzb3J0ID8ga2V5cy5zb3J0KHNvcnQpIDoga2V5cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4KHByZWZpeCwga2V5KSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICBvYmpba2V5XSxcbiAgICAgICAgICAgICAgICBwcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgICAgICBza2lwTnVsbHMsXG4gICAgICAgICAgICAgICAgZW5jb2RlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBvcHRzKSB7XG4gICAgdmFyIG9iaiA9IG9iamVjdDtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgPyB1dGlscy5hc3NpZ24oe30sIG9wdHMpIDoge307XG5cbiAgICBpZiAob3B0aW9ucy5lbmNvZGVyICE9PSBudWxsICYmIG9wdGlvbnMuZW5jb2RlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zLmVuY29kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmRlbGltaXRlciA6IG9wdGlvbnMuZGVsaW1pdGVyO1xuICAgIHZhciBzdHJpY3ROdWxsSGFuZGxpbmcgPSB0eXBlb2Ygb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nO1xuICAgIHZhciBza2lwTnVsbHMgPSB0eXBlb2Ygb3B0aW9ucy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzO1xuICAgIHZhciBlbmNvZGUgPSB0eXBlb2Ygb3B0aW9ucy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlO1xuICAgIHZhciBlbmNvZGVyID0gdHlwZW9mIG9wdGlvbnMuZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZW5jb2RlciA6IGRlZmF1bHRzLmVuY29kZXI7XG4gICAgdmFyIHNvcnQgPSB0eXBlb2Ygb3B0aW9ucy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zb3J0IDogbnVsbDtcbiAgICB2YXIgYWxsb3dEb3RzID0gdHlwZW9mIG9wdGlvbnMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogb3B0aW9ucy5hbGxvd0RvdHM7XG4gICAgdmFyIHNlcmlhbGl6ZURhdGUgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZTtcbiAgICB2YXIgZW5jb2RlVmFsdWVzT25seSA9IHR5cGVvZiBvcHRpb25zLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XG4gICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcm1hdHMuZm9ybWF0dGVycywgb3B0aW9ucy5mb3JtYXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZm9ybWF0IG9wdGlvbiBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHMuZm9ybWF0dGVyc1tvcHRpb25zLmZvcm1hdF07XG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdGlvbnMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKCdpbmRpY2VzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSAnaW5kaWNlcyc7XG4gICAgfVxuXG4gICAgdmFyIGdlbmVyYXRlQXJyYXlQcmVmaXggPSBhcnJheVByZWZpeEdlbmVyYXRvcnNbYXJyYXlGb3JtYXRdO1xuXG4gICAgaWYgKCFvYmpLZXlzKSB7XG4gICAgICAgIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICAgIG9iaktleXMuc29ydChzb3J0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiBvYmpba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoc3RyaW5naWZ5KFxuICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxuICAgICAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgZW5jb2RlID8gZW5jb2RlciA6IG51bGwsXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgICAgIGZvcm1hdHRlcixcbiAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihkZWxpbWl0ZXIpO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgaGV4VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59KCkpO1xuXG52YXIgY29tcGFjdFF1ZXVlID0gZnVuY3Rpb24gY29tcGFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgdmFyIG9iajtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFjdGVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbal0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKG9ialtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVtLm9ialtpdGVtLnByb3BdID0gY29tcGFjdGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydHMuYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Qoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGxhaW5PYmplY3RzIHx8IG9wdGlvbnMuYWxsb3dQcm90b3R5cGVzIHx8ICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0YXJnZXQsIHNvdXJjZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIG1lcmdlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgIUFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBtZXJnZVRhcmdldCA9IGV4cG9ydHMuYXJyYXlUb09iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwodGFyZ2V0LCBpKSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbaV0gJiYgdHlwZW9mIHRhcmdldFtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gZXhwb3J0cy5tZXJnZSh0YXJnZXRbaV0sIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaGFzLmNhbGwoYWNjLCBrZXkpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGV4cG9ydHMubWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBtZXJnZVRhcmdldCk7XG59O1xuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnblNpbmdsZVNvdXJjZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufTtcblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSAobXNjZGV4KSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyIDogU3RyaW5nKHN0cik7XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjID09PSAweDJEIC8vIC1cbiAgICAgICAgICAgIHx8IGMgPT09IDB4MkUgLy8gLlxuICAgICAgICAgICAgfHwgYyA9PT0gMHg1RiAvLyBfXG4gICAgICAgICAgICB8fCBjID09PSAweDdFIC8vIH5cbiAgICAgICAgICAgIHx8IChjID49IDB4MzAgJiYgYyA8PSAweDM5KSAvLyAwLTlcbiAgICAgICAgICAgIHx8IChjID49IDB4NDEgJiYgYyA8PSAweDVBKSAvLyBhLXpcbiAgICAgICAgICAgIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDdBKSAvLyBBLVpcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvdXQgKz0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyBoZXhUYWJsZVtjXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgb3V0ID0gb3V0ICsgKGhleFRhYmxlWzB4RTAgfCAoYyA+PiAxMildICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzdHJpbmcuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XG4gICAgICAgIG91dCArPSBoZXhUYWJsZVsweEYwIHwgKGMgPj4gMTgpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDEyKSAmIDB4M0YpXVxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0cy5jb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xuICAgIHZhciBxdWV1ZSA9IFt7IG9iajogeyBvOiB2YWx1ZSB9LCBwcm9wOiAnbycgfV07XG4gICAgdmFyIHJlZnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHsgb2JqOiBvYmosIHByb3A6IGtleSB9KTtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb21wYWN0UXVldWUocXVldWUpO1xufTtcblxuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpO1xufTtcbiJdfQ==
